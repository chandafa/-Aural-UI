"use strict";
var AuralixUI = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __typeError = (msg) => {
    throw TypeError(msg);
  };
  var __require = /* @__PURE__ */ ((x2) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x2, {
    get: (a, b2) => (typeof require !== "undefined" ? require : a)[b2]
  }) : x2)(function(x2) {
    if (typeof require !== "undefined") return require.apply(this, arguments);
    throw Error('Dynamic require of "' + x2 + '" is not supported');
  });
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to2, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to2, key) && key !== except)
          __defProp(to2, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to2;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
  var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
  var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
  var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
  var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);

  // node_modules/react/cjs/react.production.js
  var require_react_production = __commonJS({
    "node_modules/react/cjs/react.production.js"(exports) {
      "use strict";
      var REACT_ELEMENT_TYPE = /* @__PURE__ */ Symbol.for("react.transitional.element");
      var REACT_PORTAL_TYPE = /* @__PURE__ */ Symbol.for("react.portal");
      var REACT_FRAGMENT_TYPE = /* @__PURE__ */ Symbol.for("react.fragment");
      var REACT_STRICT_MODE_TYPE = /* @__PURE__ */ Symbol.for("react.strict_mode");
      var REACT_PROFILER_TYPE = /* @__PURE__ */ Symbol.for("react.profiler");
      var REACT_CONSUMER_TYPE = /* @__PURE__ */ Symbol.for("react.consumer");
      var REACT_CONTEXT_TYPE = /* @__PURE__ */ Symbol.for("react.context");
      var REACT_FORWARD_REF_TYPE = /* @__PURE__ */ Symbol.for("react.forward_ref");
      var REACT_SUSPENSE_TYPE = /* @__PURE__ */ Symbol.for("react.suspense");
      var REACT_MEMO_TYPE = /* @__PURE__ */ Symbol.for("react.memo");
      var REACT_LAZY_TYPE2 = /* @__PURE__ */ Symbol.for("react.lazy");
      var REACT_ACTIVITY_TYPE = /* @__PURE__ */ Symbol.for("react.activity");
      var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
      function getIteratorFn(maybeIterable) {
        if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
        maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
        return "function" === typeof maybeIterable ? maybeIterable : null;
      }
      var ReactNoopUpdateQueue = {
        isMounted: function() {
          return false;
        },
        enqueueForceUpdate: function() {
        },
        enqueueReplaceState: function() {
        },
        enqueueSetState: function() {
        }
      };
      var assign2 = Object.assign;
      var emptyObject = {};
      function Component3(props, context, updater) {
        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
      }
      Component3.prototype.isReactComponent = {};
      Component3.prototype.setState = function(partialState, callback) {
        if ("object" !== typeof partialState && "function" !== typeof partialState && null != partialState)
          throw Error(
            "takes an object of state variables to update or a function which returns an object of state variables."
          );
        this.updater.enqueueSetState(this, partialState, callback, "setState");
      };
      Component3.prototype.forceUpdate = function(callback) {
        this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
      };
      function ComponentDummy() {
      }
      ComponentDummy.prototype = Component3.prototype;
      function PureComponent(props, context, updater) {
        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
      }
      var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
      pureComponentPrototype.constructor = PureComponent;
      assign2(pureComponentPrototype, Component3.prototype);
      pureComponentPrototype.isPureReactComponent = true;
      var isArrayImpl = Array.isArray;
      function noop5() {
      }
      var ReactSharedInternals = { H: null, A: null, T: null, S: null };
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      function ReactElement(type, key, props) {
        var refProp = props.ref;
        return {
          $$typeof: REACT_ELEMENT_TYPE,
          type,
          key,
          ref: void 0 !== refProp ? refProp : null,
          props
        };
      }
      function cloneAndReplaceKey(oldElement, newKey) {
        return ReactElement(oldElement.type, newKey, oldElement.props);
      }
      function isValidElement5(object) {
        return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
      }
      function escape(key) {
        var escaperLookup = { "=": "=0", ":": "=2" };
        return "$" + key.replace(/[=:]/g, function(match2) {
          return escaperLookup[match2];
        });
      }
      var userProvidedKeyEscapeRegex = /\/+/g;
      function getElementKey(element, index2) {
        return "object" === typeof element && null !== element && null != element.key ? escape("" + element.key) : index2.toString(36);
      }
      function resolveThenable(thenable) {
        switch (thenable.status) {
          case "fulfilled":
            return thenable.value;
          case "rejected":
            throw thenable.reason;
          default:
            switch ("string" === typeof thenable.status ? thenable.then(noop5, noop5) : (thenable.status = "pending", thenable.then(
              function(fulfilledValue) {
                "pending" === thenable.status && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
              },
              function(error) {
                "pending" === thenable.status && (thenable.status = "rejected", thenable.reason = error);
              }
            )), thenable.status) {
              case "fulfilled":
                return thenable.value;
              case "rejected":
                throw thenable.reason;
            }
        }
        throw thenable;
      }
      function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
        var type = typeof children;
        if ("undefined" === type || "boolean" === type) children = null;
        var invokeCallback = false;
        if (null === children) invokeCallback = true;
        else
          switch (type) {
            case "bigint":
            case "string":
            case "number":
              invokeCallback = true;
              break;
            case "object":
              switch (children.$$typeof) {
                case REACT_ELEMENT_TYPE:
                case REACT_PORTAL_TYPE:
                  invokeCallback = true;
                  break;
                case REACT_LAZY_TYPE2:
                  return invokeCallback = children._init, mapIntoArray(
                    invokeCallback(children._payload),
                    array,
                    escapedPrefix,
                    nameSoFar,
                    callback
                  );
              }
          }
        if (invokeCallback)
          return callback = callback(children), invokeCallback = "" === nameSoFar ? "." + getElementKey(children, 0) : nameSoFar, isArrayImpl(callback) ? (escapedPrefix = "", null != invokeCallback && (escapedPrefix = invokeCallback.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array, escapedPrefix, "", function(c) {
            return c;
          })) : null != callback && (isValidElement5(callback) && (callback = cloneAndReplaceKey(
            callback,
            escapedPrefix + (null == callback.key || children && children.key === callback.key ? "" : ("" + callback.key).replace(
              userProvidedKeyEscapeRegex,
              "$&/"
            ) + "/") + invokeCallback
          )), array.push(callback)), 1;
        invokeCallback = 0;
        var nextNamePrefix = "" === nameSoFar ? "." : nameSoFar + ":";
        if (isArrayImpl(children))
          for (var i3 = 0; i3 < children.length; i3++)
            nameSoFar = children[i3], type = nextNamePrefix + getElementKey(nameSoFar, i3), invokeCallback += mapIntoArray(
              nameSoFar,
              array,
              escapedPrefix,
              type,
              callback
            );
        else if (i3 = getIteratorFn(children), "function" === typeof i3)
          for (children = i3.call(children), i3 = 0; !(nameSoFar = children.next()).done; )
            nameSoFar = nameSoFar.value, type = nextNamePrefix + getElementKey(nameSoFar, i3++), invokeCallback += mapIntoArray(
              nameSoFar,
              array,
              escapedPrefix,
              type,
              callback
            );
        else if ("object" === type) {
          if ("function" === typeof children.then)
            return mapIntoArray(
              resolveThenable(children),
              array,
              escapedPrefix,
              nameSoFar,
              callback
            );
          array = String(children);
          throw Error(
            "Objects are not valid as a React child (found: " + ("[object Object]" === array ? "object with keys {" + Object.keys(children).join(", ") + "}" : array) + "). If you meant to render a collection of children, use an array instead."
          );
        }
        return invokeCallback;
      }
      function mapChildren(children, func, context) {
        if (null == children) return children;
        var result = [], count3 = 0;
        mapIntoArray(children, result, "", "", function(child) {
          return func.call(context, child, count3++);
        });
        return result;
      }
      function lazyInitializer(payload) {
        if (-1 === payload._status) {
          var ctor = payload._result;
          ctor = ctor();
          ctor.then(
            function(moduleObject) {
              if (0 === payload._status || -1 === payload._status)
                payload._status = 1, payload._result = moduleObject;
            },
            function(error) {
              if (0 === payload._status || -1 === payload._status)
                payload._status = 2, payload._result = error;
            }
          );
          -1 === payload._status && (payload._status = 0, payload._result = ctor);
        }
        if (1 === payload._status) return payload._result.default;
        throw payload._result;
      }
      var reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
        if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
          var event = new window.ErrorEvent("error", {
            bubbles: true,
            cancelable: true,
            message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
            error
          });
          if (!window.dispatchEvent(event)) return;
        } else if ("object" === typeof process && "function" === typeof process.emit) {
          process.emit("uncaughtException", error);
          return;
        }
        console.error(error);
      };
      var Children7 = {
        map: mapChildren,
        forEach: function(children, forEachFunc, forEachContext) {
          mapChildren(
            children,
            function() {
              forEachFunc.apply(this, arguments);
            },
            forEachContext
          );
        },
        count: function(children) {
          var n2 = 0;
          mapChildren(children, function() {
            n2++;
          });
          return n2;
        },
        toArray: function(children) {
          return mapChildren(children, function(child) {
            return child;
          }) || [];
        },
        only: function(children) {
          if (!isValidElement5(children))
            throw Error(
              "React.Children.only expected to receive a single React element child."
            );
          return children;
        }
      };
      exports.Activity = REACT_ACTIVITY_TYPE;
      exports.Children = Children7;
      exports.Component = Component3;
      exports.Fragment = REACT_FRAGMENT_TYPE;
      exports.Profiler = REACT_PROFILER_TYPE;
      exports.PureComponent = PureComponent;
      exports.StrictMode = REACT_STRICT_MODE_TYPE;
      exports.Suspense = REACT_SUSPENSE_TYPE;
      exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
      exports.__COMPILER_RUNTIME = {
        __proto__: null,
        c: function(size4) {
          return ReactSharedInternals.H.useMemoCache(size4);
        }
      };
      exports.cache = function(fn) {
        return function() {
          return fn.apply(null, arguments);
        };
      };
      exports.cacheSignal = function() {
        return null;
      };
      exports.cloneElement = function(element, config2, children) {
        if (null === element || void 0 === element)
          throw Error(
            "The argument must be a React element, but you passed " + element + "."
          );
        var props = assign2({}, element.props), key = element.key;
        if (null != config2)
          for (propName in void 0 !== config2.key && (key = "" + config2.key), config2)
            !hasOwnProperty.call(config2, propName) || "key" === propName || "__self" === propName || "__source" === propName || "ref" === propName && void 0 === config2.ref || (props[propName] = config2[propName]);
        var propName = arguments.length - 2;
        if (1 === propName) props.children = children;
        else if (1 < propName) {
          for (var childArray = Array(propName), i3 = 0; i3 < propName; i3++)
            childArray[i3] = arguments[i3 + 2];
          props.children = childArray;
        }
        return ReactElement(element.type, key, props);
      };
      exports.createContext = function(defaultValue) {
        defaultValue = {
          $$typeof: REACT_CONTEXT_TYPE,
          _currentValue: defaultValue,
          _currentValue2: defaultValue,
          _threadCount: 0,
          Provider: null,
          Consumer: null
        };
        defaultValue.Provider = defaultValue;
        defaultValue.Consumer = {
          $$typeof: REACT_CONSUMER_TYPE,
          _context: defaultValue
        };
        return defaultValue;
      };
      exports.createElement = function(type, config2, children) {
        var propName, props = {}, key = null;
        if (null != config2)
          for (propName in void 0 !== config2.key && (key = "" + config2.key), config2)
            hasOwnProperty.call(config2, propName) && "key" !== propName && "__self" !== propName && "__source" !== propName && (props[propName] = config2[propName]);
        var childrenLength = arguments.length - 2;
        if (1 === childrenLength) props.children = children;
        else if (1 < childrenLength) {
          for (var childArray = Array(childrenLength), i3 = 0; i3 < childrenLength; i3++)
            childArray[i3] = arguments[i3 + 2];
          props.children = childArray;
        }
        if (type && type.defaultProps)
          for (propName in childrenLength = type.defaultProps, childrenLength)
            void 0 === props[propName] && (props[propName] = childrenLength[propName]);
        return ReactElement(type, key, props);
      };
      exports.createRef = function() {
        return { current: null };
      };
      exports.forwardRef = function(render) {
        return { $$typeof: REACT_FORWARD_REF_TYPE, render };
      };
      exports.isValidElement = isValidElement5;
      exports.lazy = function(ctor) {
        return {
          $$typeof: REACT_LAZY_TYPE2,
          _payload: { _status: -1, _result: ctor },
          _init: lazyInitializer
        };
      };
      exports.memo = function(type, compare) {
        return {
          $$typeof: REACT_MEMO_TYPE,
          type,
          compare: void 0 === compare ? null : compare
        };
      };
      exports.startTransition = function(scope) {
        var prevTransition = ReactSharedInternals.T, currentTransition = {};
        ReactSharedInternals.T = currentTransition;
        try {
          var returnValue = scope(), onStartTransitionFinish = ReactSharedInternals.S;
          null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
          "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && returnValue.then(noop5, reportGlobalError);
        } catch (error) {
          reportGlobalError(error);
        } finally {
          null !== prevTransition && null !== currentTransition.types && (prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition;
        }
      };
      exports.unstable_useCacheRefresh = function() {
        return ReactSharedInternals.H.useCacheRefresh();
      };
      exports.use = function(usable) {
        return ReactSharedInternals.H.use(usable);
      };
      exports.useActionState = function(action, initialState, permalink) {
        return ReactSharedInternals.H.useActionState(action, initialState, permalink);
      };
      exports.useCallback = function(callback, deps) {
        return ReactSharedInternals.H.useCallback(callback, deps);
      };
      exports.useContext = function(Context) {
        return ReactSharedInternals.H.useContext(Context);
      };
      exports.useDebugValue = function() {
      };
      exports.useDeferredValue = function(value, initialValue) {
        return ReactSharedInternals.H.useDeferredValue(value, initialValue);
      };
      exports.useEffect = function(create, deps) {
        return ReactSharedInternals.H.useEffect(create, deps);
      };
      exports.useEffectEvent = function(callback) {
        return ReactSharedInternals.H.useEffectEvent(callback);
      };
      exports.useId = function() {
        return ReactSharedInternals.H.useId();
      };
      exports.useImperativeHandle = function(ref, create, deps) {
        return ReactSharedInternals.H.useImperativeHandle(ref, create, deps);
      };
      exports.useInsertionEffect = function(create, deps) {
        return ReactSharedInternals.H.useInsertionEffect(create, deps);
      };
      exports.useLayoutEffect = function(create, deps) {
        return ReactSharedInternals.H.useLayoutEffect(create, deps);
      };
      exports.useMemo = function(create, deps) {
        return ReactSharedInternals.H.useMemo(create, deps);
      };
      exports.useOptimistic = function(passthrough, reducer) {
        return ReactSharedInternals.H.useOptimistic(passthrough, reducer);
      };
      exports.useReducer = function(reducer, initialArg, init) {
        return ReactSharedInternals.H.useReducer(reducer, initialArg, init);
      };
      exports.useRef = function(initialValue) {
        return ReactSharedInternals.H.useRef(initialValue);
      };
      exports.useState = function(initialState) {
        return ReactSharedInternals.H.useState(initialState);
      };
      exports.useSyncExternalStore = function(subscribe2, getSnapshot, getServerSnapshot) {
        return ReactSharedInternals.H.useSyncExternalStore(
          subscribe2,
          getSnapshot,
          getServerSnapshot
        );
      };
      exports.useTransition = function() {
        return ReactSharedInternals.H.useTransition();
      };
      exports.version = "19.2.3";
    }
  });

  // node_modules/react/cjs/react.development.js
  var require_react_development = __commonJS({
    "node_modules/react/cjs/react.development.js"(exports, module) {
      "use strict";
      "production" !== process.env.NODE_ENV && (function() {
        function defineDeprecationWarning(methodName, info) {
          Object.defineProperty(Component3.prototype, methodName, {
            get: function() {
              console.warn(
                "%s(...) is deprecated in plain JavaScript React classes. %s",
                info[0],
                info[1]
              );
            }
          });
        }
        function getIteratorFn(maybeIterable) {
          if (null === maybeIterable || "object" !== typeof maybeIterable)
            return null;
          maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
          return "function" === typeof maybeIterable ? maybeIterable : null;
        }
        function warnNoop(publicInstance, callerName) {
          publicInstance = (publicInstance = publicInstance.constructor) && (publicInstance.displayName || publicInstance.name) || "ReactClass";
          var warningKey = publicInstance + "." + callerName;
          didWarnStateUpdateForUnmountedComponent[warningKey] || (console.error(
            "Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.",
            callerName,
            publicInstance
          ), didWarnStateUpdateForUnmountedComponent[warningKey] = true);
        }
        function Component3(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        function ComponentDummy() {
        }
        function PureComponent(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        function noop5() {
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkKeyStringCoercion(value) {
          try {
            testStringCoercion(value);
            var JSCompiler_inline_result = false;
          } catch (e2) {
            JSCompiler_inline_result = true;
          }
          if (JSCompiler_inline_result) {
            JSCompiler_inline_result = console;
            var JSCompiler_temp_const = JSCompiler_inline_result.error;
            var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            JSCompiler_temp_const.call(
              JSCompiler_inline_result,
              "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
              JSCompiler_inline_result$jscomp$0
            );
            return testStringCoercion(value);
          }
        }
        function getComponentNameFromType(type) {
          if (null == type) return null;
          if ("function" === typeof type)
            return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
          if ("string" === typeof type) return type;
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
            case REACT_ACTIVITY_TYPE:
              return "Activity";
          }
          if ("object" === typeof type)
            switch ("number" === typeof type.tag && console.error(
              "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
            ), type.$$typeof) {
              case REACT_PORTAL_TYPE:
                return "Portal";
              case REACT_CONTEXT_TYPE:
                return type.displayName || "Context";
              case REACT_CONSUMER_TYPE:
                return (type._context.displayName || "Context") + ".Consumer";
              case REACT_FORWARD_REF_TYPE:
                var innerType = type.render;
                type = type.displayName;
                type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
                return type;
              case REACT_MEMO_TYPE:
                return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
              case REACT_LAZY_TYPE2:
                innerType = type._payload;
                type = type._init;
                try {
                  return getComponentNameFromType(type(innerType));
                } catch (x2) {
                }
            }
          return null;
        }
        function getTaskName(type) {
          if (type === REACT_FRAGMENT_TYPE) return "<>";
          if ("object" === typeof type && null !== type && type.$$typeof === REACT_LAZY_TYPE2)
            return "<...>";
          try {
            var name = getComponentNameFromType(type);
            return name ? "<" + name + ">" : "<...>";
          } catch (x2) {
            return "<...>";
          }
        }
        function getOwner() {
          var dispatcher = ReactSharedInternals.A;
          return null === dispatcher ? null : dispatcher.getOwner();
        }
        function UnknownOwner() {
          return Error("react-stack-top-frame");
        }
        function hasValidKey(config2) {
          if (hasOwnProperty.call(config2, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config2, "key").get;
            if (getter && getter.isReactWarning) return false;
          }
          return void 0 !== config2.key;
        }
        function defineKeyPropWarningGetter(props, displayName) {
          function warnAboutAccessingKey() {
            specialPropKeyWarningShown || (specialPropKeyWarningShown = true, console.error(
              "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
              displayName
            ));
          }
          warnAboutAccessingKey.isReactWarning = true;
          Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: true
          });
        }
        function elementRefGetterWithDeprecationWarning() {
          var componentName = getComponentNameFromType(this.type);
          didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = true, console.error(
            "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
          ));
          componentName = this.props.ref;
          return void 0 !== componentName ? componentName : null;
        }
        function ReactElement(type, key, props, owner, debugStack, debugTask) {
          var refProp = props.ref;
          type = {
            $$typeof: REACT_ELEMENT_TYPE,
            type,
            key,
            props,
            _owner: owner
          };
          null !== (void 0 !== refProp ? refProp : null) ? Object.defineProperty(type, "ref", {
            enumerable: false,
            get: elementRefGetterWithDeprecationWarning
          }) : Object.defineProperty(type, "ref", { enumerable: false, value: null });
          type._store = {};
          Object.defineProperty(type._store, "validated", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: 0
          });
          Object.defineProperty(type, "_debugInfo", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: null
          });
          Object.defineProperty(type, "_debugStack", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: debugStack
          });
          Object.defineProperty(type, "_debugTask", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: debugTask
          });
          Object.freeze && (Object.freeze(type.props), Object.freeze(type));
          return type;
        }
        function cloneAndReplaceKey(oldElement, newKey) {
          newKey = ReactElement(
            oldElement.type,
            newKey,
            oldElement.props,
            oldElement._owner,
            oldElement._debugStack,
            oldElement._debugTask
          );
          oldElement._store && (newKey._store.validated = oldElement._store.validated);
          return newKey;
        }
        function validateChildKeys(node) {
          isValidElement5(node) ? node._store && (node._store.validated = 1) : "object" === typeof node && null !== node && node.$$typeof === REACT_LAZY_TYPE2 && ("fulfilled" === node._payload.status ? isValidElement5(node._payload.value) && node._payload.value._store && (node._payload.value._store.validated = 1) : node._store && (node._store.validated = 1));
        }
        function isValidElement5(object) {
          return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function escape(key) {
          var escaperLookup = { "=": "=0", ":": "=2" };
          return "$" + key.replace(/[=:]/g, function(match2) {
            return escaperLookup[match2];
          });
        }
        function getElementKey(element, index2) {
          return "object" === typeof element && null !== element && null != element.key ? (checkKeyStringCoercion(element.key), escape("" + element.key)) : index2.toString(36);
        }
        function resolveThenable(thenable) {
          switch (thenable.status) {
            case "fulfilled":
              return thenable.value;
            case "rejected":
              throw thenable.reason;
            default:
              switch ("string" === typeof thenable.status ? thenable.then(noop5, noop5) : (thenable.status = "pending", thenable.then(
                function(fulfilledValue) {
                  "pending" === thenable.status && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
                },
                function(error) {
                  "pending" === thenable.status && (thenable.status = "rejected", thenable.reason = error);
                }
              )), thenable.status) {
                case "fulfilled":
                  return thenable.value;
                case "rejected":
                  throw thenable.reason;
              }
          }
          throw thenable;
        }
        function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
          var type = typeof children;
          if ("undefined" === type || "boolean" === type) children = null;
          var invokeCallback = false;
          if (null === children) invokeCallback = true;
          else
            switch (type) {
              case "bigint":
              case "string":
              case "number":
                invokeCallback = true;
                break;
              case "object":
                switch (children.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                  case REACT_PORTAL_TYPE:
                    invokeCallback = true;
                    break;
                  case REACT_LAZY_TYPE2:
                    return invokeCallback = children._init, mapIntoArray(
                      invokeCallback(children._payload),
                      array,
                      escapedPrefix,
                      nameSoFar,
                      callback
                    );
                }
            }
          if (invokeCallback) {
            invokeCallback = children;
            callback = callback(invokeCallback);
            var childKey = "" === nameSoFar ? "." + getElementKey(invokeCallback, 0) : nameSoFar;
            isArrayImpl(callback) ? (escapedPrefix = "", null != childKey && (escapedPrefix = childKey.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array, escapedPrefix, "", function(c) {
              return c;
            })) : null != callback && (isValidElement5(callback) && (null != callback.key && (invokeCallback && invokeCallback.key === callback.key || checkKeyStringCoercion(callback.key)), escapedPrefix = cloneAndReplaceKey(
              callback,
              escapedPrefix + (null == callback.key || invokeCallback && invokeCallback.key === callback.key ? "" : ("" + callback.key).replace(
                userProvidedKeyEscapeRegex,
                "$&/"
              ) + "/") + childKey
            ), "" !== nameSoFar && null != invokeCallback && isValidElement5(invokeCallback) && null == invokeCallback.key && invokeCallback._store && !invokeCallback._store.validated && (escapedPrefix._store.validated = 2), callback = escapedPrefix), array.push(callback));
            return 1;
          }
          invokeCallback = 0;
          childKey = "" === nameSoFar ? "." : nameSoFar + ":";
          if (isArrayImpl(children))
            for (var i3 = 0; i3 < children.length; i3++)
              nameSoFar = children[i3], type = childKey + getElementKey(nameSoFar, i3), invokeCallback += mapIntoArray(
                nameSoFar,
                array,
                escapedPrefix,
                type,
                callback
              );
          else if (i3 = getIteratorFn(children), "function" === typeof i3)
            for (i3 === children.entries && (didWarnAboutMaps || console.warn(
              "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
            ), didWarnAboutMaps = true), children = i3.call(children), i3 = 0; !(nameSoFar = children.next()).done; )
              nameSoFar = nameSoFar.value, type = childKey + getElementKey(nameSoFar, i3++), invokeCallback += mapIntoArray(
                nameSoFar,
                array,
                escapedPrefix,
                type,
                callback
              );
          else if ("object" === type) {
            if ("function" === typeof children.then)
              return mapIntoArray(
                resolveThenable(children),
                array,
                escapedPrefix,
                nameSoFar,
                callback
              );
            array = String(children);
            throw Error(
              "Objects are not valid as a React child (found: " + ("[object Object]" === array ? "object with keys {" + Object.keys(children).join(", ") + "}" : array) + "). If you meant to render a collection of children, use an array instead."
            );
          }
          return invokeCallback;
        }
        function mapChildren(children, func, context) {
          if (null == children) return children;
          var result = [], count3 = 0;
          mapIntoArray(children, result, "", "", function(child) {
            return func.call(context, child, count3++);
          });
          return result;
        }
        function lazyInitializer(payload) {
          if (-1 === payload._status) {
            var ioInfo = payload._ioInfo;
            null != ioInfo && (ioInfo.start = ioInfo.end = performance.now());
            ioInfo = payload._result;
            var thenable = ioInfo();
            thenable.then(
              function(moduleObject) {
                if (0 === payload._status || -1 === payload._status) {
                  payload._status = 1;
                  payload._result = moduleObject;
                  var _ioInfo = payload._ioInfo;
                  null != _ioInfo && (_ioInfo.end = performance.now());
                  void 0 === thenable.status && (thenable.status = "fulfilled", thenable.value = moduleObject);
                }
              },
              function(error) {
                if (0 === payload._status || -1 === payload._status) {
                  payload._status = 2;
                  payload._result = error;
                  var _ioInfo2 = payload._ioInfo;
                  null != _ioInfo2 && (_ioInfo2.end = performance.now());
                  void 0 === thenable.status && (thenable.status = "rejected", thenable.reason = error);
                }
              }
            );
            ioInfo = payload._ioInfo;
            if (null != ioInfo) {
              ioInfo.value = thenable;
              var displayName = thenable.displayName;
              "string" === typeof displayName && (ioInfo.name = displayName);
            }
            -1 === payload._status && (payload._status = 0, payload._result = thenable);
          }
          if (1 === payload._status)
            return ioInfo = payload._result, void 0 === ioInfo && console.error(
              "lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?",
              ioInfo
            ), "default" in ioInfo || console.error(
              "lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))",
              ioInfo
            ), ioInfo.default;
          throw payload._result;
        }
        function resolveDispatcher() {
          var dispatcher = ReactSharedInternals.H;
          null === dispatcher && console.error(
            "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
          );
          return dispatcher;
        }
        function releaseAsyncTransition() {
          ReactSharedInternals.asyncTransitions--;
        }
        function enqueueTask(task) {
          if (null === enqueueTaskImpl)
            try {
              var requireString = ("require" + Math.random()).slice(0, 7);
              enqueueTaskImpl = (module && module[requireString]).call(
                module,
                "timers"
              ).setImmediate;
            } catch (_err) {
              enqueueTaskImpl = function(callback) {
                false === didWarnAboutMessageChannel && (didWarnAboutMessageChannel = true, "undefined" === typeof MessageChannel && console.error(
                  "This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."
                ));
                var channel = new MessageChannel();
                channel.port1.onmessage = callback;
                channel.port2.postMessage(void 0);
              };
            }
          return enqueueTaskImpl(task);
        }
        function aggregateErrors(errors) {
          return 1 < errors.length && "function" === typeof AggregateError ? new AggregateError(errors) : errors[0];
        }
        function popActScope(prevActQueue, prevActScopeDepth) {
          prevActScopeDepth !== actScopeDepth - 1 && console.error(
            "You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "
          );
          actScopeDepth = prevActScopeDepth;
        }
        function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
          var queue = ReactSharedInternals.actQueue;
          if (null !== queue)
            if (0 !== queue.length)
              try {
                flushActQueue(queue);
                enqueueTask(function() {
                  return recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                });
                return;
              } catch (error) {
                ReactSharedInternals.thrownErrors.push(error);
              }
            else ReactSharedInternals.actQueue = null;
          0 < ReactSharedInternals.thrownErrors.length ? (queue = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, reject(queue)) : resolve(returnValue);
        }
        function flushActQueue(queue) {
          if (!isFlushing) {
            isFlushing = true;
            var i3 = 0;
            try {
              for (; i3 < queue.length; i3++) {
                var callback = queue[i3];
                do {
                  ReactSharedInternals.didUsePromise = false;
                  var continuation = callback(false);
                  if (null !== continuation) {
                    if (ReactSharedInternals.didUsePromise) {
                      queue[i3] = callback;
                      queue.splice(0, i3);
                      return;
                    }
                    callback = continuation;
                  } else break;
                } while (1);
              }
              queue.length = 0;
            } catch (error) {
              queue.splice(0, i3 + 1), ReactSharedInternals.thrownErrors.push(error);
            } finally {
              isFlushing = false;
            }
          }
        }
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
        var REACT_ELEMENT_TYPE = /* @__PURE__ */ Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = /* @__PURE__ */ Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = /* @__PURE__ */ Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = /* @__PURE__ */ Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = /* @__PURE__ */ Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = /* @__PURE__ */ Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = /* @__PURE__ */ Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = /* @__PURE__ */ Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = /* @__PURE__ */ Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = /* @__PURE__ */ Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = /* @__PURE__ */ Symbol.for("react.memo"), REACT_LAZY_TYPE2 = /* @__PURE__ */ Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = /* @__PURE__ */ Symbol.for("react.activity"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, didWarnStateUpdateForUnmountedComponent = {}, ReactNoopUpdateQueue = {
          isMounted: function() {
            return false;
          },
          enqueueForceUpdate: function(publicInstance) {
            warnNoop(publicInstance, "forceUpdate");
          },
          enqueueReplaceState: function(publicInstance) {
            warnNoop(publicInstance, "replaceState");
          },
          enqueueSetState: function(publicInstance) {
            warnNoop(publicInstance, "setState");
          }
        }, assign2 = Object.assign, emptyObject = {};
        Object.freeze(emptyObject);
        Component3.prototype.isReactComponent = {};
        Component3.prototype.setState = function(partialState, callback) {
          if ("object" !== typeof partialState && "function" !== typeof partialState && null != partialState)
            throw Error(
              "takes an object of state variables to update or a function which returns an object of state variables."
            );
          this.updater.enqueueSetState(this, partialState, callback, "setState");
        };
        Component3.prototype.forceUpdate = function(callback) {
          this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
        };
        var deprecatedAPIs = {
          isMounted: [
            "isMounted",
            "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."
          ],
          replaceState: [
            "replaceState",
            "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."
          ]
        };
        for (fnName in deprecatedAPIs)
          deprecatedAPIs.hasOwnProperty(fnName) && defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
        ComponentDummy.prototype = Component3.prototype;
        deprecatedAPIs = PureComponent.prototype = new ComponentDummy();
        deprecatedAPIs.constructor = PureComponent;
        assign2(deprecatedAPIs, Component3.prototype);
        deprecatedAPIs.isPureReactComponent = true;
        var isArrayImpl = Array.isArray, REACT_CLIENT_REFERENCE = /* @__PURE__ */ Symbol.for("react.client.reference"), ReactSharedInternals = {
          H: null,
          A: null,
          T: null,
          S: null,
          actQueue: null,
          asyncTransitions: 0,
          isBatchingLegacy: false,
          didScheduleLegacyUpdate: false,
          didUsePromise: false,
          thrownErrors: [],
          getCurrentStack: null,
          recentlyCreatedOwnerStacks: 0
        }, hasOwnProperty = Object.prototype.hasOwnProperty, createTask = console.createTask ? console.createTask : function() {
          return null;
        };
        deprecatedAPIs = {
          react_stack_bottom_frame: function(callStackForError) {
            return callStackForError();
          }
        };
        var specialPropKeyWarningShown, didWarnAboutOldJSXRuntime;
        var didWarnAboutElementRef = {};
        var unknownOwnerDebugStack = deprecatedAPIs.react_stack_bottom_frame.bind(
          deprecatedAPIs,
          UnknownOwner
        )();
        var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
        var didWarnAboutMaps = false, userProvidedKeyEscapeRegex = /\/+/g, reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
          if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
            var event = new window.ErrorEvent("error", {
              bubbles: true,
              cancelable: true,
              message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
              error
            });
            if (!window.dispatchEvent(event)) return;
          } else if ("object" === typeof process && "function" === typeof process.emit) {
            process.emit("uncaughtException", error);
            return;
          }
          console.error(error);
        }, didWarnAboutMessageChannel = false, enqueueTaskImpl = null, actScopeDepth = 0, didWarnNoAwaitAct = false, isFlushing = false, queueSeveralMicrotasks = "function" === typeof queueMicrotask ? function(callback) {
          queueMicrotask(function() {
            return queueMicrotask(callback);
          });
        } : enqueueTask;
        deprecatedAPIs = Object.freeze({
          __proto__: null,
          c: function(size4) {
            return resolveDispatcher().useMemoCache(size4);
          }
        });
        var fnName = {
          map: mapChildren,
          forEach: function(children, forEachFunc, forEachContext) {
            mapChildren(
              children,
              function() {
                forEachFunc.apply(this, arguments);
              },
              forEachContext
            );
          },
          count: function(children) {
            var n2 = 0;
            mapChildren(children, function() {
              n2++;
            });
            return n2;
          },
          toArray: function(children) {
            return mapChildren(children, function(child) {
              return child;
            }) || [];
          },
          only: function(children) {
            if (!isValidElement5(children))
              throw Error(
                "React.Children.only expected to receive a single React element child."
              );
            return children;
          }
        };
        exports.Activity = REACT_ACTIVITY_TYPE;
        exports.Children = fnName;
        exports.Component = Component3;
        exports.Fragment = REACT_FRAGMENT_TYPE;
        exports.Profiler = REACT_PROFILER_TYPE;
        exports.PureComponent = PureComponent;
        exports.StrictMode = REACT_STRICT_MODE_TYPE;
        exports.Suspense = REACT_SUSPENSE_TYPE;
        exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
        exports.__COMPILER_RUNTIME = deprecatedAPIs;
        exports.act = function(callback) {
          var prevActQueue = ReactSharedInternals.actQueue, prevActScopeDepth = actScopeDepth;
          actScopeDepth++;
          var queue = ReactSharedInternals.actQueue = null !== prevActQueue ? prevActQueue : [], didAwaitActCall = false;
          try {
            var result = callback();
          } catch (error) {
            ReactSharedInternals.thrownErrors.push(error);
          }
          if (0 < ReactSharedInternals.thrownErrors.length)
            throw popActScope(prevActQueue, prevActScopeDepth), callback = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, callback;
          if (null !== result && "object" === typeof result && "function" === typeof result.then) {
            var thenable = result;
            queueSeveralMicrotasks(function() {
              didAwaitActCall || didWarnNoAwaitAct || (didWarnNoAwaitAct = true, console.error(
                "You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"
              ));
            });
            return {
              then: function(resolve, reject) {
                didAwaitActCall = true;
                thenable.then(
                  function(returnValue) {
                    popActScope(prevActQueue, prevActScopeDepth);
                    if (0 === prevActScopeDepth) {
                      try {
                        flushActQueue(queue), enqueueTask(function() {
                          return recursivelyFlushAsyncActWork(
                            returnValue,
                            resolve,
                            reject
                          );
                        });
                      } catch (error$0) {
                        ReactSharedInternals.thrownErrors.push(error$0);
                      }
                      if (0 < ReactSharedInternals.thrownErrors.length) {
                        var _thrownError = aggregateErrors(
                          ReactSharedInternals.thrownErrors
                        );
                        ReactSharedInternals.thrownErrors.length = 0;
                        reject(_thrownError);
                      }
                    } else resolve(returnValue);
                  },
                  function(error) {
                    popActScope(prevActQueue, prevActScopeDepth);
                    0 < ReactSharedInternals.thrownErrors.length ? (error = aggregateErrors(
                      ReactSharedInternals.thrownErrors
                    ), ReactSharedInternals.thrownErrors.length = 0, reject(error)) : reject(error);
                  }
                );
              }
            };
          }
          var returnValue$jscomp$0 = result;
          popActScope(prevActQueue, prevActScopeDepth);
          0 === prevActScopeDepth && (flushActQueue(queue), 0 !== queue.length && queueSeveralMicrotasks(function() {
            didAwaitActCall || didWarnNoAwaitAct || (didWarnNoAwaitAct = true, console.error(
              "A component suspended inside an `act` scope, but the `act` call was not awaited. When testing React components that depend on asynchronous data, you must await the result:\n\nawait act(() => ...)"
            ));
          }), ReactSharedInternals.actQueue = null);
          if (0 < ReactSharedInternals.thrownErrors.length)
            throw callback = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, callback;
          return {
            then: function(resolve, reject) {
              didAwaitActCall = true;
              0 === prevActScopeDepth ? (ReactSharedInternals.actQueue = queue, enqueueTask(function() {
                return recursivelyFlushAsyncActWork(
                  returnValue$jscomp$0,
                  resolve,
                  reject
                );
              })) : resolve(returnValue$jscomp$0);
            }
          };
        };
        exports.cache = function(fn) {
          return function() {
            return fn.apply(null, arguments);
          };
        };
        exports.cacheSignal = function() {
          return null;
        };
        exports.captureOwnerStack = function() {
          var getCurrentStack = ReactSharedInternals.getCurrentStack;
          return null === getCurrentStack ? null : getCurrentStack();
        };
        exports.cloneElement = function(element, config2, children) {
          if (null === element || void 0 === element)
            throw Error(
              "The argument must be a React element, but you passed " + element + "."
            );
          var props = assign2({}, element.props), key = element.key, owner = element._owner;
          if (null != config2) {
            var JSCompiler_inline_result;
            a: {
              if (hasOwnProperty.call(config2, "ref") && (JSCompiler_inline_result = Object.getOwnPropertyDescriptor(
                config2,
                "ref"
              ).get) && JSCompiler_inline_result.isReactWarning) {
                JSCompiler_inline_result = false;
                break a;
              }
              JSCompiler_inline_result = void 0 !== config2.ref;
            }
            JSCompiler_inline_result && (owner = getOwner());
            hasValidKey(config2) && (checkKeyStringCoercion(config2.key), key = "" + config2.key);
            for (propName in config2)
              !hasOwnProperty.call(config2, propName) || "key" === propName || "__self" === propName || "__source" === propName || "ref" === propName && void 0 === config2.ref || (props[propName] = config2[propName]);
          }
          var propName = arguments.length - 2;
          if (1 === propName) props.children = children;
          else if (1 < propName) {
            JSCompiler_inline_result = Array(propName);
            for (var i3 = 0; i3 < propName; i3++)
              JSCompiler_inline_result[i3] = arguments[i3 + 2];
            props.children = JSCompiler_inline_result;
          }
          props = ReactElement(
            element.type,
            key,
            props,
            owner,
            element._debugStack,
            element._debugTask
          );
          for (key = 2; key < arguments.length; key++)
            validateChildKeys(arguments[key]);
          return props;
        };
        exports.createContext = function(defaultValue) {
          defaultValue = {
            $$typeof: REACT_CONTEXT_TYPE,
            _currentValue: defaultValue,
            _currentValue2: defaultValue,
            _threadCount: 0,
            Provider: null,
            Consumer: null
          };
          defaultValue.Provider = defaultValue;
          defaultValue.Consumer = {
            $$typeof: REACT_CONSUMER_TYPE,
            _context: defaultValue
          };
          defaultValue._currentRenderer = null;
          defaultValue._currentRenderer2 = null;
          return defaultValue;
        };
        exports.createElement = function(type, config2, children) {
          for (var i3 = 2; i3 < arguments.length; i3++)
            validateChildKeys(arguments[i3]);
          i3 = {};
          var key = null;
          if (null != config2)
            for (propName in didWarnAboutOldJSXRuntime || !("__self" in config2) || "key" in config2 || (didWarnAboutOldJSXRuntime = true, console.warn(
              "Your app (or one of its dependencies) is using an outdated JSX transform. Update to the modern JSX transform for faster performance: https://react.dev/link/new-jsx-transform"
            )), hasValidKey(config2) && (checkKeyStringCoercion(config2.key), key = "" + config2.key), config2)
              hasOwnProperty.call(config2, propName) && "key" !== propName && "__self" !== propName && "__source" !== propName && (i3[propName] = config2[propName]);
          var childrenLength = arguments.length - 2;
          if (1 === childrenLength) i3.children = children;
          else if (1 < childrenLength) {
            for (var childArray = Array(childrenLength), _i = 0; _i < childrenLength; _i++)
              childArray[_i] = arguments[_i + 2];
            Object.freeze && Object.freeze(childArray);
            i3.children = childArray;
          }
          if (type && type.defaultProps)
            for (propName in childrenLength = type.defaultProps, childrenLength)
              void 0 === i3[propName] && (i3[propName] = childrenLength[propName]);
          key && defineKeyPropWarningGetter(
            i3,
            "function" === typeof type ? type.displayName || type.name || "Unknown" : type
          );
          var propName = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
          return ReactElement(
            type,
            key,
            i3,
            getOwner(),
            propName ? Error("react-stack-top-frame") : unknownOwnerDebugStack,
            propName ? createTask(getTaskName(type)) : unknownOwnerDebugTask
          );
        };
        exports.createRef = function() {
          var refObject = { current: null };
          Object.seal(refObject);
          return refObject;
        };
        exports.forwardRef = function(render) {
          null != render && render.$$typeof === REACT_MEMO_TYPE ? console.error(
            "forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...))."
          ) : "function" !== typeof render ? console.error(
            "forwardRef requires a render function but was given %s.",
            null === render ? "null" : typeof render
          ) : 0 !== render.length && 2 !== render.length && console.error(
            "forwardRef render functions accept exactly two parameters: props and ref. %s",
            1 === render.length ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined."
          );
          null != render && null != render.defaultProps && console.error(
            "forwardRef render functions do not support defaultProps. Did you accidentally pass a React component?"
          );
          var elementType = { $$typeof: REACT_FORWARD_REF_TYPE, render }, ownName;
          Object.defineProperty(elementType, "displayName", {
            enumerable: false,
            configurable: true,
            get: function() {
              return ownName;
            },
            set: function(name) {
              ownName = name;
              render.name || render.displayName || (Object.defineProperty(render, "name", { value: name }), render.displayName = name);
            }
          });
          return elementType;
        };
        exports.isValidElement = isValidElement5;
        exports.lazy = function(ctor) {
          ctor = { _status: -1, _result: ctor };
          var lazyType = {
            $$typeof: REACT_LAZY_TYPE2,
            _payload: ctor,
            _init: lazyInitializer
          }, ioInfo = {
            name: "lazy",
            start: -1,
            end: -1,
            value: null,
            owner: null,
            debugStack: Error("react-stack-top-frame"),
            debugTask: console.createTask ? console.createTask("lazy()") : null
          };
          ctor._ioInfo = ioInfo;
          lazyType._debugInfo = [{ awaited: ioInfo }];
          return lazyType;
        };
        exports.memo = function(type, compare) {
          null == type && console.error(
            "memo: The first argument must be a component. Instead received: %s",
            null === type ? "null" : typeof type
          );
          compare = {
            $$typeof: REACT_MEMO_TYPE,
            type,
            compare: void 0 === compare ? null : compare
          };
          var ownName;
          Object.defineProperty(compare, "displayName", {
            enumerable: false,
            configurable: true,
            get: function() {
              return ownName;
            },
            set: function(name) {
              ownName = name;
              type.name || type.displayName || (Object.defineProperty(type, "name", { value: name }), type.displayName = name);
            }
          });
          return compare;
        };
        exports.startTransition = function(scope) {
          var prevTransition = ReactSharedInternals.T, currentTransition = {};
          currentTransition._updatedFibers = /* @__PURE__ */ new Set();
          ReactSharedInternals.T = currentTransition;
          try {
            var returnValue = scope(), onStartTransitionFinish = ReactSharedInternals.S;
            null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
            "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && (ReactSharedInternals.asyncTransitions++, returnValue.then(releaseAsyncTransition, releaseAsyncTransition), returnValue.then(noop5, reportGlobalError));
          } catch (error) {
            reportGlobalError(error);
          } finally {
            null === prevTransition && currentTransition._updatedFibers && (scope = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < scope && console.warn(
              "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
            )), null !== prevTransition && null !== currentTransition.types && (null !== prevTransition.types && prevTransition.types !== currentTransition.types && console.error(
              "We expected inner Transitions to have transferred the outer types set and that you cannot add to the outer Transition while inside the inner.This is a bug in React."
            ), prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition;
          }
        };
        exports.unstable_useCacheRefresh = function() {
          return resolveDispatcher().useCacheRefresh();
        };
        exports.use = function(usable) {
          return resolveDispatcher().use(usable);
        };
        exports.useActionState = function(action, initialState, permalink) {
          return resolveDispatcher().useActionState(
            action,
            initialState,
            permalink
          );
        };
        exports.useCallback = function(callback, deps) {
          return resolveDispatcher().useCallback(callback, deps);
        };
        exports.useContext = function(Context) {
          var dispatcher = resolveDispatcher();
          Context.$$typeof === REACT_CONSUMER_TYPE && console.error(
            "Calling useContext(Context.Consumer) is not supported and will cause bugs. Did you mean to call useContext(Context) instead?"
          );
          return dispatcher.useContext(Context);
        };
        exports.useDebugValue = function(value, formatterFn) {
          return resolveDispatcher().useDebugValue(value, formatterFn);
        };
        exports.useDeferredValue = function(value, initialValue) {
          return resolveDispatcher().useDeferredValue(value, initialValue);
        };
        exports.useEffect = function(create, deps) {
          null == create && console.warn(
            "React Hook useEffect requires an effect callback. Did you forget to pass a callback to the hook?"
          );
          return resolveDispatcher().useEffect(create, deps);
        };
        exports.useEffectEvent = function(callback) {
          return resolveDispatcher().useEffectEvent(callback);
        };
        exports.useId = function() {
          return resolveDispatcher().useId();
        };
        exports.useImperativeHandle = function(ref, create, deps) {
          return resolveDispatcher().useImperativeHandle(ref, create, deps);
        };
        exports.useInsertionEffect = function(create, deps) {
          null == create && console.warn(
            "React Hook useInsertionEffect requires an effect callback. Did you forget to pass a callback to the hook?"
          );
          return resolveDispatcher().useInsertionEffect(create, deps);
        };
        exports.useLayoutEffect = function(create, deps) {
          null == create && console.warn(
            "React Hook useLayoutEffect requires an effect callback. Did you forget to pass a callback to the hook?"
          );
          return resolveDispatcher().useLayoutEffect(create, deps);
        };
        exports.useMemo = function(create, deps) {
          return resolveDispatcher().useMemo(create, deps);
        };
        exports.useOptimistic = function(passthrough, reducer) {
          return resolveDispatcher().useOptimistic(passthrough, reducer);
        };
        exports.useReducer = function(reducer, initialArg, init) {
          return resolveDispatcher().useReducer(reducer, initialArg, init);
        };
        exports.useRef = function(initialValue) {
          return resolveDispatcher().useRef(initialValue);
        };
        exports.useState = function(initialState) {
          return resolveDispatcher().useState(initialState);
        };
        exports.useSyncExternalStore = function(subscribe2, getSnapshot, getServerSnapshot) {
          return resolveDispatcher().useSyncExternalStore(
            subscribe2,
            getSnapshot,
            getServerSnapshot
          );
        };
        exports.useTransition = function() {
          return resolveDispatcher().useTransition();
        };
        exports.version = "19.2.3";
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
      })();
    }
  });

  // node_modules/react/index.js
  var require_react = __commonJS({
    "node_modules/react/index.js"(exports, module) {
      "use strict";
      if (process.env.NODE_ENV === "production") {
        module.exports = require_react_production();
      } else {
        module.exports = require_react_development();
      }
    }
  });

  // ../../node_modules/react/cjs/react.production.js
  var require_react_production2 = __commonJS({
    "../../node_modules/react/cjs/react.production.js"(exports) {
      "use strict";
      var REACT_ELEMENT_TYPE = /* @__PURE__ */ Symbol.for("react.transitional.element");
      var REACT_PORTAL_TYPE = /* @__PURE__ */ Symbol.for("react.portal");
      var REACT_FRAGMENT_TYPE = /* @__PURE__ */ Symbol.for("react.fragment");
      var REACT_STRICT_MODE_TYPE = /* @__PURE__ */ Symbol.for("react.strict_mode");
      var REACT_PROFILER_TYPE = /* @__PURE__ */ Symbol.for("react.profiler");
      var REACT_CONSUMER_TYPE = /* @__PURE__ */ Symbol.for("react.consumer");
      var REACT_CONTEXT_TYPE = /* @__PURE__ */ Symbol.for("react.context");
      var REACT_FORWARD_REF_TYPE = /* @__PURE__ */ Symbol.for("react.forward_ref");
      var REACT_SUSPENSE_TYPE = /* @__PURE__ */ Symbol.for("react.suspense");
      var REACT_MEMO_TYPE = /* @__PURE__ */ Symbol.for("react.memo");
      var REACT_LAZY_TYPE2 = /* @__PURE__ */ Symbol.for("react.lazy");
      var REACT_ACTIVITY_TYPE = /* @__PURE__ */ Symbol.for("react.activity");
      var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
      function getIteratorFn(maybeIterable) {
        if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
        maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
        return "function" === typeof maybeIterable ? maybeIterable : null;
      }
      var ReactNoopUpdateQueue = {
        isMounted: function() {
          return false;
        },
        enqueueForceUpdate: function() {
        },
        enqueueReplaceState: function() {
        },
        enqueueSetState: function() {
        }
      };
      var assign2 = Object.assign;
      var emptyObject = {};
      function Component3(props, context, updater) {
        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
      }
      Component3.prototype.isReactComponent = {};
      Component3.prototype.setState = function(partialState, callback) {
        if ("object" !== typeof partialState && "function" !== typeof partialState && null != partialState)
          throw Error(
            "takes an object of state variables to update or a function which returns an object of state variables."
          );
        this.updater.enqueueSetState(this, partialState, callback, "setState");
      };
      Component3.prototype.forceUpdate = function(callback) {
        this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
      };
      function ComponentDummy() {
      }
      ComponentDummy.prototype = Component3.prototype;
      function PureComponent(props, context, updater) {
        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
      }
      var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
      pureComponentPrototype.constructor = PureComponent;
      assign2(pureComponentPrototype, Component3.prototype);
      pureComponentPrototype.isPureReactComponent = true;
      var isArrayImpl = Array.isArray;
      function noop5() {
      }
      var ReactSharedInternals = { H: null, A: null, T: null, S: null };
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      function ReactElement(type, key, props) {
        var refProp = props.ref;
        return {
          $$typeof: REACT_ELEMENT_TYPE,
          type,
          key,
          ref: void 0 !== refProp ? refProp : null,
          props
        };
      }
      function cloneAndReplaceKey(oldElement, newKey) {
        return ReactElement(oldElement.type, newKey, oldElement.props);
      }
      function isValidElement5(object) {
        return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
      }
      function escape(key) {
        var escaperLookup = { "=": "=0", ":": "=2" };
        return "$" + key.replace(/[=:]/g, function(match2) {
          return escaperLookup[match2];
        });
      }
      var userProvidedKeyEscapeRegex = /\/+/g;
      function getElementKey(element, index2) {
        return "object" === typeof element && null !== element && null != element.key ? escape("" + element.key) : index2.toString(36);
      }
      function resolveThenable(thenable) {
        switch (thenable.status) {
          case "fulfilled":
            return thenable.value;
          case "rejected":
            throw thenable.reason;
          default:
            switch ("string" === typeof thenable.status ? thenable.then(noop5, noop5) : (thenable.status = "pending", thenable.then(
              function(fulfilledValue) {
                "pending" === thenable.status && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
              },
              function(error) {
                "pending" === thenable.status && (thenable.status = "rejected", thenable.reason = error);
              }
            )), thenable.status) {
              case "fulfilled":
                return thenable.value;
              case "rejected":
                throw thenable.reason;
            }
        }
        throw thenable;
      }
      function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
        var type = typeof children;
        if ("undefined" === type || "boolean" === type) children = null;
        var invokeCallback = false;
        if (null === children) invokeCallback = true;
        else
          switch (type) {
            case "bigint":
            case "string":
            case "number":
              invokeCallback = true;
              break;
            case "object":
              switch (children.$$typeof) {
                case REACT_ELEMENT_TYPE:
                case REACT_PORTAL_TYPE:
                  invokeCallback = true;
                  break;
                case REACT_LAZY_TYPE2:
                  return invokeCallback = children._init, mapIntoArray(
                    invokeCallback(children._payload),
                    array,
                    escapedPrefix,
                    nameSoFar,
                    callback
                  );
              }
          }
        if (invokeCallback)
          return callback = callback(children), invokeCallback = "" === nameSoFar ? "." + getElementKey(children, 0) : nameSoFar, isArrayImpl(callback) ? (escapedPrefix = "", null != invokeCallback && (escapedPrefix = invokeCallback.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array, escapedPrefix, "", function(c) {
            return c;
          })) : null != callback && (isValidElement5(callback) && (callback = cloneAndReplaceKey(
            callback,
            escapedPrefix + (null == callback.key || children && children.key === callback.key ? "" : ("" + callback.key).replace(
              userProvidedKeyEscapeRegex,
              "$&/"
            ) + "/") + invokeCallback
          )), array.push(callback)), 1;
        invokeCallback = 0;
        var nextNamePrefix = "" === nameSoFar ? "." : nameSoFar + ":";
        if (isArrayImpl(children))
          for (var i3 = 0; i3 < children.length; i3++)
            nameSoFar = children[i3], type = nextNamePrefix + getElementKey(nameSoFar, i3), invokeCallback += mapIntoArray(
              nameSoFar,
              array,
              escapedPrefix,
              type,
              callback
            );
        else if (i3 = getIteratorFn(children), "function" === typeof i3)
          for (children = i3.call(children), i3 = 0; !(nameSoFar = children.next()).done; )
            nameSoFar = nameSoFar.value, type = nextNamePrefix + getElementKey(nameSoFar, i3++), invokeCallback += mapIntoArray(
              nameSoFar,
              array,
              escapedPrefix,
              type,
              callback
            );
        else if ("object" === type) {
          if ("function" === typeof children.then)
            return mapIntoArray(
              resolveThenable(children),
              array,
              escapedPrefix,
              nameSoFar,
              callback
            );
          array = String(children);
          throw Error(
            "Objects are not valid as a React child (found: " + ("[object Object]" === array ? "object with keys {" + Object.keys(children).join(", ") + "}" : array) + "). If you meant to render a collection of children, use an array instead."
          );
        }
        return invokeCallback;
      }
      function mapChildren(children, func, context) {
        if (null == children) return children;
        var result = [], count3 = 0;
        mapIntoArray(children, result, "", "", function(child) {
          return func.call(context, child, count3++);
        });
        return result;
      }
      function lazyInitializer(payload) {
        if (-1 === payload._status) {
          var ctor = payload._result;
          ctor = ctor();
          ctor.then(
            function(moduleObject) {
              if (0 === payload._status || -1 === payload._status)
                payload._status = 1, payload._result = moduleObject;
            },
            function(error) {
              if (0 === payload._status || -1 === payload._status)
                payload._status = 2, payload._result = error;
            }
          );
          -1 === payload._status && (payload._status = 0, payload._result = ctor);
        }
        if (1 === payload._status) return payload._result.default;
        throw payload._result;
      }
      var reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
        if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
          var event = new window.ErrorEvent("error", {
            bubbles: true,
            cancelable: true,
            message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
            error
          });
          if (!window.dispatchEvent(event)) return;
        } else if ("object" === typeof process && "function" === typeof process.emit) {
          process.emit("uncaughtException", error);
          return;
        }
        console.error(error);
      };
      var Children7 = {
        map: mapChildren,
        forEach: function(children, forEachFunc, forEachContext) {
          mapChildren(
            children,
            function() {
              forEachFunc.apply(this, arguments);
            },
            forEachContext
          );
        },
        count: function(children) {
          var n2 = 0;
          mapChildren(children, function() {
            n2++;
          });
          return n2;
        },
        toArray: function(children) {
          return mapChildren(children, function(child) {
            return child;
          }) || [];
        },
        only: function(children) {
          if (!isValidElement5(children))
            throw Error(
              "React.Children.only expected to receive a single React element child."
            );
          return children;
        }
      };
      exports.Activity = REACT_ACTIVITY_TYPE;
      exports.Children = Children7;
      exports.Component = Component3;
      exports.Fragment = REACT_FRAGMENT_TYPE;
      exports.Profiler = REACT_PROFILER_TYPE;
      exports.PureComponent = PureComponent;
      exports.StrictMode = REACT_STRICT_MODE_TYPE;
      exports.Suspense = REACT_SUSPENSE_TYPE;
      exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
      exports.__COMPILER_RUNTIME = {
        __proto__: null,
        c: function(size4) {
          return ReactSharedInternals.H.useMemoCache(size4);
        }
      };
      exports.cache = function(fn) {
        return function() {
          return fn.apply(null, arguments);
        };
      };
      exports.cacheSignal = function() {
        return null;
      };
      exports.cloneElement = function(element, config2, children) {
        if (null === element || void 0 === element)
          throw Error(
            "The argument must be a React element, but you passed " + element + "."
          );
        var props = assign2({}, element.props), key = element.key;
        if (null != config2)
          for (propName in void 0 !== config2.key && (key = "" + config2.key), config2)
            !hasOwnProperty.call(config2, propName) || "key" === propName || "__self" === propName || "__source" === propName || "ref" === propName && void 0 === config2.ref || (props[propName] = config2[propName]);
        var propName = arguments.length - 2;
        if (1 === propName) props.children = children;
        else if (1 < propName) {
          for (var childArray = Array(propName), i3 = 0; i3 < propName; i3++)
            childArray[i3] = arguments[i3 + 2];
          props.children = childArray;
        }
        return ReactElement(element.type, key, props);
      };
      exports.createContext = function(defaultValue) {
        defaultValue = {
          $$typeof: REACT_CONTEXT_TYPE,
          _currentValue: defaultValue,
          _currentValue2: defaultValue,
          _threadCount: 0,
          Provider: null,
          Consumer: null
        };
        defaultValue.Provider = defaultValue;
        defaultValue.Consumer = {
          $$typeof: REACT_CONSUMER_TYPE,
          _context: defaultValue
        };
        return defaultValue;
      };
      exports.createElement = function(type, config2, children) {
        var propName, props = {}, key = null;
        if (null != config2)
          for (propName in void 0 !== config2.key && (key = "" + config2.key), config2)
            hasOwnProperty.call(config2, propName) && "key" !== propName && "__self" !== propName && "__source" !== propName && (props[propName] = config2[propName]);
        var childrenLength = arguments.length - 2;
        if (1 === childrenLength) props.children = children;
        else if (1 < childrenLength) {
          for (var childArray = Array(childrenLength), i3 = 0; i3 < childrenLength; i3++)
            childArray[i3] = arguments[i3 + 2];
          props.children = childArray;
        }
        if (type && type.defaultProps)
          for (propName in childrenLength = type.defaultProps, childrenLength)
            void 0 === props[propName] && (props[propName] = childrenLength[propName]);
        return ReactElement(type, key, props);
      };
      exports.createRef = function() {
        return { current: null };
      };
      exports.forwardRef = function(render) {
        return { $$typeof: REACT_FORWARD_REF_TYPE, render };
      };
      exports.isValidElement = isValidElement5;
      exports.lazy = function(ctor) {
        return {
          $$typeof: REACT_LAZY_TYPE2,
          _payload: { _status: -1, _result: ctor },
          _init: lazyInitializer
        };
      };
      exports.memo = function(type, compare) {
        return {
          $$typeof: REACT_MEMO_TYPE,
          type,
          compare: void 0 === compare ? null : compare
        };
      };
      exports.startTransition = function(scope) {
        var prevTransition = ReactSharedInternals.T, currentTransition = {};
        ReactSharedInternals.T = currentTransition;
        try {
          var returnValue = scope(), onStartTransitionFinish = ReactSharedInternals.S;
          null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
          "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && returnValue.then(noop5, reportGlobalError);
        } catch (error) {
          reportGlobalError(error);
        } finally {
          null !== prevTransition && null !== currentTransition.types && (prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition;
        }
      };
      exports.unstable_useCacheRefresh = function() {
        return ReactSharedInternals.H.useCacheRefresh();
      };
      exports.use = function(usable) {
        return ReactSharedInternals.H.use(usable);
      };
      exports.useActionState = function(action, initialState, permalink) {
        return ReactSharedInternals.H.useActionState(action, initialState, permalink);
      };
      exports.useCallback = function(callback, deps) {
        return ReactSharedInternals.H.useCallback(callback, deps);
      };
      exports.useContext = function(Context) {
        return ReactSharedInternals.H.useContext(Context);
      };
      exports.useDebugValue = function() {
      };
      exports.useDeferredValue = function(value, initialValue) {
        return ReactSharedInternals.H.useDeferredValue(value, initialValue);
      };
      exports.useEffect = function(create, deps) {
        return ReactSharedInternals.H.useEffect(create, deps);
      };
      exports.useEffectEvent = function(callback) {
        return ReactSharedInternals.H.useEffectEvent(callback);
      };
      exports.useId = function() {
        return ReactSharedInternals.H.useId();
      };
      exports.useImperativeHandle = function(ref, create, deps) {
        return ReactSharedInternals.H.useImperativeHandle(ref, create, deps);
      };
      exports.useInsertionEffect = function(create, deps) {
        return ReactSharedInternals.H.useInsertionEffect(create, deps);
      };
      exports.useLayoutEffect = function(create, deps) {
        return ReactSharedInternals.H.useLayoutEffect(create, deps);
      };
      exports.useMemo = function(create, deps) {
        return ReactSharedInternals.H.useMemo(create, deps);
      };
      exports.useOptimistic = function(passthrough, reducer) {
        return ReactSharedInternals.H.useOptimistic(passthrough, reducer);
      };
      exports.useReducer = function(reducer, initialArg, init) {
        return ReactSharedInternals.H.useReducer(reducer, initialArg, init);
      };
      exports.useRef = function(initialValue) {
        return ReactSharedInternals.H.useRef(initialValue);
      };
      exports.useState = function(initialState) {
        return ReactSharedInternals.H.useState(initialState);
      };
      exports.useSyncExternalStore = function(subscribe2, getSnapshot, getServerSnapshot) {
        return ReactSharedInternals.H.useSyncExternalStore(
          subscribe2,
          getSnapshot,
          getServerSnapshot
        );
      };
      exports.useTransition = function() {
        return ReactSharedInternals.H.useTransition();
      };
      exports.version = "19.2.3";
    }
  });

  // ../../node_modules/react/cjs/react.development.js
  var require_react_development2 = __commonJS({
    "../../node_modules/react/cjs/react.development.js"(exports, module) {
      "use strict";
      "production" !== process.env.NODE_ENV && (function() {
        function defineDeprecationWarning(methodName, info) {
          Object.defineProperty(Component3.prototype, methodName, {
            get: function() {
              console.warn(
                "%s(...) is deprecated in plain JavaScript React classes. %s",
                info[0],
                info[1]
              );
            }
          });
        }
        function getIteratorFn(maybeIterable) {
          if (null === maybeIterable || "object" !== typeof maybeIterable)
            return null;
          maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
          return "function" === typeof maybeIterable ? maybeIterable : null;
        }
        function warnNoop(publicInstance, callerName) {
          publicInstance = (publicInstance = publicInstance.constructor) && (publicInstance.displayName || publicInstance.name) || "ReactClass";
          var warningKey = publicInstance + "." + callerName;
          didWarnStateUpdateForUnmountedComponent[warningKey] || (console.error(
            "Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.",
            callerName,
            publicInstance
          ), didWarnStateUpdateForUnmountedComponent[warningKey] = true);
        }
        function Component3(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        function ComponentDummy() {
        }
        function PureComponent(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        function noop5() {
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkKeyStringCoercion(value) {
          try {
            testStringCoercion(value);
            var JSCompiler_inline_result = false;
          } catch (e2) {
            JSCompiler_inline_result = true;
          }
          if (JSCompiler_inline_result) {
            JSCompiler_inline_result = console;
            var JSCompiler_temp_const = JSCompiler_inline_result.error;
            var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            JSCompiler_temp_const.call(
              JSCompiler_inline_result,
              "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
              JSCompiler_inline_result$jscomp$0
            );
            return testStringCoercion(value);
          }
        }
        function getComponentNameFromType(type) {
          if (null == type) return null;
          if ("function" === typeof type)
            return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
          if ("string" === typeof type) return type;
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
            case REACT_ACTIVITY_TYPE:
              return "Activity";
          }
          if ("object" === typeof type)
            switch ("number" === typeof type.tag && console.error(
              "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
            ), type.$$typeof) {
              case REACT_PORTAL_TYPE:
                return "Portal";
              case REACT_CONTEXT_TYPE:
                return type.displayName || "Context";
              case REACT_CONSUMER_TYPE:
                return (type._context.displayName || "Context") + ".Consumer";
              case REACT_FORWARD_REF_TYPE:
                var innerType = type.render;
                type = type.displayName;
                type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
                return type;
              case REACT_MEMO_TYPE:
                return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
              case REACT_LAZY_TYPE2:
                innerType = type._payload;
                type = type._init;
                try {
                  return getComponentNameFromType(type(innerType));
                } catch (x2) {
                }
            }
          return null;
        }
        function getTaskName(type) {
          if (type === REACT_FRAGMENT_TYPE) return "<>";
          if ("object" === typeof type && null !== type && type.$$typeof === REACT_LAZY_TYPE2)
            return "<...>";
          try {
            var name = getComponentNameFromType(type);
            return name ? "<" + name + ">" : "<...>";
          } catch (x2) {
            return "<...>";
          }
        }
        function getOwner() {
          var dispatcher = ReactSharedInternals.A;
          return null === dispatcher ? null : dispatcher.getOwner();
        }
        function UnknownOwner() {
          return Error("react-stack-top-frame");
        }
        function hasValidKey(config2) {
          if (hasOwnProperty.call(config2, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config2, "key").get;
            if (getter && getter.isReactWarning) return false;
          }
          return void 0 !== config2.key;
        }
        function defineKeyPropWarningGetter(props, displayName) {
          function warnAboutAccessingKey() {
            specialPropKeyWarningShown || (specialPropKeyWarningShown = true, console.error(
              "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
              displayName
            ));
          }
          warnAboutAccessingKey.isReactWarning = true;
          Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: true
          });
        }
        function elementRefGetterWithDeprecationWarning() {
          var componentName = getComponentNameFromType(this.type);
          didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = true, console.error(
            "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
          ));
          componentName = this.props.ref;
          return void 0 !== componentName ? componentName : null;
        }
        function ReactElement(type, key, props, owner, debugStack, debugTask) {
          var refProp = props.ref;
          type = {
            $$typeof: REACT_ELEMENT_TYPE,
            type,
            key,
            props,
            _owner: owner
          };
          null !== (void 0 !== refProp ? refProp : null) ? Object.defineProperty(type, "ref", {
            enumerable: false,
            get: elementRefGetterWithDeprecationWarning
          }) : Object.defineProperty(type, "ref", { enumerable: false, value: null });
          type._store = {};
          Object.defineProperty(type._store, "validated", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: 0
          });
          Object.defineProperty(type, "_debugInfo", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: null
          });
          Object.defineProperty(type, "_debugStack", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: debugStack
          });
          Object.defineProperty(type, "_debugTask", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: debugTask
          });
          Object.freeze && (Object.freeze(type.props), Object.freeze(type));
          return type;
        }
        function cloneAndReplaceKey(oldElement, newKey) {
          newKey = ReactElement(
            oldElement.type,
            newKey,
            oldElement.props,
            oldElement._owner,
            oldElement._debugStack,
            oldElement._debugTask
          );
          oldElement._store && (newKey._store.validated = oldElement._store.validated);
          return newKey;
        }
        function validateChildKeys(node) {
          isValidElement5(node) ? node._store && (node._store.validated = 1) : "object" === typeof node && null !== node && node.$$typeof === REACT_LAZY_TYPE2 && ("fulfilled" === node._payload.status ? isValidElement5(node._payload.value) && node._payload.value._store && (node._payload.value._store.validated = 1) : node._store && (node._store.validated = 1));
        }
        function isValidElement5(object) {
          return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function escape(key) {
          var escaperLookup = { "=": "=0", ":": "=2" };
          return "$" + key.replace(/[=:]/g, function(match2) {
            return escaperLookup[match2];
          });
        }
        function getElementKey(element, index2) {
          return "object" === typeof element && null !== element && null != element.key ? (checkKeyStringCoercion(element.key), escape("" + element.key)) : index2.toString(36);
        }
        function resolveThenable(thenable) {
          switch (thenable.status) {
            case "fulfilled":
              return thenable.value;
            case "rejected":
              throw thenable.reason;
            default:
              switch ("string" === typeof thenable.status ? thenable.then(noop5, noop5) : (thenable.status = "pending", thenable.then(
                function(fulfilledValue) {
                  "pending" === thenable.status && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
                },
                function(error) {
                  "pending" === thenable.status && (thenable.status = "rejected", thenable.reason = error);
                }
              )), thenable.status) {
                case "fulfilled":
                  return thenable.value;
                case "rejected":
                  throw thenable.reason;
              }
          }
          throw thenable;
        }
        function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
          var type = typeof children;
          if ("undefined" === type || "boolean" === type) children = null;
          var invokeCallback = false;
          if (null === children) invokeCallback = true;
          else
            switch (type) {
              case "bigint":
              case "string":
              case "number":
                invokeCallback = true;
                break;
              case "object":
                switch (children.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                  case REACT_PORTAL_TYPE:
                    invokeCallback = true;
                    break;
                  case REACT_LAZY_TYPE2:
                    return invokeCallback = children._init, mapIntoArray(
                      invokeCallback(children._payload),
                      array,
                      escapedPrefix,
                      nameSoFar,
                      callback
                    );
                }
            }
          if (invokeCallback) {
            invokeCallback = children;
            callback = callback(invokeCallback);
            var childKey = "" === nameSoFar ? "." + getElementKey(invokeCallback, 0) : nameSoFar;
            isArrayImpl(callback) ? (escapedPrefix = "", null != childKey && (escapedPrefix = childKey.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array, escapedPrefix, "", function(c) {
              return c;
            })) : null != callback && (isValidElement5(callback) && (null != callback.key && (invokeCallback && invokeCallback.key === callback.key || checkKeyStringCoercion(callback.key)), escapedPrefix = cloneAndReplaceKey(
              callback,
              escapedPrefix + (null == callback.key || invokeCallback && invokeCallback.key === callback.key ? "" : ("" + callback.key).replace(
                userProvidedKeyEscapeRegex,
                "$&/"
              ) + "/") + childKey
            ), "" !== nameSoFar && null != invokeCallback && isValidElement5(invokeCallback) && null == invokeCallback.key && invokeCallback._store && !invokeCallback._store.validated && (escapedPrefix._store.validated = 2), callback = escapedPrefix), array.push(callback));
            return 1;
          }
          invokeCallback = 0;
          childKey = "" === nameSoFar ? "." : nameSoFar + ":";
          if (isArrayImpl(children))
            for (var i3 = 0; i3 < children.length; i3++)
              nameSoFar = children[i3], type = childKey + getElementKey(nameSoFar, i3), invokeCallback += mapIntoArray(
                nameSoFar,
                array,
                escapedPrefix,
                type,
                callback
              );
          else if (i3 = getIteratorFn(children), "function" === typeof i3)
            for (i3 === children.entries && (didWarnAboutMaps || console.warn(
              "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
            ), didWarnAboutMaps = true), children = i3.call(children), i3 = 0; !(nameSoFar = children.next()).done; )
              nameSoFar = nameSoFar.value, type = childKey + getElementKey(nameSoFar, i3++), invokeCallback += mapIntoArray(
                nameSoFar,
                array,
                escapedPrefix,
                type,
                callback
              );
          else if ("object" === type) {
            if ("function" === typeof children.then)
              return mapIntoArray(
                resolveThenable(children),
                array,
                escapedPrefix,
                nameSoFar,
                callback
              );
            array = String(children);
            throw Error(
              "Objects are not valid as a React child (found: " + ("[object Object]" === array ? "object with keys {" + Object.keys(children).join(", ") + "}" : array) + "). If you meant to render a collection of children, use an array instead."
            );
          }
          return invokeCallback;
        }
        function mapChildren(children, func, context) {
          if (null == children) return children;
          var result = [], count3 = 0;
          mapIntoArray(children, result, "", "", function(child) {
            return func.call(context, child, count3++);
          });
          return result;
        }
        function lazyInitializer(payload) {
          if (-1 === payload._status) {
            var ioInfo = payload._ioInfo;
            null != ioInfo && (ioInfo.start = ioInfo.end = performance.now());
            ioInfo = payload._result;
            var thenable = ioInfo();
            thenable.then(
              function(moduleObject) {
                if (0 === payload._status || -1 === payload._status) {
                  payload._status = 1;
                  payload._result = moduleObject;
                  var _ioInfo = payload._ioInfo;
                  null != _ioInfo && (_ioInfo.end = performance.now());
                  void 0 === thenable.status && (thenable.status = "fulfilled", thenable.value = moduleObject);
                }
              },
              function(error) {
                if (0 === payload._status || -1 === payload._status) {
                  payload._status = 2;
                  payload._result = error;
                  var _ioInfo2 = payload._ioInfo;
                  null != _ioInfo2 && (_ioInfo2.end = performance.now());
                  void 0 === thenable.status && (thenable.status = "rejected", thenable.reason = error);
                }
              }
            );
            ioInfo = payload._ioInfo;
            if (null != ioInfo) {
              ioInfo.value = thenable;
              var displayName = thenable.displayName;
              "string" === typeof displayName && (ioInfo.name = displayName);
            }
            -1 === payload._status && (payload._status = 0, payload._result = thenable);
          }
          if (1 === payload._status)
            return ioInfo = payload._result, void 0 === ioInfo && console.error(
              "lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?",
              ioInfo
            ), "default" in ioInfo || console.error(
              "lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))",
              ioInfo
            ), ioInfo.default;
          throw payload._result;
        }
        function resolveDispatcher() {
          var dispatcher = ReactSharedInternals.H;
          null === dispatcher && console.error(
            "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
          );
          return dispatcher;
        }
        function releaseAsyncTransition() {
          ReactSharedInternals.asyncTransitions--;
        }
        function enqueueTask(task) {
          if (null === enqueueTaskImpl)
            try {
              var requireString = ("require" + Math.random()).slice(0, 7);
              enqueueTaskImpl = (module && module[requireString]).call(
                module,
                "timers"
              ).setImmediate;
            } catch (_err) {
              enqueueTaskImpl = function(callback) {
                false === didWarnAboutMessageChannel && (didWarnAboutMessageChannel = true, "undefined" === typeof MessageChannel && console.error(
                  "This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."
                ));
                var channel = new MessageChannel();
                channel.port1.onmessage = callback;
                channel.port2.postMessage(void 0);
              };
            }
          return enqueueTaskImpl(task);
        }
        function aggregateErrors(errors) {
          return 1 < errors.length && "function" === typeof AggregateError ? new AggregateError(errors) : errors[0];
        }
        function popActScope(prevActQueue, prevActScopeDepth) {
          prevActScopeDepth !== actScopeDepth - 1 && console.error(
            "You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "
          );
          actScopeDepth = prevActScopeDepth;
        }
        function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
          var queue = ReactSharedInternals.actQueue;
          if (null !== queue)
            if (0 !== queue.length)
              try {
                flushActQueue(queue);
                enqueueTask(function() {
                  return recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                });
                return;
              } catch (error) {
                ReactSharedInternals.thrownErrors.push(error);
              }
            else ReactSharedInternals.actQueue = null;
          0 < ReactSharedInternals.thrownErrors.length ? (queue = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, reject(queue)) : resolve(returnValue);
        }
        function flushActQueue(queue) {
          if (!isFlushing) {
            isFlushing = true;
            var i3 = 0;
            try {
              for (; i3 < queue.length; i3++) {
                var callback = queue[i3];
                do {
                  ReactSharedInternals.didUsePromise = false;
                  var continuation = callback(false);
                  if (null !== continuation) {
                    if (ReactSharedInternals.didUsePromise) {
                      queue[i3] = callback;
                      queue.splice(0, i3);
                      return;
                    }
                    callback = continuation;
                  } else break;
                } while (1);
              }
              queue.length = 0;
            } catch (error) {
              queue.splice(0, i3 + 1), ReactSharedInternals.thrownErrors.push(error);
            } finally {
              isFlushing = false;
            }
          }
        }
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
        var REACT_ELEMENT_TYPE = /* @__PURE__ */ Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = /* @__PURE__ */ Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = /* @__PURE__ */ Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = /* @__PURE__ */ Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = /* @__PURE__ */ Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = /* @__PURE__ */ Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = /* @__PURE__ */ Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = /* @__PURE__ */ Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = /* @__PURE__ */ Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = /* @__PURE__ */ Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = /* @__PURE__ */ Symbol.for("react.memo"), REACT_LAZY_TYPE2 = /* @__PURE__ */ Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = /* @__PURE__ */ Symbol.for("react.activity"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, didWarnStateUpdateForUnmountedComponent = {}, ReactNoopUpdateQueue = {
          isMounted: function() {
            return false;
          },
          enqueueForceUpdate: function(publicInstance) {
            warnNoop(publicInstance, "forceUpdate");
          },
          enqueueReplaceState: function(publicInstance) {
            warnNoop(publicInstance, "replaceState");
          },
          enqueueSetState: function(publicInstance) {
            warnNoop(publicInstance, "setState");
          }
        }, assign2 = Object.assign, emptyObject = {};
        Object.freeze(emptyObject);
        Component3.prototype.isReactComponent = {};
        Component3.prototype.setState = function(partialState, callback) {
          if ("object" !== typeof partialState && "function" !== typeof partialState && null != partialState)
            throw Error(
              "takes an object of state variables to update or a function which returns an object of state variables."
            );
          this.updater.enqueueSetState(this, partialState, callback, "setState");
        };
        Component3.prototype.forceUpdate = function(callback) {
          this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
        };
        var deprecatedAPIs = {
          isMounted: [
            "isMounted",
            "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."
          ],
          replaceState: [
            "replaceState",
            "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."
          ]
        };
        for (fnName in deprecatedAPIs)
          deprecatedAPIs.hasOwnProperty(fnName) && defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
        ComponentDummy.prototype = Component3.prototype;
        deprecatedAPIs = PureComponent.prototype = new ComponentDummy();
        deprecatedAPIs.constructor = PureComponent;
        assign2(deprecatedAPIs, Component3.prototype);
        deprecatedAPIs.isPureReactComponent = true;
        var isArrayImpl = Array.isArray, REACT_CLIENT_REFERENCE = /* @__PURE__ */ Symbol.for("react.client.reference"), ReactSharedInternals = {
          H: null,
          A: null,
          T: null,
          S: null,
          actQueue: null,
          asyncTransitions: 0,
          isBatchingLegacy: false,
          didScheduleLegacyUpdate: false,
          didUsePromise: false,
          thrownErrors: [],
          getCurrentStack: null,
          recentlyCreatedOwnerStacks: 0
        }, hasOwnProperty = Object.prototype.hasOwnProperty, createTask = console.createTask ? console.createTask : function() {
          return null;
        };
        deprecatedAPIs = {
          react_stack_bottom_frame: function(callStackForError) {
            return callStackForError();
          }
        };
        var specialPropKeyWarningShown, didWarnAboutOldJSXRuntime;
        var didWarnAboutElementRef = {};
        var unknownOwnerDebugStack = deprecatedAPIs.react_stack_bottom_frame.bind(
          deprecatedAPIs,
          UnknownOwner
        )();
        var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
        var didWarnAboutMaps = false, userProvidedKeyEscapeRegex = /\/+/g, reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
          if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
            var event = new window.ErrorEvent("error", {
              bubbles: true,
              cancelable: true,
              message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
              error
            });
            if (!window.dispatchEvent(event)) return;
          } else if ("object" === typeof process && "function" === typeof process.emit) {
            process.emit("uncaughtException", error);
            return;
          }
          console.error(error);
        }, didWarnAboutMessageChannel = false, enqueueTaskImpl = null, actScopeDepth = 0, didWarnNoAwaitAct = false, isFlushing = false, queueSeveralMicrotasks = "function" === typeof queueMicrotask ? function(callback) {
          queueMicrotask(function() {
            return queueMicrotask(callback);
          });
        } : enqueueTask;
        deprecatedAPIs = Object.freeze({
          __proto__: null,
          c: function(size4) {
            return resolveDispatcher().useMemoCache(size4);
          }
        });
        var fnName = {
          map: mapChildren,
          forEach: function(children, forEachFunc, forEachContext) {
            mapChildren(
              children,
              function() {
                forEachFunc.apply(this, arguments);
              },
              forEachContext
            );
          },
          count: function(children) {
            var n2 = 0;
            mapChildren(children, function() {
              n2++;
            });
            return n2;
          },
          toArray: function(children) {
            return mapChildren(children, function(child) {
              return child;
            }) || [];
          },
          only: function(children) {
            if (!isValidElement5(children))
              throw Error(
                "React.Children.only expected to receive a single React element child."
              );
            return children;
          }
        };
        exports.Activity = REACT_ACTIVITY_TYPE;
        exports.Children = fnName;
        exports.Component = Component3;
        exports.Fragment = REACT_FRAGMENT_TYPE;
        exports.Profiler = REACT_PROFILER_TYPE;
        exports.PureComponent = PureComponent;
        exports.StrictMode = REACT_STRICT_MODE_TYPE;
        exports.Suspense = REACT_SUSPENSE_TYPE;
        exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
        exports.__COMPILER_RUNTIME = deprecatedAPIs;
        exports.act = function(callback) {
          var prevActQueue = ReactSharedInternals.actQueue, prevActScopeDepth = actScopeDepth;
          actScopeDepth++;
          var queue = ReactSharedInternals.actQueue = null !== prevActQueue ? prevActQueue : [], didAwaitActCall = false;
          try {
            var result = callback();
          } catch (error) {
            ReactSharedInternals.thrownErrors.push(error);
          }
          if (0 < ReactSharedInternals.thrownErrors.length)
            throw popActScope(prevActQueue, prevActScopeDepth), callback = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, callback;
          if (null !== result && "object" === typeof result && "function" === typeof result.then) {
            var thenable = result;
            queueSeveralMicrotasks(function() {
              didAwaitActCall || didWarnNoAwaitAct || (didWarnNoAwaitAct = true, console.error(
                "You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"
              ));
            });
            return {
              then: function(resolve, reject) {
                didAwaitActCall = true;
                thenable.then(
                  function(returnValue) {
                    popActScope(prevActQueue, prevActScopeDepth);
                    if (0 === prevActScopeDepth) {
                      try {
                        flushActQueue(queue), enqueueTask(function() {
                          return recursivelyFlushAsyncActWork(
                            returnValue,
                            resolve,
                            reject
                          );
                        });
                      } catch (error$0) {
                        ReactSharedInternals.thrownErrors.push(error$0);
                      }
                      if (0 < ReactSharedInternals.thrownErrors.length) {
                        var _thrownError = aggregateErrors(
                          ReactSharedInternals.thrownErrors
                        );
                        ReactSharedInternals.thrownErrors.length = 0;
                        reject(_thrownError);
                      }
                    } else resolve(returnValue);
                  },
                  function(error) {
                    popActScope(prevActQueue, prevActScopeDepth);
                    0 < ReactSharedInternals.thrownErrors.length ? (error = aggregateErrors(
                      ReactSharedInternals.thrownErrors
                    ), ReactSharedInternals.thrownErrors.length = 0, reject(error)) : reject(error);
                  }
                );
              }
            };
          }
          var returnValue$jscomp$0 = result;
          popActScope(prevActQueue, prevActScopeDepth);
          0 === prevActScopeDepth && (flushActQueue(queue), 0 !== queue.length && queueSeveralMicrotasks(function() {
            didAwaitActCall || didWarnNoAwaitAct || (didWarnNoAwaitAct = true, console.error(
              "A component suspended inside an `act` scope, but the `act` call was not awaited. When testing React components that depend on asynchronous data, you must await the result:\n\nawait act(() => ...)"
            ));
          }), ReactSharedInternals.actQueue = null);
          if (0 < ReactSharedInternals.thrownErrors.length)
            throw callback = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, callback;
          return {
            then: function(resolve, reject) {
              didAwaitActCall = true;
              0 === prevActScopeDepth ? (ReactSharedInternals.actQueue = queue, enqueueTask(function() {
                return recursivelyFlushAsyncActWork(
                  returnValue$jscomp$0,
                  resolve,
                  reject
                );
              })) : resolve(returnValue$jscomp$0);
            }
          };
        };
        exports.cache = function(fn) {
          return function() {
            return fn.apply(null, arguments);
          };
        };
        exports.cacheSignal = function() {
          return null;
        };
        exports.captureOwnerStack = function() {
          var getCurrentStack = ReactSharedInternals.getCurrentStack;
          return null === getCurrentStack ? null : getCurrentStack();
        };
        exports.cloneElement = function(element, config2, children) {
          if (null === element || void 0 === element)
            throw Error(
              "The argument must be a React element, but you passed " + element + "."
            );
          var props = assign2({}, element.props), key = element.key, owner = element._owner;
          if (null != config2) {
            var JSCompiler_inline_result;
            a: {
              if (hasOwnProperty.call(config2, "ref") && (JSCompiler_inline_result = Object.getOwnPropertyDescriptor(
                config2,
                "ref"
              ).get) && JSCompiler_inline_result.isReactWarning) {
                JSCompiler_inline_result = false;
                break a;
              }
              JSCompiler_inline_result = void 0 !== config2.ref;
            }
            JSCompiler_inline_result && (owner = getOwner());
            hasValidKey(config2) && (checkKeyStringCoercion(config2.key), key = "" + config2.key);
            for (propName in config2)
              !hasOwnProperty.call(config2, propName) || "key" === propName || "__self" === propName || "__source" === propName || "ref" === propName && void 0 === config2.ref || (props[propName] = config2[propName]);
          }
          var propName = arguments.length - 2;
          if (1 === propName) props.children = children;
          else if (1 < propName) {
            JSCompiler_inline_result = Array(propName);
            for (var i3 = 0; i3 < propName; i3++)
              JSCompiler_inline_result[i3] = arguments[i3 + 2];
            props.children = JSCompiler_inline_result;
          }
          props = ReactElement(
            element.type,
            key,
            props,
            owner,
            element._debugStack,
            element._debugTask
          );
          for (key = 2; key < arguments.length; key++)
            validateChildKeys(arguments[key]);
          return props;
        };
        exports.createContext = function(defaultValue) {
          defaultValue = {
            $$typeof: REACT_CONTEXT_TYPE,
            _currentValue: defaultValue,
            _currentValue2: defaultValue,
            _threadCount: 0,
            Provider: null,
            Consumer: null
          };
          defaultValue.Provider = defaultValue;
          defaultValue.Consumer = {
            $$typeof: REACT_CONSUMER_TYPE,
            _context: defaultValue
          };
          defaultValue._currentRenderer = null;
          defaultValue._currentRenderer2 = null;
          return defaultValue;
        };
        exports.createElement = function(type, config2, children) {
          for (var i3 = 2; i3 < arguments.length; i3++)
            validateChildKeys(arguments[i3]);
          i3 = {};
          var key = null;
          if (null != config2)
            for (propName in didWarnAboutOldJSXRuntime || !("__self" in config2) || "key" in config2 || (didWarnAboutOldJSXRuntime = true, console.warn(
              "Your app (or one of its dependencies) is using an outdated JSX transform. Update to the modern JSX transform for faster performance: https://react.dev/link/new-jsx-transform"
            )), hasValidKey(config2) && (checkKeyStringCoercion(config2.key), key = "" + config2.key), config2)
              hasOwnProperty.call(config2, propName) && "key" !== propName && "__self" !== propName && "__source" !== propName && (i3[propName] = config2[propName]);
          var childrenLength = arguments.length - 2;
          if (1 === childrenLength) i3.children = children;
          else if (1 < childrenLength) {
            for (var childArray = Array(childrenLength), _i = 0; _i < childrenLength; _i++)
              childArray[_i] = arguments[_i + 2];
            Object.freeze && Object.freeze(childArray);
            i3.children = childArray;
          }
          if (type && type.defaultProps)
            for (propName in childrenLength = type.defaultProps, childrenLength)
              void 0 === i3[propName] && (i3[propName] = childrenLength[propName]);
          key && defineKeyPropWarningGetter(
            i3,
            "function" === typeof type ? type.displayName || type.name || "Unknown" : type
          );
          var propName = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
          return ReactElement(
            type,
            key,
            i3,
            getOwner(),
            propName ? Error("react-stack-top-frame") : unknownOwnerDebugStack,
            propName ? createTask(getTaskName(type)) : unknownOwnerDebugTask
          );
        };
        exports.createRef = function() {
          var refObject = { current: null };
          Object.seal(refObject);
          return refObject;
        };
        exports.forwardRef = function(render) {
          null != render && render.$$typeof === REACT_MEMO_TYPE ? console.error(
            "forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...))."
          ) : "function" !== typeof render ? console.error(
            "forwardRef requires a render function but was given %s.",
            null === render ? "null" : typeof render
          ) : 0 !== render.length && 2 !== render.length && console.error(
            "forwardRef render functions accept exactly two parameters: props and ref. %s",
            1 === render.length ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined."
          );
          null != render && null != render.defaultProps && console.error(
            "forwardRef render functions do not support defaultProps. Did you accidentally pass a React component?"
          );
          var elementType = { $$typeof: REACT_FORWARD_REF_TYPE, render }, ownName;
          Object.defineProperty(elementType, "displayName", {
            enumerable: false,
            configurable: true,
            get: function() {
              return ownName;
            },
            set: function(name) {
              ownName = name;
              render.name || render.displayName || (Object.defineProperty(render, "name", { value: name }), render.displayName = name);
            }
          });
          return elementType;
        };
        exports.isValidElement = isValidElement5;
        exports.lazy = function(ctor) {
          ctor = { _status: -1, _result: ctor };
          var lazyType = {
            $$typeof: REACT_LAZY_TYPE2,
            _payload: ctor,
            _init: lazyInitializer
          }, ioInfo = {
            name: "lazy",
            start: -1,
            end: -1,
            value: null,
            owner: null,
            debugStack: Error("react-stack-top-frame"),
            debugTask: console.createTask ? console.createTask("lazy()") : null
          };
          ctor._ioInfo = ioInfo;
          lazyType._debugInfo = [{ awaited: ioInfo }];
          return lazyType;
        };
        exports.memo = function(type, compare) {
          null == type && console.error(
            "memo: The first argument must be a component. Instead received: %s",
            null === type ? "null" : typeof type
          );
          compare = {
            $$typeof: REACT_MEMO_TYPE,
            type,
            compare: void 0 === compare ? null : compare
          };
          var ownName;
          Object.defineProperty(compare, "displayName", {
            enumerable: false,
            configurable: true,
            get: function() {
              return ownName;
            },
            set: function(name) {
              ownName = name;
              type.name || type.displayName || (Object.defineProperty(type, "name", { value: name }), type.displayName = name);
            }
          });
          return compare;
        };
        exports.startTransition = function(scope) {
          var prevTransition = ReactSharedInternals.T, currentTransition = {};
          currentTransition._updatedFibers = /* @__PURE__ */ new Set();
          ReactSharedInternals.T = currentTransition;
          try {
            var returnValue = scope(), onStartTransitionFinish = ReactSharedInternals.S;
            null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
            "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && (ReactSharedInternals.asyncTransitions++, returnValue.then(releaseAsyncTransition, releaseAsyncTransition), returnValue.then(noop5, reportGlobalError));
          } catch (error) {
            reportGlobalError(error);
          } finally {
            null === prevTransition && currentTransition._updatedFibers && (scope = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < scope && console.warn(
              "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
            )), null !== prevTransition && null !== currentTransition.types && (null !== prevTransition.types && prevTransition.types !== currentTransition.types && console.error(
              "We expected inner Transitions to have transferred the outer types set and that you cannot add to the outer Transition while inside the inner.This is a bug in React."
            ), prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition;
          }
        };
        exports.unstable_useCacheRefresh = function() {
          return resolveDispatcher().useCacheRefresh();
        };
        exports.use = function(usable) {
          return resolveDispatcher().use(usable);
        };
        exports.useActionState = function(action, initialState, permalink) {
          return resolveDispatcher().useActionState(
            action,
            initialState,
            permalink
          );
        };
        exports.useCallback = function(callback, deps) {
          return resolveDispatcher().useCallback(callback, deps);
        };
        exports.useContext = function(Context) {
          var dispatcher = resolveDispatcher();
          Context.$$typeof === REACT_CONSUMER_TYPE && console.error(
            "Calling useContext(Context.Consumer) is not supported and will cause bugs. Did you mean to call useContext(Context) instead?"
          );
          return dispatcher.useContext(Context);
        };
        exports.useDebugValue = function(value, formatterFn) {
          return resolveDispatcher().useDebugValue(value, formatterFn);
        };
        exports.useDeferredValue = function(value, initialValue) {
          return resolveDispatcher().useDeferredValue(value, initialValue);
        };
        exports.useEffect = function(create, deps) {
          null == create && console.warn(
            "React Hook useEffect requires an effect callback. Did you forget to pass a callback to the hook?"
          );
          return resolveDispatcher().useEffect(create, deps);
        };
        exports.useEffectEvent = function(callback) {
          return resolveDispatcher().useEffectEvent(callback);
        };
        exports.useId = function() {
          return resolveDispatcher().useId();
        };
        exports.useImperativeHandle = function(ref, create, deps) {
          return resolveDispatcher().useImperativeHandle(ref, create, deps);
        };
        exports.useInsertionEffect = function(create, deps) {
          null == create && console.warn(
            "React Hook useInsertionEffect requires an effect callback. Did you forget to pass a callback to the hook?"
          );
          return resolveDispatcher().useInsertionEffect(create, deps);
        };
        exports.useLayoutEffect = function(create, deps) {
          null == create && console.warn(
            "React Hook useLayoutEffect requires an effect callback. Did you forget to pass a callback to the hook?"
          );
          return resolveDispatcher().useLayoutEffect(create, deps);
        };
        exports.useMemo = function(create, deps) {
          return resolveDispatcher().useMemo(create, deps);
        };
        exports.useOptimistic = function(passthrough, reducer) {
          return resolveDispatcher().useOptimistic(passthrough, reducer);
        };
        exports.useReducer = function(reducer, initialArg, init) {
          return resolveDispatcher().useReducer(reducer, initialArg, init);
        };
        exports.useRef = function(initialValue) {
          return resolveDispatcher().useRef(initialValue);
        };
        exports.useState = function(initialState) {
          return resolveDispatcher().useState(initialState);
        };
        exports.useSyncExternalStore = function(subscribe2, getSnapshot, getServerSnapshot) {
          return resolveDispatcher().useSyncExternalStore(
            subscribe2,
            getSnapshot,
            getServerSnapshot
          );
        };
        exports.useTransition = function() {
          return resolveDispatcher().useTransition();
        };
        exports.version = "19.2.3";
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
      })();
    }
  });

  // ../../node_modules/react/index.js
  var require_react2 = __commonJS({
    "../../node_modules/react/index.js"(exports, module) {
      "use strict";
      if (process.env.NODE_ENV === "production") {
        module.exports = require_react_production2();
      } else {
        module.exports = require_react_development2();
      }
    }
  });

  // node_modules/react/cjs/react-jsx-runtime.production.js
  var require_react_jsx_runtime_production = __commonJS({
    "node_modules/react/cjs/react-jsx-runtime.production.js"(exports) {
      "use strict";
      var REACT_ELEMENT_TYPE = /* @__PURE__ */ Symbol.for("react.transitional.element");
      var REACT_FRAGMENT_TYPE = /* @__PURE__ */ Symbol.for("react.fragment");
      function jsxProd(type, config2, maybeKey) {
        var key = null;
        void 0 !== maybeKey && (key = "" + maybeKey);
        void 0 !== config2.key && (key = "" + config2.key);
        if ("key" in config2) {
          maybeKey = {};
          for (var propName in config2)
            "key" !== propName && (maybeKey[propName] = config2[propName]);
        } else maybeKey = config2;
        config2 = maybeKey.ref;
        return {
          $$typeof: REACT_ELEMENT_TYPE,
          type,
          key,
          ref: void 0 !== config2 ? config2 : null,
          props: maybeKey
        };
      }
      exports.Fragment = REACT_FRAGMENT_TYPE;
      exports.jsx = jsxProd;
      exports.jsxs = jsxProd;
    }
  });

  // node_modules/react/cjs/react-jsx-runtime.development.js
  var require_react_jsx_runtime_development = __commonJS({
    "node_modules/react/cjs/react-jsx-runtime.development.js"(exports) {
      "use strict";
      "production" !== process.env.NODE_ENV && (function() {
        function getComponentNameFromType(type) {
          if (null == type) return null;
          if ("function" === typeof type)
            return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
          if ("string" === typeof type) return type;
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
            case REACT_ACTIVITY_TYPE:
              return "Activity";
          }
          if ("object" === typeof type)
            switch ("number" === typeof type.tag && console.error(
              "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
            ), type.$$typeof) {
              case REACT_PORTAL_TYPE:
                return "Portal";
              case REACT_CONTEXT_TYPE:
                return type.displayName || "Context";
              case REACT_CONSUMER_TYPE:
                return (type._context.displayName || "Context") + ".Consumer";
              case REACT_FORWARD_REF_TYPE:
                var innerType = type.render;
                type = type.displayName;
                type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
                return type;
              case REACT_MEMO_TYPE:
                return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
              case REACT_LAZY_TYPE2:
                innerType = type._payload;
                type = type._init;
                try {
                  return getComponentNameFromType(type(innerType));
                } catch (x2) {
                }
            }
          return null;
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkKeyStringCoercion(value) {
          try {
            testStringCoercion(value);
            var JSCompiler_inline_result = false;
          } catch (e2) {
            JSCompiler_inline_result = true;
          }
          if (JSCompiler_inline_result) {
            JSCompiler_inline_result = console;
            var JSCompiler_temp_const = JSCompiler_inline_result.error;
            var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            JSCompiler_temp_const.call(
              JSCompiler_inline_result,
              "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
              JSCompiler_inline_result$jscomp$0
            );
            return testStringCoercion(value);
          }
        }
        function getTaskName(type) {
          if (type === REACT_FRAGMENT_TYPE) return "<>";
          if ("object" === typeof type && null !== type && type.$$typeof === REACT_LAZY_TYPE2)
            return "<...>";
          try {
            var name = getComponentNameFromType(type);
            return name ? "<" + name + ">" : "<...>";
          } catch (x2) {
            return "<...>";
          }
        }
        function getOwner() {
          var dispatcher = ReactSharedInternals.A;
          return null === dispatcher ? null : dispatcher.getOwner();
        }
        function UnknownOwner() {
          return Error("react-stack-top-frame");
        }
        function hasValidKey(config2) {
          if (hasOwnProperty.call(config2, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config2, "key").get;
            if (getter && getter.isReactWarning) return false;
          }
          return void 0 !== config2.key;
        }
        function defineKeyPropWarningGetter(props, displayName) {
          function warnAboutAccessingKey() {
            specialPropKeyWarningShown || (specialPropKeyWarningShown = true, console.error(
              "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
              displayName
            ));
          }
          warnAboutAccessingKey.isReactWarning = true;
          Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: true
          });
        }
        function elementRefGetterWithDeprecationWarning() {
          var componentName = getComponentNameFromType(this.type);
          didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = true, console.error(
            "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
          ));
          componentName = this.props.ref;
          return void 0 !== componentName ? componentName : null;
        }
        function ReactElement(type, key, props, owner, debugStack, debugTask) {
          var refProp = props.ref;
          type = {
            $$typeof: REACT_ELEMENT_TYPE,
            type,
            key,
            props,
            _owner: owner
          };
          null !== (void 0 !== refProp ? refProp : null) ? Object.defineProperty(type, "ref", {
            enumerable: false,
            get: elementRefGetterWithDeprecationWarning
          }) : Object.defineProperty(type, "ref", { enumerable: false, value: null });
          type._store = {};
          Object.defineProperty(type._store, "validated", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: 0
          });
          Object.defineProperty(type, "_debugInfo", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: null
          });
          Object.defineProperty(type, "_debugStack", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: debugStack
          });
          Object.defineProperty(type, "_debugTask", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: debugTask
          });
          Object.freeze && (Object.freeze(type.props), Object.freeze(type));
          return type;
        }
        function jsxDEVImpl(type, config2, maybeKey, isStaticChildren, debugStack, debugTask) {
          var children = config2.children;
          if (void 0 !== children)
            if (isStaticChildren)
              if (isArrayImpl(children)) {
                for (isStaticChildren = 0; isStaticChildren < children.length; isStaticChildren++)
                  validateChildKeys(children[isStaticChildren]);
                Object.freeze && Object.freeze(children);
              } else
                console.error(
                  "React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead."
                );
            else validateChildKeys(children);
          if (hasOwnProperty.call(config2, "key")) {
            children = getComponentNameFromType(type);
            var keys2 = Object.keys(config2).filter(function(k5) {
              return "key" !== k5;
            });
            isStaticChildren = 0 < keys2.length ? "{key: someKey, " + keys2.join(": ..., ") + ": ...}" : "{key: someKey}";
            didWarnAboutKeySpread[children + isStaticChildren] || (keys2 = 0 < keys2.length ? "{" + keys2.join(": ..., ") + ": ...}" : "{}", console.error(
              'A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />',
              isStaticChildren,
              children,
              keys2,
              children
            ), didWarnAboutKeySpread[children + isStaticChildren] = true);
          }
          children = null;
          void 0 !== maybeKey && (checkKeyStringCoercion(maybeKey), children = "" + maybeKey);
          hasValidKey(config2) && (checkKeyStringCoercion(config2.key), children = "" + config2.key);
          if ("key" in config2) {
            maybeKey = {};
            for (var propName in config2)
              "key" !== propName && (maybeKey[propName] = config2[propName]);
          } else maybeKey = config2;
          children && defineKeyPropWarningGetter(
            maybeKey,
            "function" === typeof type ? type.displayName || type.name || "Unknown" : type
          );
          return ReactElement(
            type,
            children,
            maybeKey,
            getOwner(),
            debugStack,
            debugTask
          );
        }
        function validateChildKeys(node) {
          isValidElement5(node) ? node._store && (node._store.validated = 1) : "object" === typeof node && null !== node && node.$$typeof === REACT_LAZY_TYPE2 && ("fulfilled" === node._payload.status ? isValidElement5(node._payload.value) && node._payload.value._store && (node._payload.value._store.validated = 1) : node._store && (node._store.validated = 1));
        }
        function isValidElement5(object) {
          return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        var React117 = require_react(), REACT_ELEMENT_TYPE = /* @__PURE__ */ Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = /* @__PURE__ */ Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = /* @__PURE__ */ Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = /* @__PURE__ */ Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = /* @__PURE__ */ Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = /* @__PURE__ */ Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = /* @__PURE__ */ Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = /* @__PURE__ */ Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = /* @__PURE__ */ Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = /* @__PURE__ */ Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = /* @__PURE__ */ Symbol.for("react.memo"), REACT_LAZY_TYPE2 = /* @__PURE__ */ Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = /* @__PURE__ */ Symbol.for("react.activity"), REACT_CLIENT_REFERENCE = /* @__PURE__ */ Symbol.for("react.client.reference"), ReactSharedInternals = React117.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, hasOwnProperty = Object.prototype.hasOwnProperty, isArrayImpl = Array.isArray, createTask = console.createTask ? console.createTask : function() {
          return null;
        };
        React117 = {
          react_stack_bottom_frame: function(callStackForError) {
            return callStackForError();
          }
        };
        var specialPropKeyWarningShown;
        var didWarnAboutElementRef = {};
        var unknownOwnerDebugStack = React117.react_stack_bottom_frame.bind(
          React117,
          UnknownOwner
        )();
        var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
        var didWarnAboutKeySpread = {};
        exports.Fragment = REACT_FRAGMENT_TYPE;
        exports.jsx = function(type, config2, maybeKey) {
          var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
          return jsxDEVImpl(
            type,
            config2,
            maybeKey,
            false,
            trackActualOwner ? Error("react-stack-top-frame") : unknownOwnerDebugStack,
            trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask
          );
        };
        exports.jsxs = function(type, config2, maybeKey) {
          var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
          return jsxDEVImpl(
            type,
            config2,
            maybeKey,
            true,
            trackActualOwner ? Error("react-stack-top-frame") : unknownOwnerDebugStack,
            trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask
          );
        };
      })();
    }
  });

  // node_modules/react/jsx-runtime.js
  var require_jsx_runtime = __commonJS({
    "node_modules/react/jsx-runtime.js"(exports, module) {
      "use strict";
      if (process.env.NODE_ENV === "production") {
        module.exports = require_react_jsx_runtime_production();
      } else {
        module.exports = require_react_jsx_runtime_development();
      }
    }
  });

  // ../../node_modules/react/cjs/react-jsx-runtime.production.js
  var require_react_jsx_runtime_production2 = __commonJS({
    "../../node_modules/react/cjs/react-jsx-runtime.production.js"(exports) {
      "use strict";
      var REACT_ELEMENT_TYPE = /* @__PURE__ */ Symbol.for("react.transitional.element");
      var REACT_FRAGMENT_TYPE = /* @__PURE__ */ Symbol.for("react.fragment");
      function jsxProd(type, config2, maybeKey) {
        var key = null;
        void 0 !== maybeKey && (key = "" + maybeKey);
        void 0 !== config2.key && (key = "" + config2.key);
        if ("key" in config2) {
          maybeKey = {};
          for (var propName in config2)
            "key" !== propName && (maybeKey[propName] = config2[propName]);
        } else maybeKey = config2;
        config2 = maybeKey.ref;
        return {
          $$typeof: REACT_ELEMENT_TYPE,
          type,
          key,
          ref: void 0 !== config2 ? config2 : null,
          props: maybeKey
        };
      }
      exports.Fragment = REACT_FRAGMENT_TYPE;
      exports.jsx = jsxProd;
      exports.jsxs = jsxProd;
    }
  });

  // ../../node_modules/react/cjs/react-jsx-runtime.development.js
  var require_react_jsx_runtime_development2 = __commonJS({
    "../../node_modules/react/cjs/react-jsx-runtime.development.js"(exports) {
      "use strict";
      "production" !== process.env.NODE_ENV && (function() {
        function getComponentNameFromType(type) {
          if (null == type) return null;
          if ("function" === typeof type)
            return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
          if ("string" === typeof type) return type;
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
            case REACT_ACTIVITY_TYPE:
              return "Activity";
          }
          if ("object" === typeof type)
            switch ("number" === typeof type.tag && console.error(
              "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
            ), type.$$typeof) {
              case REACT_PORTAL_TYPE:
                return "Portal";
              case REACT_CONTEXT_TYPE:
                return type.displayName || "Context";
              case REACT_CONSUMER_TYPE:
                return (type._context.displayName || "Context") + ".Consumer";
              case REACT_FORWARD_REF_TYPE:
                var innerType = type.render;
                type = type.displayName;
                type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
                return type;
              case REACT_MEMO_TYPE:
                return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
              case REACT_LAZY_TYPE2:
                innerType = type._payload;
                type = type._init;
                try {
                  return getComponentNameFromType(type(innerType));
                } catch (x2) {
                }
            }
          return null;
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkKeyStringCoercion(value) {
          try {
            testStringCoercion(value);
            var JSCompiler_inline_result = false;
          } catch (e2) {
            JSCompiler_inline_result = true;
          }
          if (JSCompiler_inline_result) {
            JSCompiler_inline_result = console;
            var JSCompiler_temp_const = JSCompiler_inline_result.error;
            var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            JSCompiler_temp_const.call(
              JSCompiler_inline_result,
              "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
              JSCompiler_inline_result$jscomp$0
            );
            return testStringCoercion(value);
          }
        }
        function getTaskName(type) {
          if (type === REACT_FRAGMENT_TYPE) return "<>";
          if ("object" === typeof type && null !== type && type.$$typeof === REACT_LAZY_TYPE2)
            return "<...>";
          try {
            var name = getComponentNameFromType(type);
            return name ? "<" + name + ">" : "<...>";
          } catch (x2) {
            return "<...>";
          }
        }
        function getOwner() {
          var dispatcher = ReactSharedInternals.A;
          return null === dispatcher ? null : dispatcher.getOwner();
        }
        function UnknownOwner() {
          return Error("react-stack-top-frame");
        }
        function hasValidKey(config2) {
          if (hasOwnProperty.call(config2, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config2, "key").get;
            if (getter && getter.isReactWarning) return false;
          }
          return void 0 !== config2.key;
        }
        function defineKeyPropWarningGetter(props, displayName) {
          function warnAboutAccessingKey() {
            specialPropKeyWarningShown || (specialPropKeyWarningShown = true, console.error(
              "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
              displayName
            ));
          }
          warnAboutAccessingKey.isReactWarning = true;
          Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: true
          });
        }
        function elementRefGetterWithDeprecationWarning() {
          var componentName = getComponentNameFromType(this.type);
          didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = true, console.error(
            "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
          ));
          componentName = this.props.ref;
          return void 0 !== componentName ? componentName : null;
        }
        function ReactElement(type, key, props, owner, debugStack, debugTask) {
          var refProp = props.ref;
          type = {
            $$typeof: REACT_ELEMENT_TYPE,
            type,
            key,
            props,
            _owner: owner
          };
          null !== (void 0 !== refProp ? refProp : null) ? Object.defineProperty(type, "ref", {
            enumerable: false,
            get: elementRefGetterWithDeprecationWarning
          }) : Object.defineProperty(type, "ref", { enumerable: false, value: null });
          type._store = {};
          Object.defineProperty(type._store, "validated", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: 0
          });
          Object.defineProperty(type, "_debugInfo", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: null
          });
          Object.defineProperty(type, "_debugStack", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: debugStack
          });
          Object.defineProperty(type, "_debugTask", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: debugTask
          });
          Object.freeze && (Object.freeze(type.props), Object.freeze(type));
          return type;
        }
        function jsxDEVImpl(type, config2, maybeKey, isStaticChildren, debugStack, debugTask) {
          var children = config2.children;
          if (void 0 !== children)
            if (isStaticChildren)
              if (isArrayImpl(children)) {
                for (isStaticChildren = 0; isStaticChildren < children.length; isStaticChildren++)
                  validateChildKeys(children[isStaticChildren]);
                Object.freeze && Object.freeze(children);
              } else
                console.error(
                  "React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead."
                );
            else validateChildKeys(children);
          if (hasOwnProperty.call(config2, "key")) {
            children = getComponentNameFromType(type);
            var keys2 = Object.keys(config2).filter(function(k5) {
              return "key" !== k5;
            });
            isStaticChildren = 0 < keys2.length ? "{key: someKey, " + keys2.join(": ..., ") + ": ...}" : "{key: someKey}";
            didWarnAboutKeySpread[children + isStaticChildren] || (keys2 = 0 < keys2.length ? "{" + keys2.join(": ..., ") + ": ...}" : "{}", console.error(
              'A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />',
              isStaticChildren,
              children,
              keys2,
              children
            ), didWarnAboutKeySpread[children + isStaticChildren] = true);
          }
          children = null;
          void 0 !== maybeKey && (checkKeyStringCoercion(maybeKey), children = "" + maybeKey);
          hasValidKey(config2) && (checkKeyStringCoercion(config2.key), children = "" + config2.key);
          if ("key" in config2) {
            maybeKey = {};
            for (var propName in config2)
              "key" !== propName && (maybeKey[propName] = config2[propName]);
          } else maybeKey = config2;
          children && defineKeyPropWarningGetter(
            maybeKey,
            "function" === typeof type ? type.displayName || type.name || "Unknown" : type
          );
          return ReactElement(
            type,
            children,
            maybeKey,
            getOwner(),
            debugStack,
            debugTask
          );
        }
        function validateChildKeys(node) {
          isValidElement5(node) ? node._store && (node._store.validated = 1) : "object" === typeof node && null !== node && node.$$typeof === REACT_LAZY_TYPE2 && ("fulfilled" === node._payload.status ? isValidElement5(node._payload.value) && node._payload.value._store && (node._payload.value._store.validated = 1) : node._store && (node._store.validated = 1));
        }
        function isValidElement5(object) {
          return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        var React117 = require_react2(), REACT_ELEMENT_TYPE = /* @__PURE__ */ Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = /* @__PURE__ */ Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = /* @__PURE__ */ Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = /* @__PURE__ */ Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = /* @__PURE__ */ Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = /* @__PURE__ */ Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = /* @__PURE__ */ Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = /* @__PURE__ */ Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = /* @__PURE__ */ Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = /* @__PURE__ */ Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = /* @__PURE__ */ Symbol.for("react.memo"), REACT_LAZY_TYPE2 = /* @__PURE__ */ Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = /* @__PURE__ */ Symbol.for("react.activity"), REACT_CLIENT_REFERENCE = /* @__PURE__ */ Symbol.for("react.client.reference"), ReactSharedInternals = React117.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, hasOwnProperty = Object.prototype.hasOwnProperty, isArrayImpl = Array.isArray, createTask = console.createTask ? console.createTask : function() {
          return null;
        };
        React117 = {
          react_stack_bottom_frame: function(callStackForError) {
            return callStackForError();
          }
        };
        var specialPropKeyWarningShown;
        var didWarnAboutElementRef = {};
        var unknownOwnerDebugStack = React117.react_stack_bottom_frame.bind(
          React117,
          UnknownOwner
        )();
        var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
        var didWarnAboutKeySpread = {};
        exports.Fragment = REACT_FRAGMENT_TYPE;
        exports.jsx = function(type, config2, maybeKey) {
          var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
          return jsxDEVImpl(
            type,
            config2,
            maybeKey,
            false,
            trackActualOwner ? Error("react-stack-top-frame") : unknownOwnerDebugStack,
            trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask
          );
        };
        exports.jsxs = function(type, config2, maybeKey) {
          var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
          return jsxDEVImpl(
            type,
            config2,
            maybeKey,
            true,
            trackActualOwner ? Error("react-stack-top-frame") : unknownOwnerDebugStack,
            trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask
          );
        };
      })();
    }
  });

  // ../../node_modules/react/jsx-runtime.js
  var require_jsx_runtime2 = __commonJS({
    "../../node_modules/react/jsx-runtime.js"(exports, module) {
      "use strict";
      if (process.env.NODE_ENV === "production") {
        module.exports = require_react_jsx_runtime_production2();
      } else {
        module.exports = require_react_jsx_runtime_development2();
      }
    }
  });

  // ../../node_modules/react-dom/cjs/react-dom.production.js
  var require_react_dom_production = __commonJS({
    "../../node_modules/react-dom/cjs/react-dom.production.js"(exports) {
      "use strict";
      var React117 = require_react2();
      function formatProdErrorMessage(code) {
        var url = "https://react.dev/errors/" + code;
        if (1 < arguments.length) {
          url += "?args[]=" + encodeURIComponent(arguments[1]);
          for (var i3 = 2; i3 < arguments.length; i3++)
            url += "&args[]=" + encodeURIComponent(arguments[i3]);
        }
        return "Minified React error #" + code + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
      }
      function noop5() {
      }
      var Internals = {
        d: {
          f: noop5,
          r: function() {
            throw Error(formatProdErrorMessage(522));
          },
          D: noop5,
          C: noop5,
          L: noop5,
          m: noop5,
          X: noop5,
          S: noop5,
          M: noop5
        },
        p: 0,
        findDOMNode: null
      };
      var REACT_PORTAL_TYPE = /* @__PURE__ */ Symbol.for("react.portal");
      function createPortal$1(children, containerInfo, implementation) {
        var key = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
        return {
          $$typeof: REACT_PORTAL_TYPE,
          key: null == key ? null : "" + key,
          children,
          containerInfo,
          implementation
        };
      }
      var ReactSharedInternals = React117.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
      function getCrossOriginStringAs(as, input) {
        if ("font" === as) return "";
        if ("string" === typeof input)
          return "use-credentials" === input ? input : "";
      }
      exports.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Internals;
      exports.createPortal = function(children, container) {
        var key = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
        if (!container || 1 !== container.nodeType && 9 !== container.nodeType && 11 !== container.nodeType)
          throw Error(formatProdErrorMessage(299));
        return createPortal$1(children, container, null, key);
      };
      exports.flushSync = function(fn) {
        var previousTransition = ReactSharedInternals.T, previousUpdatePriority = Internals.p;
        try {
          if (ReactSharedInternals.T = null, Internals.p = 2, fn) return fn();
        } finally {
          ReactSharedInternals.T = previousTransition, Internals.p = previousUpdatePriority, Internals.d.f();
        }
      };
      exports.preconnect = function(href, options) {
        "string" === typeof href && (options ? (options = options.crossOrigin, options = "string" === typeof options ? "use-credentials" === options ? options : "" : void 0) : options = null, Internals.d.C(href, options));
      };
      exports.prefetchDNS = function(href) {
        "string" === typeof href && Internals.d.D(href);
      };
      exports.preinit = function(href, options) {
        if ("string" === typeof href && options && "string" === typeof options.as) {
          var as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin), integrity = "string" === typeof options.integrity ? options.integrity : void 0, fetchPriority = "string" === typeof options.fetchPriority ? options.fetchPriority : void 0;
          "style" === as ? Internals.d.S(
            href,
            "string" === typeof options.precedence ? options.precedence : void 0,
            {
              crossOrigin,
              integrity,
              fetchPriority
            }
          ) : "script" === as && Internals.d.X(href, {
            crossOrigin,
            integrity,
            fetchPriority,
            nonce: "string" === typeof options.nonce ? options.nonce : void 0
          });
        }
      };
      exports.preinitModule = function(href, options) {
        if ("string" === typeof href)
          if ("object" === typeof options && null !== options) {
            if (null == options.as || "script" === options.as) {
              var crossOrigin = getCrossOriginStringAs(
                options.as,
                options.crossOrigin
              );
              Internals.d.M(href, {
                crossOrigin,
                integrity: "string" === typeof options.integrity ? options.integrity : void 0,
                nonce: "string" === typeof options.nonce ? options.nonce : void 0
              });
            }
          } else null == options && Internals.d.M(href);
      };
      exports.preload = function(href, options) {
        if ("string" === typeof href && "object" === typeof options && null !== options && "string" === typeof options.as) {
          var as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin);
          Internals.d.L(href, as, {
            crossOrigin,
            integrity: "string" === typeof options.integrity ? options.integrity : void 0,
            nonce: "string" === typeof options.nonce ? options.nonce : void 0,
            type: "string" === typeof options.type ? options.type : void 0,
            fetchPriority: "string" === typeof options.fetchPriority ? options.fetchPriority : void 0,
            referrerPolicy: "string" === typeof options.referrerPolicy ? options.referrerPolicy : void 0,
            imageSrcSet: "string" === typeof options.imageSrcSet ? options.imageSrcSet : void 0,
            imageSizes: "string" === typeof options.imageSizes ? options.imageSizes : void 0,
            media: "string" === typeof options.media ? options.media : void 0
          });
        }
      };
      exports.preloadModule = function(href, options) {
        if ("string" === typeof href)
          if (options) {
            var crossOrigin = getCrossOriginStringAs(options.as, options.crossOrigin);
            Internals.d.m(href, {
              as: "string" === typeof options.as && "script" !== options.as ? options.as : void 0,
              crossOrigin,
              integrity: "string" === typeof options.integrity ? options.integrity : void 0
            });
          } else Internals.d.m(href);
      };
      exports.requestFormReset = function(form) {
        Internals.d.r(form);
      };
      exports.unstable_batchedUpdates = function(fn, a) {
        return fn(a);
      };
      exports.useFormState = function(action, initialState, permalink) {
        return ReactSharedInternals.H.useFormState(action, initialState, permalink);
      };
      exports.useFormStatus = function() {
        return ReactSharedInternals.H.useHostTransitionStatus();
      };
      exports.version = "19.2.3";
    }
  });

  // ../../node_modules/react-dom/cjs/react-dom.development.js
  var require_react_dom_development = __commonJS({
    "../../node_modules/react-dom/cjs/react-dom.development.js"(exports) {
      "use strict";
      "production" !== process.env.NODE_ENV && (function() {
        function noop5() {
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function createPortal$1(children, containerInfo, implementation) {
          var key = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
          try {
            testStringCoercion(key);
            var JSCompiler_inline_result = false;
          } catch (e2) {
            JSCompiler_inline_result = true;
          }
          JSCompiler_inline_result && (console.error(
            "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
            "function" === typeof Symbol && Symbol.toStringTag && key[Symbol.toStringTag] || key.constructor.name || "Object"
          ), testStringCoercion(key));
          return {
            $$typeof: REACT_PORTAL_TYPE,
            key: null == key ? null : "" + key,
            children,
            containerInfo,
            implementation
          };
        }
        function getCrossOriginStringAs(as, input) {
          if ("font" === as) return "";
          if ("string" === typeof input)
            return "use-credentials" === input ? input : "";
        }
        function getValueDescriptorExpectingObjectForWarning(thing) {
          return null === thing ? "`null`" : void 0 === thing ? "`undefined`" : "" === thing ? "an empty string" : 'something with type "' + typeof thing + '"';
        }
        function getValueDescriptorExpectingEnumForWarning(thing) {
          return null === thing ? "`null`" : void 0 === thing ? "`undefined`" : "" === thing ? "an empty string" : "string" === typeof thing ? JSON.stringify(thing) : "number" === typeof thing ? "`" + thing + "`" : 'something with type "' + typeof thing + '"';
        }
        function resolveDispatcher() {
          var dispatcher = ReactSharedInternals.H;
          null === dispatcher && console.error(
            "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
          );
          return dispatcher;
        }
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
        var React117 = require_react2(), Internals = {
          d: {
            f: noop5,
            r: function() {
              throw Error(
                "Invalid form element. requestFormReset must be passed a form that was rendered by React."
              );
            },
            D: noop5,
            C: noop5,
            L: noop5,
            m: noop5,
            X: noop5,
            S: noop5,
            M: noop5
          },
          p: 0,
          findDOMNode: null
        }, REACT_PORTAL_TYPE = /* @__PURE__ */ Symbol.for("react.portal"), ReactSharedInternals = React117.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
        "function" === typeof Map && null != Map.prototype && "function" === typeof Map.prototype.forEach && "function" === typeof Set && null != Set.prototype && "function" === typeof Set.prototype.clear && "function" === typeof Set.prototype.forEach || console.error(
          "React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"
        );
        exports.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Internals;
        exports.createPortal = function(children, container) {
          var key = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
          if (!container || 1 !== container.nodeType && 9 !== container.nodeType && 11 !== container.nodeType)
            throw Error("Target container is not a DOM element.");
          return createPortal$1(children, container, null, key);
        };
        exports.flushSync = function(fn) {
          var previousTransition = ReactSharedInternals.T, previousUpdatePriority = Internals.p;
          try {
            if (ReactSharedInternals.T = null, Internals.p = 2, fn)
              return fn();
          } finally {
            ReactSharedInternals.T = previousTransition, Internals.p = previousUpdatePriority, Internals.d.f() && console.error(
              "flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task."
            );
          }
        };
        exports.preconnect = function(href, options) {
          "string" === typeof href && href ? null != options && "object" !== typeof options ? console.error(
            "ReactDOM.preconnect(): Expected the `options` argument (second) to be an object but encountered %s instead. The only supported option at this time is `crossOrigin` which accepts a string.",
            getValueDescriptorExpectingEnumForWarning(options)
          ) : null != options && "string" !== typeof options.crossOrigin && console.error(
            "ReactDOM.preconnect(): Expected the `crossOrigin` option (second argument) to be a string but encountered %s instead. Try removing this option or passing a string value instead.",
            getValueDescriptorExpectingObjectForWarning(options.crossOrigin)
          ) : console.error(
            "ReactDOM.preconnect(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
            getValueDescriptorExpectingObjectForWarning(href)
          );
          "string" === typeof href && (options ? (options = options.crossOrigin, options = "string" === typeof options ? "use-credentials" === options ? options : "" : void 0) : options = null, Internals.d.C(href, options));
        };
        exports.prefetchDNS = function(href) {
          if ("string" !== typeof href || !href)
            console.error(
              "ReactDOM.prefetchDNS(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
              getValueDescriptorExpectingObjectForWarning(href)
            );
          else if (1 < arguments.length) {
            var options = arguments[1];
            "object" === typeof options && options.hasOwnProperty("crossOrigin") ? console.error(
              "ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. It looks like the you are attempting to set a crossOrigin property for this DNS lookup hint. Browsers do not perform DNS queries using CORS and setting this attribute on the resource hint has no effect. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.",
              getValueDescriptorExpectingEnumForWarning(options)
            ) : console.error(
              "ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.",
              getValueDescriptorExpectingEnumForWarning(options)
            );
          }
          "string" === typeof href && Internals.d.D(href);
        };
        exports.preinit = function(href, options) {
          "string" === typeof href && href ? null == options || "object" !== typeof options ? console.error(
            "ReactDOM.preinit(): Expected the `options` argument (second) to be an object with an `as` property describing the type of resource to be preinitialized but encountered %s instead.",
            getValueDescriptorExpectingEnumForWarning(options)
          ) : "style" !== options.as && "script" !== options.as && console.error(
            'ReactDOM.preinit(): Expected the `as` property in the `options` argument (second) to contain a valid value describing the type of resource to be preinitialized but encountered %s instead. Valid values for `as` are "style" and "script".',
            getValueDescriptorExpectingEnumForWarning(options.as)
          ) : console.error(
            "ReactDOM.preinit(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
            getValueDescriptorExpectingObjectForWarning(href)
          );
          if ("string" === typeof href && options && "string" === typeof options.as) {
            var as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin), integrity = "string" === typeof options.integrity ? options.integrity : void 0, fetchPriority = "string" === typeof options.fetchPriority ? options.fetchPriority : void 0;
            "style" === as ? Internals.d.S(
              href,
              "string" === typeof options.precedence ? options.precedence : void 0,
              {
                crossOrigin,
                integrity,
                fetchPriority
              }
            ) : "script" === as && Internals.d.X(href, {
              crossOrigin,
              integrity,
              fetchPriority,
              nonce: "string" === typeof options.nonce ? options.nonce : void 0
            });
          }
        };
        exports.preinitModule = function(href, options) {
          var encountered = "";
          "string" === typeof href && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
          void 0 !== options && "object" !== typeof options ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : options && "as" in options && "script" !== options.as && (encountered += " The `as` option encountered was " + getValueDescriptorExpectingEnumForWarning(options.as) + ".");
          if (encountered)
            console.error(
              "ReactDOM.preinitModule(): Expected up to two arguments, a non-empty `href` string and, optionally, an `options` object with a valid `as` property.%s",
              encountered
            );
          else
            switch (encountered = options && "string" === typeof options.as ? options.as : "script", encountered) {
              case "script":
                break;
              default:
                encountered = getValueDescriptorExpectingEnumForWarning(encountered), console.error(
                  'ReactDOM.preinitModule(): Currently the only supported "as" type for this function is "script" but received "%s" instead. This warning was generated for `href` "%s". In the future other module types will be supported, aligning with the import-attributes proposal. Learn more here: (https://github.com/tc39/proposal-import-attributes)',
                  encountered,
                  href
                );
            }
          if ("string" === typeof href)
            if ("object" === typeof options && null !== options) {
              if (null == options.as || "script" === options.as)
                encountered = getCrossOriginStringAs(
                  options.as,
                  options.crossOrigin
                ), Internals.d.M(href, {
                  crossOrigin: encountered,
                  integrity: "string" === typeof options.integrity ? options.integrity : void 0,
                  nonce: "string" === typeof options.nonce ? options.nonce : void 0
                });
            } else null == options && Internals.d.M(href);
        };
        exports.preload = function(href, options) {
          var encountered = "";
          "string" === typeof href && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
          null == options || "object" !== typeof options ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : "string" === typeof options.as && options.as || (encountered += " The `as` option encountered was " + getValueDescriptorExpectingObjectForWarning(options.as) + ".");
          encountered && console.error(
            'ReactDOM.preload(): Expected two arguments, a non-empty `href` string and an `options` object with an `as` property valid for a `<link rel="preload" as="..." />` tag.%s',
            encountered
          );
          if ("string" === typeof href && "object" === typeof options && null !== options && "string" === typeof options.as) {
            encountered = options.as;
            var crossOrigin = getCrossOriginStringAs(
              encountered,
              options.crossOrigin
            );
            Internals.d.L(href, encountered, {
              crossOrigin,
              integrity: "string" === typeof options.integrity ? options.integrity : void 0,
              nonce: "string" === typeof options.nonce ? options.nonce : void 0,
              type: "string" === typeof options.type ? options.type : void 0,
              fetchPriority: "string" === typeof options.fetchPriority ? options.fetchPriority : void 0,
              referrerPolicy: "string" === typeof options.referrerPolicy ? options.referrerPolicy : void 0,
              imageSrcSet: "string" === typeof options.imageSrcSet ? options.imageSrcSet : void 0,
              imageSizes: "string" === typeof options.imageSizes ? options.imageSizes : void 0,
              media: "string" === typeof options.media ? options.media : void 0
            });
          }
        };
        exports.preloadModule = function(href, options) {
          var encountered = "";
          "string" === typeof href && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
          void 0 !== options && "object" !== typeof options ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : options && "as" in options && "string" !== typeof options.as && (encountered += " The `as` option encountered was " + getValueDescriptorExpectingObjectForWarning(options.as) + ".");
          encountered && console.error(
            'ReactDOM.preloadModule(): Expected two arguments, a non-empty `href` string and, optionally, an `options` object with an `as` property valid for a `<link rel="modulepreload" as="..." />` tag.%s',
            encountered
          );
          "string" === typeof href && (options ? (encountered = getCrossOriginStringAs(
            options.as,
            options.crossOrigin
          ), Internals.d.m(href, {
            as: "string" === typeof options.as && "script" !== options.as ? options.as : void 0,
            crossOrigin: encountered,
            integrity: "string" === typeof options.integrity ? options.integrity : void 0
          })) : Internals.d.m(href));
        };
        exports.requestFormReset = function(form) {
          Internals.d.r(form);
        };
        exports.unstable_batchedUpdates = function(fn, a) {
          return fn(a);
        };
        exports.useFormState = function(action, initialState, permalink) {
          return resolveDispatcher().useFormState(action, initialState, permalink);
        };
        exports.useFormStatus = function() {
          return resolveDispatcher().useHostTransitionStatus();
        };
        exports.version = "19.2.3";
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
      })();
    }
  });

  // ../../node_modules/react-dom/index.js
  var require_react_dom = __commonJS({
    "../../node_modules/react-dom/index.js"(exports, module) {
      "use strict";
      function checkDCE() {
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
          return;
        }
        if (process.env.NODE_ENV !== "production") {
          throw new Error("^_^");
        }
        try {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
        } catch (err) {
          console.error(err);
        }
      }
      if (process.env.NODE_ENV === "production") {
        checkDCE();
        module.exports = require_react_dom_production();
      } else {
        module.exports = require_react_dom_development();
      }
    }
  });

  // ../../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.production.js
  var require_use_sync_external_store_shim_production = __commonJS({
    "../../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.production.js"(exports) {
      "use strict";
      var React117 = require_react2();
      function is2(x2, y2) {
        return x2 === y2 && (0 !== x2 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;
      }
      var objectIs = "function" === typeof Object.is ? Object.is : is2;
      var useState48 = React117.useState;
      var useEffect48 = React117.useEffect;
      var useLayoutEffect8 = React117.useLayoutEffect;
      var useDebugValue = React117.useDebugValue;
      function useSyncExternalStore$2(subscribe2, getSnapshot) {
        var value = getSnapshot(), _useState = useState48({ inst: { value, getSnapshot } }), inst = _useState[0].inst, forceUpdate = _useState[1];
        useLayoutEffect8(
          function() {
            inst.value = value;
            inst.getSnapshot = getSnapshot;
            checkIfSnapshotChanged(inst) && forceUpdate({ inst });
          },
          [subscribe2, value, getSnapshot]
        );
        useEffect48(
          function() {
            checkIfSnapshotChanged(inst) && forceUpdate({ inst });
            return subscribe2(function() {
              checkIfSnapshotChanged(inst) && forceUpdate({ inst });
            });
          },
          [subscribe2]
        );
        useDebugValue(value);
        return value;
      }
      function checkIfSnapshotChanged(inst) {
        var latestGetSnapshot = inst.getSnapshot;
        inst = inst.value;
        try {
          var nextValue = latestGetSnapshot();
          return !objectIs(inst, nextValue);
        } catch (error) {
          return true;
        }
      }
      function useSyncExternalStore$1(subscribe2, getSnapshot) {
        return getSnapshot();
      }
      var shim = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? useSyncExternalStore$1 : useSyncExternalStore$2;
      exports.useSyncExternalStore = void 0 !== React117.useSyncExternalStore ? React117.useSyncExternalStore : shim;
    }
  });

  // ../../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js
  var require_use_sync_external_store_shim_development = __commonJS({
    "../../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js"(exports) {
      "use strict";
      "production" !== process.env.NODE_ENV && (function() {
        function is2(x2, y2) {
          return x2 === y2 && (0 !== x2 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;
        }
        function useSyncExternalStore$2(subscribe2, getSnapshot) {
          didWarnOld18Alpha || void 0 === React117.startTransition || (didWarnOld18Alpha = true, console.error(
            "You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."
          ));
          var value = getSnapshot();
          if (!didWarnUncachedGetSnapshot) {
            var cachedValue = getSnapshot();
            objectIs(value, cachedValue) || (console.error(
              "The result of getSnapshot should be cached to avoid an infinite loop"
            ), didWarnUncachedGetSnapshot = true);
          }
          cachedValue = useState48({
            inst: { value, getSnapshot }
          });
          var inst = cachedValue[0].inst, forceUpdate = cachedValue[1];
          useLayoutEffect8(
            function() {
              inst.value = value;
              inst.getSnapshot = getSnapshot;
              checkIfSnapshotChanged(inst) && forceUpdate({ inst });
            },
            [subscribe2, value, getSnapshot]
          );
          useEffect48(
            function() {
              checkIfSnapshotChanged(inst) && forceUpdate({ inst });
              return subscribe2(function() {
                checkIfSnapshotChanged(inst) && forceUpdate({ inst });
              });
            },
            [subscribe2]
          );
          useDebugValue(value);
          return value;
        }
        function checkIfSnapshotChanged(inst) {
          var latestGetSnapshot = inst.getSnapshot;
          inst = inst.value;
          try {
            var nextValue = latestGetSnapshot();
            return !objectIs(inst, nextValue);
          } catch (error) {
            return true;
          }
        }
        function useSyncExternalStore$1(subscribe2, getSnapshot) {
          return getSnapshot();
        }
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
        var React117 = require_react2(), objectIs = "function" === typeof Object.is ? Object.is : is2, useState48 = React117.useState, useEffect48 = React117.useEffect, useLayoutEffect8 = React117.useLayoutEffect, useDebugValue = React117.useDebugValue, didWarnOld18Alpha = false, didWarnUncachedGetSnapshot = false, shim = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? useSyncExternalStore$1 : useSyncExternalStore$2;
        exports.useSyncExternalStore = void 0 !== React117.useSyncExternalStore ? React117.useSyncExternalStore : shim;
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
      })();
    }
  });

  // ../../node_modules/use-sync-external-store/shim/index.js
  var require_shim = __commonJS({
    "../../node_modules/use-sync-external-store/shim/index.js"(exports, module) {
      "use strict";
      if (process.env.NODE_ENV === "production") {
        module.exports = require_use_sync_external_store_shim_production();
      } else {
        module.exports = require_use_sync_external_store_shim_development();
      }
    }
  });

  // ../../node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs
  var require_interop_require_wildcard = __commonJS({
    "../../node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs"(exports) {
      "use strict";
      function _getRequireWildcardCache(nodeInterop) {
        if (typeof WeakMap !== "function") return null;
        var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
        var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
        return (_getRequireWildcardCache = function(nodeInterop2) {
          return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
      }
      function _interop_require_wildcard(obj, nodeInterop) {
        if (!nodeInterop && obj && obj.__esModule) return obj;
        if (obj === null || typeof obj !== "object" && typeof obj !== "function") return { default: obj };
        var cache = _getRequireWildcardCache(nodeInterop);
        if (cache && cache.has(obj)) return cache.get(obj);
        var newObj = { __proto__: null };
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) Object.defineProperty(newObj, key, desc);
            else newObj[key] = obj[key];
          }
        }
        newObj.default = obj;
        if (cache) cache.set(obj, newObj);
        return newObj;
      }
      exports._ = _interop_require_wildcard;
    }
  });

  // ../../node_modules/next/dist/shared/lib/router/utils/querystring.js
  var require_querystring = __commonJS({
    "../../node_modules/next/dist/shared/lib/router/utils/querystring.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      function _export(target, all) {
        for (var name in all) Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
      }
      _export(exports, {
        assign: function() {
          return assign2;
        },
        searchParamsToUrlQuery: function() {
          return searchParamsToUrlQuery;
        },
        urlQueryToSearchParams: function() {
          return urlQueryToSearchParams;
        }
      });
      function searchParamsToUrlQuery(searchParams) {
        const query = {};
        for (const [key, value] of searchParams.entries()) {
          const existing = query[key];
          if (typeof existing === "undefined") {
            query[key] = value;
          } else if (Array.isArray(existing)) {
            existing.push(value);
          } else {
            query[key] = [
              existing,
              value
            ];
          }
        }
        return query;
      }
      function stringifyUrlQueryParam(param) {
        if (typeof param === "string") {
          return param;
        }
        if (typeof param === "number" && !isNaN(param) || typeof param === "boolean") {
          return String(param);
        } else {
          return "";
        }
      }
      function urlQueryToSearchParams(query) {
        const searchParams = new URLSearchParams();
        for (const [key, value] of Object.entries(query)) {
          if (Array.isArray(value)) {
            for (const item of value) {
              searchParams.append(key, stringifyUrlQueryParam(item));
            }
          } else {
            searchParams.set(key, stringifyUrlQueryParam(value));
          }
        }
        return searchParams;
      }
      function assign2(target, ...searchParamsList) {
        for (const searchParams of searchParamsList) {
          for (const key of searchParams.keys()) {
            target.delete(key);
          }
          for (const [key, value] of searchParams.entries()) {
            target.append(key, value);
          }
        }
        return target;
      }
    }
  });

  // ../../node_modules/next/dist/shared/lib/router/utils/format-url.js
  var require_format_url = __commonJS({
    "../../node_modules/next/dist/shared/lib/router/utils/format-url.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      function _export(target, all) {
        for (var name in all) Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
      }
      _export(exports, {
        formatUrl: function() {
          return formatUrl;
        },
        formatWithValidation: function() {
          return formatWithValidation;
        },
        urlObjectKeys: function() {
          return urlObjectKeys;
        }
      });
      var _interop_require_wildcard = require_interop_require_wildcard();
      var _querystring = /* @__PURE__ */ _interop_require_wildcard._(require_querystring());
      var slashedProtocols = /https?|ftp|gopher|file/;
      function formatUrl(urlObj) {
        let { auth, hostname } = urlObj;
        let protocol = urlObj.protocol || "";
        let pathname = urlObj.pathname || "";
        let hash = urlObj.hash || "";
        let query = urlObj.query || "";
        let host2 = false;
        auth = auth ? encodeURIComponent(auth).replace(/%3A/i, ":") + "@" : "";
        if (urlObj.host) {
          host2 = auth + urlObj.host;
        } else if (hostname) {
          host2 = auth + (~hostname.indexOf(":") ? `[${hostname}]` : hostname);
          if (urlObj.port) {
            host2 += ":" + urlObj.port;
          }
        }
        if (query && typeof query === "object") {
          query = String(_querystring.urlQueryToSearchParams(query));
        }
        let search = urlObj.search || query && `?${query}` || "";
        if (protocol && !protocol.endsWith(":")) protocol += ":";
        if (urlObj.slashes || (!protocol || slashedProtocols.test(protocol)) && host2 !== false) {
          host2 = "//" + (host2 || "");
          if (pathname && pathname[0] !== "/") pathname = "/" + pathname;
        } else if (!host2) {
          host2 = "";
        }
        if (hash && hash[0] !== "#") hash = "#" + hash;
        if (search && search[0] !== "?") search = "?" + search;
        pathname = pathname.replace(/[?#]/g, encodeURIComponent);
        search = search.replace("#", "%23");
        return `${protocol}${host2}${pathname}${search}${hash}`;
      }
      var urlObjectKeys = [
        "auth",
        "hash",
        "host",
        "hostname",
        "href",
        "path",
        "pathname",
        "port",
        "protocol",
        "query",
        "search",
        "slashes"
      ];
      function formatWithValidation(url) {
        if (process.env.NODE_ENV === "development") {
          if (url !== null && typeof url === "object") {
            Object.keys(url).forEach((key) => {
              if (!urlObjectKeys.includes(key)) {
                console.warn(`Unknown key passed via urlObject into url.format: ${key}`);
              }
            });
          }
        }
        return formatUrl(url);
      }
    }
  });

  // ../../node_modules/next/dist/shared/lib/router/utils/omit.js
  var require_omit = __commonJS({
    "../../node_modules/next/dist/shared/lib/router/utils/omit.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "omit", {
        enumerable: true,
        get: function() {
          return omit;
        }
      });
      function omit(object, keys2) {
        const omitted = {};
        Object.keys(object).forEach((key) => {
          if (!keys2.includes(key)) {
            omitted[key] = object[key];
          }
        });
        return omitted;
      }
    }
  });

  // ../../node_modules/next/dist/shared/lib/utils.js
  var require_utils = __commonJS({
    "../../node_modules/next/dist/shared/lib/utils.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      function _export(target, all) {
        for (var name in all) Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
      }
      _export(exports, {
        DecodeError: function() {
          return DecodeError;
        },
        MiddlewareNotFoundError: function() {
          return MiddlewareNotFoundError;
        },
        MissingStaticPage: function() {
          return MissingStaticPage;
        },
        NormalizeError: function() {
          return NormalizeError;
        },
        PageNotFoundError: function() {
          return PageNotFoundError;
        },
        SP: function() {
          return SP;
        },
        ST: function() {
          return ST;
        },
        WEB_VITALS: function() {
          return WEB_VITALS;
        },
        execOnce: function() {
          return execOnce;
        },
        getDisplayName: function() {
          return getDisplayName2;
        },
        getLocationOrigin: function() {
          return getLocationOrigin;
        },
        getURL: function() {
          return getURL;
        },
        isAbsoluteUrl: function() {
          return isAbsoluteUrl;
        },
        isResSent: function() {
          return isResSent;
        },
        loadGetInitialProps: function() {
          return loadGetInitialProps;
        },
        normalizeRepeatedSlashes: function() {
          return normalizeRepeatedSlashes;
        },
        stringifyError: function() {
          return stringifyError;
        }
      });
      var WEB_VITALS = [
        "CLS",
        "FCP",
        "FID",
        "INP",
        "LCP",
        "TTFB"
      ];
      function execOnce(fn) {
        let used = false;
        let result;
        return (...args) => {
          if (!used) {
            used = true;
            result = fn(...args);
          }
          return result;
        };
      }
      var ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\d+\-.]*?:/;
      var isAbsoluteUrl = (url) => ABSOLUTE_URL_REGEX.test(url);
      function getLocationOrigin() {
        const { protocol, hostname, port } = window.location;
        return `${protocol}//${hostname}${port ? ":" + port : ""}`;
      }
      function getURL() {
        const { href } = window.location;
        const origin = getLocationOrigin();
        return href.substring(origin.length);
      }
      function getDisplayName2(Component3) {
        return typeof Component3 === "string" ? Component3 : Component3.displayName || Component3.name || "Unknown";
      }
      function isResSent(res) {
        return res.finished || res.headersSent;
      }
      function normalizeRepeatedSlashes(url) {
        const urlParts = url.split("?");
        const urlNoQuery = urlParts[0];
        return urlNoQuery.replace(/\\/g, "/").replace(/\/\/+/g, "/") + (urlParts[1] ? `?${urlParts.slice(1).join("?")}` : "");
      }
      async function loadGetInitialProps(App, ctx) {
        if (process.env.NODE_ENV !== "production") {
          if (App.prototype?.getInitialProps) {
            const message2 = `"${getDisplayName2(App)}.getInitialProps()" is defined as an instance method - visit https://nextjs.org/docs/messages/get-initial-props-as-an-instance-method for more information.`;
            throw Object.defineProperty(new Error(message2), "__NEXT_ERROR_CODE", {
              value: "E394",
              enumerable: false,
              configurable: true
            });
          }
        }
        const res = ctx.res || ctx.ctx && ctx.ctx.res;
        if (!App.getInitialProps) {
          if (ctx.ctx && ctx.Component) {
            return {
              pageProps: await loadGetInitialProps(ctx.Component, ctx.ctx)
            };
          }
          return {};
        }
        const props = await App.getInitialProps(ctx);
        if (res && isResSent(res)) {
          return props;
        }
        if (!props) {
          const message2 = `"${getDisplayName2(App)}.getInitialProps()" should resolve to an object. But found "${props}" instead.`;
          throw Object.defineProperty(new Error(message2), "__NEXT_ERROR_CODE", {
            value: "E394",
            enumerable: false,
            configurable: true
          });
        }
        if (process.env.NODE_ENV !== "production") {
          if (Object.keys(props).length === 0 && !ctx.ctx) {
            console.warn(`${getDisplayName2(App)} returned an empty object from \`getInitialProps\`. This de-optimizes and prevents automatic static optimization. https://nextjs.org/docs/messages/empty-object-getInitialProps`);
          }
        }
        return props;
      }
      var SP = typeof performance !== "undefined";
      var ST = SP && [
        "mark",
        "measure",
        "getEntriesByName"
      ].every((method) => typeof performance[method] === "function");
      var DecodeError = class extends Error {
      };
      var NormalizeError = class extends Error {
      };
      var PageNotFoundError = class extends Error {
        constructor(page) {
          super();
          this.code = "ENOENT";
          this.name = "PageNotFoundError";
          this.message = `Cannot find module for page: ${page}`;
        }
      };
      var MissingStaticPage = class extends Error {
        constructor(page, message2) {
          super();
          this.message = `Failed to load static file for page: ${page} ${message2}`;
        }
      };
      var MiddlewareNotFoundError = class extends Error {
        constructor() {
          super();
          this.code = "ENOENT";
          this.message = `Cannot find the middleware module`;
        }
      };
      function stringifyError(error) {
        return JSON.stringify({
          message: error.message,
          stack: error.stack
        });
      }
    }
  });

  // ../../node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js
  var require_remove_trailing_slash = __commonJS({
    "../../node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "removeTrailingSlash", {
        enumerable: true,
        get: function() {
          return removeTrailingSlash;
        }
      });
      function removeTrailingSlash(route) {
        return route.replace(/\/$/, "") || "/";
      }
    }
  });

  // ../../node_modules/next/dist/shared/lib/router/utils/parse-path.js
  var require_parse_path = __commonJS({
    "../../node_modules/next/dist/shared/lib/router/utils/parse-path.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "parsePath", {
        enumerable: true,
        get: function() {
          return parsePath;
        }
      });
      function parsePath(path) {
        const hashIndex = path.indexOf("#");
        const queryIndex = path.indexOf("?");
        const hasQuery = queryIndex > -1 && (hashIndex < 0 || queryIndex < hashIndex);
        if (hasQuery || hashIndex > -1) {
          return {
            pathname: path.substring(0, hasQuery ? queryIndex : hashIndex),
            query: hasQuery ? path.substring(queryIndex, hashIndex > -1 ? hashIndex : void 0) : "",
            hash: hashIndex > -1 ? path.slice(hashIndex) : ""
          };
        }
        return {
          pathname: path,
          query: "",
          hash: ""
        };
      }
    }
  });

  // ../../node_modules/next/dist/client/normalize-trailing-slash.js
  var require_normalize_trailing_slash = __commonJS({
    "../../node_modules/next/dist/client/normalize-trailing-slash.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "normalizePathTrailingSlash", {
        enumerable: true,
        get: function() {
          return normalizePathTrailingSlash;
        }
      });
      var _removetrailingslash = require_remove_trailing_slash();
      var _parsepath = require_parse_path();
      var normalizePathTrailingSlash = (path) => {
        if (!path.startsWith("/") || process.env.__NEXT_MANUAL_TRAILING_SLASH) {
          return path;
        }
        const { pathname, query, hash } = (0, _parsepath.parsePath)(path);
        if (process.env.__NEXT_TRAILING_SLASH) {
          if (/\.[^/]+\/?$/.test(pathname)) {
            return `${(0, _removetrailingslash.removeTrailingSlash)(pathname)}${query}${hash}`;
          } else if (pathname.endsWith("/")) {
            return `${pathname}${query}${hash}`;
          } else {
            return `${pathname}/${query}${hash}`;
          }
        }
        return `${(0, _removetrailingslash.removeTrailingSlash)(pathname)}${query}${hash}`;
      };
      if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
        Object.defineProperty(exports.default, "__esModule", { value: true });
        Object.assign(exports.default, exports);
        module.exports = exports.default;
      }
    }
  });

  // ../../node_modules/next/dist/shared/lib/router/utils/path-has-prefix.js
  var require_path_has_prefix = __commonJS({
    "../../node_modules/next/dist/shared/lib/router/utils/path-has-prefix.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "pathHasPrefix", {
        enumerable: true,
        get: function() {
          return pathHasPrefix;
        }
      });
      var _parsepath = require_parse_path();
      function pathHasPrefix(path, prefix2) {
        if (typeof path !== "string") {
          return false;
        }
        const { pathname } = (0, _parsepath.parsePath)(path);
        return pathname === prefix2 || pathname.startsWith(prefix2 + "/");
      }
    }
  });

  // ../../node_modules/next/dist/client/has-base-path.js
  var require_has_base_path = __commonJS({
    "../../node_modules/next/dist/client/has-base-path.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "hasBasePath", {
        enumerable: true,
        get: function() {
          return hasBasePath;
        }
      });
      var _pathhasprefix = require_path_has_prefix();
      var basePath = process.env.__NEXT_ROUTER_BASEPATH || "";
      function hasBasePath(path) {
        return (0, _pathhasprefix.pathHasPrefix)(path, basePath);
      }
      if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
        Object.defineProperty(exports.default, "__esModule", { value: true });
        Object.assign(exports.default, exports);
        module.exports = exports.default;
      }
    }
  });

  // ../../node_modules/next/dist/shared/lib/router/utils/is-local-url.js
  var require_is_local_url = __commonJS({
    "../../node_modules/next/dist/shared/lib/router/utils/is-local-url.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "isLocalURL", {
        enumerable: true,
        get: function() {
          return isLocalURL;
        }
      });
      var _utils = require_utils();
      var _hasbasepath = require_has_base_path();
      function isLocalURL(url) {
        if (!(0, _utils.isAbsoluteUrl)(url)) return true;
        try {
          const locationOrigin = (0, _utils.getLocationOrigin)();
          const resolved = new URL(url, locationOrigin);
          return resolved.origin === locationOrigin && (0, _hasbasepath.hasBasePath)(resolved.pathname);
        } catch (_2) {
          return false;
        }
      }
    }
  });

  // ../../node_modules/next/dist/shared/lib/router/utils/sorted-routes.js
  var require_sorted_routes = __commonJS({
    "../../node_modules/next/dist/shared/lib/router/utils/sorted-routes.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      function _export(target, all) {
        for (var name in all) Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
      }
      _export(exports, {
        getSortedRouteObjects: function() {
          return getSortedRouteObjects;
        },
        getSortedRoutes: function() {
          return getSortedRoutes;
        }
      });
      var UrlNode = class _UrlNode {
        insert(urlPath) {
          this._insert(urlPath.split("/").filter(Boolean), [], false);
        }
        smoosh() {
          return this._smoosh();
        }
        _smoosh(prefix2 = "/") {
          const childrenPaths = [
            ...this.children.keys()
          ].sort();
          if (this.slugName !== null) {
            childrenPaths.splice(childrenPaths.indexOf("[]"), 1);
          }
          if (this.restSlugName !== null) {
            childrenPaths.splice(childrenPaths.indexOf("[...]"), 1);
          }
          if (this.optionalRestSlugName !== null) {
            childrenPaths.splice(childrenPaths.indexOf("[[...]]"), 1);
          }
          const routes = childrenPaths.map((c) => this.children.get(c)._smoosh(`${prefix2}${c}/`)).reduce((prev, curr) => [
            ...prev,
            ...curr
          ], []);
          if (this.slugName !== null) {
            routes.push(...this.children.get("[]")._smoosh(`${prefix2}[${this.slugName}]/`));
          }
          if (!this.placeholder) {
            const r4 = prefix2 === "/" ? "/" : prefix2.slice(0, -1);
            if (this.optionalRestSlugName != null) {
              throw Object.defineProperty(new Error(`You cannot define a route with the same specificity as a optional catch-all route ("${r4}" and "${r4}[[...${this.optionalRestSlugName}]]").`), "__NEXT_ERROR_CODE", {
                value: "E458",
                enumerable: false,
                configurable: true
              });
            }
            routes.unshift(r4);
          }
          if (this.restSlugName !== null) {
            routes.push(...this.children.get("[...]")._smoosh(`${prefix2}[...${this.restSlugName}]/`));
          }
          if (this.optionalRestSlugName !== null) {
            routes.push(...this.children.get("[[...]]")._smoosh(`${prefix2}[[...${this.optionalRestSlugName}]]/`));
          }
          return routes;
        }
        _insert(urlPaths, slugNames, isCatchAll) {
          if (urlPaths.length === 0) {
            this.placeholder = false;
            return;
          }
          if (isCatchAll) {
            throw Object.defineProperty(new Error(`Catch-all must be the last part of the URL.`), "__NEXT_ERROR_CODE", {
              value: "E392",
              enumerable: false,
              configurable: true
            });
          }
          let nextSegment = urlPaths[0];
          if (nextSegment.startsWith("[") && nextSegment.endsWith("]")) {
            let handleSlug = function(previousSlug, nextSlug) {
              if (previousSlug !== null) {
                if (previousSlug !== nextSlug) {
                  throw Object.defineProperty(new Error(`You cannot use different slug names for the same dynamic path ('${previousSlug}' !== '${nextSlug}').`), "__NEXT_ERROR_CODE", {
                    value: "E337",
                    enumerable: false,
                    configurable: true
                  });
                }
              }
              slugNames.forEach((slug) => {
                if (slug === nextSlug) {
                  throw Object.defineProperty(new Error(`You cannot have the same slug name "${nextSlug}" repeat within a single dynamic path`), "__NEXT_ERROR_CODE", {
                    value: "E247",
                    enumerable: false,
                    configurable: true
                  });
                }
                if (slug.replace(/\W/g, "") === nextSegment.replace(/\W/g, "")) {
                  throw Object.defineProperty(new Error(`You cannot have the slug names "${slug}" and "${nextSlug}" differ only by non-word symbols within a single dynamic path`), "__NEXT_ERROR_CODE", {
                    value: "E499",
                    enumerable: false,
                    configurable: true
                  });
                }
              });
              slugNames.push(nextSlug);
            };
            let segmentName = nextSegment.slice(1, -1);
            let isOptional = false;
            if (segmentName.startsWith("[") && segmentName.endsWith("]")) {
              segmentName = segmentName.slice(1, -1);
              isOptional = true;
            }
            if (segmentName.startsWith("\u2026")) {
              throw Object.defineProperty(new Error(`Detected a three-dot character ('\u2026') at ('${segmentName}'). Did you mean ('...')?`), "__NEXT_ERROR_CODE", {
                value: "E147",
                enumerable: false,
                configurable: true
              });
            }
            if (segmentName.startsWith("...")) {
              segmentName = segmentName.substring(3);
              isCatchAll = true;
            }
            if (segmentName.startsWith("[") || segmentName.endsWith("]")) {
              throw Object.defineProperty(new Error(`Segment names may not start or end with extra brackets ('${segmentName}').`), "__NEXT_ERROR_CODE", {
                value: "E421",
                enumerable: false,
                configurable: true
              });
            }
            if (segmentName.startsWith(".")) {
              throw Object.defineProperty(new Error(`Segment names may not start with erroneous periods ('${segmentName}').`), "__NEXT_ERROR_CODE", {
                value: "E288",
                enumerable: false,
                configurable: true
              });
            }
            if (isCatchAll) {
              if (isOptional) {
                if (this.restSlugName != null) {
                  throw Object.defineProperty(new Error(`You cannot use both an required and optional catch-all route at the same level ("[...${this.restSlugName}]" and "${urlPaths[0]}" ).`), "__NEXT_ERROR_CODE", {
                    value: "E299",
                    enumerable: false,
                    configurable: true
                  });
                }
                handleSlug(this.optionalRestSlugName, segmentName);
                this.optionalRestSlugName = segmentName;
                nextSegment = "[[...]]";
              } else {
                if (this.optionalRestSlugName != null) {
                  throw Object.defineProperty(new Error(`You cannot use both an optional and required catch-all route at the same level ("[[...${this.optionalRestSlugName}]]" and "${urlPaths[0]}").`), "__NEXT_ERROR_CODE", {
                    value: "E300",
                    enumerable: false,
                    configurable: true
                  });
                }
                handleSlug(this.restSlugName, segmentName);
                this.restSlugName = segmentName;
                nextSegment = "[...]";
              }
            } else {
              if (isOptional) {
                throw Object.defineProperty(new Error(`Optional route parameters are not yet supported ("${urlPaths[0]}").`), "__NEXT_ERROR_CODE", {
                  value: "E435",
                  enumerable: false,
                  configurable: true
                });
              }
              handleSlug(this.slugName, segmentName);
              this.slugName = segmentName;
              nextSegment = "[]";
            }
          }
          if (!this.children.has(nextSegment)) {
            this.children.set(nextSegment, new _UrlNode());
          }
          this.children.get(nextSegment)._insert(urlPaths.slice(1), slugNames, isCatchAll);
        }
        constructor() {
          this.placeholder = true;
          this.children = /* @__PURE__ */ new Map();
          this.slugName = null;
          this.restSlugName = null;
          this.optionalRestSlugName = null;
        }
      };
      function getSortedRoutes(normalizedPages) {
        const root = new UrlNode();
        normalizedPages.forEach((pagePath) => root.insert(pagePath));
        return root.smoosh();
      }
      function getSortedRouteObjects(objects, getter) {
        const indexes = {};
        const pathnames = [];
        for (let i3 = 0; i3 < objects.length; i3++) {
          const pathname = getter(objects[i3]);
          indexes[pathname] = i3;
          pathnames[i3] = pathname;
        }
        const sorted = getSortedRoutes(pathnames);
        return sorted.map((pathname) => objects[indexes[pathname]]);
      }
    }
  });

  // ../../node_modules/next/dist/shared/lib/page-path/ensure-leading-slash.js
  var require_ensure_leading_slash = __commonJS({
    "../../node_modules/next/dist/shared/lib/page-path/ensure-leading-slash.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "ensureLeadingSlash", {
        enumerable: true,
        get: function() {
          return ensureLeadingSlash;
        }
      });
      function ensureLeadingSlash(path) {
        return path.startsWith("/") ? path : `/${path}`;
      }
    }
  });

  // ../../node_modules/next/dist/shared/lib/segment.js
  var require_segment = __commonJS({
    "../../node_modules/next/dist/shared/lib/segment.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      function _export(target, all) {
        for (var name in all) Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
      }
      _export(exports, {
        DEFAULT_SEGMENT_KEY: function() {
          return DEFAULT_SEGMENT_KEY;
        },
        NOT_FOUND_SEGMENT_KEY: function() {
          return NOT_FOUND_SEGMENT_KEY;
        },
        PAGE_SEGMENT_KEY: function() {
          return PAGE_SEGMENT_KEY;
        },
        addSearchParamsIfPageSegment: function() {
          return addSearchParamsIfPageSegment;
        },
        computeSelectedLayoutSegment: function() {
          return computeSelectedLayoutSegment;
        },
        getSegmentValue: function() {
          return getSegmentValue;
        },
        getSelectedLayoutSegmentPath: function() {
          return getSelectedLayoutSegmentPath;
        },
        isGroupSegment: function() {
          return isGroupSegment;
        },
        isParallelRouteSegment: function() {
          return isParallelRouteSegment;
        }
      });
      function getSegmentValue(segment) {
        return Array.isArray(segment) ? segment[1] : segment;
      }
      function isGroupSegment(segment) {
        return segment[0] === "(" && segment.endsWith(")");
      }
      function isParallelRouteSegment(segment) {
        return segment.startsWith("@") && segment !== "@children";
      }
      function addSearchParamsIfPageSegment(segment, searchParams) {
        const isPageSegment = segment.includes(PAGE_SEGMENT_KEY);
        if (isPageSegment) {
          const stringifiedQuery = JSON.stringify(searchParams);
          return stringifiedQuery !== "{}" ? PAGE_SEGMENT_KEY + "?" + stringifiedQuery : PAGE_SEGMENT_KEY;
        }
        return segment;
      }
      function computeSelectedLayoutSegment(segments, parallelRouteKey) {
        if (!segments || segments.length === 0) {
          return null;
        }
        const rawSegment = parallelRouteKey === "children" ? segments[0] : segments[segments.length - 1];
        return rawSegment === DEFAULT_SEGMENT_KEY ? null : rawSegment;
      }
      function getSelectedLayoutSegmentPath(tree, parallelRouteKey, first = true, segmentPath = []) {
        let node;
        if (first) {
          node = tree[1][parallelRouteKey];
        } else {
          const parallelRoutes = tree[1];
          node = parallelRoutes.children ?? Object.values(parallelRoutes)[0];
        }
        if (!node) return segmentPath;
        const segment = node[0];
        let segmentValue = getSegmentValue(segment);
        if (!segmentValue || segmentValue.startsWith(PAGE_SEGMENT_KEY)) {
          return segmentPath;
        }
        segmentPath.push(segmentValue);
        return getSelectedLayoutSegmentPath(node, parallelRouteKey, false, segmentPath);
      }
      var PAGE_SEGMENT_KEY = "__PAGE__";
      var DEFAULT_SEGMENT_KEY = "__DEFAULT__";
      var NOT_FOUND_SEGMENT_KEY = "/_not-found";
    }
  });

  // ../../node_modules/next/dist/shared/lib/router/utils/app-paths.js
  var require_app_paths = __commonJS({
    "../../node_modules/next/dist/shared/lib/router/utils/app-paths.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      function _export(target, all) {
        for (var name in all) Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
      }
      _export(exports, {
        normalizeAppPath: function() {
          return normalizeAppPath;
        },
        normalizeRscURL: function() {
          return normalizeRscURL;
        }
      });
      var _ensureleadingslash = require_ensure_leading_slash();
      var _segment = require_segment();
      function normalizeAppPath(route) {
        return (0, _ensureleadingslash.ensureLeadingSlash)(route.split("/").reduce((pathname, segment, index2, segments) => {
          if (!segment) {
            return pathname;
          }
          if ((0, _segment.isGroupSegment)(segment)) {
            return pathname;
          }
          if (segment[0] === "@") {
            return pathname;
          }
          if ((segment === "page" || segment === "route") && index2 === segments.length - 1) {
            return pathname;
          }
          return `${pathname}/${segment}`;
        }, ""));
      }
      function normalizeRscURL(url) {
        return url.replace(
          /\.rsc($|\?)/,
          // $1 ensures `?` is preserved
          "$1"
        );
      }
    }
  });

  // ../../node_modules/next/dist/shared/lib/router/utils/interception-routes.js
  var require_interception_routes = __commonJS({
    "../../node_modules/next/dist/shared/lib/router/utils/interception-routes.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      function _export(target, all) {
        for (var name in all) Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
      }
      _export(exports, {
        INTERCEPTION_ROUTE_MARKERS: function() {
          return INTERCEPTION_ROUTE_MARKERS;
        },
        extractInterceptionRouteInformation: function() {
          return extractInterceptionRouteInformation;
        },
        isInterceptionRouteAppPath: function() {
          return isInterceptionRouteAppPath;
        }
      });
      var _apppaths = require_app_paths();
      var INTERCEPTION_ROUTE_MARKERS = [
        "(..)(..)",
        "(.)",
        "(..)",
        "(...)"
      ];
      function isInterceptionRouteAppPath(path) {
        return path.split("/").find((segment) => INTERCEPTION_ROUTE_MARKERS.find((m3) => segment.startsWith(m3))) !== void 0;
      }
      function extractInterceptionRouteInformation(path) {
        let interceptingRoute;
        let marker;
        let interceptedRoute;
        for (const segment of path.split("/")) {
          marker = INTERCEPTION_ROUTE_MARKERS.find((m3) => segment.startsWith(m3));
          if (marker) {
            ;
            [interceptingRoute, interceptedRoute] = path.split(marker, 2);
            break;
          }
        }
        if (!interceptingRoute || !marker || !interceptedRoute) {
          throw Object.defineProperty(new Error(`Invalid interception route: ${path}. Must be in the format /<intercepting route>/(..|...|..)(..)/<intercepted route>`), "__NEXT_ERROR_CODE", {
            value: "E269",
            enumerable: false,
            configurable: true
          });
        }
        interceptingRoute = (0, _apppaths.normalizeAppPath)(interceptingRoute);
        switch (marker) {
          case "(.)":
            if (interceptingRoute === "/") {
              interceptedRoute = `/${interceptedRoute}`;
            } else {
              interceptedRoute = interceptingRoute + "/" + interceptedRoute;
            }
            break;
          case "(..)":
            if (interceptingRoute === "/") {
              throw Object.defineProperty(new Error(`Invalid interception route: ${path}. Cannot use (..) marker at the root level, use (.) instead.`), "__NEXT_ERROR_CODE", {
                value: "E207",
                enumerable: false,
                configurable: true
              });
            }
            interceptedRoute = interceptingRoute.split("/").slice(0, -1).concat(interceptedRoute).join("/");
            break;
          case "(...)":
            interceptedRoute = "/" + interceptedRoute;
            break;
          case "(..)(..)":
            const splitInterceptingRoute = interceptingRoute.split("/");
            if (splitInterceptingRoute.length <= 2) {
              throw Object.defineProperty(new Error(`Invalid interception route: ${path}. Cannot use (..)(..) marker at the root level or one level up.`), "__NEXT_ERROR_CODE", {
                value: "E486",
                enumerable: false,
                configurable: true
              });
            }
            interceptedRoute = splitInterceptingRoute.slice(0, -2).concat(interceptedRoute).join("/");
            break;
          default:
            throw Object.defineProperty(new Error("Invariant: unexpected marker"), "__NEXT_ERROR_CODE", {
              value: "E112",
              enumerable: false,
              configurable: true
            });
        }
        return {
          interceptingRoute,
          interceptedRoute
        };
      }
    }
  });

  // ../../node_modules/next/dist/shared/lib/router/utils/is-dynamic.js
  var require_is_dynamic = __commonJS({
    "../../node_modules/next/dist/shared/lib/router/utils/is-dynamic.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "isDynamicRoute", {
        enumerable: true,
        get: function() {
          return isDynamicRoute;
        }
      });
      var _interceptionroutes = require_interception_routes();
      var TEST_ROUTE = /\/[^/]*\[[^/]+\][^/]*(?=\/|$)/;
      var TEST_STRICT_ROUTE = /\/\[[^/]+\](?=\/|$)/;
      function isDynamicRoute(route, strict = true) {
        if ((0, _interceptionroutes.isInterceptionRouteAppPath)(route)) {
          route = (0, _interceptionroutes.extractInterceptionRouteInformation)(route).interceptedRoute;
        }
        if (strict) {
          return TEST_STRICT_ROUTE.test(route);
        }
        return TEST_ROUTE.test(route);
      }
    }
  });

  // ../../node_modules/next/dist/shared/lib/router/utils/index.js
  var require_utils2 = __commonJS({
    "../../node_modules/next/dist/shared/lib/router/utils/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      function _export(target, all) {
        for (var name in all) Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
      }
      _export(exports, {
        getSortedRouteObjects: function() {
          return _sortedroutes.getSortedRouteObjects;
        },
        getSortedRoutes: function() {
          return _sortedroutes.getSortedRoutes;
        },
        isDynamicRoute: function() {
          return _isdynamic.isDynamicRoute;
        }
      });
      var _sortedroutes = require_sorted_routes();
      var _isdynamic = require_is_dynamic();
    }
  });

  // ../../node_modules/next/dist/compiled/path-to-regexp/index.js
  var require_path_to_regexp = __commonJS({
    "../../node_modules/next/dist/compiled/path-to-regexp/index.js"(exports, module) {
      "use strict";
      (() => {
        "use strict";
        if (typeof __nccwpck_require__ !== "undefined") __nccwpck_require__.ab = __dirname + "/";
        var e2 = {};
        (() => {
          var n2 = e2;
          Object.defineProperty(n2, "__esModule", { value: true });
          n2.pathToRegexp = n2.tokensToRegexp = n2.regexpToFunction = n2.match = n2.tokensToFunction = n2.compile = n2.parse = void 0;
          function lexer(e3) {
            var n3 = [];
            var r4 = 0;
            while (r4 < e3.length) {
              var t3 = e3[r4];
              if (t3 === "*" || t3 === "+" || t3 === "?") {
                n3.push({ type: "MODIFIER", index: r4, value: e3[r4++] });
                continue;
              }
              if (t3 === "\\") {
                n3.push({ type: "ESCAPED_CHAR", index: r4++, value: e3[r4++] });
                continue;
              }
              if (t3 === "{") {
                n3.push({ type: "OPEN", index: r4, value: e3[r4++] });
                continue;
              }
              if (t3 === "}") {
                n3.push({ type: "CLOSE", index: r4, value: e3[r4++] });
                continue;
              }
              if (t3 === ":") {
                var a = "";
                var i3 = r4 + 1;
                while (i3 < e3.length) {
                  var o = e3.charCodeAt(i3);
                  if (o >= 48 && o <= 57 || o >= 65 && o <= 90 || o >= 97 && o <= 122 || o === 95) {
                    a += e3[i3++];
                    continue;
                  }
                  break;
                }
                if (!a) throw new TypeError("Missing parameter name at ".concat(r4));
                n3.push({ type: "NAME", index: r4, value: a });
                r4 = i3;
                continue;
              }
              if (t3 === "(") {
                var c = 1;
                var f2 = "";
                var i3 = r4 + 1;
                if (e3[i3] === "?") {
                  throw new TypeError('Pattern cannot start with "?" at '.concat(i3));
                }
                while (i3 < e3.length) {
                  if (e3[i3] === "\\") {
                    f2 += e3[i3++] + e3[i3++];
                    continue;
                  }
                  if (e3[i3] === ")") {
                    c--;
                    if (c === 0) {
                      i3++;
                      break;
                    }
                  } else if (e3[i3] === "(") {
                    c++;
                    if (e3[i3 + 1] !== "?") {
                      throw new TypeError("Capturing groups are not allowed at ".concat(i3));
                    }
                  }
                  f2 += e3[i3++];
                }
                if (c) throw new TypeError("Unbalanced pattern at ".concat(r4));
                if (!f2) throw new TypeError("Missing pattern at ".concat(r4));
                n3.push({ type: "PATTERN", index: r4, value: f2 });
                r4 = i3;
                continue;
              }
              n3.push({ type: "CHAR", index: r4, value: e3[r4++] });
            }
            n3.push({ type: "END", index: r4, value: "" });
            return n3;
          }
          function parse2(e3, n3) {
            if (n3 === void 0) {
              n3 = {};
            }
            var r4 = lexer(e3);
            var t3 = n3.prefixes, a = t3 === void 0 ? "./" : t3, i3 = n3.delimiter, o = i3 === void 0 ? "/#?" : i3;
            var c = [];
            var f2 = 0;
            var u2 = 0;
            var p3 = "";
            var tryConsume = function(e4) {
              if (u2 < r4.length && r4[u2].type === e4) return r4[u2++].value;
            };
            var mustConsume = function(e4) {
              var n4 = tryConsume(e4);
              if (n4 !== void 0) return n4;
              var t4 = r4[u2], a2 = t4.type, i4 = t4.index;
              throw new TypeError("Unexpected ".concat(a2, " at ").concat(i4, ", expected ").concat(e4));
            };
            var consumeText = function() {
              var e4 = "";
              var n4;
              while (n4 = tryConsume("CHAR") || tryConsume("ESCAPED_CHAR")) {
                e4 += n4;
              }
              return e4;
            };
            var isSafe = function(e4) {
              for (var n4 = 0, r5 = o; n4 < r5.length; n4++) {
                var t4 = r5[n4];
                if (e4.indexOf(t4) > -1) return true;
              }
              return false;
            };
            var safePattern = function(e4) {
              var n4 = c[c.length - 1];
              var r5 = e4 || (n4 && typeof n4 === "string" ? n4 : "");
              if (n4 && !r5) {
                throw new TypeError('Must have text between two parameters, missing text after "'.concat(n4.name, '"'));
              }
              if (!r5 || isSafe(r5)) return "[^".concat(escapeString(o), "]+?");
              return "(?:(?!".concat(escapeString(r5), ")[^").concat(escapeString(o), "])+?");
            };
            while (u2 < r4.length) {
              var v2 = tryConsume("CHAR");
              var s = tryConsume("NAME");
              var d = tryConsume("PATTERN");
              if (s || d) {
                var g2 = v2 || "";
                if (a.indexOf(g2) === -1) {
                  p3 += g2;
                  g2 = "";
                }
                if (p3) {
                  c.push(p3);
                  p3 = "";
                }
                c.push({ name: s || f2++, prefix: g2, suffix: "", pattern: d || safePattern(g2), modifier: tryConsume("MODIFIER") || "" });
                continue;
              }
              var x2 = v2 || tryConsume("ESCAPED_CHAR");
              if (x2) {
                p3 += x2;
                continue;
              }
              if (p3) {
                c.push(p3);
                p3 = "";
              }
              var h = tryConsume("OPEN");
              if (h) {
                var g2 = consumeText();
                var l2 = tryConsume("NAME") || "";
                var m3 = tryConsume("PATTERN") || "";
                var T2 = consumeText();
                mustConsume("CLOSE");
                c.push({ name: l2 || (m3 ? f2++ : ""), pattern: l2 && !m3 ? safePattern(g2) : m3, prefix: g2, suffix: T2, modifier: tryConsume("MODIFIER") || "" });
                continue;
              }
              mustConsume("END");
            }
            return c;
          }
          n2.parse = parse2;
          function compile(e3, n3) {
            return tokensToFunction(parse2(e3, n3), n3);
          }
          n2.compile = compile;
          function tokensToFunction(e3, n3) {
            if (n3 === void 0) {
              n3 = {};
            }
            var r4 = flags(n3);
            var t3 = n3.encode, a = t3 === void 0 ? function(e4) {
              return e4;
            } : t3, i3 = n3.validate, o = i3 === void 0 ? true : i3;
            var c = e3.map((function(e4) {
              if (typeof e4 === "object") {
                return new RegExp("^(?:".concat(e4.pattern, ")$"), r4);
              }
            }));
            return function(n4) {
              var r5 = "";
              for (var t4 = 0; t4 < e3.length; t4++) {
                var i4 = e3[t4];
                if (typeof i4 === "string") {
                  r5 += i4;
                  continue;
                }
                var f2 = n4 ? n4[i4.name] : void 0;
                var u2 = i4.modifier === "?" || i4.modifier === "*";
                var p3 = i4.modifier === "*" || i4.modifier === "+";
                if (Array.isArray(f2)) {
                  if (!p3) {
                    throw new TypeError('Expected "'.concat(i4.name, '" to not repeat, but got an array'));
                  }
                  if (f2.length === 0) {
                    if (u2) continue;
                    throw new TypeError('Expected "'.concat(i4.name, '" to not be empty'));
                  }
                  for (var v2 = 0; v2 < f2.length; v2++) {
                    var s = a(f2[v2], i4);
                    if (o && !c[t4].test(s)) {
                      throw new TypeError('Expected all "'.concat(i4.name, '" to match "').concat(i4.pattern, '", but got "').concat(s, '"'));
                    }
                    r5 += i4.prefix + s + i4.suffix;
                  }
                  continue;
                }
                if (typeof f2 === "string" || typeof f2 === "number") {
                  var s = a(String(f2), i4);
                  if (o && !c[t4].test(s)) {
                    throw new TypeError('Expected "'.concat(i4.name, '" to match "').concat(i4.pattern, '", but got "').concat(s, '"'));
                  }
                  r5 += i4.prefix + s + i4.suffix;
                  continue;
                }
                if (u2) continue;
                var d = p3 ? "an array" : "a string";
                throw new TypeError('Expected "'.concat(i4.name, '" to be ').concat(d));
              }
              return r5;
            };
          }
          n2.tokensToFunction = tokensToFunction;
          function match2(e3, n3) {
            var r4 = [];
            var t3 = pathToRegexp(e3, r4, n3);
            return regexpToFunction(t3, r4, n3);
          }
          n2.match = match2;
          function regexpToFunction(e3, n3, r4) {
            if (r4 === void 0) {
              r4 = {};
            }
            var t3 = r4.decode, a = t3 === void 0 ? function(e4) {
              return e4;
            } : t3;
            return function(r5) {
              var t4 = e3.exec(r5);
              if (!t4) return false;
              var i3 = t4[0], o = t4.index;
              var c = /* @__PURE__ */ Object.create(null);
              var _loop_1 = function(e4) {
                if (t4[e4] === void 0) return "continue";
                var r6 = n3[e4 - 1];
                if (r6.modifier === "*" || r6.modifier === "+") {
                  c[r6.name] = t4[e4].split(r6.prefix + r6.suffix).map((function(e5) {
                    return a(e5, r6);
                  }));
                } else {
                  c[r6.name] = a(t4[e4], r6);
                }
              };
              for (var f2 = 1; f2 < t4.length; f2++) {
                _loop_1(f2);
              }
              return { path: i3, index: o, params: c };
            };
          }
          n2.regexpToFunction = regexpToFunction;
          function escapeString(e3) {
            return e3.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
          }
          function flags(e3) {
            return e3 && e3.sensitive ? "" : "i";
          }
          function regexpToRegexp(e3, n3) {
            if (!n3) return e3;
            var r4 = /\((?:\?<(.*?)>)?(?!\?)/g;
            var t3 = 0;
            var a = r4.exec(e3.source);
            while (a) {
              n3.push({ name: a[1] || t3++, prefix: "", suffix: "", modifier: "", pattern: "" });
              a = r4.exec(e3.source);
            }
            return e3;
          }
          function arrayToRegexp(e3, n3, r4) {
            var t3 = e3.map((function(e4) {
              return pathToRegexp(e4, n3, r4).source;
            }));
            return new RegExp("(?:".concat(t3.join("|"), ")"), flags(r4));
          }
          function stringToRegexp(e3, n3, r4) {
            return tokensToRegexp(parse2(e3, r4), n3, r4);
          }
          function tokensToRegexp(e3, n3, r4) {
            if (r4 === void 0) {
              r4 = {};
            }
            var t3 = r4.strict, a = t3 === void 0 ? false : t3, i3 = r4.start, o = i3 === void 0 ? true : i3, c = r4.end, f2 = c === void 0 ? true : c, u2 = r4.encode, p3 = u2 === void 0 ? function(e4) {
              return e4;
            } : u2, v2 = r4.delimiter, s = v2 === void 0 ? "/#?" : v2, d = r4.endsWith, g2 = d === void 0 ? "" : d;
            var x2 = "[".concat(escapeString(g2), "]|$");
            var h = "[".concat(escapeString(s), "]");
            var l2 = o ? "^" : "";
            for (var m3 = 0, T2 = e3; m3 < T2.length; m3++) {
              var E2 = T2[m3];
              if (typeof E2 === "string") {
                l2 += escapeString(p3(E2));
              } else {
                var w2 = escapeString(p3(E2.prefix));
                var y2 = escapeString(p3(E2.suffix));
                if (E2.pattern) {
                  if (n3) n3.push(E2);
                  if (w2 || y2) {
                    if (E2.modifier === "+" || E2.modifier === "*") {
                      var R = E2.modifier === "*" ? "?" : "";
                      l2 += "(?:".concat(w2, "((?:").concat(E2.pattern, ")(?:").concat(y2).concat(w2, "(?:").concat(E2.pattern, "))*)").concat(y2, ")").concat(R);
                    } else {
                      l2 += "(?:".concat(w2, "(").concat(E2.pattern, ")").concat(y2, ")").concat(E2.modifier);
                    }
                  } else {
                    if (E2.modifier === "+" || E2.modifier === "*") {
                      throw new TypeError('Can not repeat "'.concat(E2.name, '" without a prefix and suffix'));
                    }
                    l2 += "(".concat(E2.pattern, ")").concat(E2.modifier);
                  }
                } else {
                  l2 += "(?:".concat(w2).concat(y2, ")").concat(E2.modifier);
                }
              }
            }
            if (f2) {
              if (!a) l2 += "".concat(h, "?");
              l2 += !r4.endsWith ? "$" : "(?=".concat(x2, ")");
            } else {
              var A3 = e3[e3.length - 1];
              var _2 = typeof A3 === "string" ? h.indexOf(A3[A3.length - 1]) > -1 : A3 === void 0;
              if (!a) {
                l2 += "(?:".concat(h, "(?=").concat(x2, "))?");
              }
              if (!_2) {
                l2 += "(?=".concat(h, "|").concat(x2, ")");
              }
            }
            return new RegExp(l2, flags(r4));
          }
          n2.tokensToRegexp = tokensToRegexp;
          function pathToRegexp(e3, n3, r4) {
            if (e3 instanceof RegExp) return regexpToRegexp(e3, n3);
            if (Array.isArray(e3)) return arrayToRegexp(e3, n3, r4);
            return stringToRegexp(e3, n3, r4);
          }
          n2.pathToRegexp = pathToRegexp;
        })();
        module.exports = e2;
      })();
    }
  });

  // ../../node_modules/next/dist/lib/route-pattern-normalizer.js
  var require_route_pattern_normalizer = __commonJS({
    "../../node_modules/next/dist/lib/route-pattern-normalizer.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      function _export(target, all) {
        for (var name in all) Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
      }
      _export(exports, {
        PARAM_SEPARATOR: function() {
          return PARAM_SEPARATOR;
        },
        hasAdjacentParameterIssues: function() {
          return hasAdjacentParameterIssues;
        },
        normalizeAdjacentParameters: function() {
          return normalizeAdjacentParameters;
        },
        normalizeTokensForRegexp: function() {
          return normalizeTokensForRegexp;
        },
        stripNormalizedSeparators: function() {
          return stripNormalizedSeparators;
        },
        stripParameterSeparators: function() {
          return stripParameterSeparators;
        }
      });
      var PARAM_SEPARATOR = "_NEXTSEP_";
      function hasAdjacentParameterIssues(route) {
        if (typeof route !== "string") return false;
        if (/\/\(\.{1,3}\):[^/\s]+/.test(route)) {
          return true;
        }
        if (/:[a-zA-Z_][a-zA-Z0-9_]*:[a-zA-Z_][a-zA-Z0-9_]*/.test(route)) {
          return true;
        }
        return false;
      }
      function normalizeAdjacentParameters(route) {
        let normalized = route;
        normalized = normalized.replace(/(\([^)]*\)):([^/\s]+)/g, `$1${PARAM_SEPARATOR}:$2`);
        normalized = normalized.replace(/:([^:/\s)]+)(?=:)/g, `:$1${PARAM_SEPARATOR}`);
        return normalized;
      }
      function normalizeTokensForRegexp(tokens) {
        return tokens.map((token) => {
          if (typeof token === "object" && token !== null && // Not all token objects have 'modifier' property (e.g., simple text tokens)
          "modifier" in token && // Only repeating modifiers (* or +) cause the validation error
          // Other modifiers like '?' (optional) are fine
          (token.modifier === "*" || token.modifier === "+") && // Token objects can have different shapes depending on route pattern
          "prefix" in token && "suffix" in token && // Both prefix and suffix must be empty strings
          // This is what causes the validation error in path-to-regexp
          token.prefix === "" && token.suffix === "") {
            return {
              ...token,
              prefix: "/"
            };
          }
          return token;
        });
      }
      function stripNormalizedSeparators(pathname) {
        return pathname.replace(new RegExp(`\\)${PARAM_SEPARATOR}`, "g"), ")");
      }
      function stripParameterSeparators(params) {
        const cleaned = {};
        for (const [key, value] of Object.entries(params)) {
          if (typeof value === "string") {
            cleaned[key] = value.replace(new RegExp(`^${PARAM_SEPARATOR}`), "");
          } else if (Array.isArray(value)) {
            cleaned[key] = value.map((item) => typeof item === "string" ? item.replace(new RegExp(`^${PARAM_SEPARATOR}`), "") : item);
          } else {
            cleaned[key] = value;
          }
        }
        return cleaned;
      }
    }
  });

  // ../../node_modules/next/dist/shared/lib/router/utils/route-match-utils.js
  var require_route_match_utils = __commonJS({
    "../../node_modules/next/dist/shared/lib/router/utils/route-match-utils.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      function _export(target, all) {
        for (var name in all) Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
      }
      _export(exports, {
        safeCompile: function() {
          return safeCompile;
        },
        safePathToRegexp: function() {
          return safePathToRegexp;
        },
        safeRegexpToFunction: function() {
          return safeRegexpToFunction;
        },
        safeRouteMatcher: function() {
          return safeRouteMatcher;
        }
      });
      var _pathtoregexp = require_path_to_regexp();
      var _routepatternnormalizer = require_route_pattern_normalizer();
      function safePathToRegexp(route, keys2, options) {
        if (typeof route !== "string") {
          return (0, _pathtoregexp.pathToRegexp)(route, keys2, options);
        }
        const needsNormalization = (0, _routepatternnormalizer.hasAdjacentParameterIssues)(route);
        const routeToUse = needsNormalization ? (0, _routepatternnormalizer.normalizeAdjacentParameters)(route) : route;
        try {
          return (0, _pathtoregexp.pathToRegexp)(routeToUse, keys2, options);
        } catch (error) {
          if (!needsNormalization) {
            try {
              const normalizedRoute = (0, _routepatternnormalizer.normalizeAdjacentParameters)(route);
              return (0, _pathtoregexp.pathToRegexp)(normalizedRoute, keys2, options);
            } catch (retryError) {
              throw error;
            }
          }
          throw error;
        }
      }
      function safeCompile(route, options) {
        const needsNormalization = (0, _routepatternnormalizer.hasAdjacentParameterIssues)(route);
        const routeToUse = needsNormalization ? (0, _routepatternnormalizer.normalizeAdjacentParameters)(route) : route;
        try {
          const compiler = (0, _pathtoregexp.compile)(routeToUse, options);
          if (needsNormalization) {
            return (params) => {
              return (0, _routepatternnormalizer.stripNormalizedSeparators)(compiler(params));
            };
          }
          return compiler;
        } catch (error) {
          if (!needsNormalization) {
            try {
              const normalizedRoute = (0, _routepatternnormalizer.normalizeAdjacentParameters)(route);
              const compiler = (0, _pathtoregexp.compile)(normalizedRoute, options);
              return (params) => {
                return (0, _routepatternnormalizer.stripNormalizedSeparators)(compiler(params));
              };
            } catch (retryError) {
              throw error;
            }
          }
          throw error;
        }
      }
      function safeRegexpToFunction(regexp, keys2) {
        const originalMatcher = (0, _pathtoregexp.regexpToFunction)(regexp, keys2 || []);
        return (pathname) => {
          const result = originalMatcher(pathname);
          if (!result) return false;
          return {
            ...result,
            params: (0, _routepatternnormalizer.stripParameterSeparators)(result.params)
          };
        };
      }
      function safeRouteMatcher(matcherFn) {
        return (pathname) => {
          const result = matcherFn(pathname);
          if (!result) return false;
          return (0, _routepatternnormalizer.stripParameterSeparators)(result);
        };
      }
    }
  });

  // ../../node_modules/next/dist/shared/lib/router/utils/route-matcher.js
  var require_route_matcher = __commonJS({
    "../../node_modules/next/dist/shared/lib/router/utils/route-matcher.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "getRouteMatcher", {
        enumerable: true,
        get: function() {
          return getRouteMatcher;
        }
      });
      var _utils = require_utils();
      var _routematchutils = require_route_match_utils();
      function getRouteMatcher({ re: re2, groups }) {
        const rawMatcher = (pathname) => {
          const routeMatch = re2.exec(pathname);
          if (!routeMatch) return false;
          const decode = (param) => {
            try {
              return decodeURIComponent(param);
            } catch {
              throw Object.defineProperty(new _utils.DecodeError("failed to decode param"), "__NEXT_ERROR_CODE", {
                value: "E528",
                enumerable: false,
                configurable: true
              });
            }
          };
          const params = {};
          for (const [key, group] of Object.entries(groups)) {
            const match2 = routeMatch[group.pos];
            if (match2 !== void 0) {
              if (group.repeat) {
                params[key] = match2.split("/").map((entry) => decode(entry));
              } else {
                params[key] = decode(match2);
              }
            }
          }
          return params;
        };
        return (0, _routematchutils.safeRouteMatcher)(rawMatcher);
      }
    }
  });

  // ../../node_modules/next/dist/lib/constants.js
  var require_constants = __commonJS({
    "../../node_modules/next/dist/lib/constants.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      function _export(target, all) {
        for (var name in all) Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
      }
      _export(exports, {
        ACTION_SUFFIX: function() {
          return ACTION_SUFFIX;
        },
        APP_DIR_ALIAS: function() {
          return APP_DIR_ALIAS;
        },
        CACHE_ONE_YEAR: function() {
          return CACHE_ONE_YEAR;
        },
        DOT_NEXT_ALIAS: function() {
          return DOT_NEXT_ALIAS;
        },
        ESLINT_DEFAULT_DIRS: function() {
          return ESLINT_DEFAULT_DIRS;
        },
        GSP_NO_RETURNED_VALUE: function() {
          return GSP_NO_RETURNED_VALUE;
        },
        GSSP_COMPONENT_MEMBER_ERROR: function() {
          return GSSP_COMPONENT_MEMBER_ERROR;
        },
        GSSP_NO_RETURNED_VALUE: function() {
          return GSSP_NO_RETURNED_VALUE;
        },
        HTML_CONTENT_TYPE_HEADER: function() {
          return HTML_CONTENT_TYPE_HEADER;
        },
        INFINITE_CACHE: function() {
          return INFINITE_CACHE;
        },
        INSTRUMENTATION_HOOK_FILENAME: function() {
          return INSTRUMENTATION_HOOK_FILENAME;
        },
        JSON_CONTENT_TYPE_HEADER: function() {
          return JSON_CONTENT_TYPE_HEADER;
        },
        MATCHED_PATH_HEADER: function() {
          return MATCHED_PATH_HEADER;
        },
        MIDDLEWARE_FILENAME: function() {
          return MIDDLEWARE_FILENAME;
        },
        MIDDLEWARE_LOCATION_REGEXP: function() {
          return MIDDLEWARE_LOCATION_REGEXP;
        },
        NEXT_BODY_SUFFIX: function() {
          return NEXT_BODY_SUFFIX;
        },
        NEXT_CACHE_IMPLICIT_TAG_ID: function() {
          return NEXT_CACHE_IMPLICIT_TAG_ID;
        },
        NEXT_CACHE_REVALIDATED_TAGS_HEADER: function() {
          return NEXT_CACHE_REVALIDATED_TAGS_HEADER;
        },
        NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER: function() {
          return NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER;
        },
        NEXT_CACHE_SOFT_TAG_MAX_LENGTH: function() {
          return NEXT_CACHE_SOFT_TAG_MAX_LENGTH;
        },
        NEXT_CACHE_TAGS_HEADER: function() {
          return NEXT_CACHE_TAGS_HEADER;
        },
        NEXT_CACHE_TAG_MAX_ITEMS: function() {
          return NEXT_CACHE_TAG_MAX_ITEMS;
        },
        NEXT_CACHE_TAG_MAX_LENGTH: function() {
          return NEXT_CACHE_TAG_MAX_LENGTH;
        },
        NEXT_DATA_SUFFIX: function() {
          return NEXT_DATA_SUFFIX;
        },
        NEXT_INTERCEPTION_MARKER_PREFIX: function() {
          return NEXT_INTERCEPTION_MARKER_PREFIX;
        },
        NEXT_META_SUFFIX: function() {
          return NEXT_META_SUFFIX;
        },
        NEXT_QUERY_PARAM_PREFIX: function() {
          return NEXT_QUERY_PARAM_PREFIX;
        },
        NEXT_RESUME_HEADER: function() {
          return NEXT_RESUME_HEADER;
        },
        NON_STANDARD_NODE_ENV: function() {
          return NON_STANDARD_NODE_ENV;
        },
        PAGES_DIR_ALIAS: function() {
          return PAGES_DIR_ALIAS;
        },
        PRERENDER_REVALIDATE_HEADER: function() {
          return PRERENDER_REVALIDATE_HEADER;
        },
        PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER: function() {
          return PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER;
        },
        PROXY_FILENAME: function() {
          return PROXY_FILENAME;
        },
        PROXY_LOCATION_REGEXP: function() {
          return PROXY_LOCATION_REGEXP;
        },
        PUBLIC_DIR_MIDDLEWARE_CONFLICT: function() {
          return PUBLIC_DIR_MIDDLEWARE_CONFLICT;
        },
        ROOT_DIR_ALIAS: function() {
          return ROOT_DIR_ALIAS;
        },
        RSC_ACTION_CLIENT_WRAPPER_ALIAS: function() {
          return RSC_ACTION_CLIENT_WRAPPER_ALIAS;
        },
        RSC_ACTION_ENCRYPTION_ALIAS: function() {
          return RSC_ACTION_ENCRYPTION_ALIAS;
        },
        RSC_ACTION_PROXY_ALIAS: function() {
          return RSC_ACTION_PROXY_ALIAS;
        },
        RSC_ACTION_VALIDATE_ALIAS: function() {
          return RSC_ACTION_VALIDATE_ALIAS;
        },
        RSC_CACHE_WRAPPER_ALIAS: function() {
          return RSC_CACHE_WRAPPER_ALIAS;
        },
        RSC_DYNAMIC_IMPORT_WRAPPER_ALIAS: function() {
          return RSC_DYNAMIC_IMPORT_WRAPPER_ALIAS;
        },
        RSC_MOD_REF_PROXY_ALIAS: function() {
          return RSC_MOD_REF_PROXY_ALIAS;
        },
        RSC_SEGMENTS_DIR_SUFFIX: function() {
          return RSC_SEGMENTS_DIR_SUFFIX;
        },
        RSC_SEGMENT_SUFFIX: function() {
          return RSC_SEGMENT_SUFFIX;
        },
        RSC_SUFFIX: function() {
          return RSC_SUFFIX;
        },
        SERVER_PROPS_EXPORT_ERROR: function() {
          return SERVER_PROPS_EXPORT_ERROR;
        },
        SERVER_PROPS_GET_INIT_PROPS_CONFLICT: function() {
          return SERVER_PROPS_GET_INIT_PROPS_CONFLICT;
        },
        SERVER_PROPS_SSG_CONFLICT: function() {
          return SERVER_PROPS_SSG_CONFLICT;
        },
        SERVER_RUNTIME: function() {
          return SERVER_RUNTIME;
        },
        SSG_FALLBACK_EXPORT_ERROR: function() {
          return SSG_FALLBACK_EXPORT_ERROR;
        },
        SSG_GET_INITIAL_PROPS_CONFLICT: function() {
          return SSG_GET_INITIAL_PROPS_CONFLICT;
        },
        STATIC_STATUS_PAGE_GET_INITIAL_PROPS_ERROR: function() {
          return STATIC_STATUS_PAGE_GET_INITIAL_PROPS_ERROR;
        },
        TEXT_PLAIN_CONTENT_TYPE_HEADER: function() {
          return TEXT_PLAIN_CONTENT_TYPE_HEADER;
        },
        UNSTABLE_REVALIDATE_RENAME_ERROR: function() {
          return UNSTABLE_REVALIDATE_RENAME_ERROR;
        },
        WEBPACK_LAYERS: function() {
          return WEBPACK_LAYERS;
        },
        WEBPACK_RESOURCE_QUERIES: function() {
          return WEBPACK_RESOURCE_QUERIES;
        },
        WEB_SOCKET_MAX_RECONNECTIONS: function() {
          return WEB_SOCKET_MAX_RECONNECTIONS;
        }
      });
      var TEXT_PLAIN_CONTENT_TYPE_HEADER = "text/plain";
      var HTML_CONTENT_TYPE_HEADER = "text/html; charset=utf-8";
      var JSON_CONTENT_TYPE_HEADER = "application/json; charset=utf-8";
      var NEXT_QUERY_PARAM_PREFIX = "nxtP";
      var NEXT_INTERCEPTION_MARKER_PREFIX = "nxtI";
      var MATCHED_PATH_HEADER = "x-matched-path";
      var PRERENDER_REVALIDATE_HEADER = "x-prerender-revalidate";
      var PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER = "x-prerender-revalidate-if-generated";
      var RSC_SEGMENTS_DIR_SUFFIX = ".segments";
      var RSC_SEGMENT_SUFFIX = ".segment.rsc";
      var RSC_SUFFIX = ".rsc";
      var ACTION_SUFFIX = ".action";
      var NEXT_DATA_SUFFIX = ".json";
      var NEXT_META_SUFFIX = ".meta";
      var NEXT_BODY_SUFFIX = ".body";
      var NEXT_CACHE_TAGS_HEADER = "x-next-cache-tags";
      var NEXT_CACHE_REVALIDATED_TAGS_HEADER = "x-next-revalidated-tags";
      var NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER = "x-next-revalidate-tag-token";
      var NEXT_RESUME_HEADER = "next-resume";
      var NEXT_CACHE_TAG_MAX_ITEMS = 128;
      var NEXT_CACHE_TAG_MAX_LENGTH = 256;
      var NEXT_CACHE_SOFT_TAG_MAX_LENGTH = 1024;
      var NEXT_CACHE_IMPLICIT_TAG_ID = "_N_T_";
      var CACHE_ONE_YEAR = 31536e3;
      var INFINITE_CACHE = 4294967294;
      var MIDDLEWARE_FILENAME = "middleware";
      var MIDDLEWARE_LOCATION_REGEXP = `(?:src/)?${MIDDLEWARE_FILENAME}`;
      var PROXY_FILENAME = "proxy";
      var PROXY_LOCATION_REGEXP = `(?:src/)?${PROXY_FILENAME}`;
      var INSTRUMENTATION_HOOK_FILENAME = "instrumentation";
      var PAGES_DIR_ALIAS = "private-next-pages";
      var DOT_NEXT_ALIAS = "private-dot-next";
      var ROOT_DIR_ALIAS = "private-next-root-dir";
      var APP_DIR_ALIAS = "private-next-app-dir";
      var RSC_MOD_REF_PROXY_ALIAS = "private-next-rsc-mod-ref-proxy";
      var RSC_ACTION_VALIDATE_ALIAS = "private-next-rsc-action-validate";
      var RSC_ACTION_PROXY_ALIAS = "private-next-rsc-server-reference";
      var RSC_CACHE_WRAPPER_ALIAS = "private-next-rsc-cache-wrapper";
      var RSC_DYNAMIC_IMPORT_WRAPPER_ALIAS = "private-next-rsc-track-dynamic-import";
      var RSC_ACTION_ENCRYPTION_ALIAS = "private-next-rsc-action-encryption";
      var RSC_ACTION_CLIENT_WRAPPER_ALIAS = "private-next-rsc-action-client-wrapper";
      var PUBLIC_DIR_MIDDLEWARE_CONFLICT = `You can not have a '_next' folder inside of your public folder. This conflicts with the internal '/_next' route. https://nextjs.org/docs/messages/public-next-folder-conflict`;
      var SSG_GET_INITIAL_PROPS_CONFLICT = `You can not use getInitialProps with getStaticProps. To use SSG, please remove your getInitialProps`;
      var SERVER_PROPS_GET_INIT_PROPS_CONFLICT = `You can not use getInitialProps with getServerSideProps. Please remove getInitialProps.`;
      var SERVER_PROPS_SSG_CONFLICT = `You can not use getStaticProps or getStaticPaths with getServerSideProps. To use SSG, please remove getServerSideProps`;
      var STATIC_STATUS_PAGE_GET_INITIAL_PROPS_ERROR = `can not have getInitialProps/getServerSideProps, https://nextjs.org/docs/messages/404-get-initial-props`;
      var SERVER_PROPS_EXPORT_ERROR = `pages with \`getServerSideProps\` can not be exported. See more info here: https://nextjs.org/docs/messages/gssp-export`;
      var GSP_NO_RETURNED_VALUE = "Your `getStaticProps` function did not return an object. Did you forget to add a `return`?";
      var GSSP_NO_RETURNED_VALUE = "Your `getServerSideProps` function did not return an object. Did you forget to add a `return`?";
      var UNSTABLE_REVALIDATE_RENAME_ERROR = "The `unstable_revalidate` property is available for general use.\nPlease use `revalidate` instead.";
      var GSSP_COMPONENT_MEMBER_ERROR = `can not be attached to a page's component and must be exported from the page. See more info here: https://nextjs.org/docs/messages/gssp-component-member`;
      var NON_STANDARD_NODE_ENV = `You are using a non-standard "NODE_ENV" value in your environment. This creates inconsistencies in the project and is strongly advised against. Read more: https://nextjs.org/docs/messages/non-standard-node-env`;
      var SSG_FALLBACK_EXPORT_ERROR = `Pages with \`fallback\` enabled in \`getStaticPaths\` can not be exported. See more info here: https://nextjs.org/docs/messages/ssg-fallback-true-export`;
      var ESLINT_DEFAULT_DIRS = [
        "app",
        "pages",
        "components",
        "lib",
        "src"
      ];
      var SERVER_RUNTIME = {
        edge: "edge",
        experimentalEdge: "experimental-edge",
        nodejs: "nodejs"
      };
      var WEB_SOCKET_MAX_RECONNECTIONS = 12;
      var WEBPACK_LAYERS_NAMES = {
        /**
        * The layer for the shared code between the client and server bundles.
        */
        shared: "shared",
        /**
        * The layer for server-only runtime and picking up `react-server` export conditions.
        * Including app router RSC pages and app router custom routes and metadata routes.
        */
        reactServerComponents: "rsc",
        /**
        * Server Side Rendering layer for app (ssr).
        */
        serverSideRendering: "ssr",
        /**
        * The browser client bundle layer for actions.
        */
        actionBrowser: "action-browser",
        /**
        * The Node.js bundle layer for the API routes.
        */
        apiNode: "api-node",
        /**
        * The Edge Lite bundle layer for the API routes.
        */
        apiEdge: "api-edge",
        /**
        * The layer for the middleware code.
        */
        middleware: "middleware",
        /**
        * The layer for the instrumentation hooks.
        */
        instrument: "instrument",
        /**
        * The layer for assets on the edge.
        */
        edgeAsset: "edge-asset",
        /**
        * The browser client bundle layer for App directory.
        */
        appPagesBrowser: "app-pages-browser",
        /**
        * The browser client bundle layer for Pages directory.
        */
        pagesDirBrowser: "pages-dir-browser",
        /**
        * The Edge Lite bundle layer for Pages directory.
        */
        pagesDirEdge: "pages-dir-edge",
        /**
        * The Node.js bundle layer for Pages directory.
        */
        pagesDirNode: "pages-dir-node"
      };
      var WEBPACK_LAYERS = {
        ...WEBPACK_LAYERS_NAMES,
        GROUP: {
          builtinReact: [
            WEBPACK_LAYERS_NAMES.reactServerComponents,
            WEBPACK_LAYERS_NAMES.actionBrowser
          ],
          serverOnly: [
            WEBPACK_LAYERS_NAMES.reactServerComponents,
            WEBPACK_LAYERS_NAMES.actionBrowser,
            WEBPACK_LAYERS_NAMES.instrument,
            WEBPACK_LAYERS_NAMES.middleware
          ],
          neutralTarget: [
            // pages api
            WEBPACK_LAYERS_NAMES.apiNode,
            WEBPACK_LAYERS_NAMES.apiEdge
          ],
          clientOnly: [
            WEBPACK_LAYERS_NAMES.serverSideRendering,
            WEBPACK_LAYERS_NAMES.appPagesBrowser
          ],
          bundled: [
            WEBPACK_LAYERS_NAMES.reactServerComponents,
            WEBPACK_LAYERS_NAMES.actionBrowser,
            WEBPACK_LAYERS_NAMES.serverSideRendering,
            WEBPACK_LAYERS_NAMES.appPagesBrowser,
            WEBPACK_LAYERS_NAMES.shared,
            WEBPACK_LAYERS_NAMES.instrument,
            WEBPACK_LAYERS_NAMES.middleware
          ],
          appPages: [
            // app router pages and layouts
            WEBPACK_LAYERS_NAMES.reactServerComponents,
            WEBPACK_LAYERS_NAMES.serverSideRendering,
            WEBPACK_LAYERS_NAMES.appPagesBrowser,
            WEBPACK_LAYERS_NAMES.actionBrowser
          ]
        }
      };
      var WEBPACK_RESOURCE_QUERIES = {
        edgeSSREntry: "__next_edge_ssr_entry__",
        metadata: "__next_metadata__",
        metadataRoute: "__next_metadata_route__",
        metadataImageMeta: "__next_metadata_image_meta__"
      };
    }
  });

  // ../../node_modules/next/dist/shared/lib/escape-regexp.js
  var require_escape_regexp = __commonJS({
    "../../node_modules/next/dist/shared/lib/escape-regexp.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "escapeStringRegexp", {
        enumerable: true,
        get: function() {
          return escapeStringRegexp;
        }
      });
      var reHasRegExp = /[|\\{}()[\]^$+*?.-]/;
      var reReplaceRegExp = /[|\\{}()[\]^$+*?.-]/g;
      function escapeStringRegexp(str) {
        if (reHasRegExp.test(str)) {
          return str.replace(reReplaceRegExp, "\\$&");
        }
        return str;
      }
    }
  });

  // ../../node_modules/next/dist/shared/lib/invariant-error.js
  var require_invariant_error = __commonJS({
    "../../node_modules/next/dist/shared/lib/invariant-error.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "InvariantError", {
        enumerable: true,
        get: function() {
          return InvariantError;
        }
      });
      var InvariantError = class extends Error {
        constructor(message2, options) {
          super(`Invariant: ${message2.endsWith(".") ? message2 : message2 + "."} This is a bug in Next.js.`, options);
          this.name = "InvariantError";
        }
      };
    }
  });

  // ../../node_modules/next/dist/shared/lib/router/utils/parse-loader-tree.js
  var require_parse_loader_tree = __commonJS({
    "../../node_modules/next/dist/shared/lib/router/utils/parse-loader-tree.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "parseLoaderTree", {
        enumerable: true,
        get: function() {
          return parseLoaderTree;
        }
      });
      var _segment = require_segment();
      function parseLoaderTree(tree) {
        const [segment, parallelRoutes, modules] = tree;
        const { layout: layout2, template } = modules;
        let { page } = modules;
        page = segment === _segment.DEFAULT_SEGMENT_KEY ? modules.defaultPage : page;
        const conventionPath = layout2?.[1] || template?.[1] || page?.[1];
        return {
          page,
          segment,
          modules,
          /* it can be either layout / template / page */
          conventionPath,
          parallelRoutes
        };
      }
    }
  });

  // ../../node_modules/next/dist/shared/lib/router/utils/get-segment-param.js
  var require_get_segment_param = __commonJS({
    "../../node_modules/next/dist/shared/lib/router/utils/get-segment-param.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      function _export(target, all) {
        for (var name in all) Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
      }
      _export(exports, {
        getParamProperties: function() {
          return getParamProperties;
        },
        getSegmentParam: function() {
          return getSegmentParam;
        },
        isCatchAll: function() {
          return isCatchAll;
        }
      });
      var _interceptionroutes = require_interception_routes();
      function getSegmentParam(segment) {
        const interceptionMarker = _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.find((marker) => segment.startsWith(marker));
        if (interceptionMarker) {
          segment = segment.slice(interceptionMarker.length);
        }
        if (segment.startsWith("[[...") && segment.endsWith("]]")) {
          return {
            // TODO-APP: Optional catchall does not currently work with parallel routes,
            // so for now aren't handling a potential interception marker.
            paramType: "optional-catchall",
            paramName: segment.slice(5, -2)
          };
        }
        if (segment.startsWith("[...") && segment.endsWith("]")) {
          return {
            paramType: interceptionMarker ? `catchall-intercepted-${interceptionMarker}` : "catchall",
            paramName: segment.slice(4, -1)
          };
        }
        if (segment.startsWith("[") && segment.endsWith("]")) {
          return {
            paramType: interceptionMarker ? `dynamic-intercepted-${interceptionMarker}` : "dynamic",
            paramName: segment.slice(1, -1)
          };
        }
        return null;
      }
      function isCatchAll(type) {
        return type === "catchall" || type === "catchall-intercepted-(..)(..)" || type === "catchall-intercepted-(.)" || type === "catchall-intercepted-(..)" || type === "catchall-intercepted-(...)" || type === "optional-catchall";
      }
      function getParamProperties(paramType) {
        let repeat = false;
        let optional = false;
        switch (paramType) {
          case "catchall":
          case "catchall-intercepted-(..)(..)":
          case "catchall-intercepted-(.)":
          case "catchall-intercepted-(..)":
          case "catchall-intercepted-(...)":
            repeat = true;
            break;
          case "optional-catchall":
            repeat = true;
            optional = true;
            break;
          case "dynamic":
          case "dynamic-intercepted-(..)(..)":
          case "dynamic-intercepted-(.)":
          case "dynamic-intercepted-(..)":
          case "dynamic-intercepted-(...)":
            break;
          default:
            paramType;
        }
        return {
          repeat,
          optional
        };
      }
    }
  });

  // ../../node_modules/next/dist/shared/lib/router/routes/app.js
  var require_app = __commonJS({
    "../../node_modules/next/dist/shared/lib/router/routes/app.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      function _export(target, all) {
        for (var name in all) Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
      }
      _export(exports, {
        isInterceptionAppRoute: function() {
          return isInterceptionAppRoute;
        },
        isNormalizedAppRoute: function() {
          return isNormalizedAppRoute;
        },
        parseAppRoute: function() {
          return parseAppRoute;
        },
        parseAppRouteSegment: function() {
          return parseAppRouteSegment;
        }
      });
      var _invarianterror = require_invariant_error();
      var _getsegmentparam = require_get_segment_param();
      var _interceptionroutes = require_interception_routes();
      function parseAppRouteSegment(segment) {
        if (segment === "") {
          return null;
        }
        const interceptionMarker = _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.find((m3) => segment.startsWith(m3));
        const param = (0, _getsegmentparam.getSegmentParam)(segment);
        if (param) {
          return {
            type: "dynamic",
            name: segment,
            param,
            interceptionMarker
          };
        } else if (segment.startsWith("(") && segment.endsWith(")")) {
          return {
            type: "route-group",
            name: segment,
            interceptionMarker
          };
        } else if (segment.startsWith("@")) {
          return {
            type: "parallel-route",
            name: segment,
            interceptionMarker
          };
        } else {
          return {
            type: "static",
            name: segment,
            interceptionMarker
          };
        }
      }
      function isNormalizedAppRoute(route) {
        return route.normalized;
      }
      function isInterceptionAppRoute(route) {
        return route.interceptionMarker !== void 0 && route.interceptingRoute !== void 0 && route.interceptedRoute !== void 0;
      }
      function parseAppRoute(pathname, normalized) {
        const pathnameSegments = pathname.split("/").filter(Boolean);
        const segments = [];
        let interceptionMarker;
        let interceptingRoute;
        let interceptedRoute;
        for (const segment of pathnameSegments) {
          const appSegment = parseAppRouteSegment(segment);
          if (!appSegment) {
            continue;
          }
          if (normalized && (appSegment.type === "route-group" || appSegment.type === "parallel-route")) {
            throw Object.defineProperty(new _invarianterror.InvariantError(`${pathname} is being parsed as a normalized route, but it has a route group or parallel route segment.`), "__NEXT_ERROR_CODE", {
              value: "E923",
              enumerable: false,
              configurable: true
            });
          }
          segments.push(appSegment);
          if (appSegment.interceptionMarker) {
            const parts = pathname.split(appSegment.interceptionMarker);
            if (parts.length !== 2) {
              throw Object.defineProperty(new Error(`Invalid interception route: ${pathname}`), "__NEXT_ERROR_CODE", {
                value: "E924",
                enumerable: false,
                configurable: true
              });
            }
            interceptingRoute = normalized ? parseAppRoute(parts[0], true) : parseAppRoute(parts[0], false);
            interceptedRoute = normalized ? parseAppRoute(parts[1], true) : parseAppRoute(parts[1], false);
            interceptionMarker = appSegment.interceptionMarker;
          }
        }
        const dynamicSegments = segments.filter((segment) => segment.type === "dynamic");
        return {
          normalized,
          pathname,
          segments,
          dynamicSegments,
          interceptionMarker,
          interceptingRoute,
          interceptedRoute
        };
      }
    }
  });

  // ../../node_modules/next/dist/shared/lib/router/utils/interception-prefix-from-param-type.js
  var require_interception_prefix_from_param_type = __commonJS({
    "../../node_modules/next/dist/shared/lib/router/utils/interception-prefix-from-param-type.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "interceptionPrefixFromParamType", {
        enumerable: true,
        get: function() {
          return interceptionPrefixFromParamType;
        }
      });
      function interceptionPrefixFromParamType(paramType) {
        switch (paramType) {
          case "catchall-intercepted-(..)(..)":
          case "dynamic-intercepted-(..)(..)":
            return "(..)(..)";
          case "catchall-intercepted-(.)":
          case "dynamic-intercepted-(.)":
            return "(.)";
          case "catchall-intercepted-(..)":
          case "dynamic-intercepted-(..)":
            return "(..)";
          case "catchall-intercepted-(...)":
          case "dynamic-intercepted-(...)":
            return "(...)";
          case "catchall":
          case "dynamic":
          case "optional-catchall":
          default:
            return null;
        }
      }
    }
  });

  // ../../node_modules/next/dist/shared/lib/router/utils/resolve-param-value.js
  var require_resolve_param_value = __commonJS({
    "../../node_modules/next/dist/shared/lib/router/utils/resolve-param-value.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "resolveParamValue", {
        enumerable: true,
        get: function() {
          return resolveParamValue;
        }
      });
      var _invarianterror = require_invariant_error();
      var _interceptionprefixfromparamtype = require_interception_prefix_from_param_type();
      function getParamValueFromSegment(pathSegment, params, paramType) {
        if (pathSegment.type === "dynamic") {
          return params[pathSegment.param.paramName];
        }
        const interceptionPrefix = (0, _interceptionprefixfromparamtype.interceptionPrefixFromParamType)(paramType);
        if (interceptionPrefix === pathSegment.interceptionMarker) {
          return pathSegment.name.replace(pathSegment.interceptionMarker, "");
        }
        return pathSegment.name;
      }
      function resolveParamValue(paramName, paramType, depth, route, params) {
        switch (paramType) {
          case "catchall":
          case "optional-catchall":
          case "catchall-intercepted-(..)(..)":
          case "catchall-intercepted-(.)":
          case "catchall-intercepted-(..)":
          case "catchall-intercepted-(...)":
            const processedSegments = [];
            for (let index2 = depth; index2 < route.segments.length; index2++) {
              const pathSegment = route.segments[index2];
              if (pathSegment.type === "static") {
                let value = pathSegment.name;
                const interceptionPrefix = (0, _interceptionprefixfromparamtype.interceptionPrefixFromParamType)(paramType);
                if (interceptionPrefix && index2 === depth && interceptionPrefix === pathSegment.interceptionMarker) {
                  value = value.replace(pathSegment.interceptionMarker, "");
                }
                processedSegments.push(value);
              } else {
                if (!params.hasOwnProperty(pathSegment.param.paramName)) {
                  if (pathSegment.param.paramType === "optional-catchall") {
                    break;
                  }
                  return void 0;
                }
                const paramValue = params[pathSegment.param.paramName];
                if (Array.isArray(paramValue)) {
                  processedSegments.push(...paramValue);
                } else {
                  processedSegments.push(paramValue);
                }
              }
            }
            if (processedSegments.length > 0) {
              return processedSegments;
            } else if (paramType === "optional-catchall") {
              return void 0;
            } else {
              throw Object.defineProperty(new _invarianterror.InvariantError(`Unexpected empty path segments match for a route "${route.pathname}" with param "${paramName}" of type "${paramType}"`), "__NEXT_ERROR_CODE", {
                value: "E931",
                enumerable: false,
                configurable: true
              });
            }
          case "dynamic":
          case "dynamic-intercepted-(..)(..)":
          case "dynamic-intercepted-(.)":
          case "dynamic-intercepted-(..)":
          case "dynamic-intercepted-(...)":
            if (depth < route.segments.length) {
              const pathSegment = route.segments[depth];
              if (pathSegment.type === "dynamic" && !params.hasOwnProperty(pathSegment.param.paramName)) {
                return void 0;
              }
              return getParamValueFromSegment(pathSegment, params, paramType);
            }
            return void 0;
          default:
            paramType;
        }
      }
    }
  });

  // ../../node_modules/next/dist/shared/lib/router/utils/get-dynamic-param.js
  var require_get_dynamic_param = __commonJS({
    "../../node_modules/next/dist/shared/lib/router/utils/get-dynamic-param.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      function _export(target, all) {
        for (var name in all) Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
      }
      _export(exports, {
        PARAMETER_PATTERN: function() {
          return PARAMETER_PATTERN;
        },
        getDynamicParam: function() {
          return getDynamicParam;
        },
        interpolateParallelRouteParams: function() {
          return interpolateParallelRouteParams;
        },
        parseMatchedParameter: function() {
          return parseMatchedParameter;
        },
        parseParameter: function() {
          return parseParameter;
        }
      });
      var _invarianterror = require_invariant_error();
      var _parseloadertree = require_parse_loader_tree();
      var _app = require_app();
      var _resolveparamvalue = require_resolve_param_value();
      function getParamValue(interpolatedParams, segmentKey, fallbackRouteParams) {
        let value = interpolatedParams[segmentKey];
        if (fallbackRouteParams?.has(segmentKey)) {
          const [searchValue] = fallbackRouteParams.get(segmentKey);
          value = searchValue;
        } else if (Array.isArray(value)) {
          value = value.map((i3) => encodeURIComponent(i3));
        } else if (typeof value === "string") {
          value = encodeURIComponent(value);
        }
        return value;
      }
      function interpolateParallelRouteParams(loaderTree, params, pagePath, fallbackRouteParams) {
        const interpolated = structuredClone(params);
        const stack = [
          {
            tree: loaderTree,
            depth: 0
          }
        ];
        const route = (0, _app.parseAppRoute)(pagePath, true);
        while (stack.length > 0) {
          const { tree, depth } = stack.pop();
          const { segment, parallelRoutes } = (0, _parseloadertree.parseLoaderTree)(tree);
          const appSegment = (0, _app.parseAppRouteSegment)(segment);
          if (appSegment?.type === "dynamic" && !interpolated.hasOwnProperty(appSegment.param.paramName) && // If the param is in the fallback route params, we don't need to
          // interpolate it because it's already marked as being unknown.
          !fallbackRouteParams?.has(appSegment.param.paramName)) {
            const { paramName, paramType } = appSegment.param;
            const paramValue = (0, _resolveparamvalue.resolveParamValue)(paramName, paramType, depth, route, interpolated);
            if (paramValue !== void 0) {
              interpolated[paramName] = paramValue;
            } else if (paramType !== "optional-catchall") {
              throw Object.defineProperty(new _invarianterror.InvariantError(`Could not resolve param value for segment: ${paramName}`), "__NEXT_ERROR_CODE", {
                value: "E932",
                enumerable: false,
                configurable: true
              });
            }
          }
          let nextDepth = depth;
          if (appSegment && appSegment.type !== "route-group" && appSegment.type !== "parallel-route") {
            nextDepth++;
          }
          for (const parallelRoute of Object.values(parallelRoutes)) {
            stack.push({
              tree: parallelRoute,
              depth: nextDepth
            });
          }
        }
        return interpolated;
      }
      function getDynamicParam(interpolatedParams, segmentKey, dynamicParamType, fallbackRouteParams) {
        let value = getParamValue(interpolatedParams, segmentKey, fallbackRouteParams);
        if (!value || value.length === 0) {
          if (dynamicParamType === "oc") {
            return {
              param: segmentKey,
              value: null,
              type: dynamicParamType,
              treeSegment: [
                segmentKey,
                "",
                dynamicParamType
              ]
            };
          }
          throw Object.defineProperty(new _invarianterror.InvariantError(`Missing value for segment key: "${segmentKey}" with dynamic param type: ${dynamicParamType}`), "__NEXT_ERROR_CODE", {
            value: "E864",
            enumerable: false,
            configurable: true
          });
        }
        return {
          param: segmentKey,
          // The value that is passed to user code.
          value,
          // The value that is rendered in the router tree.
          treeSegment: [
            segmentKey,
            Array.isArray(value) ? value.join("/") : value,
            dynamicParamType
          ],
          type: dynamicParamType
        };
      }
      var PARAMETER_PATTERN = /^([^[]*)\[((?:\[[^\]]*\])|[^\]]+)\](.*)$/;
      function parseParameter(param) {
        const match2 = param.match(PARAMETER_PATTERN);
        if (!match2) {
          return parseMatchedParameter(param);
        }
        return parseMatchedParameter(match2[2]);
      }
      function parseMatchedParameter(param) {
        const optional = param.startsWith("[") && param.endsWith("]");
        if (optional) {
          param = param.slice(1, -1);
        }
        const repeat = param.startsWith("...");
        if (repeat) {
          param = param.slice(3);
        }
        return {
          key: param,
          repeat,
          optional
        };
      }
    }
  });

  // ../../node_modules/next/dist/shared/lib/router/utils/route-regex.js
  var require_route_regex = __commonJS({
    "../../node_modules/next/dist/shared/lib/router/utils/route-regex.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      function _export(target, all) {
        for (var name in all) Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
      }
      _export(exports, {
        getNamedMiddlewareRegex: function() {
          return getNamedMiddlewareRegex;
        },
        getNamedRouteRegex: function() {
          return getNamedRouteRegex;
        },
        getRouteRegex: function() {
          return getRouteRegex;
        }
      });
      var _constants = require_constants();
      var _interceptionroutes = require_interception_routes();
      var _escaperegexp = require_escape_regexp();
      var _removetrailingslash = require_remove_trailing_slash();
      var _getdynamicparam = require_get_dynamic_param();
      function getParametrizedRoute(route, includeSuffix, includePrefix) {
        const groups = {};
        let groupIndex = 1;
        const segments = [];
        for (const segment of (0, _removetrailingslash.removeTrailingSlash)(route).slice(1).split("/")) {
          const markerMatch = _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.find((m3) => segment.startsWith(m3));
          const paramMatches = segment.match(_getdynamicparam.PARAMETER_PATTERN);
          if (markerMatch && paramMatches && paramMatches[2]) {
            const { key, optional, repeat } = (0, _getdynamicparam.parseMatchedParameter)(paramMatches[2]);
            groups[key] = {
              pos: groupIndex++,
              repeat,
              optional
            };
            segments.push(`/${(0, _escaperegexp.escapeStringRegexp)(markerMatch)}([^/]+?)`);
          } else if (paramMatches && paramMatches[2]) {
            const { key, repeat, optional } = (0, _getdynamicparam.parseMatchedParameter)(paramMatches[2]);
            groups[key] = {
              pos: groupIndex++,
              repeat,
              optional
            };
            if (includePrefix && paramMatches[1]) {
              segments.push(`/${(0, _escaperegexp.escapeStringRegexp)(paramMatches[1])}`);
            }
            let s = repeat ? optional ? "(?:/(.+?))?" : "/(.+?)" : "/([^/]+?)";
            if (includePrefix && paramMatches[1]) {
              s = s.substring(1);
            }
            segments.push(s);
          } else {
            segments.push(`/${(0, _escaperegexp.escapeStringRegexp)(segment)}`);
          }
          if (includeSuffix && paramMatches && paramMatches[3]) {
            segments.push((0, _escaperegexp.escapeStringRegexp)(paramMatches[3]));
          }
        }
        return {
          parameterizedRoute: segments.join(""),
          groups
        };
      }
      function getRouteRegex(normalizedRoute, { includeSuffix = false, includePrefix = false, excludeOptionalTrailingSlash = false } = {}) {
        const { parameterizedRoute, groups } = getParametrizedRoute(normalizedRoute, includeSuffix, includePrefix);
        let re2 = parameterizedRoute;
        if (!excludeOptionalTrailingSlash) {
          re2 += "(?:/)?";
        }
        return {
          re: new RegExp(`^${re2}$`),
          groups
        };
      }
      function buildGetSafeRouteKey() {
        let i3 = 0;
        return () => {
          let routeKey = "";
          let j2 = ++i3;
          while (j2 > 0) {
            routeKey += String.fromCharCode(97 + (j2 - 1) % 26);
            j2 = Math.floor((j2 - 1) / 26);
          }
          return routeKey;
        };
      }
      function getSafeKeyFromSegment({ interceptionMarker, getSafeRouteKey, segment, routeKeys, keyPrefix, backreferenceDuplicateKeys }) {
        const { key, optional, repeat } = (0, _getdynamicparam.parseMatchedParameter)(segment);
        let cleanedKey = key.replace(/\W/g, "");
        if (keyPrefix) {
          cleanedKey = `${keyPrefix}${cleanedKey}`;
        }
        let invalidKey = false;
        if (cleanedKey.length === 0 || cleanedKey.length > 30) {
          invalidKey = true;
        }
        if (!isNaN(parseInt(cleanedKey.slice(0, 1)))) {
          invalidKey = true;
        }
        if (invalidKey) {
          cleanedKey = getSafeRouteKey();
        }
        const duplicateKey = cleanedKey in routeKeys;
        if (keyPrefix) {
          routeKeys[cleanedKey] = `${keyPrefix}${key}`;
        } else {
          routeKeys[cleanedKey] = key;
        }
        const interceptionPrefix = interceptionMarker ? (0, _escaperegexp.escapeStringRegexp)(interceptionMarker) : "";
        let pattern;
        if (duplicateKey && backreferenceDuplicateKeys) {
          pattern = `\\k<${cleanedKey}>`;
        } else if (repeat) {
          pattern = `(?<${cleanedKey}>.+?)`;
        } else {
          pattern = `(?<${cleanedKey}>[^/]+?)`;
        }
        return {
          key,
          pattern: optional ? `(?:/${interceptionPrefix}${pattern})?` : `/${interceptionPrefix}${pattern}`,
          cleanedKey,
          optional,
          repeat
        };
      }
      function getNamedParametrizedRoute(route, prefixRouteKeys, includeSuffix, includePrefix, backreferenceDuplicateKeys, reference = {
        names: {},
        intercepted: {}
      }) {
        var _a, _b;
        const getSafeRouteKey = buildGetSafeRouteKey();
        const routeKeys = {};
        const segments = [];
        const inverseParts = [];
        reference = structuredClone(reference);
        for (const segment of (0, _removetrailingslash.removeTrailingSlash)(route).slice(1).split("/")) {
          const hasInterceptionMarker = _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.some((m3) => segment.startsWith(m3));
          const paramMatches = segment.match(_getdynamicparam.PARAMETER_PATTERN);
          const interceptionMarker = hasInterceptionMarker ? paramMatches?.[1] : void 0;
          let keyPrefix;
          if (interceptionMarker && paramMatches?.[2]) {
            keyPrefix = prefixRouteKeys ? _constants.NEXT_INTERCEPTION_MARKER_PREFIX : void 0;
            reference.intercepted[paramMatches[2]] = interceptionMarker;
          } else if (paramMatches?.[2] && reference.intercepted[paramMatches[2]]) {
            keyPrefix = prefixRouteKeys ? _constants.NEXT_INTERCEPTION_MARKER_PREFIX : void 0;
          } else {
            keyPrefix = prefixRouteKeys ? _constants.NEXT_QUERY_PARAM_PREFIX : void 0;
          }
          if (interceptionMarker && paramMatches && paramMatches[2]) {
            const { key, pattern, cleanedKey, repeat, optional } = getSafeKeyFromSegment({
              getSafeRouteKey,
              interceptionMarker,
              segment: paramMatches[2],
              routeKeys,
              keyPrefix,
              backreferenceDuplicateKeys
            });
            segments.push(pattern);
            inverseParts.push(`/${paramMatches[1]}:${reference.names[key] ?? cleanedKey}${repeat ? optional ? "*" : "+" : ""}`);
            (_a = reference.names)[key] ?? (_a[key] = cleanedKey);
          } else if (paramMatches && paramMatches[2]) {
            if (includePrefix && paramMatches[1]) {
              segments.push(`/${(0, _escaperegexp.escapeStringRegexp)(paramMatches[1])}`);
              inverseParts.push(`/${paramMatches[1]}`);
            }
            const { key, pattern, cleanedKey, repeat, optional } = getSafeKeyFromSegment({
              getSafeRouteKey,
              segment: paramMatches[2],
              routeKeys,
              keyPrefix,
              backreferenceDuplicateKeys
            });
            let s = pattern;
            if (includePrefix && paramMatches[1]) {
              s = s.substring(1);
            }
            segments.push(s);
            inverseParts.push(`/:${reference.names[key] ?? cleanedKey}${repeat ? optional ? "*" : "+" : ""}`);
            (_b = reference.names)[key] ?? (_b[key] = cleanedKey);
          } else {
            segments.push(`/${(0, _escaperegexp.escapeStringRegexp)(segment)}`);
            inverseParts.push(`/${segment}`);
          }
          if (includeSuffix && paramMatches && paramMatches[3]) {
            segments.push((0, _escaperegexp.escapeStringRegexp)(paramMatches[3]));
            inverseParts.push(paramMatches[3]);
          }
        }
        return {
          namedParameterizedRoute: segments.join(""),
          routeKeys,
          pathToRegexpPattern: inverseParts.join(""),
          reference
        };
      }
      function getNamedRouteRegex(normalizedRoute, options) {
        const result = getNamedParametrizedRoute(normalizedRoute, options.prefixRouteKeys, options.includeSuffix ?? false, options.includePrefix ?? false, options.backreferenceDuplicateKeys ?? false, options.reference);
        let namedRegex = result.namedParameterizedRoute;
        if (!options.excludeOptionalTrailingSlash) {
          namedRegex += "(?:/)?";
        }
        return {
          ...getRouteRegex(normalizedRoute, options),
          namedRegex: `^${namedRegex}$`,
          routeKeys: result.routeKeys,
          pathToRegexpPattern: result.pathToRegexpPattern,
          reference: result.reference
        };
      }
      function getNamedMiddlewareRegex(normalizedRoute, options) {
        const { parameterizedRoute } = getParametrizedRoute(normalizedRoute, false, false);
        const { catchAll = true } = options;
        if (parameterizedRoute === "/") {
          let catchAllRegex = catchAll ? ".*" : "";
          return {
            namedRegex: `^/${catchAllRegex}$`
          };
        }
        const { namedParameterizedRoute } = getNamedParametrizedRoute(normalizedRoute, false, false, false, false, void 0);
        let catchAllGroupedRegex = catchAll ? "(?:(/.*)?)" : "";
        return {
          namedRegex: `^${namedParameterizedRoute}${catchAllGroupedRegex}$`
        };
      }
    }
  });

  // ../../node_modules/next/dist/shared/lib/router/utils/interpolate-as.js
  var require_interpolate_as = __commonJS({
    "../../node_modules/next/dist/shared/lib/router/utils/interpolate-as.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "interpolateAs", {
        enumerable: true,
        get: function() {
          return interpolateAs;
        }
      });
      var _routematcher = require_route_matcher();
      var _routeregex = require_route_regex();
      function interpolateAs(route, asPathname, query) {
        let interpolatedRoute = "";
        const dynamicRegex = (0, _routeregex.getRouteRegex)(route);
        const dynamicGroups = dynamicRegex.groups;
        const dynamicMatches = (
          // Try to match the dynamic route against the asPath
          (asPathname !== route ? (0, _routematcher.getRouteMatcher)(dynamicRegex)(asPathname) : "") || // Fall back to reading the values from the href
          // TODO: should this take priority; also need to change in the router.
          query
        );
        interpolatedRoute = route;
        const params = Object.keys(dynamicGroups);
        if (!params.every((param) => {
          let value = dynamicMatches[param] || "";
          const { repeat, optional } = dynamicGroups[param];
          let replaced = `[${repeat ? "..." : ""}${param}]`;
          if (optional) {
            replaced = `${!value ? "/" : ""}[${replaced}]`;
          }
          if (repeat && !Array.isArray(value)) value = [
            value
          ];
          return (optional || param in dynamicMatches) && // Interpolate group into data URL if present
          (interpolatedRoute = interpolatedRoute.replace(replaced, repeat ? value.map(
            // these values should be fully encoded instead of just
            // path delimiter escaped since they are being inserted
            // into the URL and we expect URL encoded segments
            // when parsing dynamic route params
            (segment) => encodeURIComponent(segment)
          ).join("/") : encodeURIComponent(value)) || "/");
        })) {
          interpolatedRoute = "";
        }
        return {
          params,
          result: interpolatedRoute
        };
      }
    }
  });

  // ../../node_modules/next/dist/client/resolve-href.js
  var require_resolve_href = __commonJS({
    "../../node_modules/next/dist/client/resolve-href.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "resolveHref", {
        enumerable: true,
        get: function() {
          return resolveHref;
        }
      });
      var _querystring = require_querystring();
      var _formaturl = require_format_url();
      var _omit = require_omit();
      var _utils = require_utils();
      var _normalizetrailingslash = require_normalize_trailing_slash();
      var _islocalurl = require_is_local_url();
      var _utils1 = require_utils2();
      var _interpolateas = require_interpolate_as();
      var _routeregex = require_route_regex();
      var _routematcher = require_route_matcher();
      function resolveHref(router, href, resolveAs) {
        let base;
        let urlAsString = typeof href === "string" ? href : (0, _formaturl.formatWithValidation)(href);
        const urlProtoMatch = urlAsString.match(/^[a-z][a-z0-9+.-]*:\/\//i);
        const urlAsStringNoProto = urlProtoMatch ? urlAsString.slice(urlProtoMatch[0].length) : urlAsString;
        const urlParts = urlAsStringNoProto.split("?", 1);
        if ((urlParts[0] || "").match(/(\/\/|\\)/)) {
          console.error(`Invalid href '${urlAsString}' passed to next/router in page: '${router.pathname}'. Repeated forward-slashes (//) or backslashes \\ are not valid in the href.`);
          const normalizedUrl = (0, _utils.normalizeRepeatedSlashes)(urlAsStringNoProto);
          urlAsString = (urlProtoMatch ? urlProtoMatch[0] : "") + normalizedUrl;
        }
        if (!(0, _islocalurl.isLocalURL)(urlAsString)) {
          return resolveAs ? [
            urlAsString
          ] : urlAsString;
        }
        try {
          let baseBase = urlAsString.startsWith("#") ? router.asPath : router.pathname;
          if (urlAsString.startsWith("?")) {
            baseBase = router.asPath;
            if ((0, _utils1.isDynamicRoute)(router.pathname)) {
              baseBase = router.pathname;
              const routeRegex = (0, _routeregex.getRouteRegex)(router.pathname);
              const match2 = (0, _routematcher.getRouteMatcher)(routeRegex)(router.asPath);
              if (!match2) {
                baseBase = router.asPath;
              }
            }
          }
          base = new URL(baseBase, "http://n");
        } catch (_2) {
          base = new URL("/", "http://n");
        }
        try {
          const finalUrl = new URL(urlAsString, base);
          finalUrl.pathname = (0, _normalizetrailingslash.normalizePathTrailingSlash)(finalUrl.pathname);
          let interpolatedAs = "";
          if ((0, _utils1.isDynamicRoute)(finalUrl.pathname) && finalUrl.searchParams && resolveAs) {
            const query = (0, _querystring.searchParamsToUrlQuery)(finalUrl.searchParams);
            const { result, params } = (0, _interpolateas.interpolateAs)(finalUrl.pathname, finalUrl.pathname, query);
            if (result) {
              interpolatedAs = (0, _formaturl.formatWithValidation)({
                pathname: result,
                hash: finalUrl.hash,
                query: (0, _omit.omit)(query, params)
              });
            }
          }
          const resolvedHref = finalUrl.origin === base.origin ? finalUrl.href.slice(finalUrl.origin.length) : finalUrl.href;
          return resolveAs ? [
            resolvedHref,
            interpolatedAs || resolvedHref
          ] : resolvedHref;
        } catch (_2) {
          return resolveAs ? [
            urlAsString
          ] : urlAsString;
        }
      }
      if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
        Object.defineProperty(exports.default, "__esModule", { value: true });
        Object.assign(exports.default, exports);
        module.exports = exports.default;
      }
    }
  });

  // ../../node_modules/next/dist/shared/lib/router/utils/add-path-prefix.js
  var require_add_path_prefix = __commonJS({
    "../../node_modules/next/dist/shared/lib/router/utils/add-path-prefix.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "addPathPrefix", {
        enumerable: true,
        get: function() {
          return addPathPrefix;
        }
      });
      var _parsepath = require_parse_path();
      function addPathPrefix(path, prefix2) {
        if (!path.startsWith("/") || !prefix2) {
          return path;
        }
        const { pathname, query, hash } = (0, _parsepath.parsePath)(path);
        return `${prefix2}${pathname}${query}${hash}`;
      }
    }
  });

  // ../../node_modules/next/dist/shared/lib/router/utils/add-locale.js
  var require_add_locale = __commonJS({
    "../../node_modules/next/dist/shared/lib/router/utils/add-locale.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "addLocale", {
        enumerable: true,
        get: function() {
          return addLocale;
        }
      });
      var _addpathprefix = require_add_path_prefix();
      var _pathhasprefix = require_path_has_prefix();
      function addLocale(path, locale, defaultLocale, ignorePrefix) {
        if (!locale || locale === defaultLocale) return path;
        const lower = path.toLowerCase();
        if (!ignorePrefix) {
          if ((0, _pathhasprefix.pathHasPrefix)(lower, "/api")) return path;
          if ((0, _pathhasprefix.pathHasPrefix)(lower, `/${locale.toLowerCase()}`)) return path;
        }
        return (0, _addpathprefix.addPathPrefix)(path, `/${locale}`);
      }
    }
  });

  // ../../node_modules/next/dist/client/add-locale.js
  var require_add_locale2 = __commonJS({
    "../../node_modules/next/dist/client/add-locale.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "addLocale", {
        enumerable: true,
        get: function() {
          return addLocale;
        }
      });
      var _normalizetrailingslash = require_normalize_trailing_slash();
      var addLocale = (path, ...args) => {
        if (process.env.__NEXT_I18N_SUPPORT) {
          return (0, _normalizetrailingslash.normalizePathTrailingSlash)(require_add_locale().addLocale(path, ...args));
        }
        return path;
      };
      if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
        Object.defineProperty(exports.default, "__esModule", { value: true });
        Object.assign(exports.default, exports);
        module.exports = exports.default;
      }
    }
  });

  // ../../node_modules/@swc/helpers/cjs/_interop_require_default.cjs
  var require_interop_require_default = __commonJS({
    "../../node_modules/@swc/helpers/cjs/_interop_require_default.cjs"(exports) {
      "use strict";
      function _interop_require_default(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      exports._ = _interop_require_default;
    }
  });

  // ../../node_modules/next/dist/shared/lib/router-context.shared-runtime.js
  var require_router_context_shared_runtime = __commonJS({
    "../../node_modules/next/dist/shared/lib/router-context.shared-runtime.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "RouterContext", {
        enumerable: true,
        get: function() {
          return RouterContext;
        }
      });
      var _interop_require_default = require_interop_require_default();
      var _react = /* @__PURE__ */ _interop_require_default._(require_react2());
      var RouterContext = _react.default.createContext(null);
      if (process.env.NODE_ENV !== "production") {
        RouterContext.displayName = "RouterContext";
      }
    }
  });

  // ../../node_modules/next/dist/client/request-idle-callback.js
  var require_request_idle_callback = __commonJS({
    "../../node_modules/next/dist/client/request-idle-callback.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      function _export(target, all) {
        for (var name in all) Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
      }
      _export(exports, {
        cancelIdleCallback: function() {
          return cancelIdleCallback;
        },
        requestIdleCallback: function() {
          return requestIdleCallback;
        }
      });
      var requestIdleCallback = typeof self !== "undefined" && self.requestIdleCallback && self.requestIdleCallback.bind(window) || function(cb) {
        let start2 = Date.now();
        return self.setTimeout(function() {
          cb({
            didTimeout: false,
            timeRemaining: function() {
              return Math.max(0, 50 - (Date.now() - start2));
            }
          });
        }, 1);
      };
      var cancelIdleCallback = typeof self !== "undefined" && self.cancelIdleCallback && self.cancelIdleCallback.bind(window) || function(id3) {
        return clearTimeout(id3);
      };
      if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
        Object.defineProperty(exports.default, "__esModule", { value: true });
        Object.assign(exports.default, exports);
        module.exports = exports.default;
      }
    }
  });

  // ../../node_modules/next/dist/client/use-intersection.js
  var require_use_intersection = __commonJS({
    "../../node_modules/next/dist/client/use-intersection.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "useIntersection", {
        enumerable: true,
        get: function() {
          return useIntersection;
        }
      });
      var _react = require_react2();
      var _requestidlecallback = require_request_idle_callback();
      var hasIntersectionObserver = typeof IntersectionObserver === "function";
      var observers2 = /* @__PURE__ */ new Map();
      var idList = [];
      function createObserver(options) {
        const id3 = {
          root: options.root || null,
          margin: options.rootMargin || ""
        };
        const existing = idList.find((obj) => obj.root === id3.root && obj.margin === id3.margin);
        let instance;
        if (existing) {
          instance = observers2.get(existing);
          if (instance) {
            return instance;
          }
        }
        const elements = /* @__PURE__ */ new Map();
        const observer2 = new IntersectionObserver((entries) => {
          entries.forEach((entry) => {
            const callback = elements.get(entry.target);
            const isVisible = entry.isIntersecting || entry.intersectionRatio > 0;
            if (callback && isVisible) {
              callback(isVisible);
            }
          });
        }, options);
        instance = {
          id: id3,
          observer: observer2,
          elements
        };
        idList.push(id3);
        observers2.set(id3, instance);
        return instance;
      }
      function observe(element, callback, options) {
        const { id: id3, observer: observer2, elements } = createObserver(options);
        elements.set(element, callback);
        observer2.observe(element);
        return function unobserve() {
          elements.delete(element);
          observer2.unobserve(element);
          if (elements.size === 0) {
            observer2.disconnect();
            observers2.delete(id3);
            const index2 = idList.findIndex((obj) => obj.root === id3.root && obj.margin === id3.margin);
            if (index2 > -1) {
              idList.splice(index2, 1);
            }
          }
        };
      }
      function useIntersection({ rootRef, rootMargin, disabled }) {
        const isDisabled = disabled || !hasIntersectionObserver;
        const [visible, setVisible] = (0, _react.useState)(false);
        const elementRef = (0, _react.useRef)(null);
        const setElement = (0, _react.useCallback)((element) => {
          elementRef.current = element;
        }, []);
        (0, _react.useEffect)(() => {
          if (hasIntersectionObserver) {
            if (isDisabled || visible) return;
            const element = elementRef.current;
            if (element && element.tagName) {
              const unobserve = observe(element, (isVisible) => isVisible && setVisible(isVisible), {
                root: rootRef?.current,
                rootMargin
              });
              return unobserve;
            }
          } else {
            if (!visible) {
              const idleCallback = (0, _requestidlecallback.requestIdleCallback)(() => setVisible(true));
              return () => (0, _requestidlecallback.cancelIdleCallback)(idleCallback);
            }
          }
        }, [
          isDisabled,
          rootMargin,
          rootRef,
          visible,
          elementRef.current
        ]);
        const resetVisible = (0, _react.useCallback)(() => {
          setVisible(false);
        }, []);
        return [
          setElement,
          visible,
          resetVisible
        ];
      }
      if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
        Object.defineProperty(exports.default, "__esModule", { value: true });
        Object.assign(exports.default, exports);
        module.exports = exports.default;
      }
    }
  });

  // ../../node_modules/next/dist/shared/lib/i18n/normalize-locale-path.js
  var require_normalize_locale_path = __commonJS({
    "../../node_modules/next/dist/shared/lib/i18n/normalize-locale-path.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "normalizeLocalePath", {
        enumerable: true,
        get: function() {
          return normalizeLocalePath;
        }
      });
      var cache = /* @__PURE__ */ new WeakMap();
      function normalizeLocalePath(pathname, locales) {
        if (!locales) return {
          pathname
        };
        let lowercasedLocales = cache.get(locales);
        if (!lowercasedLocales) {
          lowercasedLocales = locales.map((locale) => locale.toLowerCase());
          cache.set(locales, lowercasedLocales);
        }
        let detectedLocale;
        const segments = pathname.split("/", 2);
        if (!segments[1]) return {
          pathname
        };
        const segment = segments[1].toLowerCase();
        const index2 = lowercasedLocales.indexOf(segment);
        if (index2 < 0) return {
          pathname
        };
        detectedLocale = locales[index2];
        pathname = pathname.slice(detectedLocale.length + 1) || "/";
        return {
          pathname,
          detectedLocale
        };
      }
    }
  });

  // ../../node_modules/next/dist/client/normalize-locale-path.js
  var require_normalize_locale_path2 = __commonJS({
    "../../node_modules/next/dist/client/normalize-locale-path.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "normalizeLocalePath", {
        enumerable: true,
        get: function() {
          return normalizeLocalePath;
        }
      });
      var normalizeLocalePath = (pathname, locales) => {
        if (process.env.__NEXT_I18N_SUPPORT) {
          return require_normalize_locale_path().normalizeLocalePath(pathname, locales);
        }
        return {
          pathname,
          detectedLocale: void 0
        };
      };
      if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
        Object.defineProperty(exports.default, "__esModule", { value: true });
        Object.assign(exports.default, exports);
        module.exports = exports.default;
      }
    }
  });

  // ../../node_modules/next/dist/shared/lib/i18n/detect-domain-locale.js
  var require_detect_domain_locale = __commonJS({
    "../../node_modules/next/dist/shared/lib/i18n/detect-domain-locale.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "detectDomainLocale", {
        enumerable: true,
        get: function() {
          return detectDomainLocale;
        }
      });
      function detectDomainLocale(domainItems, hostname, detectedLocale) {
        if (!domainItems) return;
        if (detectedLocale) {
          detectedLocale = detectedLocale.toLowerCase();
        }
        for (const item of domainItems) {
          const domainHostname = item.domain?.split(":", 1)[0].toLowerCase();
          if (hostname === domainHostname || detectedLocale === item.defaultLocale.toLowerCase() || item.locales?.some((locale) => locale.toLowerCase() === detectedLocale)) {
            return item;
          }
        }
      }
    }
  });

  // ../../node_modules/next/dist/client/detect-domain-locale.js
  var require_detect_domain_locale2 = __commonJS({
    "../../node_modules/next/dist/client/detect-domain-locale.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "detectDomainLocale", {
        enumerable: true,
        get: function() {
          return detectDomainLocale;
        }
      });
      var detectDomainLocale = (...args) => {
        if (process.env.__NEXT_I18N_SUPPORT) {
          return require_detect_domain_locale().detectDomainLocale(...args);
        }
      };
      if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
        Object.defineProperty(exports.default, "__esModule", { value: true });
        Object.assign(exports.default, exports);
        module.exports = exports.default;
      }
    }
  });

  // ../../node_modules/next/dist/client/get-domain-locale.js
  var require_get_domain_locale = __commonJS({
    "../../node_modules/next/dist/client/get-domain-locale.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "getDomainLocale", {
        enumerable: true,
        get: function() {
          return getDomainLocale;
        }
      });
      var _normalizetrailingslash = require_normalize_trailing_slash();
      var basePath = process.env.__NEXT_ROUTER_BASEPATH || "";
      function getDomainLocale(path, locale, locales, domainLocales) {
        if (process.env.__NEXT_I18N_SUPPORT) {
          const normalizeLocalePath = require_normalize_locale_path2().normalizeLocalePath;
          const detectDomainLocale = require_detect_domain_locale2().detectDomainLocale;
          const target = locale || normalizeLocalePath(path, locales).detectedLocale;
          const domain = detectDomainLocale(domainLocales, void 0, target);
          if (domain) {
            const proto = `http${domain.http ? "" : "s"}://`;
            const finalLocale = target === domain.defaultLocale ? "" : `/${target}`;
            return `${proto}${domain.domain}${(0, _normalizetrailingslash.normalizePathTrailingSlash)(`${basePath}${finalLocale}${path}`)}`;
          }
          return false;
        } else {
          return false;
        }
      }
      if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
        Object.defineProperty(exports.default, "__esModule", { value: true });
        Object.assign(exports.default, exports);
        module.exports = exports.default;
      }
    }
  });

  // ../../node_modules/next/dist/client/add-base-path.js
  var require_add_base_path = __commonJS({
    "../../node_modules/next/dist/client/add-base-path.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "addBasePath", {
        enumerable: true,
        get: function() {
          return addBasePath;
        }
      });
      var _addpathprefix = require_add_path_prefix();
      var _normalizetrailingslash = require_normalize_trailing_slash();
      var basePath = process.env.__NEXT_ROUTER_BASEPATH || "";
      function addBasePath(path, required) {
        return (0, _normalizetrailingslash.normalizePathTrailingSlash)(process.env.__NEXT_MANUAL_CLIENT_BASE_PATH && !required ? path : (0, _addpathprefix.addPathPrefix)(path, basePath));
      }
      if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
        Object.defineProperty(exports.default, "__esModule", { value: true });
        Object.assign(exports.default, exports);
        module.exports = exports.default;
      }
    }
  });

  // ../../node_modules/next/dist/client/use-merged-ref.js
  var require_use_merged_ref = __commonJS({
    "../../node_modules/next/dist/client/use-merged-ref.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "useMergedRef", {
        enumerable: true,
        get: function() {
          return useMergedRef;
        }
      });
      var _react = require_react2();
      function useMergedRef(refA, refB) {
        const cleanupA = (0, _react.useRef)(null);
        const cleanupB = (0, _react.useRef)(null);
        return (0, _react.useCallback)((current) => {
          if (current === null) {
            const cleanupFnA = cleanupA.current;
            if (cleanupFnA) {
              cleanupA.current = null;
              cleanupFnA();
            }
            const cleanupFnB = cleanupB.current;
            if (cleanupFnB) {
              cleanupB.current = null;
              cleanupFnB();
            }
          } else {
            if (refA) {
              cleanupA.current = applyRef(refA, current);
            }
            if (refB) {
              cleanupB.current = applyRef(refB, current);
            }
          }
        }, [
          refA,
          refB
        ]);
      }
      function applyRef(refA, current) {
        if (typeof refA === "function") {
          const cleanup = refA(current);
          if (typeof cleanup === "function") {
            return cleanup;
          } else {
            return () => refA(null);
          }
        } else {
          refA.current = current;
          return () => {
            refA.current = null;
          };
        }
      }
      if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
        Object.defineProperty(exports.default, "__esModule", { value: true });
        Object.assign(exports.default, exports);
        module.exports = exports.default;
      }
    }
  });

  // ../../node_modules/next/dist/shared/lib/utils/error-once.js
  var require_error_once = __commonJS({
    "../../node_modules/next/dist/shared/lib/utils/error-once.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "errorOnce", {
        enumerable: true,
        get: function() {
          return errorOnce;
        }
      });
      var errorOnce = (_2) => {
      };
      if (process.env.NODE_ENV !== "production") {
        const errors = /* @__PURE__ */ new Set();
        errorOnce = (msg) => {
          if (!errors.has(msg)) {
            console.error(msg);
          }
          errors.add(msg);
        };
      }
    }
  });

  // ../../node_modules/next/dist/client/link.js
  var require_link = __commonJS({
    "../../node_modules/next/dist/client/link.js"(exports, module) {
      "use strict";
      "use client";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      function _export(target, all) {
        for (var name in all) Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
      }
      _export(exports, {
        default: function() {
          return _default;
        },
        useLinkStatus: function() {
          return useLinkStatus;
        }
      });
      var _interop_require_wildcard = require_interop_require_wildcard();
      var _jsxruntime = require_jsx_runtime2();
      var _react = /* @__PURE__ */ _interop_require_wildcard._(require_react2());
      var _resolvehref = require_resolve_href();
      var _islocalurl = require_is_local_url();
      var _formaturl = require_format_url();
      var _utils = require_utils();
      var _addlocale = require_add_locale2();
      var _routercontextsharedruntime = require_router_context_shared_runtime();
      var _useintersection = require_use_intersection();
      var _getdomainlocale = require_get_domain_locale();
      var _addbasepath = require_add_base_path();
      var _usemergedref = require_use_merged_ref();
      var _erroronce = require_error_once();
      var prefetched = /* @__PURE__ */ new Set();
      function prefetch(router, href, as, options) {
        if (typeof window === "undefined") {
          return;
        }
        if (!(0, _islocalurl.isLocalURL)(href)) {
          return;
        }
        if (!options.bypassPrefetchedCheck) {
          const locale = (
            // Let the link's locale prop override the default router locale.
            typeof options.locale !== "undefined" ? options.locale : "locale" in router ? router.locale : void 0
          );
          const prefetchedKey = href + "%" + as + "%" + locale;
          if (prefetched.has(prefetchedKey)) {
            return;
          }
          prefetched.add(prefetchedKey);
        }
        router.prefetch(href, as, options).catch((err) => {
          if (process.env.NODE_ENV !== "production") {
            throw err;
          }
        });
      }
      function isModifiedEvent(event) {
        const eventTarget = event.currentTarget;
        const target = eventTarget.getAttribute("target");
        return target && target !== "_self" || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey || // triggers resource download
        event.nativeEvent && event.nativeEvent.which === 2;
      }
      function linkClicked(e2, router, href, as, replace, shallow, scroll2, locale, onNavigate) {
        const { nodeName } = e2.currentTarget;
        const isAnchorNodeName = nodeName.toUpperCase() === "A";
        if (isAnchorNodeName && isModifiedEvent(e2) || e2.currentTarget.hasAttribute("download")) {
          return;
        }
        if (!(0, _islocalurl.isLocalURL)(href)) {
          if (replace) {
            e2.preventDefault();
            location.replace(href);
          }
          return;
        }
        e2.preventDefault();
        const navigate = () => {
          if (onNavigate) {
            let isDefaultPrevented = false;
            onNavigate({
              preventDefault: () => {
                isDefaultPrevented = true;
              }
            });
            if (isDefaultPrevented) {
              return;
            }
          }
          const routerScroll = scroll2 ?? true;
          if ("beforePopState" in router) {
            router[replace ? "replace" : "push"](href, as, {
              shallow,
              locale,
              scroll: routerScroll
            });
          } else {
            router[replace ? "replace" : "push"](as || href, {
              scroll: routerScroll
            });
          }
        };
        navigate();
      }
      function formatStringOrUrl(urlObjOrString) {
        if (typeof urlObjOrString === "string") {
          return urlObjOrString;
        }
        return (0, _formaturl.formatUrl)(urlObjOrString);
      }
      var Link2 = /* @__PURE__ */ _react.default.forwardRef(function LinkComponent(props, forwardedRef) {
        let children;
        const { href: hrefProp, as: asProp, children: childrenProp, prefetch: prefetchProp = null, passHref, replace, shallow, scroll: scroll2, locale, onClick, onNavigate, onMouseEnter: onMouseEnterProp, onTouchStart: onTouchStartProp, legacyBehavior = false, ...restProps } = props;
        children = childrenProp;
        if (legacyBehavior && (typeof children === "string" || typeof children === "number")) {
          children = /* @__PURE__ */ (0, _jsxruntime.jsx)("a", {
            children
          });
        }
        const router = _react.default.useContext(_routercontextsharedruntime.RouterContext);
        const prefetchEnabled = prefetchProp !== false;
        if (process.env.NODE_ENV !== "production") {
          let createPropError = function(args) {
            return Object.defineProperty(new Error(`Failed prop type: The prop \`${args.key}\` expects a ${args.expected} in \`<Link>\`, but got \`${args.actual}\` instead.` + (typeof window !== "undefined" ? "\nOpen your browser's console to view the Component stack trace." : "")), "__NEXT_ERROR_CODE", {
              value: "E319",
              enumerable: false,
              configurable: true
            });
          };
          const requiredPropsGuard = {
            href: true
          };
          const requiredProps = Object.keys(requiredPropsGuard);
          requiredProps.forEach((key) => {
            if (key === "href") {
              if (props[key] == null || typeof props[key] !== "string" && typeof props[key] !== "object") {
                throw createPropError({
                  key,
                  expected: "`string` or `object`",
                  actual: props[key] === null ? "null" : typeof props[key]
                });
              }
            } else {
              const _2 = key;
            }
          });
          const optionalPropsGuard = {
            as: true,
            replace: true,
            scroll: true,
            shallow: true,
            passHref: true,
            prefetch: true,
            locale: true,
            onClick: true,
            onMouseEnter: true,
            onTouchStart: true,
            legacyBehavior: true,
            onNavigate: true
          };
          const optionalProps = Object.keys(optionalPropsGuard);
          optionalProps.forEach((key) => {
            const valType = typeof props[key];
            if (key === "as") {
              if (props[key] && valType !== "string" && valType !== "object") {
                throw createPropError({
                  key,
                  expected: "`string` or `object`",
                  actual: valType
                });
              }
            } else if (key === "locale") {
              if (props[key] && valType !== "string") {
                throw createPropError({
                  key,
                  expected: "`string`",
                  actual: valType
                });
              }
            } else if (key === "onClick" || key === "onMouseEnter" || key === "onTouchStart" || key === "onNavigate") {
              if (props[key] && valType !== "function") {
                throw createPropError({
                  key,
                  expected: "`function`",
                  actual: valType
                });
              }
            } else if (key === "replace" || key === "scroll" || key === "shallow" || key === "passHref" || key === "legacyBehavior") {
              if (props[key] != null && valType !== "boolean") {
                throw createPropError({
                  key,
                  expected: "`boolean`",
                  actual: valType
                });
              }
            } else if (key === "prefetch") {
              if (props[key] != null && valType !== "boolean" && props[key] !== "auto") {
                throw createPropError({
                  key,
                  expected: '`boolean | "auto"`',
                  actual: valType
                });
              }
            } else {
              const _2 = key;
            }
          });
        }
        const { href, as } = _react.default.useMemo(() => {
          if (!router) {
            const resolvedHref2 = formatStringOrUrl(hrefProp);
            return {
              href: resolvedHref2,
              as: asProp ? formatStringOrUrl(asProp) : resolvedHref2
            };
          }
          const [resolvedHref, resolvedAs] = (0, _resolvehref.resolveHref)(router, hrefProp, true);
          return {
            href: resolvedHref,
            as: asProp ? (0, _resolvehref.resolveHref)(router, asProp) : resolvedAs || resolvedHref
          };
        }, [
          router,
          hrefProp,
          asProp
        ]);
        const previousHref = _react.default.useRef(href);
        const previousAs = _react.default.useRef(as);
        let child;
        if (legacyBehavior) {
          if (process.env.NODE_ENV === "development") {
            if (onClick) {
              console.warn(`"onClick" was passed to <Link> with \`href\` of \`${hrefProp}\` but "legacyBehavior" was set. The legacy behavior requires onClick be set on the child of next/link`);
            }
            if (onMouseEnterProp) {
              console.warn(`"onMouseEnter" was passed to <Link> with \`href\` of \`${hrefProp}\` but "legacyBehavior" was set. The legacy behavior requires onMouseEnter be set on the child of next/link`);
            }
            try {
              child = _react.default.Children.only(children);
            } catch (err) {
              if (!children) {
                throw Object.defineProperty(new Error(`No children were passed to <Link> with \`href\` of \`${hrefProp}\` but one child is required https://nextjs.org/docs/messages/link-no-children`), "__NEXT_ERROR_CODE", {
                  value: "E320",
                  enumerable: false,
                  configurable: true
                });
              }
              throw Object.defineProperty(new Error(`Multiple children were passed to <Link> with \`href\` of \`${hrefProp}\` but only one child is supported https://nextjs.org/docs/messages/link-multiple-children` + (typeof window !== "undefined" ? " \nOpen your browser's console to view the Component stack trace." : "")), "__NEXT_ERROR_CODE", {
                value: "E266",
                enumerable: false,
                configurable: true
              });
            }
          } else {
            child = _react.default.Children.only(children);
          }
        } else {
          if (process.env.NODE_ENV === "development") {
            if (children?.type === "a") {
              throw Object.defineProperty(new Error("Invalid <Link> with <a> child. Please remove <a> or use <Link legacyBehavior>.\nLearn more: https://nextjs.org/docs/messages/invalid-new-link-with-extra-anchor"), "__NEXT_ERROR_CODE", {
                value: "E209",
                enumerable: false,
                configurable: true
              });
            }
          }
        }
        const childRef = legacyBehavior ? child && typeof child === "object" && child.ref : forwardedRef;
        const [setIntersectionRef, isVisible, resetVisible] = (0, _useintersection.useIntersection)({
          rootMargin: "200px"
        });
        const setIntersectionWithResetRef = _react.default.useCallback((el) => {
          if (previousAs.current !== as || previousHref.current !== href) {
            resetVisible();
            previousAs.current = as;
            previousHref.current = href;
          }
          setIntersectionRef(el);
        }, [
          as,
          href,
          resetVisible,
          setIntersectionRef
        ]);
        const setRef3 = (0, _usemergedref.useMergedRef)(setIntersectionWithResetRef, childRef);
        _react.default.useEffect(() => {
          if (process.env.NODE_ENV !== "production") {
            return;
          }
          if (!router) {
            return;
          }
          if (!isVisible || !prefetchEnabled) {
            return;
          }
          prefetch(router, href, as, {
            locale
          });
        }, [
          as,
          href,
          isVisible,
          locale,
          prefetchEnabled,
          router?.locale,
          router
        ]);
        const childProps = {
          ref: setRef3,
          onClick(e2) {
            if (process.env.NODE_ENV !== "production") {
              if (!e2) {
                throw Object.defineProperty(new Error(`Component rendered inside next/link has to pass click event to "onClick" prop.`), "__NEXT_ERROR_CODE", {
                  value: "E312",
                  enumerable: false,
                  configurable: true
                });
              }
            }
            if (!legacyBehavior && typeof onClick === "function") {
              onClick(e2);
            }
            if (legacyBehavior && child.props && typeof child.props.onClick === "function") {
              child.props.onClick(e2);
            }
            if (!router) {
              return;
            }
            if (e2.defaultPrevented) {
              return;
            }
            linkClicked(e2, router, href, as, replace, shallow, scroll2, locale, onNavigate);
          },
          onMouseEnter(e2) {
            if (!legacyBehavior && typeof onMouseEnterProp === "function") {
              onMouseEnterProp(e2);
            }
            if (legacyBehavior && child.props && typeof child.props.onMouseEnter === "function") {
              child.props.onMouseEnter(e2);
            }
            if (!router) {
              return;
            }
            prefetch(router, href, as, {
              locale,
              priority: true,
              // @see {https://github.com/vercel/next.js/discussions/40268?sort=top#discussioncomment-3572642}
              bypassPrefetchedCheck: true
            });
          },
          onTouchStart: process.env.__NEXT_LINK_NO_TOUCH_START ? void 0 : function onTouchStart(e2) {
            if (!legacyBehavior && typeof onTouchStartProp === "function") {
              onTouchStartProp(e2);
            }
            if (legacyBehavior && child.props && typeof child.props.onTouchStart === "function") {
              child.props.onTouchStart(e2);
            }
            if (!router) {
              return;
            }
            prefetch(router, href, as, {
              locale,
              priority: true,
              // @see {https://github.com/vercel/next.js/discussions/40268?sort=top#discussioncomment-3572642}
              bypassPrefetchedCheck: true
            });
          }
        };
        if ((0, _utils.isAbsoluteUrl)(as)) {
          childProps.href = as;
        } else if (!legacyBehavior || passHref || child.type === "a" && !("href" in child.props)) {
          const curLocale = typeof locale !== "undefined" ? locale : router?.locale;
          const localeDomain = router?.isLocaleDomain && (0, _getdomainlocale.getDomainLocale)(as, curLocale, router?.locales, router?.domainLocales);
          childProps.href = localeDomain || (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(as, curLocale, router?.defaultLocale));
        }
        if (legacyBehavior) {
          if (process.env.NODE_ENV === "development") {
            (0, _erroronce.errorOnce)("`legacyBehavior` is deprecated and will be removed in a future release. A codemod is available to upgrade your components:\n\nnpx @next/codemod@latest new-link .\n\nLearn more: https://nextjs.org/docs/app/building-your-application/upgrading/codemods#remove-a-tags-from-link-components");
          }
          return /* @__PURE__ */ _react.default.cloneElement(child, childProps);
        }
        return /* @__PURE__ */ (0, _jsxruntime.jsx)("a", {
          ...restProps,
          ...childProps,
          children
        });
      });
      var LinkStatusContext = /* @__PURE__ */ (0, _react.createContext)({
        // We do not support link status in the Pages Router, so we always return false
        pending: false
      });
      var useLinkStatus = () => {
        return (0, _react.useContext)(LinkStatusContext);
      };
      var _default = Link2;
      if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
        Object.defineProperty(exports.default, "__esModule", { value: true });
        Object.assign(exports.default, exports);
        module.exports = exports.default;
      }
    }
  });

  // ../../node_modules/next/link.js
  var require_link2 = __commonJS({
    "../../node_modules/next/link.js"(exports, module) {
      "use strict";
      module.exports = require_link();
    }
  });

  // src/components/FloatingLines.css
  var init_FloatingLines = __esm({
    "src/components/FloatingLines.css"() {
    }
  });

  // src/components/FloatingLines.tsx
  var import_react79, import_jsx_runtime50;
  var init_FloatingLines2 = __esm({
    "src/components/FloatingLines.tsx"() {
      "use strict";
      "use client";
      import_react79 = __toESM(require_react());
      init_FloatingLines();
      import_jsx_runtime50 = __toESM(require_jsx_runtime());
    }
  });

  // src/index.ts
  var index_exports = {};
  __export(index_exports, {
    Accordion: () => Accordion,
    AccordionItem: () => AccordionItem,
    ActivityIndicator: () => ActivityIndicator,
    Alert: () => Alert,
    AnimatedBeam: () => AnimatedBeam,
    AnimatedDotPattern: () => AnimatedDotPattern,
    AnimatedGradientText: () => AnimatedGradientText,
    AnimatedTerminal: () => AnimatedTerminal,
    AuroraBackground: () => AuroraBackground,
    Avatar: () => Avatar2,
    AvatarFallback: () => AvatarFallback2,
    AvatarImage: () => AvatarImage2,
    Badge: () => Badge,
    BentoGrid: () => BentoGrid,
    BentoGridItem: () => BentoGridItem,
    BlurText: () => BlurText,
    BorderBeam: () => BorderBeam,
    Breadcrumb: () => Breadcrumb,
    Button: () => Button,
    Calendar: () => Calendar2,
    Card: () => Card,
    CardContent: () => CardContent,
    CardDescription: () => CardDescription,
    CardFooter: () => CardFooter,
    CardHeader: () => CardHeader,
    CardTitle: () => CardTitle,
    Carousel: () => Carousel,
    CharReveal: () => CharReveal,
    Checkbox: () => Checkbox,
    CircularProgress: () => CircularProgress,
    Combobox: () => Combobox,
    CommandMenu: () => CommandMenu,
    Confetti: () => Confetti,
    CopyCommand: () => CopyCommand,
    DatePicker: () => DatePicker,
    Dialog: () => Dialog2,
    DialogButton: () => DialogButton,
    Divider: () => Divider,
    Dock: () => Dock,
    DockIcon: () => DockIcon,
    DotPattern: () => DotPattern,
    Dropdown: () => Dropdown2,
    DropdownItem: () => DropdownItem,
    DropdownLabel: () => DropdownLabel,
    DropdownSeparator: () => DropdownSeparator,
    EmptyState: () => EmptyState,
    ErrorState: () => ErrorState,
    ExpandableCard: () => ExpandableCard,
    FileTree: () => FileTree,
    FlipCard: () => FlipCard,
    FlipWords: () => FlipWords,
    FlipWords3D: () => FlipWords3D,
    Form: () => Form,
    FormDescription: () => FormDescription,
    FormError: () => FormError,
    FormField: () => FormField,
    FormLabel: () => FormLabel,
    GlassCard: () => GlassCard,
    Globe: () => Globe,
    GlowingParticles: () => GlowingParticles,
    GlowingText: () => GlowingText,
    GradientText: () => GradientText,
    GridPattern: () => GridPattern,
    HoverCard: () => HoverCard,
    HoverCardContent: () => HoverCardContent,
    IPhoneMockup: () => IPhoneMockup,
    Input: () => Input,
    InputOTP: () => InputOTP,
    InputOTPGroup: () => InputOTPGroup,
    InputOTPSeparator: () => InputOTPSeparator,
    InputOTPSlot: () => InputOTPSlot,
    Kbd: () => Kbd,
    MacBookMockup: () => MacBookMockup,
    MagicCard: () => MagicCard,
    Marquee: () => Marquee,
    Meteors: () => Meteors,
    Modal: () => Modal,
    ModalBody: () => ModalBody,
    ModalFooter: () => ModalFooter,
    ModalHeader: () => ModalHeader,
    ModalTitle: () => ModalTitle,
    Navbar: () => Navbar,
    NeonButton: () => NeonButton,
    NoData: () => NoData,
    NoSearchResults: () => NoSearchResults,
    NumberField: () => NumberField,
    NumberTicker: () => NumberTicker,
    Pagination: () => Pagination,
    Particles: () => Particles,
    Popover: () => Popover,
    Progress: () => Progress,
    Radio: () => Radio,
    RadioGroup: () => RadioGroup,
    ResizableHandle: () => ResizableHandle,
    ResizablePanel: () => ResizablePanel,
    ResizablePanelGroup: () => ResizablePanelGroup,
    Ripple: () => Ripple,
    RippleButton: () => RippleButton,
    SafariMockup: () => SafariMockup,
    ScrollAnimation: () => ScrollAnimation,
    SearchField: () => SearchField,
    SegmentedControl: () => SegmentedControl,
    Select: () => Select2,
    Sheet: () => Sheet,
    SheetClose: () => SheetClose,
    SheetContent: () => SheetContent,
    SheetDescription: () => SheetDescription,
    SheetFooter: () => SheetFooter,
    SheetHeader: () => SheetHeader,
    SheetOverlay: () => SheetOverlay,
    SheetPortal: () => SheetPortal,
    SheetTitle: () => SheetTitle,
    SheetTrigger: () => SheetTrigger,
    ShinyText: () => ShinyText,
    Shortcut: () => Shortcut,
    Skeleton: () => Skeleton,
    Slider: () => Slider2,
    Spinner: () => Spinner,
    SpotlightCard: () => SpotlightCard,
    SpringButton: () => SpringButton,
    StatusBadge: () => StatusBadge,
    StatusDot: () => StatusDot,
    Switch: () => Switch,
    Table: () => Table,
    TableBody: () => TableBody,
    TableCaption: () => TableCaption,
    TableCell: () => TableCell,
    TableFooter: () => TableFooter,
    TableHead: () => TableHead,
    TableHeader: () => TableHeader,
    TableRow: () => TableRow,
    Tabs: () => Tabs,
    TabsContent: () => TabsContent,
    TabsList: () => TabsList,
    TabsTrigger: () => TabsTrigger,
    Tag: () => Tag,
    TagGroup: () => TagGroup,
    TerminalLine: () => TerminalLine,
    TerminalMockup: () => TerminalMockup,
    TextReveal: () => TextReveal,
    Textarea: () => Textarea,
    TiltCard: () => TiltCard,
    ToastProvider: () => ToastProvider,
    Toggle: () => Toggle,
    ToggleGroup: () => ToggleGroup2,
    ToggleGroupItem: () => ToggleGroupItem2,
    Tooltip: () => Tooltip2,
    TooltipContent: () => TooltipContent2,
    TooltipProvider: () => TooltipProvider2,
    TooltipTrigger: () => TooltipTrigger2,
    TracingBeam: () => TracingBeam,
    TrueFocus: () => TrueFocus,
    TypingAnimation: () => TypingAnimation,
    buttonVariants: () => buttonVariants,
    cn: () => cn,
    toggleVariants: () => toggleVariants,
    useConfetti: () => useConfetti,
    useToast: () => useToast
  });

  // node_modules/clsx/dist/clsx.mjs
  function r(e2) {
    var t3, f2, n2 = "";
    if ("string" == typeof e2 || "number" == typeof e2) n2 += e2;
    else if ("object" == typeof e2) if (Array.isArray(e2)) {
      var o = e2.length;
      for (t3 = 0; t3 < o; t3++) e2[t3] && (f2 = r(e2[t3])) && (n2 && (n2 += " "), n2 += f2);
    } else for (f2 in e2) e2[f2] && (n2 && (n2 += " "), n2 += f2);
    return n2;
  }
  function clsx() {
    for (var e2, t3, f2 = 0, n2 = "", o = arguments.length; f2 < o; f2++) (e2 = arguments[f2]) && (t3 = r(e2)) && (n2 && (n2 += " "), n2 += t3);
    return n2;
  }

  // node_modules/tailwind-merge/dist/bundle-mjs.mjs
  var CLASS_PART_SEPARATOR = "-";
  var createClassGroupUtils = (config2) => {
    const classMap = createClassMap(config2);
    const {
      conflictingClassGroups,
      conflictingClassGroupModifiers
    } = config2;
    const getClassGroupId = (className) => {
      const classParts = className.split(CLASS_PART_SEPARATOR);
      if (classParts[0] === "" && classParts.length !== 1) {
        classParts.shift();
      }
      return getGroupRecursive(classParts, classMap) || getGroupIdForArbitraryProperty(className);
    };
    const getConflictingClassGroupIds = (classGroupId, hasPostfixModifier) => {
      const conflicts = conflictingClassGroups[classGroupId] || [];
      if (hasPostfixModifier && conflictingClassGroupModifiers[classGroupId]) {
        return [...conflicts, ...conflictingClassGroupModifiers[classGroupId]];
      }
      return conflicts;
    };
    return {
      getClassGroupId,
      getConflictingClassGroupIds
    };
  };
  var getGroupRecursive = (classParts, classPartObject) => {
    if (classParts.length === 0) {
      return classPartObject.classGroupId;
    }
    const currentClassPart = classParts[0];
    const nextClassPartObject = classPartObject.nextPart.get(currentClassPart);
    const classGroupFromNextClassPart = nextClassPartObject ? getGroupRecursive(classParts.slice(1), nextClassPartObject) : void 0;
    if (classGroupFromNextClassPart) {
      return classGroupFromNextClassPart;
    }
    if (classPartObject.validators.length === 0) {
      return void 0;
    }
    const classRest = classParts.join(CLASS_PART_SEPARATOR);
    return classPartObject.validators.find(({
      validator
    }) => validator(classRest))?.classGroupId;
  };
  var arbitraryPropertyRegex = /^\[(.+)\]$/;
  var getGroupIdForArbitraryProperty = (className) => {
    if (arbitraryPropertyRegex.test(className)) {
      const arbitraryPropertyClassName = arbitraryPropertyRegex.exec(className)[1];
      const property = arbitraryPropertyClassName?.substring(0, arbitraryPropertyClassName.indexOf(":"));
      if (property) {
        return "arbitrary.." + property;
      }
    }
  };
  var createClassMap = (config2) => {
    const {
      theme,
      prefix: prefix2
    } = config2;
    const classMap = {
      nextPart: /* @__PURE__ */ new Map(),
      validators: []
    };
    const prefixedClassGroupEntries = getPrefixedClassGroupEntries(Object.entries(config2.classGroups), prefix2);
    prefixedClassGroupEntries.forEach(([classGroupId, classGroup]) => {
      processClassesRecursively(classGroup, classMap, classGroupId, theme);
    });
    return classMap;
  };
  var processClassesRecursively = (classGroup, classPartObject, classGroupId, theme) => {
    classGroup.forEach((classDefinition) => {
      if (typeof classDefinition === "string") {
        const classPartObjectToEdit = classDefinition === "" ? classPartObject : getPart(classPartObject, classDefinition);
        classPartObjectToEdit.classGroupId = classGroupId;
        return;
      }
      if (typeof classDefinition === "function") {
        if (isThemeGetter(classDefinition)) {
          processClassesRecursively(classDefinition(theme), classPartObject, classGroupId, theme);
          return;
        }
        classPartObject.validators.push({
          validator: classDefinition,
          classGroupId
        });
        return;
      }
      Object.entries(classDefinition).forEach(([key, classGroup2]) => {
        processClassesRecursively(classGroup2, getPart(classPartObject, key), classGroupId, theme);
      });
    });
  };
  var getPart = (classPartObject, path) => {
    let currentClassPartObject = classPartObject;
    path.split(CLASS_PART_SEPARATOR).forEach((pathPart) => {
      if (!currentClassPartObject.nextPart.has(pathPart)) {
        currentClassPartObject.nextPart.set(pathPart, {
          nextPart: /* @__PURE__ */ new Map(),
          validators: []
        });
      }
      currentClassPartObject = currentClassPartObject.nextPart.get(pathPart);
    });
    return currentClassPartObject;
  };
  var isThemeGetter = (func) => func.isThemeGetter;
  var getPrefixedClassGroupEntries = (classGroupEntries, prefix2) => {
    if (!prefix2) {
      return classGroupEntries;
    }
    return classGroupEntries.map(([classGroupId, classGroup]) => {
      const prefixedClassGroup = classGroup.map((classDefinition) => {
        if (typeof classDefinition === "string") {
          return prefix2 + classDefinition;
        }
        if (typeof classDefinition === "object") {
          return Object.fromEntries(Object.entries(classDefinition).map(([key, value]) => [prefix2 + key, value]));
        }
        return classDefinition;
      });
      return [classGroupId, prefixedClassGroup];
    });
  };
  var createLruCache = (maxCacheSize) => {
    if (maxCacheSize < 1) {
      return {
        get: () => void 0,
        set: () => {
        }
      };
    }
    let cacheSize = 0;
    let cache = /* @__PURE__ */ new Map();
    let previousCache = /* @__PURE__ */ new Map();
    const update3 = (key, value) => {
      cache.set(key, value);
      cacheSize++;
      if (cacheSize > maxCacheSize) {
        cacheSize = 0;
        previousCache = cache;
        cache = /* @__PURE__ */ new Map();
      }
    };
    return {
      get(key) {
        let value = cache.get(key);
        if (value !== void 0) {
          return value;
        }
        if ((value = previousCache.get(key)) !== void 0) {
          update3(key, value);
          return value;
        }
      },
      set(key, value) {
        if (cache.has(key)) {
          cache.set(key, value);
        } else {
          update3(key, value);
        }
      }
    };
  };
  var IMPORTANT_MODIFIER = "!";
  var createParseClassName = (config2) => {
    const {
      separator,
      experimentalParseClassName
    } = config2;
    const isSeparatorSingleCharacter = separator.length === 1;
    const firstSeparatorCharacter = separator[0];
    const separatorLength = separator.length;
    const parseClassName = (className) => {
      const modifiers = [];
      let bracketDepth = 0;
      let modifierStart = 0;
      let postfixModifierPosition;
      for (let index2 = 0; index2 < className.length; index2++) {
        let currentCharacter = className[index2];
        if (bracketDepth === 0) {
          if (currentCharacter === firstSeparatorCharacter && (isSeparatorSingleCharacter || className.slice(index2, index2 + separatorLength) === separator)) {
            modifiers.push(className.slice(modifierStart, index2));
            modifierStart = index2 + separatorLength;
            continue;
          }
          if (currentCharacter === "/") {
            postfixModifierPosition = index2;
            continue;
          }
        }
        if (currentCharacter === "[") {
          bracketDepth++;
        } else if (currentCharacter === "]") {
          bracketDepth--;
        }
      }
      const baseClassNameWithImportantModifier = modifiers.length === 0 ? className : className.substring(modifierStart);
      const hasImportantModifier = baseClassNameWithImportantModifier.startsWith(IMPORTANT_MODIFIER);
      const baseClassName = hasImportantModifier ? baseClassNameWithImportantModifier.substring(1) : baseClassNameWithImportantModifier;
      const maybePostfixModifierPosition = postfixModifierPosition && postfixModifierPosition > modifierStart ? postfixModifierPosition - modifierStart : void 0;
      return {
        modifiers,
        hasImportantModifier,
        baseClassName,
        maybePostfixModifierPosition
      };
    };
    if (experimentalParseClassName) {
      return (className) => experimentalParseClassName({
        className,
        parseClassName
      });
    }
    return parseClassName;
  };
  var sortModifiers = (modifiers) => {
    if (modifiers.length <= 1) {
      return modifiers;
    }
    const sortedModifiers = [];
    let unsortedModifiers = [];
    modifiers.forEach((modifier) => {
      const isArbitraryVariant = modifier[0] === "[";
      if (isArbitraryVariant) {
        sortedModifiers.push(...unsortedModifiers.sort(), modifier);
        unsortedModifiers = [];
      } else {
        unsortedModifiers.push(modifier);
      }
    });
    sortedModifiers.push(...unsortedModifiers.sort());
    return sortedModifiers;
  };
  var createConfigUtils = (config2) => ({
    cache: createLruCache(config2.cacheSize),
    parseClassName: createParseClassName(config2),
    ...createClassGroupUtils(config2)
  });
  var SPLIT_CLASSES_REGEX = /\s+/;
  var mergeClassList = (classList, configUtils) => {
    const {
      parseClassName,
      getClassGroupId,
      getConflictingClassGroupIds
    } = configUtils;
    const classGroupsInConflict = [];
    const classNames = classList.trim().split(SPLIT_CLASSES_REGEX);
    let result = "";
    for (let index2 = classNames.length - 1; index2 >= 0; index2 -= 1) {
      const originalClassName = classNames[index2];
      const {
        modifiers,
        hasImportantModifier,
        baseClassName,
        maybePostfixModifierPosition
      } = parseClassName(originalClassName);
      let hasPostfixModifier = Boolean(maybePostfixModifierPosition);
      let classGroupId = getClassGroupId(hasPostfixModifier ? baseClassName.substring(0, maybePostfixModifierPosition) : baseClassName);
      if (!classGroupId) {
        if (!hasPostfixModifier) {
          result = originalClassName + (result.length > 0 ? " " + result : result);
          continue;
        }
        classGroupId = getClassGroupId(baseClassName);
        if (!classGroupId) {
          result = originalClassName + (result.length > 0 ? " " + result : result);
          continue;
        }
        hasPostfixModifier = false;
      }
      const variantModifier = sortModifiers(modifiers).join(":");
      const modifierId = hasImportantModifier ? variantModifier + IMPORTANT_MODIFIER : variantModifier;
      const classId = modifierId + classGroupId;
      if (classGroupsInConflict.includes(classId)) {
        continue;
      }
      classGroupsInConflict.push(classId);
      const conflictGroups = getConflictingClassGroupIds(classGroupId, hasPostfixModifier);
      for (let i3 = 0; i3 < conflictGroups.length; ++i3) {
        const group = conflictGroups[i3];
        classGroupsInConflict.push(modifierId + group);
      }
      result = originalClassName + (result.length > 0 ? " " + result : result);
    }
    return result;
  };
  function twJoin() {
    let index2 = 0;
    let argument;
    let resolvedValue;
    let string = "";
    while (index2 < arguments.length) {
      if (argument = arguments[index2++]) {
        if (resolvedValue = toValue(argument)) {
          string && (string += " ");
          string += resolvedValue;
        }
      }
    }
    return string;
  }
  var toValue = (mix2) => {
    if (typeof mix2 === "string") {
      return mix2;
    }
    let resolvedValue;
    let string = "";
    for (let k5 = 0; k5 < mix2.length; k5++) {
      if (mix2[k5]) {
        if (resolvedValue = toValue(mix2[k5])) {
          string && (string += " ");
          string += resolvedValue;
        }
      }
    }
    return string;
  };
  function createTailwindMerge(createConfigFirst, ...createConfigRest) {
    let configUtils;
    let cacheGet;
    let cacheSet;
    let functionToCall = initTailwindMerge;
    function initTailwindMerge(classList) {
      const config2 = createConfigRest.reduce((previousConfig, createConfigCurrent) => createConfigCurrent(previousConfig), createConfigFirst());
      configUtils = createConfigUtils(config2);
      cacheGet = configUtils.cache.get;
      cacheSet = configUtils.cache.set;
      functionToCall = tailwindMerge;
      return tailwindMerge(classList);
    }
    function tailwindMerge(classList) {
      const cachedResult = cacheGet(classList);
      if (cachedResult) {
        return cachedResult;
      }
      const result = mergeClassList(classList, configUtils);
      cacheSet(classList, result);
      return result;
    }
    return function callTailwindMerge() {
      return functionToCall(twJoin.apply(null, arguments));
    };
  }
  var fromTheme = (key) => {
    const themeGetter = (theme) => theme[key] || [];
    themeGetter.isThemeGetter = true;
    return themeGetter;
  };
  var arbitraryValueRegex = /^\[(?:([a-z-]+):)?(.+)\]$/i;
  var fractionRegex = /^\d+\/\d+$/;
  var stringLengths = /* @__PURE__ */ new Set(["px", "full", "screen"]);
  var tshirtUnitRegex = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/;
  var lengthUnitRegex = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/;
  var colorFunctionRegex = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/;
  var shadowRegex = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/;
  var imageRegex = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/;
  var isLength = (value) => isNumber(value) || stringLengths.has(value) || fractionRegex.test(value);
  var isArbitraryLength = (value) => getIsArbitraryValue(value, "length", isLengthOnly);
  var isNumber = (value) => Boolean(value) && !Number.isNaN(Number(value));
  var isArbitraryNumber = (value) => getIsArbitraryValue(value, "number", isNumber);
  var isInteger = (value) => Boolean(value) && Number.isInteger(Number(value));
  var isPercent = (value) => value.endsWith("%") && isNumber(value.slice(0, -1));
  var isArbitraryValue = (value) => arbitraryValueRegex.test(value);
  var isTshirtSize = (value) => tshirtUnitRegex.test(value);
  var sizeLabels = /* @__PURE__ */ new Set(["length", "size", "percentage"]);
  var isArbitrarySize = (value) => getIsArbitraryValue(value, sizeLabels, isNever);
  var isArbitraryPosition = (value) => getIsArbitraryValue(value, "position", isNever);
  var imageLabels = /* @__PURE__ */ new Set(["image", "url"]);
  var isArbitraryImage = (value) => getIsArbitraryValue(value, imageLabels, isImage);
  var isArbitraryShadow = (value) => getIsArbitraryValue(value, "", isShadow);
  var isAny = () => true;
  var getIsArbitraryValue = (value, label, testValue) => {
    const result = arbitraryValueRegex.exec(value);
    if (result) {
      if (result[1]) {
        return typeof label === "string" ? result[1] === label : label.has(result[1]);
      }
      return testValue(result[2]);
    }
    return false;
  };
  var isLengthOnly = (value) => (
    // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
    // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
    // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
    lengthUnitRegex.test(value) && !colorFunctionRegex.test(value)
  );
  var isNever = () => false;
  var isShadow = (value) => shadowRegex.test(value);
  var isImage = (value) => imageRegex.test(value);
  var getDefaultConfig = () => {
    const colors3 = fromTheme("colors");
    const spacing = fromTheme("spacing");
    const blur = fromTheme("blur");
    const brightness = fromTheme("brightness");
    const borderColor = fromTheme("borderColor");
    const borderRadius = fromTheme("borderRadius");
    const borderSpacing = fromTheme("borderSpacing");
    const borderWidth = fromTheme("borderWidth");
    const contrast = fromTheme("contrast");
    const grayscale = fromTheme("grayscale");
    const hueRotate = fromTheme("hueRotate");
    const invert = fromTheme("invert");
    const gap = fromTheme("gap");
    const gradientColorStops = fromTheme("gradientColorStops");
    const gradientColorStopPositions = fromTheme("gradientColorStopPositions");
    const inset = fromTheme("inset");
    const margin = fromTheme("margin");
    const opacity = fromTheme("opacity");
    const padding = fromTheme("padding");
    const saturate = fromTheme("saturate");
    const scale2 = fromTheme("scale");
    const sepia = fromTheme("sepia");
    const skew = fromTheme("skew");
    const space = fromTheme("space");
    const translate = fromTheme("translate");
    const getOverscroll = () => ["auto", "contain", "none"];
    const getOverflow = () => ["auto", "hidden", "clip", "visible", "scroll"];
    const getSpacingWithAutoAndArbitrary = () => ["auto", isArbitraryValue, spacing];
    const getSpacingWithArbitrary = () => [isArbitraryValue, spacing];
    const getLengthWithEmptyAndArbitrary = () => ["", isLength, isArbitraryLength];
    const getNumberWithAutoAndArbitrary = () => ["auto", isNumber, isArbitraryValue];
    const getPositions = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"];
    const getLineStyles = () => ["solid", "dashed", "dotted", "double", "none"];
    const getBlendModes = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"];
    const getAlign = () => ["start", "end", "center", "between", "around", "evenly", "stretch"];
    const getZeroAndEmpty = () => ["", "0", isArbitraryValue];
    const getBreaks = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"];
    const getNumberAndArbitrary = () => [isNumber, isArbitraryValue];
    return {
      cacheSize: 500,
      separator: ":",
      theme: {
        colors: [isAny],
        spacing: [isLength, isArbitraryLength],
        blur: ["none", "", isTshirtSize, isArbitraryValue],
        brightness: getNumberAndArbitrary(),
        borderColor: [colors3],
        borderRadius: ["none", "", "full", isTshirtSize, isArbitraryValue],
        borderSpacing: getSpacingWithArbitrary(),
        borderWidth: getLengthWithEmptyAndArbitrary(),
        contrast: getNumberAndArbitrary(),
        grayscale: getZeroAndEmpty(),
        hueRotate: getNumberAndArbitrary(),
        invert: getZeroAndEmpty(),
        gap: getSpacingWithArbitrary(),
        gradientColorStops: [colors3],
        gradientColorStopPositions: [isPercent, isArbitraryLength],
        inset: getSpacingWithAutoAndArbitrary(),
        margin: getSpacingWithAutoAndArbitrary(),
        opacity: getNumberAndArbitrary(),
        padding: getSpacingWithArbitrary(),
        saturate: getNumberAndArbitrary(),
        scale: getNumberAndArbitrary(),
        sepia: getZeroAndEmpty(),
        skew: getNumberAndArbitrary(),
        space: getSpacingWithArbitrary(),
        translate: getSpacingWithArbitrary()
      },
      classGroups: {
        // Layout
        /**
         * Aspect Ratio
         * @see https://tailwindcss.com/docs/aspect-ratio
         */
        aspect: [{
          aspect: ["auto", "square", "video", isArbitraryValue]
        }],
        /**
         * Container
         * @see https://tailwindcss.com/docs/container
         */
        container: ["container"],
        /**
         * Columns
         * @see https://tailwindcss.com/docs/columns
         */
        columns: [{
          columns: [isTshirtSize]
        }],
        /**
         * Break After
         * @see https://tailwindcss.com/docs/break-after
         */
        "break-after": [{
          "break-after": getBreaks()
        }],
        /**
         * Break Before
         * @see https://tailwindcss.com/docs/break-before
         */
        "break-before": [{
          "break-before": getBreaks()
        }],
        /**
         * Break Inside
         * @see https://tailwindcss.com/docs/break-inside
         */
        "break-inside": [{
          "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
        }],
        /**
         * Box Decoration Break
         * @see https://tailwindcss.com/docs/box-decoration-break
         */
        "box-decoration": [{
          "box-decoration": ["slice", "clone"]
        }],
        /**
         * Box Sizing
         * @see https://tailwindcss.com/docs/box-sizing
         */
        box: [{
          box: ["border", "content"]
        }],
        /**
         * Display
         * @see https://tailwindcss.com/docs/display
         */
        display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
        /**
         * Floats
         * @see https://tailwindcss.com/docs/float
         */
        float: [{
          float: ["right", "left", "none", "start", "end"]
        }],
        /**
         * Clear
         * @see https://tailwindcss.com/docs/clear
         */
        clear: [{
          clear: ["left", "right", "both", "none", "start", "end"]
        }],
        /**
         * Isolation
         * @see https://tailwindcss.com/docs/isolation
         */
        isolation: ["isolate", "isolation-auto"],
        /**
         * Object Fit
         * @see https://tailwindcss.com/docs/object-fit
         */
        "object-fit": [{
          object: ["contain", "cover", "fill", "none", "scale-down"]
        }],
        /**
         * Object Position
         * @see https://tailwindcss.com/docs/object-position
         */
        "object-position": [{
          object: [...getPositions(), isArbitraryValue]
        }],
        /**
         * Overflow
         * @see https://tailwindcss.com/docs/overflow
         */
        overflow: [{
          overflow: getOverflow()
        }],
        /**
         * Overflow X
         * @see https://tailwindcss.com/docs/overflow
         */
        "overflow-x": [{
          "overflow-x": getOverflow()
        }],
        /**
         * Overflow Y
         * @see https://tailwindcss.com/docs/overflow
         */
        "overflow-y": [{
          "overflow-y": getOverflow()
        }],
        /**
         * Overscroll Behavior
         * @see https://tailwindcss.com/docs/overscroll-behavior
         */
        overscroll: [{
          overscroll: getOverscroll()
        }],
        /**
         * Overscroll Behavior X
         * @see https://tailwindcss.com/docs/overscroll-behavior
         */
        "overscroll-x": [{
          "overscroll-x": getOverscroll()
        }],
        /**
         * Overscroll Behavior Y
         * @see https://tailwindcss.com/docs/overscroll-behavior
         */
        "overscroll-y": [{
          "overscroll-y": getOverscroll()
        }],
        /**
         * Position
         * @see https://tailwindcss.com/docs/position
         */
        position: ["static", "fixed", "absolute", "relative", "sticky"],
        /**
         * Top / Right / Bottom / Left
         * @see https://tailwindcss.com/docs/top-right-bottom-left
         */
        inset: [{
          inset: [inset]
        }],
        /**
         * Right / Left
         * @see https://tailwindcss.com/docs/top-right-bottom-left
         */
        "inset-x": [{
          "inset-x": [inset]
        }],
        /**
         * Top / Bottom
         * @see https://tailwindcss.com/docs/top-right-bottom-left
         */
        "inset-y": [{
          "inset-y": [inset]
        }],
        /**
         * Start
         * @see https://tailwindcss.com/docs/top-right-bottom-left
         */
        start: [{
          start: [inset]
        }],
        /**
         * End
         * @see https://tailwindcss.com/docs/top-right-bottom-left
         */
        end: [{
          end: [inset]
        }],
        /**
         * Top
         * @see https://tailwindcss.com/docs/top-right-bottom-left
         */
        top: [{
          top: [inset]
        }],
        /**
         * Right
         * @see https://tailwindcss.com/docs/top-right-bottom-left
         */
        right: [{
          right: [inset]
        }],
        /**
         * Bottom
         * @see https://tailwindcss.com/docs/top-right-bottom-left
         */
        bottom: [{
          bottom: [inset]
        }],
        /**
         * Left
         * @see https://tailwindcss.com/docs/top-right-bottom-left
         */
        left: [{
          left: [inset]
        }],
        /**
         * Visibility
         * @see https://tailwindcss.com/docs/visibility
         */
        visibility: ["visible", "invisible", "collapse"],
        /**
         * Z-Index
         * @see https://tailwindcss.com/docs/z-index
         */
        z: [{
          z: ["auto", isInteger, isArbitraryValue]
        }],
        // Flexbox and Grid
        /**
         * Flex Basis
         * @see https://tailwindcss.com/docs/flex-basis
         */
        basis: [{
          basis: getSpacingWithAutoAndArbitrary()
        }],
        /**
         * Flex Direction
         * @see https://tailwindcss.com/docs/flex-direction
         */
        "flex-direction": [{
          flex: ["row", "row-reverse", "col", "col-reverse"]
        }],
        /**
         * Flex Wrap
         * @see https://tailwindcss.com/docs/flex-wrap
         */
        "flex-wrap": [{
          flex: ["wrap", "wrap-reverse", "nowrap"]
        }],
        /**
         * Flex
         * @see https://tailwindcss.com/docs/flex
         */
        flex: [{
          flex: ["1", "auto", "initial", "none", isArbitraryValue]
        }],
        /**
         * Flex Grow
         * @see https://tailwindcss.com/docs/flex-grow
         */
        grow: [{
          grow: getZeroAndEmpty()
        }],
        /**
         * Flex Shrink
         * @see https://tailwindcss.com/docs/flex-shrink
         */
        shrink: [{
          shrink: getZeroAndEmpty()
        }],
        /**
         * Order
         * @see https://tailwindcss.com/docs/order
         */
        order: [{
          order: ["first", "last", "none", isInteger, isArbitraryValue]
        }],
        /**
         * Grid Template Columns
         * @see https://tailwindcss.com/docs/grid-template-columns
         */
        "grid-cols": [{
          "grid-cols": [isAny]
        }],
        /**
         * Grid Column Start / End
         * @see https://tailwindcss.com/docs/grid-column
         */
        "col-start-end": [{
          col: ["auto", {
            span: ["full", isInteger, isArbitraryValue]
          }, isArbitraryValue]
        }],
        /**
         * Grid Column Start
         * @see https://tailwindcss.com/docs/grid-column
         */
        "col-start": [{
          "col-start": getNumberWithAutoAndArbitrary()
        }],
        /**
         * Grid Column End
         * @see https://tailwindcss.com/docs/grid-column
         */
        "col-end": [{
          "col-end": getNumberWithAutoAndArbitrary()
        }],
        /**
         * Grid Template Rows
         * @see https://tailwindcss.com/docs/grid-template-rows
         */
        "grid-rows": [{
          "grid-rows": [isAny]
        }],
        /**
         * Grid Row Start / End
         * @see https://tailwindcss.com/docs/grid-row
         */
        "row-start-end": [{
          row: ["auto", {
            span: [isInteger, isArbitraryValue]
          }, isArbitraryValue]
        }],
        /**
         * Grid Row Start
         * @see https://tailwindcss.com/docs/grid-row
         */
        "row-start": [{
          "row-start": getNumberWithAutoAndArbitrary()
        }],
        /**
         * Grid Row End
         * @see https://tailwindcss.com/docs/grid-row
         */
        "row-end": [{
          "row-end": getNumberWithAutoAndArbitrary()
        }],
        /**
         * Grid Auto Flow
         * @see https://tailwindcss.com/docs/grid-auto-flow
         */
        "grid-flow": [{
          "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
        }],
        /**
         * Grid Auto Columns
         * @see https://tailwindcss.com/docs/grid-auto-columns
         */
        "auto-cols": [{
          "auto-cols": ["auto", "min", "max", "fr", isArbitraryValue]
        }],
        /**
         * Grid Auto Rows
         * @see https://tailwindcss.com/docs/grid-auto-rows
         */
        "auto-rows": [{
          "auto-rows": ["auto", "min", "max", "fr", isArbitraryValue]
        }],
        /**
         * Gap
         * @see https://tailwindcss.com/docs/gap
         */
        gap: [{
          gap: [gap]
        }],
        /**
         * Gap X
         * @see https://tailwindcss.com/docs/gap
         */
        "gap-x": [{
          "gap-x": [gap]
        }],
        /**
         * Gap Y
         * @see https://tailwindcss.com/docs/gap
         */
        "gap-y": [{
          "gap-y": [gap]
        }],
        /**
         * Justify Content
         * @see https://tailwindcss.com/docs/justify-content
         */
        "justify-content": [{
          justify: ["normal", ...getAlign()]
        }],
        /**
         * Justify Items
         * @see https://tailwindcss.com/docs/justify-items
         */
        "justify-items": [{
          "justify-items": ["start", "end", "center", "stretch"]
        }],
        /**
         * Justify Self
         * @see https://tailwindcss.com/docs/justify-self
         */
        "justify-self": [{
          "justify-self": ["auto", "start", "end", "center", "stretch"]
        }],
        /**
         * Align Content
         * @see https://tailwindcss.com/docs/align-content
         */
        "align-content": [{
          content: ["normal", ...getAlign(), "baseline"]
        }],
        /**
         * Align Items
         * @see https://tailwindcss.com/docs/align-items
         */
        "align-items": [{
          items: ["start", "end", "center", "baseline", "stretch"]
        }],
        /**
         * Align Self
         * @see https://tailwindcss.com/docs/align-self
         */
        "align-self": [{
          self: ["auto", "start", "end", "center", "stretch", "baseline"]
        }],
        /**
         * Place Content
         * @see https://tailwindcss.com/docs/place-content
         */
        "place-content": [{
          "place-content": [...getAlign(), "baseline"]
        }],
        /**
         * Place Items
         * @see https://tailwindcss.com/docs/place-items
         */
        "place-items": [{
          "place-items": ["start", "end", "center", "baseline", "stretch"]
        }],
        /**
         * Place Self
         * @see https://tailwindcss.com/docs/place-self
         */
        "place-self": [{
          "place-self": ["auto", "start", "end", "center", "stretch"]
        }],
        // Spacing
        /**
         * Padding
         * @see https://tailwindcss.com/docs/padding
         */
        p: [{
          p: [padding]
        }],
        /**
         * Padding X
         * @see https://tailwindcss.com/docs/padding
         */
        px: [{
          px: [padding]
        }],
        /**
         * Padding Y
         * @see https://tailwindcss.com/docs/padding
         */
        py: [{
          py: [padding]
        }],
        /**
         * Padding Start
         * @see https://tailwindcss.com/docs/padding
         */
        ps: [{
          ps: [padding]
        }],
        /**
         * Padding End
         * @see https://tailwindcss.com/docs/padding
         */
        pe: [{
          pe: [padding]
        }],
        /**
         * Padding Top
         * @see https://tailwindcss.com/docs/padding
         */
        pt: [{
          pt: [padding]
        }],
        /**
         * Padding Right
         * @see https://tailwindcss.com/docs/padding
         */
        pr: [{
          pr: [padding]
        }],
        /**
         * Padding Bottom
         * @see https://tailwindcss.com/docs/padding
         */
        pb: [{
          pb: [padding]
        }],
        /**
         * Padding Left
         * @see https://tailwindcss.com/docs/padding
         */
        pl: [{
          pl: [padding]
        }],
        /**
         * Margin
         * @see https://tailwindcss.com/docs/margin
         */
        m: [{
          m: [margin]
        }],
        /**
         * Margin X
         * @see https://tailwindcss.com/docs/margin
         */
        mx: [{
          mx: [margin]
        }],
        /**
         * Margin Y
         * @see https://tailwindcss.com/docs/margin
         */
        my: [{
          my: [margin]
        }],
        /**
         * Margin Start
         * @see https://tailwindcss.com/docs/margin
         */
        ms: [{
          ms: [margin]
        }],
        /**
         * Margin End
         * @see https://tailwindcss.com/docs/margin
         */
        me: [{
          me: [margin]
        }],
        /**
         * Margin Top
         * @see https://tailwindcss.com/docs/margin
         */
        mt: [{
          mt: [margin]
        }],
        /**
         * Margin Right
         * @see https://tailwindcss.com/docs/margin
         */
        mr: [{
          mr: [margin]
        }],
        /**
         * Margin Bottom
         * @see https://tailwindcss.com/docs/margin
         */
        mb: [{
          mb: [margin]
        }],
        /**
         * Margin Left
         * @see https://tailwindcss.com/docs/margin
         */
        ml: [{
          ml: [margin]
        }],
        /**
         * Space Between X
         * @see https://tailwindcss.com/docs/space
         */
        "space-x": [{
          "space-x": [space]
        }],
        /**
         * Space Between X Reverse
         * @see https://tailwindcss.com/docs/space
         */
        "space-x-reverse": ["space-x-reverse"],
        /**
         * Space Between Y
         * @see https://tailwindcss.com/docs/space
         */
        "space-y": [{
          "space-y": [space]
        }],
        /**
         * Space Between Y Reverse
         * @see https://tailwindcss.com/docs/space
         */
        "space-y-reverse": ["space-y-reverse"],
        // Sizing
        /**
         * Width
         * @see https://tailwindcss.com/docs/width
         */
        w: [{
          w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", isArbitraryValue, spacing]
        }],
        /**
         * Min-Width
         * @see https://tailwindcss.com/docs/min-width
         */
        "min-w": [{
          "min-w": [isArbitraryValue, spacing, "min", "max", "fit"]
        }],
        /**
         * Max-Width
         * @see https://tailwindcss.com/docs/max-width
         */
        "max-w": [{
          "max-w": [isArbitraryValue, spacing, "none", "full", "min", "max", "fit", "prose", {
            screen: [isTshirtSize]
          }, isTshirtSize]
        }],
        /**
         * Height
         * @see https://tailwindcss.com/docs/height
         */
        h: [{
          h: [isArbitraryValue, spacing, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
        }],
        /**
         * Min-Height
         * @see https://tailwindcss.com/docs/min-height
         */
        "min-h": [{
          "min-h": [isArbitraryValue, spacing, "min", "max", "fit", "svh", "lvh", "dvh"]
        }],
        /**
         * Max-Height
         * @see https://tailwindcss.com/docs/max-height
         */
        "max-h": [{
          "max-h": [isArbitraryValue, spacing, "min", "max", "fit", "svh", "lvh", "dvh"]
        }],
        /**
         * Size
         * @see https://tailwindcss.com/docs/size
         */
        size: [{
          size: [isArbitraryValue, spacing, "auto", "min", "max", "fit"]
        }],
        // Typography
        /**
         * Font Size
         * @see https://tailwindcss.com/docs/font-size
         */
        "font-size": [{
          text: ["base", isTshirtSize, isArbitraryLength]
        }],
        /**
         * Font Smoothing
         * @see https://tailwindcss.com/docs/font-smoothing
         */
        "font-smoothing": ["antialiased", "subpixel-antialiased"],
        /**
         * Font Style
         * @see https://tailwindcss.com/docs/font-style
         */
        "font-style": ["italic", "not-italic"],
        /**
         * Font Weight
         * @see https://tailwindcss.com/docs/font-weight
         */
        "font-weight": [{
          font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", isArbitraryNumber]
        }],
        /**
         * Font Family
         * @see https://tailwindcss.com/docs/font-family
         */
        "font-family": [{
          font: [isAny]
        }],
        /**
         * Font Variant Numeric
         * @see https://tailwindcss.com/docs/font-variant-numeric
         */
        "fvn-normal": ["normal-nums"],
        /**
         * Font Variant Numeric
         * @see https://tailwindcss.com/docs/font-variant-numeric
         */
        "fvn-ordinal": ["ordinal"],
        /**
         * Font Variant Numeric
         * @see https://tailwindcss.com/docs/font-variant-numeric
         */
        "fvn-slashed-zero": ["slashed-zero"],
        /**
         * Font Variant Numeric
         * @see https://tailwindcss.com/docs/font-variant-numeric
         */
        "fvn-figure": ["lining-nums", "oldstyle-nums"],
        /**
         * Font Variant Numeric
         * @see https://tailwindcss.com/docs/font-variant-numeric
         */
        "fvn-spacing": ["proportional-nums", "tabular-nums"],
        /**
         * Font Variant Numeric
         * @see https://tailwindcss.com/docs/font-variant-numeric
         */
        "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
        /**
         * Letter Spacing
         * @see https://tailwindcss.com/docs/letter-spacing
         */
        tracking: [{
          tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", isArbitraryValue]
        }],
        /**
         * Line Clamp
         * @see https://tailwindcss.com/docs/line-clamp
         */
        "line-clamp": [{
          "line-clamp": ["none", isNumber, isArbitraryNumber]
        }],
        /**
         * Line Height
         * @see https://tailwindcss.com/docs/line-height
         */
        leading: [{
          leading: ["none", "tight", "snug", "normal", "relaxed", "loose", isLength, isArbitraryValue]
        }],
        /**
         * List Style Image
         * @see https://tailwindcss.com/docs/list-style-image
         */
        "list-image": [{
          "list-image": ["none", isArbitraryValue]
        }],
        /**
         * List Style Type
         * @see https://tailwindcss.com/docs/list-style-type
         */
        "list-style-type": [{
          list: ["none", "disc", "decimal", isArbitraryValue]
        }],
        /**
         * List Style Position
         * @see https://tailwindcss.com/docs/list-style-position
         */
        "list-style-position": [{
          list: ["inside", "outside"]
        }],
        /**
         * Placeholder Color
         * @deprecated since Tailwind CSS v3.0.0
         * @see https://tailwindcss.com/docs/placeholder-color
         */
        "placeholder-color": [{
          placeholder: [colors3]
        }],
        /**
         * Placeholder Opacity
         * @see https://tailwindcss.com/docs/placeholder-opacity
         */
        "placeholder-opacity": [{
          "placeholder-opacity": [opacity]
        }],
        /**
         * Text Alignment
         * @see https://tailwindcss.com/docs/text-align
         */
        "text-alignment": [{
          text: ["left", "center", "right", "justify", "start", "end"]
        }],
        /**
         * Text Color
         * @see https://tailwindcss.com/docs/text-color
         */
        "text-color": [{
          text: [colors3]
        }],
        /**
         * Text Opacity
         * @see https://tailwindcss.com/docs/text-opacity
         */
        "text-opacity": [{
          "text-opacity": [opacity]
        }],
        /**
         * Text Decoration
         * @see https://tailwindcss.com/docs/text-decoration
         */
        "text-decoration": ["underline", "overline", "line-through", "no-underline"],
        /**
         * Text Decoration Style
         * @see https://tailwindcss.com/docs/text-decoration-style
         */
        "text-decoration-style": [{
          decoration: [...getLineStyles(), "wavy"]
        }],
        /**
         * Text Decoration Thickness
         * @see https://tailwindcss.com/docs/text-decoration-thickness
         */
        "text-decoration-thickness": [{
          decoration: ["auto", "from-font", isLength, isArbitraryLength]
        }],
        /**
         * Text Underline Offset
         * @see https://tailwindcss.com/docs/text-underline-offset
         */
        "underline-offset": [{
          "underline-offset": ["auto", isLength, isArbitraryValue]
        }],
        /**
         * Text Decoration Color
         * @see https://tailwindcss.com/docs/text-decoration-color
         */
        "text-decoration-color": [{
          decoration: [colors3]
        }],
        /**
         * Text Transform
         * @see https://tailwindcss.com/docs/text-transform
         */
        "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
        /**
         * Text Overflow
         * @see https://tailwindcss.com/docs/text-overflow
         */
        "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
        /**
         * Text Wrap
         * @see https://tailwindcss.com/docs/text-wrap
         */
        "text-wrap": [{
          text: ["wrap", "nowrap", "balance", "pretty"]
        }],
        /**
         * Text Indent
         * @see https://tailwindcss.com/docs/text-indent
         */
        indent: [{
          indent: getSpacingWithArbitrary()
        }],
        /**
         * Vertical Alignment
         * @see https://tailwindcss.com/docs/vertical-align
         */
        "vertical-align": [{
          align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", isArbitraryValue]
        }],
        /**
         * Whitespace
         * @see https://tailwindcss.com/docs/whitespace
         */
        whitespace: [{
          whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
        }],
        /**
         * Word Break
         * @see https://tailwindcss.com/docs/word-break
         */
        break: [{
          break: ["normal", "words", "all", "keep"]
        }],
        /**
         * Hyphens
         * @see https://tailwindcss.com/docs/hyphens
         */
        hyphens: [{
          hyphens: ["none", "manual", "auto"]
        }],
        /**
         * Content
         * @see https://tailwindcss.com/docs/content
         */
        content: [{
          content: ["none", isArbitraryValue]
        }],
        // Backgrounds
        /**
         * Background Attachment
         * @see https://tailwindcss.com/docs/background-attachment
         */
        "bg-attachment": [{
          bg: ["fixed", "local", "scroll"]
        }],
        /**
         * Background Clip
         * @see https://tailwindcss.com/docs/background-clip
         */
        "bg-clip": [{
          "bg-clip": ["border", "padding", "content", "text"]
        }],
        /**
         * Background Opacity
         * @deprecated since Tailwind CSS v3.0.0
         * @see https://tailwindcss.com/docs/background-opacity
         */
        "bg-opacity": [{
          "bg-opacity": [opacity]
        }],
        /**
         * Background Origin
         * @see https://tailwindcss.com/docs/background-origin
         */
        "bg-origin": [{
          "bg-origin": ["border", "padding", "content"]
        }],
        /**
         * Background Position
         * @see https://tailwindcss.com/docs/background-position
         */
        "bg-position": [{
          bg: [...getPositions(), isArbitraryPosition]
        }],
        /**
         * Background Repeat
         * @see https://tailwindcss.com/docs/background-repeat
         */
        "bg-repeat": [{
          bg: ["no-repeat", {
            repeat: ["", "x", "y", "round", "space"]
          }]
        }],
        /**
         * Background Size
         * @see https://tailwindcss.com/docs/background-size
         */
        "bg-size": [{
          bg: ["auto", "cover", "contain", isArbitrarySize]
        }],
        /**
         * Background Image
         * @see https://tailwindcss.com/docs/background-image
         */
        "bg-image": [{
          bg: ["none", {
            "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
          }, isArbitraryImage]
        }],
        /**
         * Background Color
         * @see https://tailwindcss.com/docs/background-color
         */
        "bg-color": [{
          bg: [colors3]
        }],
        /**
         * Gradient Color Stops From Position
         * @see https://tailwindcss.com/docs/gradient-color-stops
         */
        "gradient-from-pos": [{
          from: [gradientColorStopPositions]
        }],
        /**
         * Gradient Color Stops Via Position
         * @see https://tailwindcss.com/docs/gradient-color-stops
         */
        "gradient-via-pos": [{
          via: [gradientColorStopPositions]
        }],
        /**
         * Gradient Color Stops To Position
         * @see https://tailwindcss.com/docs/gradient-color-stops
         */
        "gradient-to-pos": [{
          to: [gradientColorStopPositions]
        }],
        /**
         * Gradient Color Stops From
         * @see https://tailwindcss.com/docs/gradient-color-stops
         */
        "gradient-from": [{
          from: [gradientColorStops]
        }],
        /**
         * Gradient Color Stops Via
         * @see https://tailwindcss.com/docs/gradient-color-stops
         */
        "gradient-via": [{
          via: [gradientColorStops]
        }],
        /**
         * Gradient Color Stops To
         * @see https://tailwindcss.com/docs/gradient-color-stops
         */
        "gradient-to": [{
          to: [gradientColorStops]
        }],
        // Borders
        /**
         * Border Radius
         * @see https://tailwindcss.com/docs/border-radius
         */
        rounded: [{
          rounded: [borderRadius]
        }],
        /**
         * Border Radius Start
         * @see https://tailwindcss.com/docs/border-radius
         */
        "rounded-s": [{
          "rounded-s": [borderRadius]
        }],
        /**
         * Border Radius End
         * @see https://tailwindcss.com/docs/border-radius
         */
        "rounded-e": [{
          "rounded-e": [borderRadius]
        }],
        /**
         * Border Radius Top
         * @see https://tailwindcss.com/docs/border-radius
         */
        "rounded-t": [{
          "rounded-t": [borderRadius]
        }],
        /**
         * Border Radius Right
         * @see https://tailwindcss.com/docs/border-radius
         */
        "rounded-r": [{
          "rounded-r": [borderRadius]
        }],
        /**
         * Border Radius Bottom
         * @see https://tailwindcss.com/docs/border-radius
         */
        "rounded-b": [{
          "rounded-b": [borderRadius]
        }],
        /**
         * Border Radius Left
         * @see https://tailwindcss.com/docs/border-radius
         */
        "rounded-l": [{
          "rounded-l": [borderRadius]
        }],
        /**
         * Border Radius Start Start
         * @see https://tailwindcss.com/docs/border-radius
         */
        "rounded-ss": [{
          "rounded-ss": [borderRadius]
        }],
        /**
         * Border Radius Start End
         * @see https://tailwindcss.com/docs/border-radius
         */
        "rounded-se": [{
          "rounded-se": [borderRadius]
        }],
        /**
         * Border Radius End End
         * @see https://tailwindcss.com/docs/border-radius
         */
        "rounded-ee": [{
          "rounded-ee": [borderRadius]
        }],
        /**
         * Border Radius End Start
         * @see https://tailwindcss.com/docs/border-radius
         */
        "rounded-es": [{
          "rounded-es": [borderRadius]
        }],
        /**
         * Border Radius Top Left
         * @see https://tailwindcss.com/docs/border-radius
         */
        "rounded-tl": [{
          "rounded-tl": [borderRadius]
        }],
        /**
         * Border Radius Top Right
         * @see https://tailwindcss.com/docs/border-radius
         */
        "rounded-tr": [{
          "rounded-tr": [borderRadius]
        }],
        /**
         * Border Radius Bottom Right
         * @see https://tailwindcss.com/docs/border-radius
         */
        "rounded-br": [{
          "rounded-br": [borderRadius]
        }],
        /**
         * Border Radius Bottom Left
         * @see https://tailwindcss.com/docs/border-radius
         */
        "rounded-bl": [{
          "rounded-bl": [borderRadius]
        }],
        /**
         * Border Width
         * @see https://tailwindcss.com/docs/border-width
         */
        "border-w": [{
          border: [borderWidth]
        }],
        /**
         * Border Width X
         * @see https://tailwindcss.com/docs/border-width
         */
        "border-w-x": [{
          "border-x": [borderWidth]
        }],
        /**
         * Border Width Y
         * @see https://tailwindcss.com/docs/border-width
         */
        "border-w-y": [{
          "border-y": [borderWidth]
        }],
        /**
         * Border Width Start
         * @see https://tailwindcss.com/docs/border-width
         */
        "border-w-s": [{
          "border-s": [borderWidth]
        }],
        /**
         * Border Width End
         * @see https://tailwindcss.com/docs/border-width
         */
        "border-w-e": [{
          "border-e": [borderWidth]
        }],
        /**
         * Border Width Top
         * @see https://tailwindcss.com/docs/border-width
         */
        "border-w-t": [{
          "border-t": [borderWidth]
        }],
        /**
         * Border Width Right
         * @see https://tailwindcss.com/docs/border-width
         */
        "border-w-r": [{
          "border-r": [borderWidth]
        }],
        /**
         * Border Width Bottom
         * @see https://tailwindcss.com/docs/border-width
         */
        "border-w-b": [{
          "border-b": [borderWidth]
        }],
        /**
         * Border Width Left
         * @see https://tailwindcss.com/docs/border-width
         */
        "border-w-l": [{
          "border-l": [borderWidth]
        }],
        /**
         * Border Opacity
         * @see https://tailwindcss.com/docs/border-opacity
         */
        "border-opacity": [{
          "border-opacity": [opacity]
        }],
        /**
         * Border Style
         * @see https://tailwindcss.com/docs/border-style
         */
        "border-style": [{
          border: [...getLineStyles(), "hidden"]
        }],
        /**
         * Divide Width X
         * @see https://tailwindcss.com/docs/divide-width
         */
        "divide-x": [{
          "divide-x": [borderWidth]
        }],
        /**
         * Divide Width X Reverse
         * @see https://tailwindcss.com/docs/divide-width
         */
        "divide-x-reverse": ["divide-x-reverse"],
        /**
         * Divide Width Y
         * @see https://tailwindcss.com/docs/divide-width
         */
        "divide-y": [{
          "divide-y": [borderWidth]
        }],
        /**
         * Divide Width Y Reverse
         * @see https://tailwindcss.com/docs/divide-width
         */
        "divide-y-reverse": ["divide-y-reverse"],
        /**
         * Divide Opacity
         * @see https://tailwindcss.com/docs/divide-opacity
         */
        "divide-opacity": [{
          "divide-opacity": [opacity]
        }],
        /**
         * Divide Style
         * @see https://tailwindcss.com/docs/divide-style
         */
        "divide-style": [{
          divide: getLineStyles()
        }],
        /**
         * Border Color
         * @see https://tailwindcss.com/docs/border-color
         */
        "border-color": [{
          border: [borderColor]
        }],
        /**
         * Border Color X
         * @see https://tailwindcss.com/docs/border-color
         */
        "border-color-x": [{
          "border-x": [borderColor]
        }],
        /**
         * Border Color Y
         * @see https://tailwindcss.com/docs/border-color
         */
        "border-color-y": [{
          "border-y": [borderColor]
        }],
        /**
         * Border Color S
         * @see https://tailwindcss.com/docs/border-color
         */
        "border-color-s": [{
          "border-s": [borderColor]
        }],
        /**
         * Border Color E
         * @see https://tailwindcss.com/docs/border-color
         */
        "border-color-e": [{
          "border-e": [borderColor]
        }],
        /**
         * Border Color Top
         * @see https://tailwindcss.com/docs/border-color
         */
        "border-color-t": [{
          "border-t": [borderColor]
        }],
        /**
         * Border Color Right
         * @see https://tailwindcss.com/docs/border-color
         */
        "border-color-r": [{
          "border-r": [borderColor]
        }],
        /**
         * Border Color Bottom
         * @see https://tailwindcss.com/docs/border-color
         */
        "border-color-b": [{
          "border-b": [borderColor]
        }],
        /**
         * Border Color Left
         * @see https://tailwindcss.com/docs/border-color
         */
        "border-color-l": [{
          "border-l": [borderColor]
        }],
        /**
         * Divide Color
         * @see https://tailwindcss.com/docs/divide-color
         */
        "divide-color": [{
          divide: [borderColor]
        }],
        /**
         * Outline Style
         * @see https://tailwindcss.com/docs/outline-style
         */
        "outline-style": [{
          outline: ["", ...getLineStyles()]
        }],
        /**
         * Outline Offset
         * @see https://tailwindcss.com/docs/outline-offset
         */
        "outline-offset": [{
          "outline-offset": [isLength, isArbitraryValue]
        }],
        /**
         * Outline Width
         * @see https://tailwindcss.com/docs/outline-width
         */
        "outline-w": [{
          outline: [isLength, isArbitraryLength]
        }],
        /**
         * Outline Color
         * @see https://tailwindcss.com/docs/outline-color
         */
        "outline-color": [{
          outline: [colors3]
        }],
        /**
         * Ring Width
         * @see https://tailwindcss.com/docs/ring-width
         */
        "ring-w": [{
          ring: getLengthWithEmptyAndArbitrary()
        }],
        /**
         * Ring Width Inset
         * @see https://tailwindcss.com/docs/ring-width
         */
        "ring-w-inset": ["ring-inset"],
        /**
         * Ring Color
         * @see https://tailwindcss.com/docs/ring-color
         */
        "ring-color": [{
          ring: [colors3]
        }],
        /**
         * Ring Opacity
         * @see https://tailwindcss.com/docs/ring-opacity
         */
        "ring-opacity": [{
          "ring-opacity": [opacity]
        }],
        /**
         * Ring Offset Width
         * @see https://tailwindcss.com/docs/ring-offset-width
         */
        "ring-offset-w": [{
          "ring-offset": [isLength, isArbitraryLength]
        }],
        /**
         * Ring Offset Color
         * @see https://tailwindcss.com/docs/ring-offset-color
         */
        "ring-offset-color": [{
          "ring-offset": [colors3]
        }],
        // Effects
        /**
         * Box Shadow
         * @see https://tailwindcss.com/docs/box-shadow
         */
        shadow: [{
          shadow: ["", "inner", "none", isTshirtSize, isArbitraryShadow]
        }],
        /**
         * Box Shadow Color
         * @see https://tailwindcss.com/docs/box-shadow-color
         */
        "shadow-color": [{
          shadow: [isAny]
        }],
        /**
         * Opacity
         * @see https://tailwindcss.com/docs/opacity
         */
        opacity: [{
          opacity: [opacity]
        }],
        /**
         * Mix Blend Mode
         * @see https://tailwindcss.com/docs/mix-blend-mode
         */
        "mix-blend": [{
          "mix-blend": [...getBlendModes(), "plus-lighter", "plus-darker"]
        }],
        /**
         * Background Blend Mode
         * @see https://tailwindcss.com/docs/background-blend-mode
         */
        "bg-blend": [{
          "bg-blend": getBlendModes()
        }],
        // Filters
        /**
         * Filter
         * @deprecated since Tailwind CSS v3.0.0
         * @see https://tailwindcss.com/docs/filter
         */
        filter: [{
          filter: ["", "none"]
        }],
        /**
         * Blur
         * @see https://tailwindcss.com/docs/blur
         */
        blur: [{
          blur: [blur]
        }],
        /**
         * Brightness
         * @see https://tailwindcss.com/docs/brightness
         */
        brightness: [{
          brightness: [brightness]
        }],
        /**
         * Contrast
         * @see https://tailwindcss.com/docs/contrast
         */
        contrast: [{
          contrast: [contrast]
        }],
        /**
         * Drop Shadow
         * @see https://tailwindcss.com/docs/drop-shadow
         */
        "drop-shadow": [{
          "drop-shadow": ["", "none", isTshirtSize, isArbitraryValue]
        }],
        /**
         * Grayscale
         * @see https://tailwindcss.com/docs/grayscale
         */
        grayscale: [{
          grayscale: [grayscale]
        }],
        /**
         * Hue Rotate
         * @see https://tailwindcss.com/docs/hue-rotate
         */
        "hue-rotate": [{
          "hue-rotate": [hueRotate]
        }],
        /**
         * Invert
         * @see https://tailwindcss.com/docs/invert
         */
        invert: [{
          invert: [invert]
        }],
        /**
         * Saturate
         * @see https://tailwindcss.com/docs/saturate
         */
        saturate: [{
          saturate: [saturate]
        }],
        /**
         * Sepia
         * @see https://tailwindcss.com/docs/sepia
         */
        sepia: [{
          sepia: [sepia]
        }],
        /**
         * Backdrop Filter
         * @deprecated since Tailwind CSS v3.0.0
         * @see https://tailwindcss.com/docs/backdrop-filter
         */
        "backdrop-filter": [{
          "backdrop-filter": ["", "none"]
        }],
        /**
         * Backdrop Blur
         * @see https://tailwindcss.com/docs/backdrop-blur
         */
        "backdrop-blur": [{
          "backdrop-blur": [blur]
        }],
        /**
         * Backdrop Brightness
         * @see https://tailwindcss.com/docs/backdrop-brightness
         */
        "backdrop-brightness": [{
          "backdrop-brightness": [brightness]
        }],
        /**
         * Backdrop Contrast
         * @see https://tailwindcss.com/docs/backdrop-contrast
         */
        "backdrop-contrast": [{
          "backdrop-contrast": [contrast]
        }],
        /**
         * Backdrop Grayscale
         * @see https://tailwindcss.com/docs/backdrop-grayscale
         */
        "backdrop-grayscale": [{
          "backdrop-grayscale": [grayscale]
        }],
        /**
         * Backdrop Hue Rotate
         * @see https://tailwindcss.com/docs/backdrop-hue-rotate
         */
        "backdrop-hue-rotate": [{
          "backdrop-hue-rotate": [hueRotate]
        }],
        /**
         * Backdrop Invert
         * @see https://tailwindcss.com/docs/backdrop-invert
         */
        "backdrop-invert": [{
          "backdrop-invert": [invert]
        }],
        /**
         * Backdrop Opacity
         * @see https://tailwindcss.com/docs/backdrop-opacity
         */
        "backdrop-opacity": [{
          "backdrop-opacity": [opacity]
        }],
        /**
         * Backdrop Saturate
         * @see https://tailwindcss.com/docs/backdrop-saturate
         */
        "backdrop-saturate": [{
          "backdrop-saturate": [saturate]
        }],
        /**
         * Backdrop Sepia
         * @see https://tailwindcss.com/docs/backdrop-sepia
         */
        "backdrop-sepia": [{
          "backdrop-sepia": [sepia]
        }],
        // Tables
        /**
         * Border Collapse
         * @see https://tailwindcss.com/docs/border-collapse
         */
        "border-collapse": [{
          border: ["collapse", "separate"]
        }],
        /**
         * Border Spacing
         * @see https://tailwindcss.com/docs/border-spacing
         */
        "border-spacing": [{
          "border-spacing": [borderSpacing]
        }],
        /**
         * Border Spacing X
         * @see https://tailwindcss.com/docs/border-spacing
         */
        "border-spacing-x": [{
          "border-spacing-x": [borderSpacing]
        }],
        /**
         * Border Spacing Y
         * @see https://tailwindcss.com/docs/border-spacing
         */
        "border-spacing-y": [{
          "border-spacing-y": [borderSpacing]
        }],
        /**
         * Table Layout
         * @see https://tailwindcss.com/docs/table-layout
         */
        "table-layout": [{
          table: ["auto", "fixed"]
        }],
        /**
         * Caption Side
         * @see https://tailwindcss.com/docs/caption-side
         */
        caption: [{
          caption: ["top", "bottom"]
        }],
        // Transitions and Animation
        /**
         * Tranisition Property
         * @see https://tailwindcss.com/docs/transition-property
         */
        transition: [{
          transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", isArbitraryValue]
        }],
        /**
         * Transition Duration
         * @see https://tailwindcss.com/docs/transition-duration
         */
        duration: [{
          duration: getNumberAndArbitrary()
        }],
        /**
         * Transition Timing Function
         * @see https://tailwindcss.com/docs/transition-timing-function
         */
        ease: [{
          ease: ["linear", "in", "out", "in-out", isArbitraryValue]
        }],
        /**
         * Transition Delay
         * @see https://tailwindcss.com/docs/transition-delay
         */
        delay: [{
          delay: getNumberAndArbitrary()
        }],
        /**
         * Animation
         * @see https://tailwindcss.com/docs/animation
         */
        animate: [{
          animate: ["none", "spin", "ping", "pulse", "bounce", isArbitraryValue]
        }],
        // Transforms
        /**
         * Transform
         * @see https://tailwindcss.com/docs/transform
         */
        transform: [{
          transform: ["", "gpu", "none"]
        }],
        /**
         * Scale
         * @see https://tailwindcss.com/docs/scale
         */
        scale: [{
          scale: [scale2]
        }],
        /**
         * Scale X
         * @see https://tailwindcss.com/docs/scale
         */
        "scale-x": [{
          "scale-x": [scale2]
        }],
        /**
         * Scale Y
         * @see https://tailwindcss.com/docs/scale
         */
        "scale-y": [{
          "scale-y": [scale2]
        }],
        /**
         * Rotate
         * @see https://tailwindcss.com/docs/rotate
         */
        rotate: [{
          rotate: [isInteger, isArbitraryValue]
        }],
        /**
         * Translate X
         * @see https://tailwindcss.com/docs/translate
         */
        "translate-x": [{
          "translate-x": [translate]
        }],
        /**
         * Translate Y
         * @see https://tailwindcss.com/docs/translate
         */
        "translate-y": [{
          "translate-y": [translate]
        }],
        /**
         * Skew X
         * @see https://tailwindcss.com/docs/skew
         */
        "skew-x": [{
          "skew-x": [skew]
        }],
        /**
         * Skew Y
         * @see https://tailwindcss.com/docs/skew
         */
        "skew-y": [{
          "skew-y": [skew]
        }],
        /**
         * Transform Origin
         * @see https://tailwindcss.com/docs/transform-origin
         */
        "transform-origin": [{
          origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", isArbitraryValue]
        }],
        // Interactivity
        /**
         * Accent Color
         * @see https://tailwindcss.com/docs/accent-color
         */
        accent: [{
          accent: ["auto", colors3]
        }],
        /**
         * Appearance
         * @see https://tailwindcss.com/docs/appearance
         */
        appearance: [{
          appearance: ["none", "auto"]
        }],
        /**
         * Cursor
         * @see https://tailwindcss.com/docs/cursor
         */
        cursor: [{
          cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", isArbitraryValue]
        }],
        /**
         * Caret Color
         * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
         */
        "caret-color": [{
          caret: [colors3]
        }],
        /**
         * Pointer Events
         * @see https://tailwindcss.com/docs/pointer-events
         */
        "pointer-events": [{
          "pointer-events": ["none", "auto"]
        }],
        /**
         * Resize
         * @see https://tailwindcss.com/docs/resize
         */
        resize: [{
          resize: ["none", "y", "x", ""]
        }],
        /**
         * Scroll Behavior
         * @see https://tailwindcss.com/docs/scroll-behavior
         */
        "scroll-behavior": [{
          scroll: ["auto", "smooth"]
        }],
        /**
         * Scroll Margin
         * @see https://tailwindcss.com/docs/scroll-margin
         */
        "scroll-m": [{
          "scroll-m": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Margin X
         * @see https://tailwindcss.com/docs/scroll-margin
         */
        "scroll-mx": [{
          "scroll-mx": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Margin Y
         * @see https://tailwindcss.com/docs/scroll-margin
         */
        "scroll-my": [{
          "scroll-my": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Margin Start
         * @see https://tailwindcss.com/docs/scroll-margin
         */
        "scroll-ms": [{
          "scroll-ms": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Margin End
         * @see https://tailwindcss.com/docs/scroll-margin
         */
        "scroll-me": [{
          "scroll-me": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Margin Top
         * @see https://tailwindcss.com/docs/scroll-margin
         */
        "scroll-mt": [{
          "scroll-mt": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Margin Right
         * @see https://tailwindcss.com/docs/scroll-margin
         */
        "scroll-mr": [{
          "scroll-mr": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Margin Bottom
         * @see https://tailwindcss.com/docs/scroll-margin
         */
        "scroll-mb": [{
          "scroll-mb": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Margin Left
         * @see https://tailwindcss.com/docs/scroll-margin
         */
        "scroll-ml": [{
          "scroll-ml": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Padding
         * @see https://tailwindcss.com/docs/scroll-padding
         */
        "scroll-p": [{
          "scroll-p": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Padding X
         * @see https://tailwindcss.com/docs/scroll-padding
         */
        "scroll-px": [{
          "scroll-px": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Padding Y
         * @see https://tailwindcss.com/docs/scroll-padding
         */
        "scroll-py": [{
          "scroll-py": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Padding Start
         * @see https://tailwindcss.com/docs/scroll-padding
         */
        "scroll-ps": [{
          "scroll-ps": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Padding End
         * @see https://tailwindcss.com/docs/scroll-padding
         */
        "scroll-pe": [{
          "scroll-pe": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Padding Top
         * @see https://tailwindcss.com/docs/scroll-padding
         */
        "scroll-pt": [{
          "scroll-pt": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Padding Right
         * @see https://tailwindcss.com/docs/scroll-padding
         */
        "scroll-pr": [{
          "scroll-pr": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Padding Bottom
         * @see https://tailwindcss.com/docs/scroll-padding
         */
        "scroll-pb": [{
          "scroll-pb": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Padding Left
         * @see https://tailwindcss.com/docs/scroll-padding
         */
        "scroll-pl": [{
          "scroll-pl": getSpacingWithArbitrary()
        }],
        /**
         * Scroll Snap Align
         * @see https://tailwindcss.com/docs/scroll-snap-align
         */
        "snap-align": [{
          snap: ["start", "end", "center", "align-none"]
        }],
        /**
         * Scroll Snap Stop
         * @see https://tailwindcss.com/docs/scroll-snap-stop
         */
        "snap-stop": [{
          snap: ["normal", "always"]
        }],
        /**
         * Scroll Snap Type
         * @see https://tailwindcss.com/docs/scroll-snap-type
         */
        "snap-type": [{
          snap: ["none", "x", "y", "both"]
        }],
        /**
         * Scroll Snap Type Strictness
         * @see https://tailwindcss.com/docs/scroll-snap-type
         */
        "snap-strictness": [{
          snap: ["mandatory", "proximity"]
        }],
        /**
         * Touch Action
         * @see https://tailwindcss.com/docs/touch-action
         */
        touch: [{
          touch: ["auto", "none", "manipulation"]
        }],
        /**
         * Touch Action X
         * @see https://tailwindcss.com/docs/touch-action
         */
        "touch-x": [{
          "touch-pan": ["x", "left", "right"]
        }],
        /**
         * Touch Action Y
         * @see https://tailwindcss.com/docs/touch-action
         */
        "touch-y": [{
          "touch-pan": ["y", "up", "down"]
        }],
        /**
         * Touch Action Pinch Zoom
         * @see https://tailwindcss.com/docs/touch-action
         */
        "touch-pz": ["touch-pinch-zoom"],
        /**
         * User Select
         * @see https://tailwindcss.com/docs/user-select
         */
        select: [{
          select: ["none", "text", "all", "auto"]
        }],
        /**
         * Will Change
         * @see https://tailwindcss.com/docs/will-change
         */
        "will-change": [{
          "will-change": ["auto", "scroll", "contents", "transform", isArbitraryValue]
        }],
        // SVG
        /**
         * Fill
         * @see https://tailwindcss.com/docs/fill
         */
        fill: [{
          fill: [colors3, "none"]
        }],
        /**
         * Stroke Width
         * @see https://tailwindcss.com/docs/stroke-width
         */
        "stroke-w": [{
          stroke: [isLength, isArbitraryLength, isArbitraryNumber]
        }],
        /**
         * Stroke
         * @see https://tailwindcss.com/docs/stroke
         */
        stroke: [{
          stroke: [colors3, "none"]
        }],
        // Accessibility
        /**
         * Screen Readers
         * @see https://tailwindcss.com/docs/screen-readers
         */
        sr: ["sr-only", "not-sr-only"],
        /**
         * Forced Color Adjust
         * @see https://tailwindcss.com/docs/forced-color-adjust
         */
        "forced-color-adjust": [{
          "forced-color-adjust": ["auto", "none"]
        }]
      },
      conflictingClassGroups: {
        overflow: ["overflow-x", "overflow-y"],
        overscroll: ["overscroll-x", "overscroll-y"],
        inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
        "inset-x": ["right", "left"],
        "inset-y": ["top", "bottom"],
        flex: ["basis", "grow", "shrink"],
        gap: ["gap-x", "gap-y"],
        p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
        px: ["pr", "pl"],
        py: ["pt", "pb"],
        m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
        mx: ["mr", "ml"],
        my: ["mt", "mb"],
        size: ["w", "h"],
        "font-size": ["leading"],
        "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
        "fvn-ordinal": ["fvn-normal"],
        "fvn-slashed-zero": ["fvn-normal"],
        "fvn-figure": ["fvn-normal"],
        "fvn-spacing": ["fvn-normal"],
        "fvn-fraction": ["fvn-normal"],
        "line-clamp": ["display", "overflow"],
        rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
        "rounded-s": ["rounded-ss", "rounded-es"],
        "rounded-e": ["rounded-se", "rounded-ee"],
        "rounded-t": ["rounded-tl", "rounded-tr"],
        "rounded-r": ["rounded-tr", "rounded-br"],
        "rounded-b": ["rounded-br", "rounded-bl"],
        "rounded-l": ["rounded-tl", "rounded-bl"],
        "border-spacing": ["border-spacing-x", "border-spacing-y"],
        "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
        "border-w-x": ["border-w-r", "border-w-l"],
        "border-w-y": ["border-w-t", "border-w-b"],
        "border-color": ["border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
        "border-color-x": ["border-color-r", "border-color-l"],
        "border-color-y": ["border-color-t", "border-color-b"],
        "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
        "scroll-mx": ["scroll-mr", "scroll-ml"],
        "scroll-my": ["scroll-mt", "scroll-mb"],
        "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
        "scroll-px": ["scroll-pr", "scroll-pl"],
        "scroll-py": ["scroll-pt", "scroll-pb"],
        touch: ["touch-x", "touch-y", "touch-pz"],
        "touch-x": ["touch"],
        "touch-y": ["touch"],
        "touch-pz": ["touch"]
      },
      conflictingClassGroupModifiers: {
        "font-size": ["leading"]
      }
    };
  };
  var twMerge = /* @__PURE__ */ createTailwindMerge(getDefaultConfig);

  // src/utils.ts
  function cn(...inputs) {
    return twMerge(clsx(inputs));
  }

  // src/components/Accordion.tsx
  var React = __toESM(require_react());

  // ../../node_modules/lucide-react/dist/esm/createLucideIcon.js
  var import_react2 = __toESM(require_react2());

  // ../../node_modules/lucide-react/dist/esm/shared/src/utils.js
  var toKebabCase = (string) => string.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
  var toCamelCase = (string) => string.replace(
    /^([A-Z])|[\s-_]+(\w)/g,
    (match2, p1, p22) => p22 ? p22.toUpperCase() : p1.toLowerCase()
  );
  var toPascalCase = (string) => {
    const camelCase = toCamelCase(string);
    return camelCase.charAt(0).toUpperCase() + camelCase.slice(1);
  };
  var mergeClasses = (...classes) => classes.filter((className, index2, array) => {
    return Boolean(className) && className.trim() !== "" && array.indexOf(className) === index2;
  }).join(" ").trim();
  var hasA11yProp = (props) => {
    for (const prop in props) {
      if (prop.startsWith("aria-") || prop === "role" || prop === "title") {
        return true;
      }
    }
  };

  // ../../node_modules/lucide-react/dist/esm/Icon.js
  var import_react = __toESM(require_react2());

  // ../../node_modules/lucide-react/dist/esm/defaultAttributes.js
  var defaultAttributes = {
    xmlns: "http://www.w3.org/2000/svg",
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: 2,
    strokeLinecap: "round",
    strokeLinejoin: "round"
  };

  // ../../node_modules/lucide-react/dist/esm/Icon.js
  var Icon = (0, import_react.forwardRef)(
    ({
      color: color2 = "currentColor",
      size: size4 = 24,
      strokeWidth = 2,
      absoluteStrokeWidth,
      className = "",
      children,
      iconNode,
      ...rest
    }, ref) => (0, import_react.createElement)(
      "svg",
      {
        ref,
        ...defaultAttributes,
        width: size4,
        height: size4,
        stroke: color2,
        strokeWidth: absoluteStrokeWidth ? Number(strokeWidth) * 24 / Number(size4) : strokeWidth,
        className: mergeClasses("lucide", className),
        ...!children && !hasA11yProp(rest) && { "aria-hidden": "true" },
        ...rest
      },
      [
        ...iconNode.map(([tag, attrs]) => (0, import_react.createElement)(tag, attrs)),
        ...Array.isArray(children) ? children : [children]
      ]
    )
  );

  // ../../node_modules/lucide-react/dist/esm/createLucideIcon.js
  var createLucideIcon = (iconName, iconNode) => {
    const Component3 = (0, import_react2.forwardRef)(
      ({ className, ...props }, ref) => (0, import_react2.createElement)(Icon, {
        ref,
        iconNode,
        className: mergeClasses(
          `lucide-${toKebabCase(toPascalCase(iconName))}`,
          `lucide-${iconName}`,
          className
        ),
        ...props
      })
    );
    Component3.displayName = toPascalCase(iconName);
    return Component3;
  };

  // ../../node_modules/lucide-react/dist/esm/icons/calendar.js
  var __iconNode = [
    ["path", { d: "M8 2v4", key: "1cmpym" }],
    ["path", { d: "M16 2v4", key: "4m81vk" }],
    ["rect", { width: "18", height: "18", x: "3", y: "4", rx: "2", key: "1hopcy" }],
    ["path", { d: "M3 10h18", key: "8toen8" }]
  ];
  var Calendar = createLucideIcon("calendar", __iconNode);

  // ../../node_modules/lucide-react/dist/esm/icons/check.js
  var __iconNode2 = [["path", { d: "M20 6 9 17l-5-5", key: "1gmf2c" }]];
  var Check = createLucideIcon("check", __iconNode2);

  // ../../node_modules/lucide-react/dist/esm/icons/chevron-down.js
  var __iconNode3 = [["path", { d: "m6 9 6 6 6-6", key: "qrunsl" }]];
  var ChevronDown = createLucideIcon("chevron-down", __iconNode3);

  // ../../node_modules/lucide-react/dist/esm/icons/chevron-left.js
  var __iconNode4 = [["path", { d: "m15 18-6-6 6-6", key: "1wnfg3" }]];
  var ChevronLeft = createLucideIcon("chevron-left", __iconNode4);

  // ../../node_modules/lucide-react/dist/esm/icons/chevron-right.js
  var __iconNode5 = [["path", { d: "m9 18 6-6-6-6", key: "mthhwq" }]];
  var ChevronRight = createLucideIcon("chevron-right", __iconNode5);

  // ../../node_modules/lucide-react/dist/esm/icons/chevrons-up-down.js
  var __iconNode6 = [
    ["path", { d: "m7 15 5 5 5-5", key: "1hf1tw" }],
    ["path", { d: "m7 9 5-5 5 5", key: "sgt6xg" }]
  ];
  var ChevronsUpDown = createLucideIcon("chevrons-up-down", __iconNode6);

  // ../../node_modules/lucide-react/dist/esm/icons/circle-alert.js
  var __iconNode7 = [
    ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
    ["line", { x1: "12", x2: "12", y1: "8", y2: "12", key: "1pkeuh" }],
    ["line", { x1: "12", x2: "12.01", y1: "16", y2: "16", key: "4dfq90" }]
  ];
  var CircleAlert = createLucideIcon("circle-alert", __iconNode7);

  // ../../node_modules/lucide-react/dist/esm/icons/copy.js
  var __iconNode8 = [
    ["rect", { width: "14", height: "14", x: "8", y: "8", rx: "2", ry: "2", key: "17jyea" }],
    ["path", { d: "M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2", key: "zix9uf" }]
  ];
  var Copy = createLucideIcon("copy", __iconNode8);

  // ../../node_modules/lucide-react/dist/esm/icons/dot.js
  var __iconNode9 = [["circle", { cx: "12.1", cy: "12.1", r: "1", key: "18d7e5" }]];
  var Dot = createLucideIcon("dot", __iconNode9);

  // ../../node_modules/lucide-react/dist/esm/icons/grip-vertical.js
  var __iconNode10 = [
    ["circle", { cx: "9", cy: "12", r: "1", key: "1vctgf" }],
    ["circle", { cx: "9", cy: "5", r: "1", key: "hp0tcf" }],
    ["circle", { cx: "9", cy: "19", r: "1", key: "fkjjf6" }],
    ["circle", { cx: "15", cy: "12", r: "1", key: "1tmaij" }],
    ["circle", { cx: "15", cy: "5", r: "1", key: "19l28e" }],
    ["circle", { cx: "15", cy: "19", r: "1", key: "f4zoj3" }]
  ];
  var GripVertical = createLucideIcon("grip-vertical", __iconNode10);

  // ../../node_modules/lucide-react/dist/esm/icons/info.js
  var __iconNode11 = [
    ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
    ["path", { d: "M12 16v-4", key: "1dtifu" }],
    ["path", { d: "M12 8h.01", key: "e9boi3" }]
  ];
  var Info = createLucideIcon("info", __iconNode11);

  // ../../node_modules/lucide-react/dist/esm/icons/x.js
  var __iconNode12 = [
    ["path", { d: "M18 6 6 18", key: "1bl5f8" }],
    ["path", { d: "m6 6 12 12", key: "d8bk6v" }]
  ];
  var X = createLucideIcon("x", __iconNode12);

  // src/components/Accordion.tsx
  var import_jsx_runtime = __toESM(require_jsx_runtime());
  var AccordionContext = React.createContext(null);
  function Accordion({
    children,
    className,
    variant = "simple"
  }) {
    const [openItem, setOpenItem] = React.useState(null);
    const toggleItem = (value) => {
      setOpenItem((prev) => prev === value ? null : value);
    };
    return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(AccordionContext.Provider, { value: { openItem, toggleItem, variant }, children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", { className: cn(
      "space-y-2",
      variant === "separated" && "space-y-4",
      // More space for separated
      className
    ), children }) });
  }
  function AccordionItem({ value, trigger, children, className }) {
    const context = React.useContext(AccordionContext);
    if (!context) throw new Error("AccordionItem must be used within Accordion");
    const isOpen = context.openItem === value;
    const { variant } = context;
    return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", { className: cn(
      "overflow-hidden transition-all duration-200",
      // Variant: Simple (Default) - Border bottom only
      variant === "simple" && "border-b border-border rounded-none bg-transparent",
      // Variant: Boxed - Contained within a box
      variant === "boxed" && "border border-border bg-muted/30 backdrop-blur-sm first:rounded-t-2xl last:rounded-b-2xl",
      // Variant: Separated - Individual floating cards
      variant === "separated" && "rounded-2xl border border-border bg-card text-card-foreground shadow-sm",
      className
    ), children: [
      /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(
        "button",
        {
          onClick: () => context.toggleItem(value),
          className: cn(
            "flex w-full items-center justify-between px-4 py-4 text-left font-medium transition-all hover:bg-muted/50 [&[data-state=open]>svg]:rotate-180",
            variant === "simple" && "hover:bg-transparent hover:text-foreground/80"
          ),
          "data-state": isOpen ? "open" : "closed",
          children: [
            trigger,
            /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ChevronDown, { className: "h-4 w-4 shrink-0 transition-transform duration-200 text-muted-foreground" })
          ]
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
        "div",
        {
          className: cn(
            "overflow-hidden text-sm transition-all duration-300 ease-in-out",
            isOpen ? "max-h-96 opacity-100" : "max-h-0 opacity-0",
            isOpen && variant !== "simple" && "pb-4 px-4"
            // Padding for boxed/separated
          ),
          children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", { className: cn(
            "text-muted-foreground pt-2",
            variant !== "simple" && "border-t border-border"
          ), children })
        }
      )
    ] });
  }

  // src/components/Alert.tsx
  var import_jsx_runtime2 = __toESM(require_jsx_runtime());
  var icons = {
    success: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("svg", { className: "h-5 w-5", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", strokeWidth: 2, children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M5 13l4 4L19 7" }) }),
    error: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("svg", { className: "h-5 w-5", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", strokeWidth: 2, children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M6 18L18 6M6 6l12 12" }) }),
    warning: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("svg", { className: "h-5 w-5", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", strokeWidth: 2, children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" }) }),
    info: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("svg", { className: "h-5 w-5", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", strokeWidth: 2, children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" }) })
  };
  function Alert({
    children,
    variant = "info",
    design = "standard",
    // Visual style
    title,
    icon = true,
    className
  }) {
    return /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)(
      "div",
      {
        role: "alert",
        className: cn(
          "flex gap-3 p-4 backdrop-blur-sm transition-all duration-300",
          {
            // Base Colors (Severity)
            "text-success": variant === "success",
            "text-destructive": variant === "error",
            "text-warning": variant === "warning",
            "text-info": variant === "info",
            // Design: Standard (Bordered + Soft Background)
            "rounded-[2rem] border": design === "standard",
            "border-success/30 bg-success/10": design === "standard" && variant === "success",
            "border-destructive/30 bg-destructive/10": design === "standard" && variant === "error",
            "border-warning/30 bg-warning/10": design === "standard" && variant === "warning",
            "border-info/30 bg-info/10": design === "standard" && variant === "info",
            // Design: Solid (Filled)
            "rounded-[2rem] text-white shadow-lg": design === "solid",
            "bg-success": design === "solid" && variant === "success",
            "bg-destructive": design === "solid" && variant === "error",
            "bg-warning": design === "solid" && variant === "warning",
            "bg-info": design === "solid" && variant === "info",
            // Design: Left Accent (Minimal)
            "bg-white dark:bg-zinc-900 border-l-4 rounded-r-lg shadow-sm border-t-0 border-b-0 border-r-0": design === "left-accent",
            "border-success": design === "left-accent" && variant === "success",
            "border-destructive": design === "left-accent" && variant === "error",
            "border-warning": design === "left-accent" && variant === "warning",
            "border-info": design === "left-accent" && variant === "info"
          },
          className
        ),
        children: [
          icon && /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("div", { className: cn("flex-shrink-0", design === "solid" ? "text-white" : ""), children: icons[variant] }),
          /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { className: "flex-1", children: [
            title && /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("div", { className: "mb-1 font-semibold", children: title }),
            /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("div", { className: "text-sm opacity-90", children })
          ] })
        ]
      }
    );
  }

  // ../../node_modules/framer-motion/dist/es/components/AnimatePresence/index.mjs
  var import_jsx_runtime5 = __toESM(require_jsx_runtime2(), 1);
  var import_react12 = __toESM(require_react2(), 1);

  // ../../node_modules/framer-motion/dist/es/context/LayoutGroupContext.mjs
  var import_react3 = __toESM(require_react2(), 1);
  var LayoutGroupContext = (0, import_react3.createContext)({});

  // ../../node_modules/framer-motion/dist/es/utils/use-constant.mjs
  var import_react4 = __toESM(require_react2(), 1);
  function useConstant(init) {
    const ref = (0, import_react4.useRef)(null);
    if (ref.current === null) {
      ref.current = init();
    }
    return ref.current;
  }

  // ../../node_modules/framer-motion/dist/es/utils/use-isomorphic-effect.mjs
  var import_react5 = __toESM(require_react2(), 1);

  // ../../node_modules/framer-motion/dist/es/utils/is-browser.mjs
  var isBrowser = typeof window !== "undefined";

  // ../../node_modules/framer-motion/dist/es/utils/use-isomorphic-effect.mjs
  var useIsomorphicLayoutEffect = isBrowser ? import_react5.useLayoutEffect : import_react5.useEffect;

  // ../../node_modules/framer-motion/dist/es/components/AnimatePresence/PresenceChild.mjs
  var import_jsx_runtime4 = __toESM(require_jsx_runtime2(), 1);
  var React4 = __toESM(require_react2(), 1);
  var import_react9 = __toESM(require_react2(), 1);

  // ../../node_modules/framer-motion/dist/es/context/PresenceContext.mjs
  var import_react6 = __toESM(require_react2(), 1);
  var PresenceContext = /* @__PURE__ */ (0, import_react6.createContext)(null);

  // ../../node_modules/framer-motion/dist/es/components/AnimatePresence/PopChild.mjs
  var import_jsx_runtime3 = __toESM(require_jsx_runtime2(), 1);

  // ../../node_modules/motion-utils/dist/es/array.mjs
  function addUniqueItem(arr, item) {
    if (arr.indexOf(item) === -1)
      arr.push(item);
  }
  function removeItem(arr, item) {
    const index2 = arr.indexOf(item);
    if (index2 > -1)
      arr.splice(index2, 1);
  }

  // ../../node_modules/motion-utils/dist/es/clamp.mjs
  var clamp = (min3, max3, v2) => {
    if (v2 > max3)
      return max3;
    if (v2 < min3)
      return min3;
    return v2;
  };

  // ../../node_modules/motion-utils/dist/es/format-error-message.mjs
  function formatErrorMessage(message2, errorCode) {
    return errorCode ? `${message2}. For more information and steps for solving, visit https://motion.dev/troubleshooting/${errorCode}` : message2;
  }

  // ../../node_modules/motion-utils/dist/es/errors.mjs
  var warning = () => {
  };
  var invariant = () => {
  };
  if (typeof process !== "undefined" && process.env?.NODE_ENV !== "production") {
    warning = (check, message2, errorCode) => {
      if (!check && typeof console !== "undefined") {
        console.warn(formatErrorMessage(message2, errorCode));
      }
    };
    invariant = (check, message2, errorCode) => {
      if (!check) {
        throw new Error(formatErrorMessage(message2, errorCode));
      }
    };
  }

  // ../../node_modules/motion-utils/dist/es/global-config.mjs
  var MotionGlobalConfig = {};

  // ../../node_modules/motion-utils/dist/es/is-numerical-string.mjs
  var isNumericalString = (v2) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(v2);

  // ../../node_modules/motion-utils/dist/es/is-object.mjs
  function isObject(value) {
    return typeof value === "object" && value !== null;
  }

  // ../../node_modules/motion-utils/dist/es/is-zero-value-string.mjs
  var isZeroValueString = (v2) => /^0[^.\s]+$/u.test(v2);

  // ../../node_modules/motion-utils/dist/es/memo.mjs
  // @__NO_SIDE_EFFECTS__
  function memo(callback) {
    let result;
    return () => {
      if (result === void 0)
        result = callback();
      return result;
    };
  }

  // ../../node_modules/motion-utils/dist/es/noop.mjs
  var noop = /* @__NO_SIDE_EFFECTS__ */ (any) => any;

  // ../../node_modules/motion-utils/dist/es/pipe.mjs
  var combineFunctions = (a, b2) => (v2) => b2(a(v2));
  var pipe = (...transformers) => transformers.reduce(combineFunctions);

  // ../../node_modules/motion-utils/dist/es/progress.mjs
  var progress = /* @__NO_SIDE_EFFECTS__ */ (from, to2, value) => {
    const toFromDifference = to2 - from;
    return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;
  };

  // ../../node_modules/motion-utils/dist/es/subscription-manager.mjs
  var SubscriptionManager = class {
    constructor() {
      this.subscriptions = [];
    }
    add(handler) {
      addUniqueItem(this.subscriptions, handler);
      return () => removeItem(this.subscriptions, handler);
    }
    notify(a, b2, c) {
      const numSubscriptions = this.subscriptions.length;
      if (!numSubscriptions)
        return;
      if (numSubscriptions === 1) {
        this.subscriptions[0](a, b2, c);
      } else {
        for (let i3 = 0; i3 < numSubscriptions; i3++) {
          const handler = this.subscriptions[i3];
          handler && handler(a, b2, c);
        }
      }
    }
    getSize() {
      return this.subscriptions.length;
    }
    clear() {
      this.subscriptions.length = 0;
    }
  };

  // ../../node_modules/motion-utils/dist/es/time-conversion.mjs
  var secondsToMilliseconds = /* @__NO_SIDE_EFFECTS__ */ (seconds) => seconds * 1e3;
  var millisecondsToSeconds = /* @__NO_SIDE_EFFECTS__ */ (milliseconds) => milliseconds / 1e3;

  // ../../node_modules/motion-utils/dist/es/velocity-per-second.mjs
  function velocityPerSecond(velocity, frameDuration) {
    return frameDuration ? velocity * (1e3 / frameDuration) : 0;
  }

  // ../../node_modules/motion-utils/dist/es/warn-once.mjs
  var warned = /* @__PURE__ */ new Set();
  function warnOnce(condition, message2, errorCode) {
    if (condition || warned.has(message2))
      return;
    console.warn(formatErrorMessage(message2, errorCode));
    warned.add(message2);
  }

  // ../../node_modules/motion-utils/dist/es/easing/cubic-bezier.mjs
  var calcBezier = (t3, a1, a2) => (((1 - 3 * a2 + 3 * a1) * t3 + (3 * a2 - 6 * a1)) * t3 + 3 * a1) * t3;
  var subdivisionPrecision = 1e-7;
  var subdivisionMaxIterations = 12;
  function binarySubdivide(x2, lowerBound, upperBound, mX1, mX2) {
    let currentX;
    let currentT;
    let i3 = 0;
    do {
      currentT = lowerBound + (upperBound - lowerBound) / 2;
      currentX = calcBezier(currentT, mX1, mX2) - x2;
      if (currentX > 0) {
        upperBound = currentT;
      } else {
        lowerBound = currentT;
      }
    } while (Math.abs(currentX) > subdivisionPrecision && ++i3 < subdivisionMaxIterations);
    return currentT;
  }
  function cubicBezier(mX1, mY1, mX2, mY2) {
    if (mX1 === mY1 && mX2 === mY2)
      return noop;
    const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);
    return (t3) => t3 === 0 || t3 === 1 ? t3 : calcBezier(getTForX(t3), mY1, mY2);
  }

  // ../../node_modules/motion-utils/dist/es/easing/modifiers/mirror.mjs
  var mirrorEasing = (easing) => (p3) => p3 <= 0.5 ? easing(2 * p3) / 2 : (2 - easing(2 * (1 - p3))) / 2;

  // ../../node_modules/motion-utils/dist/es/easing/modifiers/reverse.mjs
  var reverseEasing = (easing) => (p3) => 1 - easing(1 - p3);

  // ../../node_modules/motion-utils/dist/es/easing/back.mjs
  var backOut = /* @__PURE__ */ cubicBezier(0.33, 1.53, 0.69, 0.99);
  var backIn = /* @__PURE__ */ reverseEasing(backOut);
  var backInOut = /* @__PURE__ */ mirrorEasing(backIn);

  // ../../node_modules/motion-utils/dist/es/easing/anticipate.mjs
  var anticipate = (p3) => (p3 *= 2) < 1 ? 0.5 * backIn(p3) : 0.5 * (2 - Math.pow(2, -10 * (p3 - 1)));

  // ../../node_modules/motion-utils/dist/es/easing/circ.mjs
  var circIn = (p3) => 1 - Math.sin(Math.acos(p3));
  var circOut = reverseEasing(circIn);
  var circInOut = mirrorEasing(circIn);

  // ../../node_modules/motion-utils/dist/es/easing/ease.mjs
  var easeIn = /* @__PURE__ */ cubicBezier(0.42, 0, 1, 1);
  var easeOut = /* @__PURE__ */ cubicBezier(0, 0, 0.58, 1);
  var easeInOut = /* @__PURE__ */ cubicBezier(0.42, 0, 0.58, 1);

  // ../../node_modules/motion-utils/dist/es/easing/utils/is-easing-array.mjs
  var isEasingArray = (ease2) => {
    return Array.isArray(ease2) && typeof ease2[0] !== "number";
  };

  // ../../node_modules/motion-utils/dist/es/easing/utils/is-bezier-definition.mjs
  var isBezierDefinition = (easing) => Array.isArray(easing) && typeof easing[0] === "number";

  // ../../node_modules/motion-utils/dist/es/easing/utils/map.mjs
  var easingLookup = {
    linear: noop,
    easeIn,
    easeInOut,
    easeOut,
    circIn,
    circInOut,
    circOut,
    backIn,
    backInOut,
    backOut,
    anticipate
  };
  var isValidEasing = (easing) => {
    return typeof easing === "string";
  };
  var easingDefinitionToFunction = (definition) => {
    if (isBezierDefinition(definition)) {
      invariant(definition.length === 4, `Cubic bezier arrays must contain four numerical values.`, "cubic-bezier-length");
      const [x1, y1, x2, y2] = definition;
      return cubicBezier(x1, y1, x2, y2);
    } else if (isValidEasing(definition)) {
      invariant(easingLookup[definition] !== void 0, `Invalid easing type '${definition}'`, "invalid-easing-type");
      return easingLookup[definition];
    }
    return definition;
  };

  // ../../node_modules/motion-dom/dist/es/frameloop/order.mjs
  var stepsOrder = [
    "setup",
    // Compute
    "read",
    // Read
    "resolveKeyframes",
    // Write/Read/Write/Read
    "preUpdate",
    // Compute
    "update",
    // Compute
    "preRender",
    // Compute
    "render",
    // Write
    "postRender"
    // Compute
  ];

  // ../../node_modules/motion-dom/dist/es/stats/buffer.mjs
  var statsBuffer = {
    value: null,
    addProjectionMetrics: null
  };

  // ../../node_modules/motion-dom/dist/es/frameloop/render-step.mjs
  function createRenderStep(runNextFrame, stepName) {
    let thisFrame = /* @__PURE__ */ new Set();
    let nextFrame = /* @__PURE__ */ new Set();
    let isProcessing = false;
    let flushNextFrame = false;
    const toKeepAlive = /* @__PURE__ */ new WeakSet();
    let latestFrameData = {
      delta: 0,
      timestamp: 0,
      isProcessing: false
    };
    let numCalls = 0;
    function triggerCallback(callback) {
      if (toKeepAlive.has(callback)) {
        step.schedule(callback);
        runNextFrame();
      }
      numCalls++;
      callback(latestFrameData);
    }
    const step = {
      /**
       * Schedule a process to run on the next frame.
       */
      schedule: (callback, keepAlive = false, immediate = false) => {
        const addToCurrentFrame = immediate && isProcessing;
        const queue = addToCurrentFrame ? thisFrame : nextFrame;
        if (keepAlive)
          toKeepAlive.add(callback);
        if (!queue.has(callback))
          queue.add(callback);
        return callback;
      },
      /**
       * Cancel the provided callback from running on the next frame.
       */
      cancel: (callback) => {
        nextFrame.delete(callback);
        toKeepAlive.delete(callback);
      },
      /**
       * Execute all schedule callbacks.
       */
      process: (frameData2) => {
        latestFrameData = frameData2;
        if (isProcessing) {
          flushNextFrame = true;
          return;
        }
        isProcessing = true;
        [thisFrame, nextFrame] = [nextFrame, thisFrame];
        thisFrame.forEach(triggerCallback);
        if (stepName && statsBuffer.value) {
          statsBuffer.value.frameloop[stepName].push(numCalls);
        }
        numCalls = 0;
        thisFrame.clear();
        isProcessing = false;
        if (flushNextFrame) {
          flushNextFrame = false;
          step.process(frameData2);
        }
      }
    };
    return step;
  }

  // ../../node_modules/motion-dom/dist/es/frameloop/batcher.mjs
  var maxElapsed = 40;
  function createRenderBatcher(scheduleNextBatch, allowKeepAlive) {
    let runNextFrame = false;
    let useDefaultElapsed = true;
    const state = {
      delta: 0,
      timestamp: 0,
      isProcessing: false
    };
    const flagRunNextFrame = () => runNextFrame = true;
    const steps2 = stepsOrder.reduce((acc, key) => {
      acc[key] = createRenderStep(flagRunNextFrame, allowKeepAlive ? key : void 0);
      return acc;
    }, {});
    const { setup, read, resolveKeyframes, preUpdate, update: update3, preRender, render, postRender } = steps2;
    const processBatch = () => {
      const timestamp = MotionGlobalConfig.useManualTiming ? state.timestamp : performance.now();
      runNextFrame = false;
      if (!MotionGlobalConfig.useManualTiming) {
        state.delta = useDefaultElapsed ? 1e3 / 60 : Math.max(Math.min(timestamp - state.timestamp, maxElapsed), 1);
      }
      state.timestamp = timestamp;
      state.isProcessing = true;
      setup.process(state);
      read.process(state);
      resolveKeyframes.process(state);
      preUpdate.process(state);
      update3.process(state);
      preRender.process(state);
      render.process(state);
      postRender.process(state);
      state.isProcessing = false;
      if (runNextFrame && allowKeepAlive) {
        useDefaultElapsed = false;
        scheduleNextBatch(processBatch);
      }
    };
    const wake = () => {
      runNextFrame = true;
      useDefaultElapsed = true;
      if (!state.isProcessing) {
        scheduleNextBatch(processBatch);
      }
    };
    const schedule2 = stepsOrder.reduce((acc, key) => {
      const step = steps2[key];
      acc[key] = (process2, keepAlive = false, immediate = false) => {
        if (!runNextFrame)
          wake();
        return step.schedule(process2, keepAlive, immediate);
      };
      return acc;
    }, {});
    const cancel = (process2) => {
      for (let i3 = 0; i3 < stepsOrder.length; i3++) {
        steps2[stepsOrder[i3]].cancel(process2);
      }
    };
    return { schedule: schedule2, cancel, state, steps: steps2 };
  }

  // ../../node_modules/motion-dom/dist/es/frameloop/frame.mjs
  var { schedule: frame, cancel: cancelFrame, state: frameData, steps: frameSteps } = /* @__PURE__ */ createRenderBatcher(typeof requestAnimationFrame !== "undefined" ? requestAnimationFrame : noop, true);

  // ../../node_modules/motion-dom/dist/es/frameloop/sync-time.mjs
  var now;
  function clearTime() {
    now = void 0;
  }
  var time = {
    now: () => {
      if (now === void 0) {
        time.set(frameData.isProcessing || MotionGlobalConfig.useManualTiming ? frameData.timestamp : performance.now());
      }
      return now;
    },
    set: (newTime) => {
      now = newTime;
      queueMicrotask(clearTime);
    }
  };

  // ../../node_modules/motion-dom/dist/es/stats/animation-count.mjs
  var activeAnimations = {
    layout: 0,
    mainThread: 0,
    waapi: 0
  };

  // ../../node_modules/motion-dom/dist/es/animation/utils/is-css-variable.mjs
  var checkStringStartsWith = (token) => (key) => typeof key === "string" && key.startsWith(token);
  var isCSSVariableName = /* @__PURE__ */ checkStringStartsWith("--");
  var startsAsVariableToken = /* @__PURE__ */ checkStringStartsWith("var(--");
  var isCSSVariableToken = (value) => {
    const startsWithToken = startsAsVariableToken(value);
    if (!startsWithToken)
      return false;
    return singleCssVariableRegex.test(value.split("/*")[0].trim());
  };
  var singleCssVariableRegex = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu;
  function containsCSSVariable(value) {
    if (typeof value !== "string")
      return false;
    return value.split("/*")[0].includes("var(--");
  }

  // ../../node_modules/motion-dom/dist/es/value/types/numbers/index.mjs
  var number = {
    test: (v2) => typeof v2 === "number",
    parse: parseFloat,
    transform: (v2) => v2
  };
  var alpha = {
    ...number,
    transform: (v2) => clamp(0, 1, v2)
  };
  var scale = {
    ...number,
    default: 1
  };

  // ../../node_modules/motion-dom/dist/es/value/types/utils/sanitize.mjs
  var sanitize = (v2) => Math.round(v2 * 1e5) / 1e5;

  // ../../node_modules/motion-dom/dist/es/value/types/utils/float-regex.mjs
  var floatRegex = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;

  // ../../node_modules/motion-dom/dist/es/value/types/utils/is-nullish.mjs
  function isNullish(v2) {
    return v2 == null;
  }

  // ../../node_modules/motion-dom/dist/es/value/types/utils/single-color-regex.mjs
  var singleColorRegex = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu;

  // ../../node_modules/motion-dom/dist/es/value/types/color/utils.mjs
  var isColorString = (type, testProp) => (v2) => {
    return Boolean(typeof v2 === "string" && singleColorRegex.test(v2) && v2.startsWith(type) || testProp && !isNullish(v2) && Object.prototype.hasOwnProperty.call(v2, testProp));
  };
  var splitColor = (aName, bName, cName) => (v2) => {
    if (typeof v2 !== "string")
      return v2;
    const [a, b2, c, alpha2] = v2.match(floatRegex);
    return {
      [aName]: parseFloat(a),
      [bName]: parseFloat(b2),
      [cName]: parseFloat(c),
      alpha: alpha2 !== void 0 ? parseFloat(alpha2) : 1
    };
  };

  // ../../node_modules/motion-dom/dist/es/value/types/color/rgba.mjs
  var clampRgbUnit = (v2) => clamp(0, 255, v2);
  var rgbUnit = {
    ...number,
    transform: (v2) => Math.round(clampRgbUnit(v2))
  };
  var rgba = {
    test: /* @__PURE__ */ isColorString("rgb", "red"),
    parse: /* @__PURE__ */ splitColor("red", "green", "blue"),
    transform: ({ red, green, blue, alpha: alpha$1 = 1 }) => "rgba(" + rgbUnit.transform(red) + ", " + rgbUnit.transform(green) + ", " + rgbUnit.transform(blue) + ", " + sanitize(alpha.transform(alpha$1)) + ")"
  };

  // ../../node_modules/motion-dom/dist/es/value/types/color/hex.mjs
  function parseHex(v2) {
    let r4 = "";
    let g2 = "";
    let b2 = "";
    let a = "";
    if (v2.length > 5) {
      r4 = v2.substring(1, 3);
      g2 = v2.substring(3, 5);
      b2 = v2.substring(5, 7);
      a = v2.substring(7, 9);
    } else {
      r4 = v2.substring(1, 2);
      g2 = v2.substring(2, 3);
      b2 = v2.substring(3, 4);
      a = v2.substring(4, 5);
      r4 += r4;
      g2 += g2;
      b2 += b2;
      a += a;
    }
    return {
      red: parseInt(r4, 16),
      green: parseInt(g2, 16),
      blue: parseInt(b2, 16),
      alpha: a ? parseInt(a, 16) / 255 : 1
    };
  }
  var hex = {
    test: /* @__PURE__ */ isColorString("#"),
    parse: parseHex,
    transform: rgba.transform
  };

  // ../../node_modules/motion-dom/dist/es/value/types/numbers/units.mjs
  var createUnitType = /* @__NO_SIDE_EFFECTS__ */ (unit) => ({
    test: (v2) => typeof v2 === "string" && v2.endsWith(unit) && v2.split(" ").length === 1,
    parse: parseFloat,
    transform: (v2) => `${v2}${unit}`
  });
  var degrees = /* @__PURE__ */ createUnitType("deg");
  var percent = /* @__PURE__ */ createUnitType("%");
  var px = /* @__PURE__ */ createUnitType("px");
  var vh = /* @__PURE__ */ createUnitType("vh");
  var vw = /* @__PURE__ */ createUnitType("vw");
  var progressPercentage = /* @__PURE__ */ (() => ({
    ...percent,
    parse: (v2) => percent.parse(v2) / 100,
    transform: (v2) => percent.transform(v2 * 100)
  }))();

  // ../../node_modules/motion-dom/dist/es/value/types/color/hsla.mjs
  var hsla = {
    test: /* @__PURE__ */ isColorString("hsl", "hue"),
    parse: /* @__PURE__ */ splitColor("hue", "saturation", "lightness"),
    transform: ({ hue, saturation, lightness, alpha: alpha$1 = 1 }) => {
      return "hsla(" + Math.round(hue) + ", " + percent.transform(sanitize(saturation)) + ", " + percent.transform(sanitize(lightness)) + ", " + sanitize(alpha.transform(alpha$1)) + ")";
    }
  };

  // ../../node_modules/motion-dom/dist/es/value/types/color/index.mjs
  var color = {
    test: (v2) => rgba.test(v2) || hex.test(v2) || hsla.test(v2),
    parse: (v2) => {
      if (rgba.test(v2)) {
        return rgba.parse(v2);
      } else if (hsla.test(v2)) {
        return hsla.parse(v2);
      } else {
        return hex.parse(v2);
      }
    },
    transform: (v2) => {
      return typeof v2 === "string" ? v2 : v2.hasOwnProperty("red") ? rgba.transform(v2) : hsla.transform(v2);
    },
    getAnimatableNone: (v2) => {
      const parsed = color.parse(v2);
      parsed.alpha = 0;
      return color.transform(parsed);
    }
  };

  // ../../node_modules/motion-dom/dist/es/value/types/utils/color-regex.mjs
  var colorRegex = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;

  // ../../node_modules/motion-dom/dist/es/value/types/complex/index.mjs
  function test(v2) {
    return isNaN(v2) && typeof v2 === "string" && (v2.match(floatRegex)?.length || 0) + (v2.match(colorRegex)?.length || 0) > 0;
  }
  var NUMBER_TOKEN = "number";
  var COLOR_TOKEN = "color";
  var VAR_TOKEN = "var";
  var VAR_FUNCTION_TOKEN = "var(";
  var SPLIT_TOKEN = "${}";
  var complexRegex = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
  function analyseComplexValue(value) {
    const originalValue = value.toString();
    const values = [];
    const indexes = {
      color: [],
      number: [],
      var: []
    };
    const types = [];
    let i3 = 0;
    const tokenised = originalValue.replace(complexRegex, (parsedValue) => {
      if (color.test(parsedValue)) {
        indexes.color.push(i3);
        types.push(COLOR_TOKEN);
        values.push(color.parse(parsedValue));
      } else if (parsedValue.startsWith(VAR_FUNCTION_TOKEN)) {
        indexes.var.push(i3);
        types.push(VAR_TOKEN);
        values.push(parsedValue);
      } else {
        indexes.number.push(i3);
        types.push(NUMBER_TOKEN);
        values.push(parseFloat(parsedValue));
      }
      ++i3;
      return SPLIT_TOKEN;
    });
    const split = tokenised.split(SPLIT_TOKEN);
    return { values, split, indexes, types };
  }
  function parseComplexValue(v2) {
    return analyseComplexValue(v2).values;
  }
  function createTransformer(source) {
    const { split, types } = analyseComplexValue(source);
    const numSections = split.length;
    return (v2) => {
      let output = "";
      for (let i3 = 0; i3 < numSections; i3++) {
        output += split[i3];
        if (v2[i3] !== void 0) {
          const type = types[i3];
          if (type === NUMBER_TOKEN) {
            output += sanitize(v2[i3]);
          } else if (type === COLOR_TOKEN) {
            output += color.transform(v2[i3]);
          } else {
            output += v2[i3];
          }
        }
      }
      return output;
    };
  }
  var convertNumbersToZero = (v2) => typeof v2 === "number" ? 0 : color.test(v2) ? color.getAnimatableNone(v2) : v2;
  function getAnimatableNone(v2) {
    const parsed = parseComplexValue(v2);
    const transformer = createTransformer(v2);
    return transformer(parsed.map(convertNumbersToZero));
  }
  var complex = {
    test,
    parse: parseComplexValue,
    createTransformer,
    getAnimatableNone
  };

  // ../../node_modules/motion-dom/dist/es/value/types/color/hsla-to-rgba.mjs
  function hueToRgb(p3, q3, t3) {
    if (t3 < 0)
      t3 += 1;
    if (t3 > 1)
      t3 -= 1;
    if (t3 < 1 / 6)
      return p3 + (q3 - p3) * 6 * t3;
    if (t3 < 1 / 2)
      return q3;
    if (t3 < 2 / 3)
      return p3 + (q3 - p3) * (2 / 3 - t3) * 6;
    return p3;
  }
  function hslaToRgba({ hue, saturation, lightness, alpha: alpha2 }) {
    hue /= 360;
    saturation /= 100;
    lightness /= 100;
    let red = 0;
    let green = 0;
    let blue = 0;
    if (!saturation) {
      red = green = blue = lightness;
    } else {
      const q3 = lightness < 0.5 ? lightness * (1 + saturation) : lightness + saturation - lightness * saturation;
      const p3 = 2 * lightness - q3;
      red = hueToRgb(p3, q3, hue + 1 / 3);
      green = hueToRgb(p3, q3, hue);
      blue = hueToRgb(p3, q3, hue - 1 / 3);
    }
    return {
      red: Math.round(red * 255),
      green: Math.round(green * 255),
      blue: Math.round(blue * 255),
      alpha: alpha2
    };
  }

  // ../../node_modules/motion-dom/dist/es/utils/mix/immediate.mjs
  function mixImmediate(a, b2) {
    return (p3) => p3 > 0 ? b2 : a;
  }

  // ../../node_modules/motion-dom/dist/es/utils/mix/number.mjs
  var mixNumber = (from, to2, progress2) => {
    return from + (to2 - from) * progress2;
  };

  // ../../node_modules/motion-dom/dist/es/utils/mix/color.mjs
  var mixLinearColor = (from, to2, v2) => {
    const fromExpo = from * from;
    const expo = v2 * (to2 * to2 - fromExpo) + fromExpo;
    return expo < 0 ? 0 : Math.sqrt(expo);
  };
  var colorTypes = [hex, rgba, hsla];
  var getColorType = (v2) => colorTypes.find((type) => type.test(v2));
  function asRGBA(color2) {
    const type = getColorType(color2);
    warning(Boolean(type), `'${color2}' is not an animatable color. Use the equivalent color code instead.`, "color-not-animatable");
    if (!Boolean(type))
      return false;
    let model = type.parse(color2);
    if (type === hsla) {
      model = hslaToRgba(model);
    }
    return model;
  }
  var mixColor = (from, to2) => {
    const fromRGBA = asRGBA(from);
    const toRGBA = asRGBA(to2);
    if (!fromRGBA || !toRGBA) {
      return mixImmediate(from, to2);
    }
    const blended = { ...fromRGBA };
    return (v2) => {
      blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v2);
      blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v2);
      blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v2);
      blended.alpha = mixNumber(fromRGBA.alpha, toRGBA.alpha, v2);
      return rgba.transform(blended);
    };
  };

  // ../../node_modules/motion-dom/dist/es/utils/mix/visibility.mjs
  var invisibleValues = /* @__PURE__ */ new Set(["none", "hidden"]);
  function mixVisibility(origin, target) {
    if (invisibleValues.has(origin)) {
      return (p3) => p3 <= 0 ? origin : target;
    } else {
      return (p3) => p3 >= 1 ? target : origin;
    }
  }

  // ../../node_modules/motion-dom/dist/es/utils/mix/complex.mjs
  function mixNumber2(a, b2) {
    return (p3) => mixNumber(a, b2, p3);
  }
  function getMixer(a) {
    if (typeof a === "number") {
      return mixNumber2;
    } else if (typeof a === "string") {
      return isCSSVariableToken(a) ? mixImmediate : color.test(a) ? mixColor : mixComplex;
    } else if (Array.isArray(a)) {
      return mixArray;
    } else if (typeof a === "object") {
      return color.test(a) ? mixColor : mixObject;
    }
    return mixImmediate;
  }
  function mixArray(a, b2) {
    const output = [...a];
    const numValues = output.length;
    const blendValue = a.map((v2, i3) => getMixer(v2)(v2, b2[i3]));
    return (p3) => {
      for (let i3 = 0; i3 < numValues; i3++) {
        output[i3] = blendValue[i3](p3);
      }
      return output;
    };
  }
  function mixObject(a, b2) {
    const output = { ...a, ...b2 };
    const blendValue = {};
    for (const key in output) {
      if (a[key] !== void 0 && b2[key] !== void 0) {
        blendValue[key] = getMixer(a[key])(a[key], b2[key]);
      }
    }
    return (v2) => {
      for (const key in blendValue) {
        output[key] = blendValue[key](v2);
      }
      return output;
    };
  }
  function matchOrder(origin, target) {
    const orderedOrigin = [];
    const pointers = { color: 0, var: 0, number: 0 };
    for (let i3 = 0; i3 < target.values.length; i3++) {
      const type = target.types[i3];
      const originIndex = origin.indexes[type][pointers[type]];
      const originValue = origin.values[originIndex] ?? 0;
      orderedOrigin[i3] = originValue;
      pointers[type]++;
    }
    return orderedOrigin;
  }
  var mixComplex = (origin, target) => {
    const template = complex.createTransformer(target);
    const originStats = analyseComplexValue(origin);
    const targetStats = analyseComplexValue(target);
    const canInterpolate = originStats.indexes.var.length === targetStats.indexes.var.length && originStats.indexes.color.length === targetStats.indexes.color.length && originStats.indexes.number.length >= targetStats.indexes.number.length;
    if (canInterpolate) {
      if (invisibleValues.has(origin) && !targetStats.values.length || invisibleValues.has(target) && !originStats.values.length) {
        return mixVisibility(origin, target);
      }
      return pipe(mixArray(matchOrder(originStats, targetStats), targetStats.values), template);
    } else {
      warning(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`, "complex-values-different");
      return mixImmediate(origin, target);
    }
  };

  // ../../node_modules/motion-dom/dist/es/utils/mix/index.mjs
  function mix(from, to2, p3) {
    if (typeof from === "number" && typeof to2 === "number" && typeof p3 === "number") {
      return mixNumber(from, to2, p3);
    }
    const mixer = getMixer(from);
    return mixer(from, to2);
  }

  // ../../node_modules/motion-dom/dist/es/animation/drivers/frame.mjs
  var frameloopDriver = (update3) => {
    const passTimestamp = ({ timestamp }) => update3(timestamp);
    return {
      start: (keepAlive = true) => frame.update(passTimestamp, keepAlive),
      stop: () => cancelFrame(passTimestamp),
      /**
       * If we're processing this frame we can use the
       * framelocked timestamp to keep things in sync.
       */
      now: () => frameData.isProcessing ? frameData.timestamp : time.now()
    };
  };

  // ../../node_modules/motion-dom/dist/es/animation/waapi/utils/linear.mjs
  var generateLinearEasing = (easing, duration, resolution = 10) => {
    let points = "";
    const numPoints = Math.max(Math.round(duration / resolution), 2);
    for (let i3 = 0; i3 < numPoints; i3++) {
      points += Math.round(easing(i3 / (numPoints - 1)) * 1e4) / 1e4 + ", ";
    }
    return `linear(${points.substring(0, points.length - 2)})`;
  };

  // ../../node_modules/motion-dom/dist/es/animation/generators/utils/calc-duration.mjs
  var maxGeneratorDuration = 2e4;
  function calcGeneratorDuration(generator) {
    let duration = 0;
    const timeStep = 50;
    let state = generator.next(duration);
    while (!state.done && duration < maxGeneratorDuration) {
      duration += timeStep;
      state = generator.next(duration);
    }
    return duration >= maxGeneratorDuration ? Infinity : duration;
  }

  // ../../node_modules/motion-dom/dist/es/animation/generators/utils/create-generator-easing.mjs
  function createGeneratorEasing(options, scale2 = 100, createGenerator) {
    const generator = createGenerator({ ...options, keyframes: [0, scale2] });
    const duration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);
    return {
      type: "keyframes",
      ease: (progress2) => {
        return generator.next(duration * progress2).value / scale2;
      },
      duration: millisecondsToSeconds(duration)
    };
  }

  // ../../node_modules/motion-dom/dist/es/animation/generators/utils/velocity.mjs
  var velocitySampleDuration = 5;
  function calcGeneratorVelocity(resolveValue, t3, current) {
    const prevT = Math.max(t3 - velocitySampleDuration, 0);
    return velocityPerSecond(current - resolveValue(prevT), t3 - prevT);
  }

  // ../../node_modules/motion-dom/dist/es/animation/generators/spring/defaults.mjs
  var springDefaults = {
    // Default spring physics
    stiffness: 100,
    damping: 10,
    mass: 1,
    velocity: 0,
    // Default duration/bounce-based options
    duration: 800,
    // in ms
    bounce: 0.3,
    visualDuration: 0.3,
    // in seconds
    // Rest thresholds
    restSpeed: {
      granular: 0.01,
      default: 2
    },
    restDelta: {
      granular: 5e-3,
      default: 0.5
    },
    // Limits
    minDuration: 0.01,
    // in seconds
    maxDuration: 10,
    // in seconds
    minDamping: 0.05,
    maxDamping: 1
  };

  // ../../node_modules/motion-dom/dist/es/animation/generators/spring/find.mjs
  var safeMin = 1e-3;
  function findSpring({ duration = springDefaults.duration, bounce = springDefaults.bounce, velocity = springDefaults.velocity, mass = springDefaults.mass }) {
    let envelope;
    let derivative;
    warning(duration <= secondsToMilliseconds(springDefaults.maxDuration), "Spring duration must be 10 seconds or less", "spring-duration-limit");
    let dampingRatio = 1 - bounce;
    dampingRatio = clamp(springDefaults.minDamping, springDefaults.maxDamping, dampingRatio);
    duration = clamp(springDefaults.minDuration, springDefaults.maxDuration, millisecondsToSeconds(duration));
    if (dampingRatio < 1) {
      envelope = (undampedFreq2) => {
        const exponentialDecay = undampedFreq2 * dampingRatio;
        const delta = exponentialDecay * duration;
        const a = exponentialDecay - velocity;
        const b2 = calcAngularFreq(undampedFreq2, dampingRatio);
        const c = Math.exp(-delta);
        return safeMin - a / b2 * c;
      };
      derivative = (undampedFreq2) => {
        const exponentialDecay = undampedFreq2 * dampingRatio;
        const delta = exponentialDecay * duration;
        const d = delta * velocity + velocity;
        const e2 = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq2, 2) * duration;
        const f2 = Math.exp(-delta);
        const g2 = calcAngularFreq(Math.pow(undampedFreq2, 2), dampingRatio);
        const factor = -envelope(undampedFreq2) + safeMin > 0 ? -1 : 1;
        return factor * ((d - e2) * f2) / g2;
      };
    } else {
      envelope = (undampedFreq2) => {
        const a = Math.exp(-undampedFreq2 * duration);
        const b2 = (undampedFreq2 - velocity) * duration + 1;
        return -safeMin + a * b2;
      };
      derivative = (undampedFreq2) => {
        const a = Math.exp(-undampedFreq2 * duration);
        const b2 = (velocity - undampedFreq2) * (duration * duration);
        return a * b2;
      };
    }
    const initialGuess = 5 / duration;
    const undampedFreq = approximateRoot(envelope, derivative, initialGuess);
    duration = secondsToMilliseconds(duration);
    if (isNaN(undampedFreq)) {
      return {
        stiffness: springDefaults.stiffness,
        damping: springDefaults.damping,
        duration
      };
    } else {
      const stiffness = Math.pow(undampedFreq, 2) * mass;
      return {
        stiffness,
        damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),
        duration
      };
    }
  }
  var rootIterations = 12;
  function approximateRoot(envelope, derivative, initialGuess) {
    let result = initialGuess;
    for (let i3 = 1; i3 < rootIterations; i3++) {
      result = result - envelope(result) / derivative(result);
    }
    return result;
  }
  function calcAngularFreq(undampedFreq, dampingRatio) {
    return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
  }

  // ../../node_modules/motion-dom/dist/es/animation/generators/spring/index.mjs
  var durationKeys = ["duration", "bounce"];
  var physicsKeys = ["stiffness", "damping", "mass"];
  function isSpringType(options, keys2) {
    return keys2.some((key) => options[key] !== void 0);
  }
  function getSpringOptions(options) {
    let springOptions = {
      velocity: springDefaults.velocity,
      stiffness: springDefaults.stiffness,
      damping: springDefaults.damping,
      mass: springDefaults.mass,
      isResolvedFromDuration: false,
      ...options
    };
    if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {
      if (options.visualDuration) {
        const visualDuration = options.visualDuration;
        const root = 2 * Math.PI / (visualDuration * 1.2);
        const stiffness = root * root;
        const damping = 2 * clamp(0.05, 1, 1 - (options.bounce || 0)) * Math.sqrt(stiffness);
        springOptions = {
          ...springOptions,
          mass: springDefaults.mass,
          stiffness,
          damping
        };
      } else {
        const derived = findSpring(options);
        springOptions = {
          ...springOptions,
          ...derived,
          mass: springDefaults.mass
        };
        springOptions.isResolvedFromDuration = true;
      }
    }
    return springOptions;
  }
  function spring(optionsOrVisualDuration = springDefaults.visualDuration, bounce = springDefaults.bounce) {
    const options = typeof optionsOrVisualDuration !== "object" ? {
      visualDuration: optionsOrVisualDuration,
      keyframes: [0, 1],
      bounce
    } : optionsOrVisualDuration;
    let { restSpeed, restDelta } = options;
    const origin = options.keyframes[0];
    const target = options.keyframes[options.keyframes.length - 1];
    const state = { done: false, value: origin };
    const { stiffness, damping, mass, duration, velocity, isResolvedFromDuration } = getSpringOptions({
      ...options,
      velocity: -millisecondsToSeconds(options.velocity || 0)
    });
    const initialVelocity = velocity || 0;
    const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));
    const initialDelta = target - origin;
    const undampedAngularFreq = millisecondsToSeconds(Math.sqrt(stiffness / mass));
    const isGranularScale = Math.abs(initialDelta) < 5;
    restSpeed || (restSpeed = isGranularScale ? springDefaults.restSpeed.granular : springDefaults.restSpeed.default);
    restDelta || (restDelta = isGranularScale ? springDefaults.restDelta.granular : springDefaults.restDelta.default);
    let resolveSpring;
    if (dampingRatio < 1) {
      const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);
      resolveSpring = (t3) => {
        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t3);
        return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t3) + initialDelta * Math.cos(angularFreq * t3));
      };
    } else if (dampingRatio === 1) {
      resolveSpring = (t3) => target - Math.exp(-undampedAngularFreq * t3) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t3);
    } else {
      const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);
      resolveSpring = (t3) => {
        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t3);
        const freqForT = Math.min(dampedAngularFreq * t3, 300);
        return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;
      };
    }
    const generator = {
      calculatedDuration: isResolvedFromDuration ? duration || null : null,
      next: (t3) => {
        const current = resolveSpring(t3);
        if (!isResolvedFromDuration) {
          let currentVelocity = t3 === 0 ? initialVelocity : 0;
          if (dampingRatio < 1) {
            currentVelocity = t3 === 0 ? secondsToMilliseconds(initialVelocity) : calcGeneratorVelocity(resolveSpring, t3, current);
          }
          const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;
          const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;
          state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;
        } else {
          state.done = t3 >= duration;
        }
        state.value = state.done ? target : current;
        return state;
      },
      toString: () => {
        const calculatedDuration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);
        const easing = generateLinearEasing((progress2) => generator.next(calculatedDuration * progress2).value, calculatedDuration, 30);
        return calculatedDuration + "ms " + easing;
      },
      toTransition: () => {
      }
    };
    return generator;
  }
  spring.applyToOptions = (options) => {
    const generatorOptions = createGeneratorEasing(options, 100, spring);
    options.ease = generatorOptions.ease;
    options.duration = secondsToMilliseconds(generatorOptions.duration);
    options.type = "keyframes";
    return options;
  };

  // ../../node_modules/motion-dom/dist/es/animation/generators/inertia.mjs
  function inertia({ keyframes: keyframes2, velocity = 0, power = 0.8, timeConstant = 325, bounceDamping = 10, bounceStiffness = 500, modifyTarget, min: min3, max: max3, restDelta = 0.5, restSpeed }) {
    const origin = keyframes2[0];
    const state = {
      done: false,
      value: origin
    };
    const isOutOfBounds = (v2) => min3 !== void 0 && v2 < min3 || max3 !== void 0 && v2 > max3;
    const nearestBoundary = (v2) => {
      if (min3 === void 0)
        return max3;
      if (max3 === void 0)
        return min3;
      return Math.abs(min3 - v2) < Math.abs(max3 - v2) ? min3 : max3;
    };
    let amplitude = power * velocity;
    const ideal = origin + amplitude;
    const target = modifyTarget === void 0 ? ideal : modifyTarget(ideal);
    if (target !== ideal)
      amplitude = target - origin;
    const calcDelta = (t3) => -amplitude * Math.exp(-t3 / timeConstant);
    const calcLatest = (t3) => target + calcDelta(t3);
    const applyFriction = (t3) => {
      const delta = calcDelta(t3);
      const latest = calcLatest(t3);
      state.done = Math.abs(delta) <= restDelta;
      state.value = state.done ? target : latest;
    };
    let timeReachedBoundary;
    let spring$1;
    const checkCatchBoundary = (t3) => {
      if (!isOutOfBounds(state.value))
        return;
      timeReachedBoundary = t3;
      spring$1 = spring({
        keyframes: [state.value, nearestBoundary(state.value)],
        velocity: calcGeneratorVelocity(calcLatest, t3, state.value),
        // TODO: This should be passing * 1000
        damping: bounceDamping,
        stiffness: bounceStiffness,
        restDelta,
        restSpeed
      });
    };
    checkCatchBoundary(0);
    return {
      calculatedDuration: null,
      next: (t3) => {
        let hasUpdatedFrame = false;
        if (!spring$1 && timeReachedBoundary === void 0) {
          hasUpdatedFrame = true;
          applyFriction(t3);
          checkCatchBoundary(t3);
        }
        if (timeReachedBoundary !== void 0 && t3 >= timeReachedBoundary) {
          return spring$1.next(t3 - timeReachedBoundary);
        } else {
          !hasUpdatedFrame && applyFriction(t3);
          return state;
        }
      }
    };
  }

  // ../../node_modules/motion-dom/dist/es/utils/interpolate.mjs
  function createMixers(output, ease2, customMixer) {
    const mixers = [];
    const mixerFactory = customMixer || MotionGlobalConfig.mix || mix;
    const numMixers = output.length - 1;
    for (let i3 = 0; i3 < numMixers; i3++) {
      let mixer = mixerFactory(output[i3], output[i3 + 1]);
      if (ease2) {
        const easingFunction = Array.isArray(ease2) ? ease2[i3] || noop : ease2;
        mixer = pipe(easingFunction, mixer);
      }
      mixers.push(mixer);
    }
    return mixers;
  }
  function interpolate(input, output, { clamp: isClamp = true, ease: ease2, mixer } = {}) {
    const inputLength = input.length;
    invariant(inputLength === output.length, "Both input and output ranges must be the same length", "range-length");
    if (inputLength === 1)
      return () => output[0];
    if (inputLength === 2 && output[0] === output[1])
      return () => output[1];
    const isZeroDeltaRange = input[0] === input[1];
    if (input[0] > input[inputLength - 1]) {
      input = [...input].reverse();
      output = [...output].reverse();
    }
    const mixers = createMixers(output, ease2, mixer);
    const numMixers = mixers.length;
    const interpolator = (v2) => {
      if (isZeroDeltaRange && v2 < input[0])
        return output[0];
      let i3 = 0;
      if (numMixers > 1) {
        for (; i3 < input.length - 2; i3++) {
          if (v2 < input[i3 + 1])
            break;
        }
      }
      const progressInRange = progress(input[i3], input[i3 + 1], v2);
      return mixers[i3](progressInRange);
    };
    return isClamp ? (v2) => interpolator(clamp(input[0], input[inputLength - 1], v2)) : interpolator;
  }

  // ../../node_modules/motion-dom/dist/es/animation/keyframes/offsets/fill.mjs
  function fillOffset(offset4, remaining) {
    const min3 = offset4[offset4.length - 1];
    for (let i3 = 1; i3 <= remaining; i3++) {
      const offsetProgress = progress(0, remaining, i3);
      offset4.push(mixNumber(min3, 1, offsetProgress));
    }
  }

  // ../../node_modules/motion-dom/dist/es/animation/keyframes/offsets/default.mjs
  function defaultOffset(arr) {
    const offset4 = [0];
    fillOffset(offset4, arr.length - 1);
    return offset4;
  }

  // ../../node_modules/motion-dom/dist/es/animation/keyframes/offsets/time.mjs
  function convertOffsetToTimes(offset4, duration) {
    return offset4.map((o) => o * duration);
  }

  // ../../node_modules/motion-dom/dist/es/animation/generators/keyframes.mjs
  function defaultEasing(values, easing) {
    return values.map(() => easing || easeInOut).splice(0, values.length - 1);
  }
  function keyframes({ duration = 300, keyframes: keyframeValues, times, ease: ease2 = "easeInOut" }) {
    const easingFunctions = isEasingArray(ease2) ? ease2.map(easingDefinitionToFunction) : easingDefinitionToFunction(ease2);
    const state = {
      done: false,
      value: keyframeValues[0]
    };
    const absoluteTimes = convertOffsetToTimes(
      // Only use the provided offsets if they're the correct length
      // TODO Maybe we should warn here if there's a length mismatch
      times && times.length === keyframeValues.length ? times : defaultOffset(keyframeValues),
      duration
    );
    const mapTimeToKeyframe = interpolate(absoluteTimes, keyframeValues, {
      ease: Array.isArray(easingFunctions) ? easingFunctions : defaultEasing(keyframeValues, easingFunctions)
    });
    return {
      calculatedDuration: duration,
      next: (t3) => {
        state.value = mapTimeToKeyframe(t3);
        state.done = t3 >= duration;
        return state;
      }
    };
  }

  // ../../node_modules/motion-dom/dist/es/animation/keyframes/get-final.mjs
  var isNotNull = (value) => value !== null;
  function getFinalKeyframe(keyframes2, { repeat, repeatType = "loop" }, finalKeyframe, speed = 1) {
    const resolvedKeyframes = keyframes2.filter(isNotNull);
    const useFirstKeyframe = speed < 0 || repeat && repeatType !== "loop" && repeat % 2 === 1;
    const index2 = useFirstKeyframe ? 0 : resolvedKeyframes.length - 1;
    return !index2 || finalKeyframe === void 0 ? resolvedKeyframes[index2] : finalKeyframe;
  }

  // ../../node_modules/motion-dom/dist/es/animation/utils/replace-transition-type.mjs
  var transitionTypeMap = {
    decay: inertia,
    inertia,
    tween: keyframes,
    keyframes,
    spring
  };
  function replaceTransitionType(transition) {
    if (typeof transition.type === "string") {
      transition.type = transitionTypeMap[transition.type];
    }
  }

  // ../../node_modules/motion-dom/dist/es/animation/utils/WithPromise.mjs
  var WithPromise = class {
    constructor() {
      this.updateFinished();
    }
    get finished() {
      return this._finished;
    }
    updateFinished() {
      this._finished = new Promise((resolve) => {
        this.resolve = resolve;
      });
    }
    notifyFinished() {
      this.resolve();
    }
    /**
     * Allows the animation to be awaited.
     *
     * @deprecated Use `finished` instead.
     */
    then(onResolve, onReject) {
      return this.finished.then(onResolve, onReject);
    }
  };

  // ../../node_modules/motion-dom/dist/es/animation/JSAnimation.mjs
  var percentToProgress = (percent2) => percent2 / 100;
  var JSAnimation = class extends WithPromise {
    constructor(options) {
      super();
      this.state = "idle";
      this.startTime = null;
      this.isStopped = false;
      this.currentTime = 0;
      this.holdTime = null;
      this.playbackSpeed = 1;
      this.stop = () => {
        const { motionValue: motionValue2 } = this.options;
        if (motionValue2 && motionValue2.updatedAt !== time.now()) {
          this.tick(time.now());
        }
        this.isStopped = true;
        if (this.state === "idle")
          return;
        this.teardown();
        this.options.onStop?.();
      };
      activeAnimations.mainThread++;
      this.options = options;
      this.initAnimation();
      this.play();
      if (options.autoplay === false)
        this.pause();
    }
    initAnimation() {
      const { options } = this;
      replaceTransitionType(options);
      const { type = keyframes, repeat = 0, repeatDelay = 0, repeatType, velocity = 0 } = options;
      let { keyframes: keyframes$1 } = options;
      const generatorFactory = type || keyframes;
      if (process.env.NODE_ENV !== "production" && generatorFactory !== keyframes) {
        invariant(keyframes$1.length <= 2, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${keyframes$1}`, "spring-two-frames");
      }
      if (generatorFactory !== keyframes && typeof keyframes$1[0] !== "number") {
        this.mixKeyframes = pipe(percentToProgress, mix(keyframes$1[0], keyframes$1[1]));
        keyframes$1 = [0, 100];
      }
      const generator = generatorFactory({ ...options, keyframes: keyframes$1 });
      if (repeatType === "mirror") {
        this.mirroredGenerator = generatorFactory({
          ...options,
          keyframes: [...keyframes$1].reverse(),
          velocity: -velocity
        });
      }
      if (generator.calculatedDuration === null) {
        generator.calculatedDuration = calcGeneratorDuration(generator);
      }
      const { calculatedDuration } = generator;
      this.calculatedDuration = calculatedDuration;
      this.resolvedDuration = calculatedDuration + repeatDelay;
      this.totalDuration = this.resolvedDuration * (repeat + 1) - repeatDelay;
      this.generator = generator;
    }
    updateTime(timestamp) {
      const animationTime = Math.round(timestamp - this.startTime) * this.playbackSpeed;
      if (this.holdTime !== null) {
        this.currentTime = this.holdTime;
      } else {
        this.currentTime = animationTime;
      }
    }
    tick(timestamp, sample = false) {
      const { generator, totalDuration, mixKeyframes, mirroredGenerator, resolvedDuration, calculatedDuration } = this;
      if (this.startTime === null)
        return generator.next(0);
      const { delay: delay2 = 0, keyframes: keyframes2, repeat, repeatType, repeatDelay, type, onUpdate, finalKeyframe } = this.options;
      if (this.speed > 0) {
        this.startTime = Math.min(this.startTime, timestamp);
      } else if (this.speed < 0) {
        this.startTime = Math.min(timestamp - totalDuration / this.speed, this.startTime);
      }
      if (sample) {
        this.currentTime = timestamp;
      } else {
        this.updateTime(timestamp);
      }
      const timeWithoutDelay = this.currentTime - delay2 * (this.playbackSpeed >= 0 ? 1 : -1);
      const isInDelayPhase = this.playbackSpeed >= 0 ? timeWithoutDelay < 0 : timeWithoutDelay > totalDuration;
      this.currentTime = Math.max(timeWithoutDelay, 0);
      if (this.state === "finished" && this.holdTime === null) {
        this.currentTime = totalDuration;
      }
      let elapsed = this.currentTime;
      let frameGenerator = generator;
      if (repeat) {
        const progress2 = Math.min(this.currentTime, totalDuration) / resolvedDuration;
        let currentIteration = Math.floor(progress2);
        let iterationProgress = progress2 % 1;
        if (!iterationProgress && progress2 >= 1) {
          iterationProgress = 1;
        }
        iterationProgress === 1 && currentIteration--;
        currentIteration = Math.min(currentIteration, repeat + 1);
        const isOddIteration = Boolean(currentIteration % 2);
        if (isOddIteration) {
          if (repeatType === "reverse") {
            iterationProgress = 1 - iterationProgress;
            if (repeatDelay) {
              iterationProgress -= repeatDelay / resolvedDuration;
            }
          } else if (repeatType === "mirror") {
            frameGenerator = mirroredGenerator;
          }
        }
        elapsed = clamp(0, 1, iterationProgress) * resolvedDuration;
      }
      const state = isInDelayPhase ? { done: false, value: keyframes2[0] } : frameGenerator.next(elapsed);
      if (mixKeyframes) {
        state.value = mixKeyframes(state.value);
      }
      let { done } = state;
      if (!isInDelayPhase && calculatedDuration !== null) {
        done = this.playbackSpeed >= 0 ? this.currentTime >= totalDuration : this.currentTime <= 0;
      }
      const isAnimationFinished = this.holdTime === null && (this.state === "finished" || this.state === "running" && done);
      if (isAnimationFinished && type !== inertia) {
        state.value = getFinalKeyframe(keyframes2, this.options, finalKeyframe, this.speed);
      }
      if (onUpdate) {
        onUpdate(state.value);
      }
      if (isAnimationFinished) {
        this.finish();
      }
      return state;
    }
    /**
     * Allows the returned animation to be awaited or promise-chained. Currently
     * resolves when the animation finishes at all but in a future update could/should
     * reject if its cancels.
     */
    then(resolve, reject) {
      return this.finished.then(resolve, reject);
    }
    get duration() {
      return millisecondsToSeconds(this.calculatedDuration);
    }
    get iterationDuration() {
      const { delay: delay2 = 0 } = this.options || {};
      return this.duration + millisecondsToSeconds(delay2);
    }
    get time() {
      return millisecondsToSeconds(this.currentTime);
    }
    set time(newTime) {
      newTime = secondsToMilliseconds(newTime);
      this.currentTime = newTime;
      if (this.startTime === null || this.holdTime !== null || this.playbackSpeed === 0) {
        this.holdTime = newTime;
      } else if (this.driver) {
        this.startTime = this.driver.now() - newTime / this.playbackSpeed;
      }
      this.driver?.start(false);
    }
    get speed() {
      return this.playbackSpeed;
    }
    set speed(newSpeed) {
      this.updateTime(time.now());
      const hasChanged = this.playbackSpeed !== newSpeed;
      this.playbackSpeed = newSpeed;
      if (hasChanged) {
        this.time = millisecondsToSeconds(this.currentTime);
      }
    }
    play() {
      if (this.isStopped)
        return;
      const { driver = frameloopDriver, startTime } = this.options;
      if (!this.driver) {
        this.driver = driver((timestamp) => this.tick(timestamp));
      }
      this.options.onPlay?.();
      const now2 = this.driver.now();
      if (this.state === "finished") {
        this.updateFinished();
        this.startTime = now2;
      } else if (this.holdTime !== null) {
        this.startTime = now2 - this.holdTime;
      } else if (!this.startTime) {
        this.startTime = startTime ?? now2;
      }
      if (this.state === "finished" && this.speed < 0) {
        this.startTime += this.calculatedDuration;
      }
      this.holdTime = null;
      this.state = "running";
      this.driver.start();
    }
    pause() {
      this.state = "paused";
      this.updateTime(time.now());
      this.holdTime = this.currentTime;
    }
    complete() {
      if (this.state !== "running") {
        this.play();
      }
      this.state = "finished";
      this.holdTime = null;
    }
    finish() {
      this.notifyFinished();
      this.teardown();
      this.state = "finished";
      this.options.onComplete?.();
    }
    cancel() {
      this.holdTime = null;
      this.startTime = 0;
      this.tick(0);
      this.teardown();
      this.options.onCancel?.();
    }
    teardown() {
      this.state = "idle";
      this.stopDriver();
      this.startTime = this.holdTime = null;
      activeAnimations.mainThread--;
    }
    stopDriver() {
      if (!this.driver)
        return;
      this.driver.stop();
      this.driver = void 0;
    }
    sample(sampleTime) {
      this.startTime = 0;
      return this.tick(sampleTime, true);
    }
    attachTimeline(timeline) {
      if (this.options.allowFlatten) {
        this.options.type = "keyframes";
        this.options.ease = "linear";
        this.initAnimation();
      }
      this.driver?.stop();
      return timeline.observe(this);
    }
  };

  // ../../node_modules/motion-dom/dist/es/animation/keyframes/utils/fill-wildcards.mjs
  function fillWildcards(keyframes2) {
    for (let i3 = 1; i3 < keyframes2.length; i3++) {
      keyframes2[i3] ?? (keyframes2[i3] = keyframes2[i3 - 1]);
    }
  }

  // ../../node_modules/motion-dom/dist/es/render/dom/parse-transform.mjs
  var radToDeg = (rad) => rad * 180 / Math.PI;
  var rotate = (v2) => {
    const angle = radToDeg(Math.atan2(v2[1], v2[0]));
    return rebaseAngle(angle);
  };
  var matrix2dParsers = {
    x: 4,
    y: 5,
    translateX: 4,
    translateY: 5,
    scaleX: 0,
    scaleY: 3,
    scale: (v2) => (Math.abs(v2[0]) + Math.abs(v2[3])) / 2,
    rotate,
    rotateZ: rotate,
    skewX: (v2) => radToDeg(Math.atan(v2[1])),
    skewY: (v2) => radToDeg(Math.atan(v2[2])),
    skew: (v2) => (Math.abs(v2[1]) + Math.abs(v2[2])) / 2
  };
  var rebaseAngle = (angle) => {
    angle = angle % 360;
    if (angle < 0)
      angle += 360;
    return angle;
  };
  var rotateZ = rotate;
  var scaleX = (v2) => Math.sqrt(v2[0] * v2[0] + v2[1] * v2[1]);
  var scaleY = (v2) => Math.sqrt(v2[4] * v2[4] + v2[5] * v2[5]);
  var matrix3dParsers = {
    x: 12,
    y: 13,
    z: 14,
    translateX: 12,
    translateY: 13,
    translateZ: 14,
    scaleX,
    scaleY,
    scale: (v2) => (scaleX(v2) + scaleY(v2)) / 2,
    rotateX: (v2) => rebaseAngle(radToDeg(Math.atan2(v2[6], v2[5]))),
    rotateY: (v2) => rebaseAngle(radToDeg(Math.atan2(-v2[2], v2[0]))),
    rotateZ,
    rotate: rotateZ,
    skewX: (v2) => radToDeg(Math.atan(v2[4])),
    skewY: (v2) => radToDeg(Math.atan(v2[1])),
    skew: (v2) => (Math.abs(v2[1]) + Math.abs(v2[4])) / 2
  };
  function defaultTransformValue(name) {
    return name.includes("scale") ? 1 : 0;
  }
  function parseValueFromTransform(transform2, name) {
    if (!transform2 || transform2 === "none") {
      return defaultTransformValue(name);
    }
    const matrix3dMatch = transform2.match(/^matrix3d\(([-\d.e\s,]+)\)$/u);
    let parsers;
    let match2;
    if (matrix3dMatch) {
      parsers = matrix3dParsers;
      match2 = matrix3dMatch;
    } else {
      const matrix2dMatch = transform2.match(/^matrix\(([-\d.e\s,]+)\)$/u);
      parsers = matrix2dParsers;
      match2 = matrix2dMatch;
    }
    if (!match2) {
      return defaultTransformValue(name);
    }
    const valueParser = parsers[name];
    const values = match2[1].split(",").map(convertTransformToNumber);
    return typeof valueParser === "function" ? valueParser(values) : values[valueParser];
  }
  var readTransformValue = (instance, name) => {
    const { transform: transform2 = "none" } = getComputedStyle(instance);
    return parseValueFromTransform(transform2, name);
  };
  function convertTransformToNumber(value) {
    return parseFloat(value.trim());
  }

  // ../../node_modules/motion-dom/dist/es/render/utils/keys-transform.mjs
  var transformPropOrder = [
    "transformPerspective",
    "x",
    "y",
    "z",
    "translateX",
    "translateY",
    "translateZ",
    "scale",
    "scaleX",
    "scaleY",
    "rotate",
    "rotateX",
    "rotateY",
    "rotateZ",
    "skew",
    "skewX",
    "skewY"
  ];
  var transformProps = /* @__PURE__ */ (() => new Set(transformPropOrder))();

  // ../../node_modules/motion-dom/dist/es/animation/keyframes/utils/unit-conversion.mjs
  var isNumOrPxType = (v2) => v2 === number || v2 === px;
  var transformKeys = /* @__PURE__ */ new Set(["x", "y", "z"]);
  var nonTranslationalTransformKeys = transformPropOrder.filter((key) => !transformKeys.has(key));
  function removeNonTranslationalTransform(visualElement) {
    const removedTransforms = [];
    nonTranslationalTransformKeys.forEach((key) => {
      const value = visualElement.getValue(key);
      if (value !== void 0) {
        removedTransforms.push([key, value.get()]);
        value.set(key.startsWith("scale") ? 1 : 0);
      }
    });
    return removedTransforms;
  }
  var positionalValues = {
    // Dimensions
    width: ({ x: x2 }, { paddingLeft = "0", paddingRight = "0" }) => x2.max - x2.min - parseFloat(paddingLeft) - parseFloat(paddingRight),
    height: ({ y: y2 }, { paddingTop = "0", paddingBottom = "0" }) => y2.max - y2.min - parseFloat(paddingTop) - parseFloat(paddingBottom),
    top: (_bbox, { top }) => parseFloat(top),
    left: (_bbox, { left }) => parseFloat(left),
    bottom: ({ y: y2 }, { top }) => parseFloat(top) + (y2.max - y2.min),
    right: ({ x: x2 }, { left }) => parseFloat(left) + (x2.max - x2.min),
    // Transform
    x: (_bbox, { transform: transform2 }) => parseValueFromTransform(transform2, "x"),
    y: (_bbox, { transform: transform2 }) => parseValueFromTransform(transform2, "y")
  };
  positionalValues.translateX = positionalValues.x;
  positionalValues.translateY = positionalValues.y;

  // ../../node_modules/motion-dom/dist/es/animation/keyframes/KeyframesResolver.mjs
  var toResolve = /* @__PURE__ */ new Set();
  var isScheduled = false;
  var anyNeedsMeasurement = false;
  var isForced = false;
  function measureAllKeyframes() {
    if (anyNeedsMeasurement) {
      const resolversToMeasure = Array.from(toResolve).filter((resolver) => resolver.needsMeasurement);
      const elementsToMeasure = new Set(resolversToMeasure.map((resolver) => resolver.element));
      const transformsToRestore = /* @__PURE__ */ new Map();
      elementsToMeasure.forEach((element) => {
        const removedTransforms = removeNonTranslationalTransform(element);
        if (!removedTransforms.length)
          return;
        transformsToRestore.set(element, removedTransforms);
        element.render();
      });
      resolversToMeasure.forEach((resolver) => resolver.measureInitialState());
      elementsToMeasure.forEach((element) => {
        element.render();
        const restore = transformsToRestore.get(element);
        if (restore) {
          restore.forEach(([key, value]) => {
            element.getValue(key)?.set(value);
          });
        }
      });
      resolversToMeasure.forEach((resolver) => resolver.measureEndState());
      resolversToMeasure.forEach((resolver) => {
        if (resolver.suspendedScrollY !== void 0) {
          window.scrollTo(0, resolver.suspendedScrollY);
        }
      });
    }
    anyNeedsMeasurement = false;
    isScheduled = false;
    toResolve.forEach((resolver) => resolver.complete(isForced));
    toResolve.clear();
  }
  function readAllKeyframes() {
    toResolve.forEach((resolver) => {
      resolver.readKeyframes();
      if (resolver.needsMeasurement) {
        anyNeedsMeasurement = true;
      }
    });
  }
  function flushKeyframeResolvers() {
    isForced = true;
    readAllKeyframes();
    measureAllKeyframes();
    isForced = false;
  }
  var KeyframeResolver = class {
    constructor(unresolvedKeyframes, onComplete, name, motionValue2, element, isAsync = false) {
      this.state = "pending";
      this.isAsync = false;
      this.needsMeasurement = false;
      this.unresolvedKeyframes = [...unresolvedKeyframes];
      this.onComplete = onComplete;
      this.name = name;
      this.motionValue = motionValue2;
      this.element = element;
      this.isAsync = isAsync;
    }
    scheduleResolve() {
      this.state = "scheduled";
      if (this.isAsync) {
        toResolve.add(this);
        if (!isScheduled) {
          isScheduled = true;
          frame.read(readAllKeyframes);
          frame.resolveKeyframes(measureAllKeyframes);
        }
      } else {
        this.readKeyframes();
        this.complete();
      }
    }
    readKeyframes() {
      const { unresolvedKeyframes, name, element, motionValue: motionValue2 } = this;
      if (unresolvedKeyframes[0] === null) {
        const currentValue = motionValue2?.get();
        const finalKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];
        if (currentValue !== void 0) {
          unresolvedKeyframes[0] = currentValue;
        } else if (element && name) {
          const valueAsRead = element.readValue(name, finalKeyframe);
          if (valueAsRead !== void 0 && valueAsRead !== null) {
            unresolvedKeyframes[0] = valueAsRead;
          }
        }
        if (unresolvedKeyframes[0] === void 0) {
          unresolvedKeyframes[0] = finalKeyframe;
        }
        if (motionValue2 && currentValue === void 0) {
          motionValue2.set(unresolvedKeyframes[0]);
        }
      }
      fillWildcards(unresolvedKeyframes);
    }
    setFinalKeyframe() {
    }
    measureInitialState() {
    }
    renderEndStyles() {
    }
    measureEndState() {
    }
    complete(isForcedComplete = false) {
      this.state = "complete";
      this.onComplete(this.unresolvedKeyframes, this.finalKeyframe, isForcedComplete);
      toResolve.delete(this);
    }
    cancel() {
      if (this.state === "scheduled") {
        toResolve.delete(this);
        this.state = "pending";
      }
    }
    resume() {
      if (this.state === "pending")
        this.scheduleResolve();
    }
  };

  // ../../node_modules/motion-dom/dist/es/render/dom/is-css-var.mjs
  var isCSSVar = (name) => name.startsWith("--");

  // ../../node_modules/motion-dom/dist/es/render/dom/style-set.mjs
  function setStyle(element, name, value) {
    isCSSVar(name) ? element.style.setProperty(name, value) : element.style[name] = value;
  }

  // ../../node_modules/motion-dom/dist/es/utils/supports/scroll-timeline.mjs
  var supportsScrollTimeline = /* @__PURE__ */ memo(() => window.ScrollTimeline !== void 0);

  // ../../node_modules/motion-dom/dist/es/utils/supports/flags.mjs
  var supportsFlags = {};

  // ../../node_modules/motion-dom/dist/es/utils/supports/memo.mjs
  function memoSupports(callback, supportsFlag) {
    const memoized = memo(callback);
    return () => supportsFlags[supportsFlag] ?? memoized();
  }

  // ../../node_modules/motion-dom/dist/es/utils/supports/linear-easing.mjs
  var supportsLinearEasing = /* @__PURE__ */ memoSupports(() => {
    try {
      document.createElement("div").animate({ opacity: 0 }, { easing: "linear(0, 1)" });
    } catch (e2) {
      return false;
    }
    return true;
  }, "linearEasing");

  // ../../node_modules/motion-dom/dist/es/animation/waapi/easing/cubic-bezier.mjs
  var cubicBezierAsString = ([a, b2, c, d]) => `cubic-bezier(${a}, ${b2}, ${c}, ${d})`;

  // ../../node_modules/motion-dom/dist/es/animation/waapi/easing/supported.mjs
  var supportedWaapiEasing = {
    linear: "linear",
    ease: "ease",
    easeIn: "ease-in",
    easeOut: "ease-out",
    easeInOut: "ease-in-out",
    circIn: /* @__PURE__ */ cubicBezierAsString([0, 0.65, 0.55, 1]),
    circOut: /* @__PURE__ */ cubicBezierAsString([0.55, 0, 1, 0.45]),
    backIn: /* @__PURE__ */ cubicBezierAsString([0.31, 0.01, 0.66, -0.59]),
    backOut: /* @__PURE__ */ cubicBezierAsString([0.33, 1.53, 0.69, 0.99])
  };

  // ../../node_modules/motion-dom/dist/es/animation/waapi/easing/map-easing.mjs
  function mapEasingToNativeEasing(easing, duration) {
    if (!easing) {
      return void 0;
    } else if (typeof easing === "function") {
      return supportsLinearEasing() ? generateLinearEasing(easing, duration) : "ease-out";
    } else if (isBezierDefinition(easing)) {
      return cubicBezierAsString(easing);
    } else if (Array.isArray(easing)) {
      return easing.map((segmentEasing) => mapEasingToNativeEasing(segmentEasing, duration) || supportedWaapiEasing.easeOut);
    } else {
      return supportedWaapiEasing[easing];
    }
  }

  // ../../node_modules/motion-dom/dist/es/animation/waapi/start-waapi-animation.mjs
  function startWaapiAnimation(element, valueName, keyframes2, { delay: delay2 = 0, duration = 300, repeat = 0, repeatType = "loop", ease: ease2 = "easeOut", times } = {}, pseudoElement = void 0) {
    const keyframeOptions = {
      [valueName]: keyframes2
    };
    if (times)
      keyframeOptions.offset = times;
    const easing = mapEasingToNativeEasing(ease2, duration);
    if (Array.isArray(easing))
      keyframeOptions.easing = easing;
    if (statsBuffer.value) {
      activeAnimations.waapi++;
    }
    const options = {
      delay: delay2,
      duration,
      easing: !Array.isArray(easing) ? easing : "linear",
      fill: "both",
      iterations: repeat + 1,
      direction: repeatType === "reverse" ? "alternate" : "normal"
    };
    if (pseudoElement)
      options.pseudoElement = pseudoElement;
    const animation = element.animate(keyframeOptions, options);
    if (statsBuffer.value) {
      animation.finished.finally(() => {
        activeAnimations.waapi--;
      });
    }
    return animation;
  }

  // ../../node_modules/motion-dom/dist/es/animation/generators/utils/is-generator.mjs
  function isGenerator(type) {
    return typeof type === "function" && "applyToOptions" in type;
  }

  // ../../node_modules/motion-dom/dist/es/animation/waapi/utils/apply-generator.mjs
  function applyGeneratorOptions({ type, ...options }) {
    if (isGenerator(type) && supportsLinearEasing()) {
      return type.applyToOptions(options);
    } else {
      options.duration ?? (options.duration = 300);
      options.ease ?? (options.ease = "easeOut");
    }
    return options;
  }

  // ../../node_modules/motion-dom/dist/es/animation/NativeAnimation.mjs
  var NativeAnimation = class extends WithPromise {
    constructor(options) {
      super();
      this.finishedTime = null;
      this.isStopped = false;
      this.manualStartTime = null;
      if (!options)
        return;
      const { element, name, keyframes: keyframes2, pseudoElement, allowFlatten = false, finalKeyframe, onComplete } = options;
      this.isPseudoElement = Boolean(pseudoElement);
      this.allowFlatten = allowFlatten;
      this.options = options;
      invariant(typeof options.type !== "string", `Mini animate() doesn't support "type" as a string.`, "mini-spring");
      const transition = applyGeneratorOptions(options);
      this.animation = startWaapiAnimation(element, name, keyframes2, transition, pseudoElement);
      if (transition.autoplay === false) {
        this.animation.pause();
      }
      this.animation.onfinish = () => {
        this.finishedTime = this.time;
        if (!pseudoElement) {
          const keyframe = getFinalKeyframe(keyframes2, this.options, finalKeyframe, this.speed);
          if (this.updateMotionValue) {
            this.updateMotionValue(keyframe);
          } else {
            setStyle(element, name, keyframe);
          }
          this.animation.cancel();
        }
        onComplete?.();
        this.notifyFinished();
      };
    }
    play() {
      if (this.isStopped)
        return;
      this.manualStartTime = null;
      this.animation.play();
      if (this.state === "finished") {
        this.updateFinished();
      }
    }
    pause() {
      this.animation.pause();
    }
    complete() {
      this.animation.finish?.();
    }
    cancel() {
      try {
        this.animation.cancel();
      } catch (e2) {
      }
    }
    stop() {
      if (this.isStopped)
        return;
      this.isStopped = true;
      const { state } = this;
      if (state === "idle" || state === "finished") {
        return;
      }
      if (this.updateMotionValue) {
        this.updateMotionValue();
      } else {
        this.commitStyles();
      }
      if (!this.isPseudoElement)
        this.cancel();
    }
    /**
     * WAAPI doesn't natively have any interruption capabilities.
     *
     * In this method, we commit styles back to the DOM before cancelling
     * the animation.
     *
     * This is designed to be overridden by NativeAnimationExtended, which
     * will create a renderless JS animation and sample it twice to calculate
     * its current value, "previous" value, and therefore allow
     * Motion to also correctly calculate velocity for any subsequent animation
     * while deferring the commit until the next animation frame.
     */
    commitStyles() {
      if (!this.isPseudoElement) {
        this.animation.commitStyles?.();
      }
    }
    get duration() {
      const duration = this.animation.effect?.getComputedTiming?.().duration || 0;
      return millisecondsToSeconds(Number(duration));
    }
    get iterationDuration() {
      const { delay: delay2 = 0 } = this.options || {};
      return this.duration + millisecondsToSeconds(delay2);
    }
    get time() {
      return millisecondsToSeconds(Number(this.animation.currentTime) || 0);
    }
    set time(newTime) {
      this.manualStartTime = null;
      this.finishedTime = null;
      this.animation.currentTime = secondsToMilliseconds(newTime);
    }
    /**
     * The playback speed of the animation.
     * 1 = normal speed, 2 = double speed, 0.5 = half speed.
     */
    get speed() {
      return this.animation.playbackRate;
    }
    set speed(newSpeed) {
      if (newSpeed < 0)
        this.finishedTime = null;
      this.animation.playbackRate = newSpeed;
    }
    get state() {
      return this.finishedTime !== null ? "finished" : this.animation.playState;
    }
    get startTime() {
      return this.manualStartTime ?? Number(this.animation.startTime);
    }
    set startTime(newStartTime) {
      this.manualStartTime = this.animation.startTime = newStartTime;
    }
    /**
     * Attaches a timeline to the animation, for instance the `ScrollTimeline`.
     */
    attachTimeline({ timeline, observe }) {
      if (this.allowFlatten) {
        this.animation.effect?.updateTiming({ easing: "linear" });
      }
      this.animation.onfinish = null;
      if (timeline && supportsScrollTimeline()) {
        this.animation.timeline = timeline;
        return noop;
      } else {
        return observe(this);
      }
    }
  };

  // ../../node_modules/motion-dom/dist/es/animation/waapi/utils/unsupported-easing.mjs
  var unsupportedEasingFunctions = {
    anticipate,
    backInOut,
    circInOut
  };
  function isUnsupportedEase(key) {
    return key in unsupportedEasingFunctions;
  }
  function replaceStringEasing(transition) {
    if (typeof transition.ease === "string" && isUnsupportedEase(transition.ease)) {
      transition.ease = unsupportedEasingFunctions[transition.ease];
    }
  }

  // ../../node_modules/motion-dom/dist/es/animation/NativeAnimationExtended.mjs
  var sampleDelta = 10;
  var NativeAnimationExtended = class extends NativeAnimation {
    constructor(options) {
      replaceStringEasing(options);
      replaceTransitionType(options);
      super(options);
      if (options.startTime !== void 0) {
        this.startTime = options.startTime;
      }
      this.options = options;
    }
    /**
     * WAAPI doesn't natively have any interruption capabilities.
     *
     * Rather than read committed styles back out of the DOM, we can
     * create a renderless JS animation and sample it twice to calculate
     * its current value, "previous" value, and therefore allow
     * Motion to calculate velocity for any subsequent animation.
     */
    updateMotionValue(value) {
      const { motionValue: motionValue2, onUpdate, onComplete, element, ...options } = this.options;
      if (!motionValue2)
        return;
      if (value !== void 0) {
        motionValue2.set(value);
        return;
      }
      const sampleAnimation = new JSAnimation({
        ...options,
        autoplay: false
      });
      const sampleTime = Math.max(sampleDelta, time.now() - this.startTime);
      const delta = clamp(0, sampleDelta, sampleTime - sampleDelta);
      motionValue2.setWithVelocity(sampleAnimation.sample(Math.max(0, sampleTime - delta)).value, sampleAnimation.sample(sampleTime).value, delta);
      sampleAnimation.stop();
    }
  };

  // ../../node_modules/motion-dom/dist/es/animation/utils/is-animatable.mjs
  var isAnimatable = (value, name) => {
    if (name === "zIndex")
      return false;
    if (typeof value === "number" || Array.isArray(value))
      return true;
    if (typeof value === "string" && // It's animatable if we have a string
    (complex.test(value) || value === "0") && // And it contains numbers and/or colors
    !value.startsWith("url(")) {
      return true;
    }
    return false;
  };

  // ../../node_modules/motion-dom/dist/es/animation/utils/can-animate.mjs
  function hasKeyframesChanged(keyframes2) {
    const current = keyframes2[0];
    if (keyframes2.length === 1)
      return true;
    for (let i3 = 0; i3 < keyframes2.length; i3++) {
      if (keyframes2[i3] !== current)
        return true;
    }
  }
  function canAnimate(keyframes2, name, type, velocity) {
    const originKeyframe = keyframes2[0];
    if (originKeyframe === null)
      return false;
    if (name === "display" || name === "visibility")
      return true;
    const targetKeyframe = keyframes2[keyframes2.length - 1];
    const isOriginAnimatable = isAnimatable(originKeyframe, name);
    const isTargetAnimatable = isAnimatable(targetKeyframe, name);
    warning(isOriginAnimatable === isTargetAnimatable, `You are trying to animate ${name} from "${originKeyframe}" to "${targetKeyframe}". "${isOriginAnimatable ? targetKeyframe : originKeyframe}" is not an animatable value.`, "value-not-animatable");
    if (!isOriginAnimatable || !isTargetAnimatable) {
      return false;
    }
    return hasKeyframesChanged(keyframes2) || (type === "spring" || isGenerator(type)) && velocity;
  }

  // ../../node_modules/motion-dom/dist/es/animation/utils/make-animation-instant.mjs
  function makeAnimationInstant(options) {
    options.duration = 0;
    options.type = "keyframes";
  }

  // ../../node_modules/motion-dom/dist/es/animation/waapi/supports/waapi.mjs
  var acceleratedValues = /* @__PURE__ */ new Set([
    "opacity",
    "clipPath",
    "filter",
    "transform"
    // TODO: Could be re-enabled now we have support for linear() easing
    // "background-color"
  ]);
  var supportsWaapi = /* @__PURE__ */ memo(() => Object.hasOwnProperty.call(Element.prototype, "animate"));
  function supportsBrowserAnimation(options) {
    const { motionValue: motionValue2, name, repeatDelay, repeatType, damping, type } = options;
    const subject = motionValue2?.owner?.current;
    if (!(subject instanceof HTMLElement)) {
      return false;
    }
    const { onUpdate, transformTemplate } = motionValue2.owner.getProps();
    return supportsWaapi() && name && acceleratedValues.has(name) && (name !== "transform" || !transformTemplate) && /**
     * If we're outputting values to onUpdate then we can't use WAAPI as there's
     * no way to read the value from WAAPI every frame.
     */
    !onUpdate && !repeatDelay && repeatType !== "mirror" && damping !== 0 && type !== "inertia";
  }

  // ../../node_modules/motion-dom/dist/es/animation/AsyncMotionValueAnimation.mjs
  var MAX_RESOLVE_DELAY = 40;
  var AsyncMotionValueAnimation = class extends WithPromise {
    constructor({ autoplay = true, delay: delay2 = 0, type = "keyframes", repeat = 0, repeatDelay = 0, repeatType = "loop", keyframes: keyframes2, name, motionValue: motionValue2, element, ...options }) {
      super();
      this.stop = () => {
        if (this._animation) {
          this._animation.stop();
          this.stopTimeline?.();
        }
        this.keyframeResolver?.cancel();
      };
      this.createdAt = time.now();
      const optionsWithDefaults = {
        autoplay,
        delay: delay2,
        type,
        repeat,
        repeatDelay,
        repeatType,
        name,
        motionValue: motionValue2,
        element,
        ...options
      };
      const KeyframeResolver$1 = element?.KeyframeResolver || KeyframeResolver;
      this.keyframeResolver = new KeyframeResolver$1(keyframes2, (resolvedKeyframes, finalKeyframe, forced) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe, optionsWithDefaults, !forced), name, motionValue2, element);
      this.keyframeResolver?.scheduleResolve();
    }
    onKeyframesResolved(keyframes2, finalKeyframe, options, sync2) {
      this.keyframeResolver = void 0;
      const { name, type, velocity, delay: delay2, isHandoff, onUpdate } = options;
      this.resolvedAt = time.now();
      if (!canAnimate(keyframes2, name, type, velocity)) {
        if (MotionGlobalConfig.instantAnimations || !delay2) {
          onUpdate?.(getFinalKeyframe(keyframes2, options, finalKeyframe));
        }
        keyframes2[0] = keyframes2[keyframes2.length - 1];
        makeAnimationInstant(options);
        options.repeat = 0;
      }
      const startTime = sync2 ? !this.resolvedAt ? this.createdAt : this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY ? this.resolvedAt : this.createdAt : void 0;
      const resolvedOptions = {
        startTime,
        finalKeyframe,
        ...options,
        keyframes: keyframes2
      };
      const animation = !isHandoff && supportsBrowserAnimation(resolvedOptions) ? new NativeAnimationExtended({
        ...resolvedOptions,
        element: resolvedOptions.motionValue.owner.current
      }) : new JSAnimation(resolvedOptions);
      animation.finished.then(() => this.notifyFinished()).catch(noop);
      if (this.pendingTimeline) {
        this.stopTimeline = animation.attachTimeline(this.pendingTimeline);
        this.pendingTimeline = void 0;
      }
      this._animation = animation;
    }
    get finished() {
      if (!this._animation) {
        return this._finished;
      } else {
        return this.animation.finished;
      }
    }
    then(onResolve, _onReject) {
      return this.finished.finally(onResolve).then(() => {
      });
    }
    get animation() {
      if (!this._animation) {
        this.keyframeResolver?.resume();
        flushKeyframeResolvers();
      }
      return this._animation;
    }
    get duration() {
      return this.animation.duration;
    }
    get iterationDuration() {
      return this.animation.iterationDuration;
    }
    get time() {
      return this.animation.time;
    }
    set time(newTime) {
      this.animation.time = newTime;
    }
    get speed() {
      return this.animation.speed;
    }
    get state() {
      return this.animation.state;
    }
    set speed(newSpeed) {
      this.animation.speed = newSpeed;
    }
    get startTime() {
      return this.animation.startTime;
    }
    attachTimeline(timeline) {
      if (this._animation) {
        this.stopTimeline = this.animation.attachTimeline(timeline);
      } else {
        this.pendingTimeline = timeline;
      }
      return () => this.stop();
    }
    play() {
      this.animation.play();
    }
    pause() {
      this.animation.pause();
    }
    complete() {
      this.animation.complete();
    }
    cancel() {
      if (this._animation) {
        this.animation.cancel();
      }
      this.keyframeResolver?.cancel();
    }
  };

  // ../../node_modules/motion-dom/dist/es/animation/utils/css-variables-conversion.mjs
  var splitCSSVariableRegex = (
    // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words
    /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u
  );
  function parseCSSVariable(current) {
    const match2 = splitCSSVariableRegex.exec(current);
    if (!match2)
      return [,];
    const [, token1, token2, fallback] = match2;
    return [`--${token1 ?? token2}`, fallback];
  }
  var maxDepth = 4;
  function getVariableValue(current, element, depth = 1) {
    invariant(depth <= maxDepth, `Max CSS variable fallback depth detected in property "${current}". This may indicate a circular fallback dependency.`, "max-css-var-depth");
    const [token, fallback] = parseCSSVariable(current);
    if (!token)
      return;
    const resolved = window.getComputedStyle(element).getPropertyValue(token);
    if (resolved) {
      const trimmed = resolved.trim();
      return isNumericalString(trimmed) ? parseFloat(trimmed) : trimmed;
    }
    return isCSSVariableToken(fallback) ? getVariableValue(fallback, element, depth + 1) : fallback;
  }

  // ../../node_modules/motion-dom/dist/es/animation/utils/get-value-transition.mjs
  function getValueTransition(transition, key) {
    return transition?.[key] ?? transition?.["default"] ?? transition;
  }

  // ../../node_modules/motion-dom/dist/es/render/utils/keys-position.mjs
  var positionalKeys = /* @__PURE__ */ new Set([
    "width",
    "height",
    "top",
    "left",
    "right",
    "bottom",
    ...transformPropOrder
  ]);

  // ../../node_modules/motion-dom/dist/es/value/types/auto.mjs
  var auto = {
    test: (v2) => v2 === "auto",
    parse: (v2) => v2
  };

  // ../../node_modules/motion-dom/dist/es/value/types/test.mjs
  var testValueType = (v2) => (type) => type.test(v2);

  // ../../node_modules/motion-dom/dist/es/value/types/dimensions.mjs
  var dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto];
  var findDimensionValueType = (v2) => dimensionValueTypes.find(testValueType(v2));

  // ../../node_modules/motion-dom/dist/es/animation/keyframes/utils/is-none.mjs
  function isNone(value) {
    if (typeof value === "number") {
      return value === 0;
    } else if (value !== null) {
      return value === "none" || value === "0" || isZeroValueString(value);
    } else {
      return true;
    }
  }

  // ../../node_modules/motion-dom/dist/es/value/types/complex/filter.mjs
  var maxDefaults = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
  function applyDefaultFilter(v2) {
    const [name, value] = v2.slice(0, -1).split("(");
    if (name === "drop-shadow")
      return v2;
    const [number2] = value.match(floatRegex) || [];
    if (!number2)
      return v2;
    const unit = value.replace(number2, "");
    let defaultValue = maxDefaults.has(name) ? 1 : 0;
    if (number2 !== value)
      defaultValue *= 100;
    return name + "(" + defaultValue + unit + ")";
  }
  var functionRegex = /\b([a-z-]*)\(.*?\)/gu;
  var filter = {
    ...complex,
    getAnimatableNone: (v2) => {
      const functions = v2.match(functionRegex);
      return functions ? functions.map(applyDefaultFilter).join(" ") : v2;
    }
  };

  // ../../node_modules/motion-dom/dist/es/value/types/int.mjs
  var int = {
    ...number,
    transform: Math.round
  };

  // ../../node_modules/motion-dom/dist/es/value/types/maps/transform.mjs
  var transformValueTypes = {
    rotate: degrees,
    rotateX: degrees,
    rotateY: degrees,
    rotateZ: degrees,
    scale,
    scaleX: scale,
    scaleY: scale,
    scaleZ: scale,
    skew: degrees,
    skewX: degrees,
    skewY: degrees,
    distance: px,
    translateX: px,
    translateY: px,
    translateZ: px,
    x: px,
    y: px,
    z: px,
    perspective: px,
    transformPerspective: px,
    opacity: alpha,
    originX: progressPercentage,
    originY: progressPercentage,
    originZ: px
  };

  // ../../node_modules/motion-dom/dist/es/value/types/maps/number.mjs
  var numberValueTypes = {
    // Border props
    borderWidth: px,
    borderTopWidth: px,
    borderRightWidth: px,
    borderBottomWidth: px,
    borderLeftWidth: px,
    borderRadius: px,
    radius: px,
    borderTopLeftRadius: px,
    borderTopRightRadius: px,
    borderBottomRightRadius: px,
    borderBottomLeftRadius: px,
    // Positioning props
    width: px,
    maxWidth: px,
    height: px,
    maxHeight: px,
    top: px,
    right: px,
    bottom: px,
    left: px,
    inset: px,
    insetBlock: px,
    insetBlockStart: px,
    insetBlockEnd: px,
    insetInline: px,
    insetInlineStart: px,
    insetInlineEnd: px,
    // Spacing props
    padding: px,
    paddingTop: px,
    paddingRight: px,
    paddingBottom: px,
    paddingLeft: px,
    paddingBlock: px,
    paddingBlockStart: px,
    paddingBlockEnd: px,
    paddingInline: px,
    paddingInlineStart: px,
    paddingInlineEnd: px,
    margin: px,
    marginTop: px,
    marginRight: px,
    marginBottom: px,
    marginLeft: px,
    marginBlock: px,
    marginBlockStart: px,
    marginBlockEnd: px,
    marginInline: px,
    marginInlineStart: px,
    marginInlineEnd: px,
    // Misc
    backgroundPositionX: px,
    backgroundPositionY: px,
    ...transformValueTypes,
    zIndex: int,
    // SVG
    fillOpacity: alpha,
    strokeOpacity: alpha,
    numOctaves: int
  };

  // ../../node_modules/motion-dom/dist/es/value/types/maps/defaults.mjs
  var defaultValueTypes = {
    ...numberValueTypes,
    // Color props
    color,
    backgroundColor: color,
    outlineColor: color,
    fill: color,
    stroke: color,
    // Border props
    borderColor: color,
    borderTopColor: color,
    borderRightColor: color,
    borderBottomColor: color,
    borderLeftColor: color,
    filter,
    WebkitFilter: filter
  };
  var getDefaultValueType = (key) => defaultValueTypes[key];

  // ../../node_modules/motion-dom/dist/es/value/types/utils/animatable-none.mjs
  function getAnimatableNone2(key, value) {
    let defaultValueType = getDefaultValueType(key);
    if (defaultValueType !== filter)
      defaultValueType = complex;
    return defaultValueType.getAnimatableNone ? defaultValueType.getAnimatableNone(value) : void 0;
  }

  // ../../node_modules/motion-dom/dist/es/animation/keyframes/utils/make-none-animatable.mjs
  var invalidTemplates = /* @__PURE__ */ new Set(["auto", "none", "0"]);
  function makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name) {
    let i3 = 0;
    let animatableTemplate = void 0;
    while (i3 < unresolvedKeyframes.length && !animatableTemplate) {
      const keyframe = unresolvedKeyframes[i3];
      if (typeof keyframe === "string" && !invalidTemplates.has(keyframe) && analyseComplexValue(keyframe).values.length) {
        animatableTemplate = unresolvedKeyframes[i3];
      }
      i3++;
    }
    if (animatableTemplate && name) {
      for (const noneIndex of noneKeyframeIndexes) {
        unresolvedKeyframes[noneIndex] = getAnimatableNone2(name, animatableTemplate);
      }
    }
  }

  // ../../node_modules/motion-dom/dist/es/animation/keyframes/DOMKeyframesResolver.mjs
  var DOMKeyframesResolver = class extends KeyframeResolver {
    constructor(unresolvedKeyframes, onComplete, name, motionValue2, element) {
      super(unresolvedKeyframes, onComplete, name, motionValue2, element, true);
    }
    readKeyframes() {
      const { unresolvedKeyframes, element, name } = this;
      if (!element || !element.current)
        return;
      super.readKeyframes();
      for (let i3 = 0; i3 < unresolvedKeyframes.length; i3++) {
        let keyframe = unresolvedKeyframes[i3];
        if (typeof keyframe === "string") {
          keyframe = keyframe.trim();
          if (isCSSVariableToken(keyframe)) {
            const resolved = getVariableValue(keyframe, element.current);
            if (resolved !== void 0) {
              unresolvedKeyframes[i3] = resolved;
            }
            if (i3 === unresolvedKeyframes.length - 1) {
              this.finalKeyframe = keyframe;
            }
          }
        }
      }
      this.resolveNoneKeyframes();
      if (!positionalKeys.has(name) || unresolvedKeyframes.length !== 2) {
        return;
      }
      const [origin, target] = unresolvedKeyframes;
      const originType = findDimensionValueType(origin);
      const targetType = findDimensionValueType(target);
      const originHasVar = containsCSSVariable(origin);
      const targetHasVar = containsCSSVariable(target);
      if (originHasVar !== targetHasVar && positionalValues[name]) {
        this.needsMeasurement = true;
        return;
      }
      if (originType === targetType)
        return;
      if (isNumOrPxType(originType) && isNumOrPxType(targetType)) {
        for (let i3 = 0; i3 < unresolvedKeyframes.length; i3++) {
          const value = unresolvedKeyframes[i3];
          if (typeof value === "string") {
            unresolvedKeyframes[i3] = parseFloat(value);
          }
        }
      } else if (positionalValues[name]) {
        this.needsMeasurement = true;
      }
    }
    resolveNoneKeyframes() {
      const { unresolvedKeyframes, name } = this;
      const noneKeyframeIndexes = [];
      for (let i3 = 0; i3 < unresolvedKeyframes.length; i3++) {
        if (unresolvedKeyframes[i3] === null || isNone(unresolvedKeyframes[i3])) {
          noneKeyframeIndexes.push(i3);
        }
      }
      if (noneKeyframeIndexes.length) {
        makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name);
      }
    }
    measureInitialState() {
      const { element, unresolvedKeyframes, name } = this;
      if (!element || !element.current)
        return;
      if (name === "height") {
        this.suspendedScrollY = window.pageYOffset;
      }
      this.measuredOrigin = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));
      unresolvedKeyframes[0] = this.measuredOrigin;
      const measureKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];
      if (measureKeyframe !== void 0) {
        element.getValue(name, measureKeyframe).jump(measureKeyframe, false);
      }
    }
    measureEndState() {
      const { element, name, unresolvedKeyframes } = this;
      if (!element || !element.current)
        return;
      const value = element.getValue(name);
      value && value.jump(this.measuredOrigin, false);
      const finalKeyframeIndex = unresolvedKeyframes.length - 1;
      const finalKeyframe = unresolvedKeyframes[finalKeyframeIndex];
      unresolvedKeyframes[finalKeyframeIndex] = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));
      if (finalKeyframe !== null && this.finalKeyframe === void 0) {
        this.finalKeyframe = finalKeyframe;
      }
      if (this.removedTransforms?.length) {
        this.removedTransforms.forEach(([unsetTransformName, unsetTransformValue]) => {
          element.getValue(unsetTransformName).set(unsetTransformValue);
        });
      }
      this.resolveNoneKeyframes();
    }
  };

  // ../../node_modules/motion-dom/dist/es/utils/resolve-elements.mjs
  function resolveElements(elementOrSelector, scope, selectorCache) {
    if (elementOrSelector instanceof EventTarget) {
      return [elementOrSelector];
    } else if (typeof elementOrSelector === "string") {
      let root = document;
      if (scope) {
        root = scope.current;
      }
      const elements = selectorCache?.[elementOrSelector] ?? root.querySelectorAll(elementOrSelector);
      return elements ? Array.from(elements) : [];
    }
    return Array.from(elementOrSelector);
  }

  // ../../node_modules/motion-dom/dist/es/value/types/utils/get-as-type.mjs
  var getValueAsType = (value, type) => {
    return type && typeof value === "number" ? type.transform(value) : value;
  };

  // ../../node_modules/motion-dom/dist/es/utils/is-html-element.mjs
  function isHTMLElement(element) {
    return isObject(element) && "offsetHeight" in element;
  }

  // ../../node_modules/motion-dom/dist/es/value/index.mjs
  var MAX_VELOCITY_DELTA = 30;
  var isFloat = (value) => {
    return !isNaN(parseFloat(value));
  };
  var collectMotionValues = {
    current: void 0
  };
  var MotionValue = class {
    /**
     * @param init - The initiating value
     * @param config - Optional configuration options
     *
     * -  `transformer`: A function to transform incoming values with.
     */
    constructor(init, options = {}) {
      this.canTrackVelocity = null;
      this.events = {};
      this.updateAndNotify = (v2) => {
        const currentTime = time.now();
        if (this.updatedAt !== currentTime) {
          this.setPrevFrameValue();
        }
        this.prev = this.current;
        this.setCurrent(v2);
        if (this.current !== this.prev) {
          this.events.change?.notify(this.current);
          if (this.dependents) {
            for (const dependent of this.dependents) {
              dependent.dirty();
            }
          }
        }
      };
      this.hasAnimated = false;
      this.setCurrent(init);
      this.owner = options.owner;
    }
    setCurrent(current) {
      this.current = current;
      this.updatedAt = time.now();
      if (this.canTrackVelocity === null && current !== void 0) {
        this.canTrackVelocity = isFloat(this.current);
      }
    }
    setPrevFrameValue(prevFrameValue = this.current) {
      this.prevFrameValue = prevFrameValue;
      this.prevUpdatedAt = this.updatedAt;
    }
    /**
     * Adds a function that will be notified when the `MotionValue` is updated.
     *
     * It returns a function that, when called, will cancel the subscription.
     *
     * When calling `onChange` inside a React component, it should be wrapped with the
     * `useEffect` hook. As it returns an unsubscribe function, this should be returned
     * from the `useEffect` function to ensure you don't add duplicate subscribers..
     *
     * ```jsx
     * export const MyComponent = () => {
     *   const x = useMotionValue(0)
     *   const y = useMotionValue(0)
     *   const opacity = useMotionValue(1)
     *
     *   useEffect(() => {
     *     function updateOpacity() {
     *       const maxXY = Math.max(x.get(), y.get())
     *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
     *       opacity.set(newOpacity)
     *     }
     *
     *     const unsubscribeX = x.on("change", updateOpacity)
     *     const unsubscribeY = y.on("change", updateOpacity)
     *
     *     return () => {
     *       unsubscribeX()
     *       unsubscribeY()
     *     }
     *   }, [])
     *
     *   return <motion.div style={{ x }} />
     * }
     * ```
     *
     * @param subscriber - A function that receives the latest value.
     * @returns A function that, when called, will cancel this subscription.
     *
     * @deprecated
     */
    onChange(subscription) {
      if (process.env.NODE_ENV !== "production") {
        warnOnce(false, `value.onChange(callback) is deprecated. Switch to value.on("change", callback).`);
      }
      return this.on("change", subscription);
    }
    on(eventName, callback) {
      if (!this.events[eventName]) {
        this.events[eventName] = new SubscriptionManager();
      }
      const unsubscribe = this.events[eventName].add(callback);
      if (eventName === "change") {
        return () => {
          unsubscribe();
          frame.read(() => {
            if (!this.events.change.getSize()) {
              this.stop();
            }
          });
        };
      }
      return unsubscribe;
    }
    clearListeners() {
      for (const eventManagers in this.events) {
        this.events[eventManagers].clear();
      }
    }
    /**
     * Attaches a passive effect to the `MotionValue`.
     */
    attach(passiveEffect, stopPassiveEffect) {
      this.passiveEffect = passiveEffect;
      this.stopPassiveEffect = stopPassiveEffect;
    }
    /**
     * Sets the state of the `MotionValue`.
     *
     * @remarks
     *
     * ```jsx
     * const x = useMotionValue(0)
     * x.set(10)
     * ```
     *
     * @param latest - Latest value to set.
     * @param render - Whether to notify render subscribers. Defaults to `true`
     *
     * @public
     */
    set(v2) {
      if (!this.passiveEffect) {
        this.updateAndNotify(v2);
      } else {
        this.passiveEffect(v2, this.updateAndNotify);
      }
    }
    setWithVelocity(prev, current, delta) {
      this.set(current);
      this.prev = void 0;
      this.prevFrameValue = prev;
      this.prevUpdatedAt = this.updatedAt - delta;
    }
    /**
     * Set the state of the `MotionValue`, stopping any active animations,
     * effects, and resets velocity to `0`.
     */
    jump(v2, endAnimation = true) {
      this.updateAndNotify(v2);
      this.prev = v2;
      this.prevUpdatedAt = this.prevFrameValue = void 0;
      endAnimation && this.stop();
      if (this.stopPassiveEffect)
        this.stopPassiveEffect();
    }
    dirty() {
      this.events.change?.notify(this.current);
    }
    addDependent(dependent) {
      if (!this.dependents) {
        this.dependents = /* @__PURE__ */ new Set();
      }
      this.dependents.add(dependent);
    }
    removeDependent(dependent) {
      if (this.dependents) {
        this.dependents.delete(dependent);
      }
    }
    /**
     * Returns the latest state of `MotionValue`
     *
     * @returns - The latest state of `MotionValue`
     *
     * @public
     */
    get() {
      if (collectMotionValues.current) {
        collectMotionValues.current.push(this);
      }
      return this.current;
    }
    /**
     * @public
     */
    getPrevious() {
      return this.prev;
    }
    /**
     * Returns the latest velocity of `MotionValue`
     *
     * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
     *
     * @public
     */
    getVelocity() {
      const currentTime = time.now();
      if (!this.canTrackVelocity || this.prevFrameValue === void 0 || currentTime - this.updatedAt > MAX_VELOCITY_DELTA) {
        return 0;
      }
      const delta = Math.min(this.updatedAt - this.prevUpdatedAt, MAX_VELOCITY_DELTA);
      return velocityPerSecond(parseFloat(this.current) - parseFloat(this.prevFrameValue), delta);
    }
    /**
     * Registers a new animation to control this `MotionValue`. Only one
     * animation can drive a `MotionValue` at one time.
     *
     * ```jsx
     * value.start()
     * ```
     *
     * @param animation - A function that starts the provided animation
     */
    start(startAnimation) {
      this.stop();
      return new Promise((resolve) => {
        this.hasAnimated = true;
        this.animation = startAnimation(resolve);
        if (this.events.animationStart) {
          this.events.animationStart.notify();
        }
      }).then(() => {
        if (this.events.animationComplete) {
          this.events.animationComplete.notify();
        }
        this.clearAnimation();
      });
    }
    /**
     * Stop the currently active animation.
     *
     * @public
     */
    stop() {
      if (this.animation) {
        this.animation.stop();
        if (this.events.animationCancel) {
          this.events.animationCancel.notify();
        }
      }
      this.clearAnimation();
    }
    /**
     * Returns `true` if this value is currently animating.
     *
     * @public
     */
    isAnimating() {
      return !!this.animation;
    }
    clearAnimation() {
      delete this.animation;
    }
    /**
     * Destroy and clean up subscribers to this `MotionValue`.
     *
     * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
     * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
     * created a `MotionValue` via the `motionValue` function.
     *
     * @public
     */
    destroy() {
      this.dependents?.clear();
      this.events.destroy?.notify();
      this.clearListeners();
      this.stop();
      if (this.stopPassiveEffect) {
        this.stopPassiveEffect();
      }
    }
  };
  function motionValue(init, options) {
    return new MotionValue(init, options);
  }

  // ../../node_modules/motion-dom/dist/es/frameloop/microtask.mjs
  var { schedule: microtask, cancel: cancelMicrotask } = /* @__PURE__ */ createRenderBatcher(queueMicrotask, false);

  // ../../node_modules/motion-dom/dist/es/gestures/drag/state/is-active.mjs
  var isDragging = {
    x: false,
    y: false
  };
  function isDragActive() {
    return isDragging.x || isDragging.y;
  }

  // ../../node_modules/motion-dom/dist/es/gestures/drag/state/set-active.mjs
  function setDragLock(axis) {
    if (axis === "x" || axis === "y") {
      if (isDragging[axis]) {
        return null;
      } else {
        isDragging[axis] = true;
        return () => {
          isDragging[axis] = false;
        };
      }
    } else {
      if (isDragging.x || isDragging.y) {
        return null;
      } else {
        isDragging.x = isDragging.y = true;
        return () => {
          isDragging.x = isDragging.y = false;
        };
      }
    }
  }

  // ../../node_modules/motion-dom/dist/es/gestures/utils/setup.mjs
  function setupGesture(elementOrSelector, options) {
    const elements = resolveElements(elementOrSelector);
    const gestureAbortController = new AbortController();
    const eventOptions = {
      passive: true,
      ...options,
      signal: gestureAbortController.signal
    };
    const cancel = () => gestureAbortController.abort();
    return [elements, eventOptions, cancel];
  }

  // ../../node_modules/motion-dom/dist/es/gestures/hover.mjs
  function isValidHover(event) {
    return !(event.pointerType === "touch" || isDragActive());
  }
  function hover(elementOrSelector, onHoverStart, options = {}) {
    const [elements, eventOptions, cancel] = setupGesture(elementOrSelector, options);
    const onPointerEnter = (enterEvent) => {
      if (!isValidHover(enterEvent))
        return;
      const { target } = enterEvent;
      const onHoverEnd = onHoverStart(target, enterEvent);
      if (typeof onHoverEnd !== "function" || !target)
        return;
      const onPointerLeave = (leaveEvent) => {
        if (!isValidHover(leaveEvent))
          return;
        onHoverEnd(leaveEvent);
        target.removeEventListener("pointerleave", onPointerLeave);
      };
      target.addEventListener("pointerleave", onPointerLeave, eventOptions);
    };
    elements.forEach((element) => {
      element.addEventListener("pointerenter", onPointerEnter, eventOptions);
    });
    return cancel;
  }

  // ../../node_modules/motion-dom/dist/es/gestures/utils/is-node-or-child.mjs
  var isNodeOrChild = (parent, child) => {
    if (!child) {
      return false;
    } else if (parent === child) {
      return true;
    } else {
      return isNodeOrChild(parent, child.parentElement);
    }
  };

  // ../../node_modules/motion-dom/dist/es/gestures/utils/is-primary-pointer.mjs
  var isPrimaryPointer = (event) => {
    if (event.pointerType === "mouse") {
      return typeof event.button !== "number" || event.button <= 0;
    } else {
      return event.isPrimary !== false;
    }
  };

  // ../../node_modules/motion-dom/dist/es/gestures/press/utils/is-keyboard-accessible.mjs
  var interactiveElements = /* @__PURE__ */ new Set([
    "BUTTON",
    "INPUT",
    "SELECT",
    "TEXTAREA",
    "A"
  ]);
  function isElementKeyboardAccessible(element) {
    return interactiveElements.has(element.tagName) || element.isContentEditable === true;
  }

  // ../../node_modules/motion-dom/dist/es/gestures/press/utils/state.mjs
  var isPressing = /* @__PURE__ */ new WeakSet();

  // ../../node_modules/motion-dom/dist/es/gestures/press/utils/keyboard.mjs
  function filterEvents(callback) {
    return (event) => {
      if (event.key !== "Enter")
        return;
      callback(event);
    };
  }
  function firePointerEvent(target, type) {
    target.dispatchEvent(new PointerEvent("pointer" + type, { isPrimary: true, bubbles: true }));
  }
  var enableKeyboardPress = (focusEvent, eventOptions) => {
    const element = focusEvent.currentTarget;
    if (!element)
      return;
    const handleKeydown = filterEvents(() => {
      if (isPressing.has(element))
        return;
      firePointerEvent(element, "down");
      const handleKeyup = filterEvents(() => {
        firePointerEvent(element, "up");
      });
      const handleBlur = () => firePointerEvent(element, "cancel");
      element.addEventListener("keyup", handleKeyup, eventOptions);
      element.addEventListener("blur", handleBlur, eventOptions);
    });
    element.addEventListener("keydown", handleKeydown, eventOptions);
    element.addEventListener("blur", () => element.removeEventListener("keydown", handleKeydown), eventOptions);
  };

  // ../../node_modules/motion-dom/dist/es/gestures/press/index.mjs
  function isValidPressEvent(event) {
    return isPrimaryPointer(event) && !isDragActive();
  }
  function press(targetOrSelector, onPressStart, options = {}) {
    const [targets, eventOptions, cancelEvents] = setupGesture(targetOrSelector, options);
    const startPress = (startEvent) => {
      const target = startEvent.currentTarget;
      if (!isValidPressEvent(startEvent))
        return;
      isPressing.add(target);
      const onPressEnd = onPressStart(target, startEvent);
      const onPointerEnd = (endEvent, success) => {
        window.removeEventListener("pointerup", onPointerUp);
        window.removeEventListener("pointercancel", onPointerCancel);
        if (isPressing.has(target)) {
          isPressing.delete(target);
        }
        if (!isValidPressEvent(endEvent)) {
          return;
        }
        if (typeof onPressEnd === "function") {
          onPressEnd(endEvent, { success });
        }
      };
      const onPointerUp = (upEvent) => {
        onPointerEnd(upEvent, target === window || target === document || options.useGlobalTarget || isNodeOrChild(target, upEvent.target));
      };
      const onPointerCancel = (cancelEvent) => {
        onPointerEnd(cancelEvent, false);
      };
      window.addEventListener("pointerup", onPointerUp, eventOptions);
      window.addEventListener("pointercancel", onPointerCancel, eventOptions);
    };
    targets.forEach((target) => {
      const pointerDownTarget = options.useGlobalTarget ? window : target;
      pointerDownTarget.addEventListener("pointerdown", startPress, eventOptions);
      if (isHTMLElement(target)) {
        target.addEventListener("focus", (event) => enableKeyboardPress(event, eventOptions));
        if (!isElementKeyboardAccessible(target) && !target.hasAttribute("tabindex")) {
          target.tabIndex = 0;
        }
      }
    });
    return cancelEvents;
  }

  // ../../node_modules/motion-dom/dist/es/utils/is-svg-element.mjs
  function isSVGElement(element) {
    return isObject(element) && "ownerSVGElement" in element;
  }

  // ../../node_modules/motion-dom/dist/es/resize/handle-element.mjs
  var resizeHandlers = /* @__PURE__ */ new WeakMap();
  var observer;
  var getSize = (borderBoxAxis, svgAxis, htmlAxis) => (target, borderBoxSize) => {
    if (borderBoxSize && borderBoxSize[0]) {
      return borderBoxSize[0][borderBoxAxis + "Size"];
    } else if (isSVGElement(target) && "getBBox" in target) {
      return target.getBBox()[svgAxis];
    } else {
      return target[htmlAxis];
    }
  };
  var getWidth = /* @__PURE__ */ getSize("inline", "width", "offsetWidth");
  var getHeight = /* @__PURE__ */ getSize("block", "height", "offsetHeight");
  function notifyTarget({ target, borderBoxSize }) {
    resizeHandlers.get(target)?.forEach((handler) => {
      handler(target, {
        get width() {
          return getWidth(target, borderBoxSize);
        },
        get height() {
          return getHeight(target, borderBoxSize);
        }
      });
    });
  }
  function notifyAll(entries) {
    entries.forEach(notifyTarget);
  }
  function createResizeObserver() {
    if (typeof ResizeObserver === "undefined")
      return;
    observer = new ResizeObserver(notifyAll);
  }
  function resizeElement(target, handler) {
    if (!observer)
      createResizeObserver();
    const elements = resolveElements(target);
    elements.forEach((element) => {
      let elementHandlers = resizeHandlers.get(element);
      if (!elementHandlers) {
        elementHandlers = /* @__PURE__ */ new Set();
        resizeHandlers.set(element, elementHandlers);
      }
      elementHandlers.add(handler);
      observer?.observe(element);
    });
    return () => {
      elements.forEach((element) => {
        const elementHandlers = resizeHandlers.get(element);
        elementHandlers?.delete(handler);
        if (!elementHandlers?.size) {
          observer?.unobserve(element);
        }
      });
    };
  }

  // ../../node_modules/motion-dom/dist/es/resize/handle-window.mjs
  var windowCallbacks = /* @__PURE__ */ new Set();
  var windowResizeHandler;
  function createWindowResizeHandler() {
    windowResizeHandler = () => {
      const info = {
        get width() {
          return window.innerWidth;
        },
        get height() {
          return window.innerHeight;
        }
      };
      windowCallbacks.forEach((callback) => callback(info));
    };
    window.addEventListener("resize", windowResizeHandler);
  }
  function resizeWindow(callback) {
    windowCallbacks.add(callback);
    if (!windowResizeHandler)
      createWindowResizeHandler();
    return () => {
      windowCallbacks.delete(callback);
      if (!windowCallbacks.size && typeof windowResizeHandler === "function") {
        window.removeEventListener("resize", windowResizeHandler);
        windowResizeHandler = void 0;
      }
    };
  }

  // ../../node_modules/motion-dom/dist/es/resize/index.mjs
  function resize(a, b2) {
    return typeof a === "function" ? resizeWindow(a) : resizeElement(a, b2);
  }

  // ../../node_modules/motion-dom/dist/es/scroll/observe.mjs
  function observeTimeline(update3, timeline) {
    let prevProgress;
    const onFrame = () => {
      const { currentTime } = timeline;
      const percentage = currentTime === null ? 0 : currentTime.value;
      const progress2 = percentage / 100;
      if (prevProgress !== progress2) {
        update3(progress2);
      }
      prevProgress = progress2;
    };
    frame.preUpdate(onFrame, true);
    return () => cancelFrame(onFrame);
  }

  // ../../node_modules/motion-dom/dist/es/utils/is-svg-svg-element.mjs
  function isSVGSVGElement(element) {
    return isSVGElement(element) && element.tagName === "svg";
  }

  // ../../node_modules/motion-dom/dist/es/utils/transform.mjs
  function transform(...args) {
    const useImmediate = !Array.isArray(args[0]);
    const argOffset = useImmediate ? 0 : -1;
    const inputValue = args[0 + argOffset];
    const inputRange = args[1 + argOffset];
    const outputRange = args[2 + argOffset];
    const options = args[3 + argOffset];
    const interpolator = interpolate(inputRange, outputRange, options);
    return useImmediate ? interpolator(inputValue) : interpolator;
  }

  // ../../node_modules/motion-dom/dist/es/value/utils/is-motion-value.mjs
  var isMotionValue = (value) => Boolean(value && value.getVelocity);

  // ../../node_modules/motion-dom/dist/es/value/spring-value.mjs
  function attachSpring(value, source, options) {
    const initialValue = value.get();
    let activeAnimation = null;
    let latestValue = initialValue;
    let latestSetter;
    const unit = typeof initialValue === "string" ? initialValue.replace(/[\d.-]/g, "") : void 0;
    const stopAnimation = () => {
      if (activeAnimation) {
        activeAnimation.stop();
        activeAnimation = null;
      }
    };
    const startAnimation = () => {
      stopAnimation();
      activeAnimation = new JSAnimation({
        keyframes: [asNumber(value.get()), asNumber(latestValue)],
        velocity: value.getVelocity(),
        type: "spring",
        restDelta: 1e-3,
        restSpeed: 0.01,
        ...options,
        onUpdate: latestSetter
      });
    };
    value.attach((v2, set) => {
      latestValue = v2;
      latestSetter = (latest) => set(parseValue(latest, unit));
      frame.postRender(() => {
        startAnimation();
        value["events"].animationStart?.notify();
        activeAnimation?.then(() => {
          value["events"].animationComplete?.notify();
        });
      });
    }, stopAnimation);
    if (isMotionValue(source)) {
      const removeSourceOnChange = source.on("change", (v2) => value.set(parseValue(v2, unit)));
      const removeValueOnDestroy = value.on("destroy", removeSourceOnChange);
      return () => {
        removeSourceOnChange();
        removeValueOnDestroy();
      };
    }
    return stopAnimation;
  }
  function parseValue(v2, unit) {
    return unit ? v2 + unit : v2;
  }
  function asNumber(v2) {
    return typeof v2 === "number" ? v2 : parseFloat(v2);
  }

  // ../../node_modules/motion-dom/dist/es/value/types/utils/find.mjs
  var valueTypes = [...dimensionValueTypes, color, complex];
  var findValueType = (v2) => valueTypes.find(testValueType(v2));

  // ../../node_modules/framer-motion/dist/es/components/AnimatePresence/PopChild.mjs
  var React3 = __toESM(require_react2(), 1);
  var import_react8 = __toESM(require_react2(), 1);

  // ../../node_modules/framer-motion/dist/es/context/MotionConfigContext.mjs
  var import_react7 = __toESM(require_react2(), 1);
  var MotionConfigContext = (0, import_react7.createContext)({
    transformPagePoint: (p3) => p3,
    isStatic: false,
    reducedMotion: "never"
  });

  // ../../node_modules/framer-motion/dist/es/utils/use-composed-ref.mjs
  var React2 = __toESM(require_react2(), 1);
  function setRef(ref, value) {
    if (typeof ref === "function") {
      return ref(value);
    } else if (ref !== null && ref !== void 0) {
      ref.current = value;
    }
  }
  function composeRefs(...refs) {
    return (node) => {
      let hasCleanup = false;
      const cleanups = refs.map((ref) => {
        const cleanup = setRef(ref, node);
        if (!hasCleanup && typeof cleanup === "function") {
          hasCleanup = true;
        }
        return cleanup;
      });
      if (hasCleanup) {
        return () => {
          for (let i3 = 0; i3 < cleanups.length; i3++) {
            const cleanup = cleanups[i3];
            if (typeof cleanup === "function") {
              cleanup();
            } else {
              setRef(refs[i3], null);
            }
          }
        };
      }
    };
  }
  function useComposedRefs(...refs) {
    return React2.useCallback(composeRefs(...refs), refs);
  }

  // ../../node_modules/framer-motion/dist/es/components/AnimatePresence/PopChild.mjs
  var PopChildMeasure = class extends React3.Component {
    getSnapshotBeforeUpdate(prevProps) {
      const element = this.props.childRef.current;
      if (element && prevProps.isPresent && !this.props.isPresent) {
        const parent = element.offsetParent;
        const parentWidth = isHTMLElement(parent) ? parent.offsetWidth || 0 : 0;
        const size4 = this.props.sizeRef.current;
        size4.height = element.offsetHeight || 0;
        size4.width = element.offsetWidth || 0;
        size4.top = element.offsetTop;
        size4.left = element.offsetLeft;
        size4.right = parentWidth - size4.width - size4.left;
      }
      return null;
    }
    /**
     * Required with getSnapshotBeforeUpdate to stop React complaining.
     */
    componentDidUpdate() {
    }
    render() {
      return this.props.children;
    }
  };
  function PopChild({ children, isPresent, anchorX, root }) {
    const id3 = (0, import_react8.useId)();
    const ref = (0, import_react8.useRef)(null);
    const size4 = (0, import_react8.useRef)({
      width: 0,
      height: 0,
      top: 0,
      left: 0,
      right: 0
    });
    const { nonce } = (0, import_react8.useContext)(MotionConfigContext);
    const childRef = children.props?.ref ?? children?.ref;
    const composedRef = useComposedRefs(ref, childRef);
    (0, import_react8.useInsertionEffect)(() => {
      const { width, height, top, left, right } = size4.current;
      if (isPresent || !ref.current || !width || !height)
        return;
      const x2 = anchorX === "left" ? `left: ${left}` : `right: ${right}`;
      ref.current.dataset.motionPopId = id3;
      const style = document.createElement("style");
      if (nonce)
        style.nonce = nonce;
      const parent = root ?? document.head;
      parent.appendChild(style);
      if (style.sheet) {
        style.sheet.insertRule(`
          [data-motion-pop-id="${id3}"] {
            position: absolute !important;
            width: ${width}px !important;
            height: ${height}px !important;
            ${x2}px !important;
            top: ${top}px !important;
          }
        `);
      }
      return () => {
        if (parent.contains(style)) {
          parent.removeChild(style);
        }
      };
    }, [isPresent]);
    return (0, import_jsx_runtime3.jsx)(PopChildMeasure, { isPresent, childRef: ref, sizeRef: size4, children: React3.cloneElement(children, { ref: composedRef }) });
  }

  // ../../node_modules/framer-motion/dist/es/components/AnimatePresence/PresenceChild.mjs
  var PresenceChild = ({ children, initial, isPresent, onExitComplete, custom, presenceAffectsLayout, mode, anchorX, root }) => {
    const presenceChildren = useConstant(newChildrenMap);
    const id3 = (0, import_react9.useId)();
    let isReusedContext = true;
    let context = (0, import_react9.useMemo)(() => {
      isReusedContext = false;
      return {
        id: id3,
        initial,
        isPresent,
        custom,
        onExitComplete: (childId) => {
          presenceChildren.set(childId, true);
          for (const isComplete of presenceChildren.values()) {
            if (!isComplete)
              return;
          }
          onExitComplete && onExitComplete();
        },
        register: (childId) => {
          presenceChildren.set(childId, false);
          return () => presenceChildren.delete(childId);
        }
      };
    }, [isPresent, presenceChildren, onExitComplete]);
    if (presenceAffectsLayout && isReusedContext) {
      context = { ...context };
    }
    (0, import_react9.useMemo)(() => {
      presenceChildren.forEach((_2, key) => presenceChildren.set(key, false));
    }, [isPresent]);
    React4.useEffect(() => {
      !isPresent && !presenceChildren.size && onExitComplete && onExitComplete();
    }, [isPresent]);
    if (mode === "popLayout") {
      children = (0, import_jsx_runtime4.jsx)(PopChild, { isPresent, anchorX, root, children });
    }
    return (0, import_jsx_runtime4.jsx)(PresenceContext.Provider, { value: context, children });
  };
  function newChildrenMap() {
    return /* @__PURE__ */ new Map();
  }

  // ../../node_modules/framer-motion/dist/es/components/AnimatePresence/use-presence.mjs
  var import_react10 = __toESM(require_react2(), 1);
  function usePresence(subscribe2 = true) {
    const context = (0, import_react10.useContext)(PresenceContext);
    if (context === null)
      return [true, null];
    const { isPresent, onExitComplete, register } = context;
    const id3 = (0, import_react10.useId)();
    (0, import_react10.useEffect)(() => {
      if (subscribe2) {
        return register(id3);
      }
    }, [subscribe2]);
    const safeToRemove = (0, import_react10.useCallback)(() => subscribe2 && onExitComplete && onExitComplete(id3), [id3, onExitComplete, subscribe2]);
    return !isPresent && onExitComplete ? [false, safeToRemove] : [true];
  }

  // ../../node_modules/framer-motion/dist/es/components/AnimatePresence/utils.mjs
  var import_react11 = __toESM(require_react2(), 1);
  var getChildKey = (child) => child.key || "";
  function onlyElements(children) {
    const filtered = [];
    import_react11.Children.forEach(children, (child) => {
      if ((0, import_react11.isValidElement)(child))
        filtered.push(child);
    });
    return filtered;
  }

  // ../../node_modules/framer-motion/dist/es/components/AnimatePresence/index.mjs
  var AnimatePresence = ({ children, custom, initial = true, onExitComplete, presenceAffectsLayout = true, mode = "sync", propagate = false, anchorX = "left", root }) => {
    const [isParentPresent, safeToRemove] = usePresence(propagate);
    const presentChildren = (0, import_react12.useMemo)(() => onlyElements(children), [children]);
    const presentKeys = propagate && !isParentPresent ? [] : presentChildren.map(getChildKey);
    const isInitialRender = (0, import_react12.useRef)(true);
    const pendingPresentChildren = (0, import_react12.useRef)(presentChildren);
    const exitComplete = useConstant(() => /* @__PURE__ */ new Map());
    const exitingComponents = (0, import_react12.useRef)(/* @__PURE__ */ new Set());
    const [diffedChildren, setDiffedChildren] = (0, import_react12.useState)(presentChildren);
    const [renderedChildren, setRenderedChildren] = (0, import_react12.useState)(presentChildren);
    useIsomorphicLayoutEffect(() => {
      isInitialRender.current = false;
      pendingPresentChildren.current = presentChildren;
      for (let i3 = 0; i3 < renderedChildren.length; i3++) {
        const key = getChildKey(renderedChildren[i3]);
        if (!presentKeys.includes(key)) {
          if (exitComplete.get(key) !== true) {
            exitComplete.set(key, false);
          }
        } else {
          exitComplete.delete(key);
          exitingComponents.current.delete(key);
        }
      }
    }, [renderedChildren, presentKeys.length, presentKeys.join("-")]);
    const exitingChildren = [];
    if (presentChildren !== diffedChildren) {
      let nextChildren = [...presentChildren];
      for (let i3 = 0; i3 < renderedChildren.length; i3++) {
        const child = renderedChildren[i3];
        const key = getChildKey(child);
        if (!presentKeys.includes(key)) {
          nextChildren.splice(i3, 0, child);
          exitingChildren.push(child);
        }
      }
      if (mode === "wait" && exitingChildren.length) {
        nextChildren = exitingChildren;
      }
      setRenderedChildren(onlyElements(nextChildren));
      setDiffedChildren(presentChildren);
      return null;
    }
    if (process.env.NODE_ENV !== "production" && mode === "wait" && renderedChildren.length > 1) {
      console.warn(`You're attempting to animate multiple children within AnimatePresence, but its mode is set to "wait". This will lead to odd visual behaviour.`);
    }
    const { forceRender } = (0, import_react12.useContext)(LayoutGroupContext);
    return (0, import_jsx_runtime5.jsx)(import_jsx_runtime5.Fragment, { children: renderedChildren.map((child) => {
      const key = getChildKey(child);
      const isPresent = propagate && !isParentPresent ? false : presentChildren === renderedChildren || presentKeys.includes(key);
      const onExit = () => {
        if (exitingComponents.current.has(key)) {
          return;
        }
        exitingComponents.current.add(key);
        if (exitComplete.has(key)) {
          exitComplete.set(key, true);
        } else {
          return;
        }
        let isEveryExitComplete = true;
        exitComplete.forEach((isExitComplete) => {
          if (!isExitComplete)
            isEveryExitComplete = false;
        });
        if (isEveryExitComplete) {
          forceRender?.();
          setRenderedChildren(pendingPresentChildren.current);
          propagate && safeToRemove?.();
          onExitComplete && onExitComplete();
        }
      };
      return (0, import_jsx_runtime5.jsx)(PresenceChild, { isPresent, initial: !isInitialRender.current || initial ? void 0 : false, custom, presenceAffectsLayout, mode, root, onExitComplete: isPresent ? void 0 : onExit, anchorX, children: child }, key);
    }) });
  };

  // ../../node_modules/framer-motion/dist/es/context/LazyContext.mjs
  var import_react13 = __toESM(require_react2(), 1);
  var LazyContext = (0, import_react13.createContext)({ strict: false });

  // ../../node_modules/framer-motion/dist/es/motion/features/definitions.mjs
  var featureProps = {
    animation: [
      "animate",
      "variants",
      "whileHover",
      "whileTap",
      "exit",
      "whileInView",
      "whileFocus",
      "whileDrag"
    ],
    exit: ["exit"],
    drag: ["drag", "dragControls"],
    focus: ["whileFocus"],
    hover: ["whileHover", "onHoverStart", "onHoverEnd"],
    tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
    pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
    inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
    layout: ["layout", "layoutId"]
  };
  var featureDefinitions = {};
  for (const key in featureProps) {
    featureDefinitions[key] = {
      isEnabled: (props) => featureProps[key].some((name) => !!props[name])
    };
  }

  // ../../node_modules/framer-motion/dist/es/motion/features/load-features.mjs
  function loadFeatures(features) {
    for (const key in features) {
      featureDefinitions[key] = {
        ...featureDefinitions[key],
        ...features[key]
      };
    }
  }

  // ../../node_modules/framer-motion/dist/es/motion/utils/valid-prop.mjs
  var validMotionProps = /* @__PURE__ */ new Set([
    "animate",
    "exit",
    "variants",
    "initial",
    "style",
    "values",
    "variants",
    "transition",
    "transformTemplate",
    "custom",
    "inherit",
    "onBeforeLayoutMeasure",
    "onAnimationStart",
    "onAnimationComplete",
    "onUpdate",
    "onDragStart",
    "onDrag",
    "onDragEnd",
    "onMeasureDragConstraints",
    "onDirectionLock",
    "onDragTransitionEnd",
    "_dragX",
    "_dragY",
    "onHoverStart",
    "onHoverEnd",
    "onViewportEnter",
    "onViewportLeave",
    "globalTapTarget",
    "ignoreStrict",
    "viewport"
  ]);
  function isValidMotionProp(key) {
    return key.startsWith("while") || key.startsWith("drag") && key !== "draggable" || key.startsWith("layout") || key.startsWith("onTap") || key.startsWith("onPan") || key.startsWith("onLayout") || validMotionProps.has(key);
  }

  // ../../node_modules/framer-motion/dist/es/render/dom/utils/filter-props.mjs
  var shouldForward = (key) => !isValidMotionProp(key);
  function loadExternalIsValidProp(isValidProp) {
    if (typeof isValidProp !== "function")
      return;
    shouldForward = (key) => key.startsWith("on") ? !isValidMotionProp(key) : isValidProp(key);
  }
  try {
    loadExternalIsValidProp(__require("@emotion/is-prop-valid").default);
  } catch {
  }
  function filterProps(props, isDom, forwardMotionProps) {
    const filteredProps = {};
    for (const key in props) {
      if (key === "values" && typeof props.values === "object")
        continue;
      if (shouldForward(key) || forwardMotionProps === true && isValidMotionProp(key) || !isDom && !isValidMotionProp(key) || // If trying to use native HTML drag events, forward drag listeners
      props["draggable"] && key.startsWith("onDrag")) {
        filteredProps[key] = props[key];
      }
    }
    return filteredProps;
  }

  // ../../node_modules/framer-motion/dist/es/motion/index.mjs
  var import_jsx_runtime6 = __toESM(require_jsx_runtime2(), 1);
  var import_react23 = __toESM(require_react2(), 1);

  // ../../node_modules/framer-motion/dist/es/context/MotionContext/index.mjs
  var import_react14 = __toESM(require_react2(), 1);
  var MotionContext = /* @__PURE__ */ (0, import_react14.createContext)({});

  // ../../node_modules/framer-motion/dist/es/context/MotionContext/create.mjs
  var import_react15 = __toESM(require_react2(), 1);

  // ../../node_modules/framer-motion/dist/es/animation/utils/is-animation-controls.mjs
  function isAnimationControls(v2) {
    return v2 !== null && typeof v2 === "object" && typeof v2.start === "function";
  }

  // ../../node_modules/framer-motion/dist/es/render/utils/is-variant-label.mjs
  function isVariantLabel(v2) {
    return typeof v2 === "string" || Array.isArray(v2);
  }

  // ../../node_modules/framer-motion/dist/es/render/utils/variant-props.mjs
  var variantPriorityOrder = [
    "animate",
    "whileInView",
    "whileFocus",
    "whileHover",
    "whileTap",
    "whileDrag",
    "exit"
  ];
  var variantProps = ["initial", ...variantPriorityOrder];

  // ../../node_modules/framer-motion/dist/es/render/utils/is-controlling-variants.mjs
  function isControllingVariants(props) {
    return isAnimationControls(props.animate) || variantProps.some((name) => isVariantLabel(props[name]));
  }
  function isVariantNode(props) {
    return Boolean(isControllingVariants(props) || props.variants);
  }

  // ../../node_modules/framer-motion/dist/es/context/MotionContext/utils.mjs
  function getCurrentTreeVariants(props, context) {
    if (isControllingVariants(props)) {
      const { initial, animate } = props;
      return {
        initial: initial === false || isVariantLabel(initial) ? initial : void 0,
        animate: isVariantLabel(animate) ? animate : void 0
      };
    }
    return props.inherit !== false ? context : {};
  }

  // ../../node_modules/framer-motion/dist/es/context/MotionContext/create.mjs
  function useCreateMotionContext(props) {
    const { initial, animate } = getCurrentTreeVariants(props, (0, import_react15.useContext)(MotionContext));
    return (0, import_react15.useMemo)(() => ({ initial, animate }), [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate)]);
  }
  function variantLabelsAsDependency(prop) {
    return Array.isArray(prop) ? prop.join(" ") : prop;
  }

  // ../../node_modules/framer-motion/dist/es/render/dom/use-render.mjs
  var import_react18 = __toESM(require_react2(), 1);

  // ../../node_modules/framer-motion/dist/es/render/html/use-props.mjs
  var import_react16 = __toESM(require_react2(), 1);

  // ../../node_modules/framer-motion/dist/es/projection/styles/scale-border-radius.mjs
  function pixelsToPercent(pixels, axis) {
    if (axis.max === axis.min)
      return 0;
    return pixels / (axis.max - axis.min) * 100;
  }
  var correctBorderRadius = {
    correct: (latest, node) => {
      if (!node.target)
        return latest;
      if (typeof latest === "string") {
        if (px.test(latest)) {
          latest = parseFloat(latest);
        } else {
          return latest;
        }
      }
      const x2 = pixelsToPercent(latest, node.target.x);
      const y2 = pixelsToPercent(latest, node.target.y);
      return `${x2}% ${y2}%`;
    }
  };

  // ../../node_modules/framer-motion/dist/es/projection/styles/scale-box-shadow.mjs
  var correctBoxShadow = {
    correct: (latest, { treeScale, projectionDelta }) => {
      const original = latest;
      const shadow = complex.parse(latest);
      if (shadow.length > 5)
        return original;
      const template = complex.createTransformer(latest);
      const offset4 = typeof shadow[0] !== "number" ? 1 : 0;
      const xScale = projectionDelta.x.scale * treeScale.x;
      const yScale = projectionDelta.y.scale * treeScale.y;
      shadow[0 + offset4] /= xScale;
      shadow[1 + offset4] /= yScale;
      const averageScale = mixNumber(xScale, yScale, 0.5);
      if (typeof shadow[2 + offset4] === "number")
        shadow[2 + offset4] /= averageScale;
      if (typeof shadow[3 + offset4] === "number")
        shadow[3 + offset4] /= averageScale;
      return template(shadow);
    }
  };

  // ../../node_modules/framer-motion/dist/es/projection/styles/scale-correction.mjs
  var scaleCorrectors = {
    borderRadius: {
      ...correctBorderRadius,
      applyTo: [
        "borderTopLeftRadius",
        "borderTopRightRadius",
        "borderBottomLeftRadius",
        "borderBottomRightRadius"
      ]
    },
    borderTopLeftRadius: correctBorderRadius,
    borderTopRightRadius: correctBorderRadius,
    borderBottomLeftRadius: correctBorderRadius,
    borderBottomRightRadius: correctBorderRadius,
    boxShadow: correctBoxShadow
  };

  // ../../node_modules/framer-motion/dist/es/motion/utils/is-forced-motion-value.mjs
  function isForcedMotionValue(key, { layout: layout2, layoutId }) {
    return transformProps.has(key) || key.startsWith("origin") || (layout2 || layoutId !== void 0) && (!!scaleCorrectors[key] || key === "opacity");
  }

  // ../../node_modules/framer-motion/dist/es/render/html/utils/build-transform.mjs
  var translateAlias = {
    x: "translateX",
    y: "translateY",
    z: "translateZ",
    transformPerspective: "perspective"
  };
  var numTransforms = transformPropOrder.length;
  function buildTransform(latestValues, transform2, transformTemplate) {
    let transformString = "";
    let transformIsDefault = true;
    for (let i3 = 0; i3 < numTransforms; i3++) {
      const key = transformPropOrder[i3];
      const value = latestValues[key];
      if (value === void 0)
        continue;
      let valueIsDefault = true;
      if (typeof value === "number") {
        valueIsDefault = value === (key.startsWith("scale") ? 1 : 0);
      } else {
        valueIsDefault = parseFloat(value) === 0;
      }
      if (!valueIsDefault || transformTemplate) {
        const valueAsType = getValueAsType(value, numberValueTypes[key]);
        if (!valueIsDefault) {
          transformIsDefault = false;
          const transformName = translateAlias[key] || key;
          transformString += `${transformName}(${valueAsType}) `;
        }
        if (transformTemplate) {
          transform2[key] = valueAsType;
        }
      }
    }
    transformString = transformString.trim();
    if (transformTemplate) {
      transformString = transformTemplate(transform2, transformIsDefault ? "" : transformString);
    } else if (transformIsDefault) {
      transformString = "none";
    }
    return transformString;
  }

  // ../../node_modules/framer-motion/dist/es/render/html/utils/build-styles.mjs
  function buildHTMLStyles(state, latestValues, transformTemplate) {
    const { style, vars, transformOrigin: transformOrigin2 } = state;
    let hasTransform2 = false;
    let hasTransformOrigin = false;
    for (const key in latestValues) {
      const value = latestValues[key];
      if (transformProps.has(key)) {
        hasTransform2 = true;
        continue;
      } else if (isCSSVariableName(key)) {
        vars[key] = value;
        continue;
      } else {
        const valueAsType = getValueAsType(value, numberValueTypes[key]);
        if (key.startsWith("origin")) {
          hasTransformOrigin = true;
          transformOrigin2[key] = valueAsType;
        } else {
          style[key] = valueAsType;
        }
      }
    }
    if (!latestValues.transform) {
      if (hasTransform2 || transformTemplate) {
        style.transform = buildTransform(latestValues, state.transform, transformTemplate);
      } else if (style.transform) {
        style.transform = "none";
      }
    }
    if (hasTransformOrigin) {
      const { originX = "50%", originY = "50%", originZ = 0 } = transformOrigin2;
      style.transformOrigin = `${originX} ${originY} ${originZ}`;
    }
  }

  // ../../node_modules/framer-motion/dist/es/render/html/utils/create-render-state.mjs
  var createHtmlRenderState = () => ({
    style: {},
    transform: {},
    transformOrigin: {},
    vars: {}
  });

  // ../../node_modules/framer-motion/dist/es/render/html/use-props.mjs
  function copyRawValuesOnly(target, source, props) {
    for (const key in source) {
      if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {
        target[key] = source[key];
      }
    }
  }
  function useInitialMotionValues({ transformTemplate }, visualState) {
    return (0, import_react16.useMemo)(() => {
      const state = createHtmlRenderState();
      buildHTMLStyles(state, visualState, transformTemplate);
      return Object.assign({}, state.vars, state.style);
    }, [visualState]);
  }
  function useStyle(props, visualState) {
    const styleProp = props.style || {};
    const style = {};
    copyRawValuesOnly(style, styleProp, props);
    Object.assign(style, useInitialMotionValues(props, visualState));
    return style;
  }
  function useHTMLProps(props, visualState) {
    const htmlProps = {};
    const style = useStyle(props, visualState);
    if (props.drag && props.dragListener !== false) {
      htmlProps.draggable = false;
      style.userSelect = style.WebkitUserSelect = style.WebkitTouchCallout = "none";
      style.touchAction = props.drag === true ? "none" : `pan-${props.drag === "x" ? "y" : "x"}`;
    }
    if (props.tabIndex === void 0 && (props.onTap || props.onTapStart || props.whileTap)) {
      htmlProps.tabIndex = 0;
    }
    htmlProps.style = style;
    return htmlProps;
  }

  // ../../node_modules/framer-motion/dist/es/render/svg/use-props.mjs
  var import_react17 = __toESM(require_react2(), 1);

  // ../../node_modules/framer-motion/dist/es/render/svg/utils/path.mjs
  var dashKeys = {
    offset: "stroke-dashoffset",
    array: "stroke-dasharray"
  };
  var camelKeys = {
    offset: "strokeDashoffset",
    array: "strokeDasharray"
  };
  function buildSVGPath(attrs, length, spacing = 1, offset4 = 0, useDashCase = true) {
    attrs.pathLength = 1;
    const keys2 = useDashCase ? dashKeys : camelKeys;
    attrs[keys2.offset] = px.transform(-offset4);
    const pathLength = px.transform(length);
    const pathSpacing = px.transform(spacing);
    attrs[keys2.array] = `${pathLength} ${pathSpacing}`;
  }

  // ../../node_modules/framer-motion/dist/es/render/svg/utils/build-attrs.mjs
  var cssMotionPathProperties = [
    "offsetDistance",
    "offsetPath",
    "offsetRotate",
    "offsetAnchor"
  ];
  function buildSVGAttrs(state, {
    attrX,
    attrY,
    attrScale,
    pathLength,
    pathSpacing = 1,
    pathOffset = 0,
    // This is object creation, which we try to avoid per-frame.
    ...latest
  }, isSVGTag2, transformTemplate, styleProp) {
    buildHTMLStyles(state, latest, transformTemplate);
    if (isSVGTag2) {
      if (state.style.viewBox) {
        state.attrs.viewBox = state.style.viewBox;
      }
      return;
    }
    state.attrs = state.style;
    state.style = {};
    const { attrs, style } = state;
    if (attrs.transform) {
      style.transform = attrs.transform;
      delete attrs.transform;
    }
    if (style.transform || attrs.transformOrigin) {
      style.transformOrigin = attrs.transformOrigin ?? "50% 50%";
      delete attrs.transformOrigin;
    }
    if (style.transform) {
      style.transformBox = styleProp?.transformBox ?? "fill-box";
      delete attrs.transformBox;
    }
    for (const key of cssMotionPathProperties) {
      if (attrs[key] !== void 0) {
        style[key] = attrs[key];
        delete attrs[key];
      }
    }
    if (attrX !== void 0)
      attrs.x = attrX;
    if (attrY !== void 0)
      attrs.y = attrY;
    if (attrScale !== void 0)
      attrs.scale = attrScale;
    if (pathLength !== void 0) {
      buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);
    }
  }

  // ../../node_modules/framer-motion/dist/es/render/svg/utils/create-render-state.mjs
  var createSvgRenderState = () => ({
    ...createHtmlRenderState(),
    attrs: {}
  });

  // ../../node_modules/framer-motion/dist/es/render/svg/utils/is-svg-tag.mjs
  var isSVGTag = (tag) => typeof tag === "string" && tag.toLowerCase() === "svg";

  // ../../node_modules/framer-motion/dist/es/render/svg/use-props.mjs
  function useSVGProps(props, visualState, _isStatic, Component3) {
    const visualProps = (0, import_react17.useMemo)(() => {
      const state = createSvgRenderState();
      buildSVGAttrs(state, visualState, isSVGTag(Component3), props.transformTemplate, props.style);
      return {
        ...state.attrs,
        style: { ...state.style }
      };
    }, [visualState]);
    if (props.style) {
      const rawStyles = {};
      copyRawValuesOnly(rawStyles, props.style, props);
      visualProps.style = { ...rawStyles, ...visualProps.style };
    }
    return visualProps;
  }

  // ../../node_modules/framer-motion/dist/es/render/svg/lowercase-elements.mjs
  var lowercaseSVGElements = [
    "animate",
    "circle",
    "defs",
    "desc",
    "ellipse",
    "g",
    "image",
    "line",
    "filter",
    "marker",
    "mask",
    "metadata",
    "path",
    "pattern",
    "polygon",
    "polyline",
    "rect",
    "stop",
    "switch",
    "symbol",
    "svg",
    "text",
    "tspan",
    "use",
    "view"
  ];

  // ../../node_modules/framer-motion/dist/es/render/dom/utils/is-svg-component.mjs
  function isSVGComponent(Component3) {
    if (
      /**
       * If it's not a string, it's a custom React component. Currently we only support
       * HTML custom React components.
       */
      typeof Component3 !== "string" || /**
       * If it contains a dash, the element is a custom HTML webcomponent.
       */
      Component3.includes("-")
    ) {
      return false;
    } else if (
      /**
       * If it's in our list of lowercase SVG tags, it's an SVG component
       */
      lowercaseSVGElements.indexOf(Component3) > -1 || /**
       * If it contains a capital letter, it's an SVG component
       */
      /[A-Z]/u.test(Component3)
    ) {
      return true;
    }
    return false;
  }

  // ../../node_modules/framer-motion/dist/es/render/dom/use-render.mjs
  function useRender(Component3, props, ref, { latestValues }, isStatic, forwardMotionProps = false, isSVG) {
    const useVisualProps = isSVG ?? isSVGComponent(Component3) ? useSVGProps : useHTMLProps;
    const visualProps = useVisualProps(props, latestValues, isStatic, Component3);
    const filteredProps = filterProps(props, typeof Component3 === "string", forwardMotionProps);
    const elementProps = Component3 !== import_react18.Fragment ? { ...filteredProps, ...visualProps, ref } : {};
    const { children } = props;
    const renderedChildren = (0, import_react18.useMemo)(() => isMotionValue(children) ? children.get() : children, [children]);
    return (0, import_react18.createElement)(Component3, {
      ...elementProps,
      children: renderedChildren
    });
  }

  // ../../node_modules/framer-motion/dist/es/motion/utils/use-visual-state.mjs
  var import_react19 = __toESM(require_react2(), 1);

  // ../../node_modules/framer-motion/dist/es/render/utils/resolve-variants.mjs
  function getValueState(visualElement) {
    const state = [{}, {}];
    visualElement?.values.forEach((value, key) => {
      state[0][key] = value.get();
      state[1][key] = value.getVelocity();
    });
    return state;
  }
  function resolveVariantFromProps(props, definition, custom, visualElement) {
    if (typeof definition === "function") {
      const [current, velocity] = getValueState(visualElement);
      definition = definition(custom !== void 0 ? custom : props.custom, current, velocity);
    }
    if (typeof definition === "string") {
      definition = props.variants && props.variants[definition];
    }
    if (typeof definition === "function") {
      const [current, velocity] = getValueState(visualElement);
      definition = definition(custom !== void 0 ? custom : props.custom, current, velocity);
    }
    return definition;
  }

  // ../../node_modules/framer-motion/dist/es/value/utils/resolve-motion-value.mjs
  function resolveMotionValue(value) {
    return isMotionValue(value) ? value.get() : value;
  }

  // ../../node_modules/framer-motion/dist/es/motion/utils/use-visual-state.mjs
  function makeState({ scrapeMotionValuesFromProps: scrapeMotionValuesFromProps3, createRenderState }, props, context, presenceContext) {
    const state = {
      latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps3),
      renderState: createRenderState()
    };
    return state;
  }
  function makeLatestValues(props, context, presenceContext, scrapeMotionValues) {
    const values = {};
    const motionValues = scrapeMotionValues(props, {});
    for (const key in motionValues) {
      values[key] = resolveMotionValue(motionValues[key]);
    }
    let { initial, animate } = props;
    const isControllingVariants$1 = isControllingVariants(props);
    const isVariantNode$1 = isVariantNode(props);
    if (context && isVariantNode$1 && !isControllingVariants$1 && props.inherit !== false) {
      if (initial === void 0)
        initial = context.initial;
      if (animate === void 0)
        animate = context.animate;
    }
    let isInitialAnimationBlocked = presenceContext ? presenceContext.initial === false : false;
    isInitialAnimationBlocked = isInitialAnimationBlocked || initial === false;
    const variantToSet = isInitialAnimationBlocked ? animate : initial;
    if (variantToSet && typeof variantToSet !== "boolean" && !isAnimationControls(variantToSet)) {
      const list = Array.isArray(variantToSet) ? variantToSet : [variantToSet];
      for (let i3 = 0; i3 < list.length; i3++) {
        const resolved = resolveVariantFromProps(props, list[i3]);
        if (resolved) {
          const { transitionEnd, transition, ...target } = resolved;
          for (const key in target) {
            let valueTarget = target[key];
            if (Array.isArray(valueTarget)) {
              const index2 = isInitialAnimationBlocked ? valueTarget.length - 1 : 0;
              valueTarget = valueTarget[index2];
            }
            if (valueTarget !== null) {
              values[key] = valueTarget;
            }
          }
          for (const key in transitionEnd) {
            values[key] = transitionEnd[key];
          }
        }
      }
    }
    return values;
  }
  var makeUseVisualState = (config2) => (props, isStatic) => {
    const context = (0, import_react19.useContext)(MotionContext);
    const presenceContext = (0, import_react19.useContext)(PresenceContext);
    const make = () => makeState(config2, props, context, presenceContext);
    return isStatic ? make() : useConstant(make);
  };

  // ../../node_modules/framer-motion/dist/es/render/html/utils/scrape-motion-values.mjs
  function scrapeMotionValuesFromProps(props, prevProps, visualElement) {
    const { style } = props;
    const newValues = {};
    for (const key in style) {
      if (isMotionValue(style[key]) || prevProps.style && isMotionValue(prevProps.style[key]) || isForcedMotionValue(key, props) || visualElement?.getValue(key)?.liveStyle !== void 0) {
        newValues[key] = style[key];
      }
    }
    return newValues;
  }

  // ../../node_modules/framer-motion/dist/es/render/html/use-html-visual-state.mjs
  var useHTMLVisualState = /* @__PURE__ */ makeUseVisualState({
    scrapeMotionValuesFromProps,
    createRenderState: createHtmlRenderState
  });

  // ../../node_modules/framer-motion/dist/es/render/svg/utils/scrape-motion-values.mjs
  function scrapeMotionValuesFromProps2(props, prevProps, visualElement) {
    const newValues = scrapeMotionValuesFromProps(props, prevProps, visualElement);
    for (const key in props) {
      if (isMotionValue(props[key]) || isMotionValue(prevProps[key])) {
        const targetKey = transformPropOrder.indexOf(key) !== -1 ? "attr" + key.charAt(0).toUpperCase() + key.substring(1) : key;
        newValues[targetKey] = props[key];
      }
    }
    return newValues;
  }

  // ../../node_modules/framer-motion/dist/es/render/svg/use-svg-visual-state.mjs
  var useSVGVisualState = /* @__PURE__ */ makeUseVisualState({
    scrapeMotionValuesFromProps: scrapeMotionValuesFromProps2,
    createRenderState: createSvgRenderState
  });

  // ../../node_modules/framer-motion/dist/es/motion/utils/symbol.mjs
  var motionComponentSymbol = /* @__PURE__ */ Symbol.for("motionComponentSymbol");

  // ../../node_modules/framer-motion/dist/es/motion/utils/use-motion-ref.mjs
  var import_react20 = __toESM(require_react2(), 1);
  function useMotionRef(visualState, visualElement, externalRef) {
    const externalRefContainer = (0, import_react20.useRef)(externalRef);
    (0, import_react20.useInsertionEffect)(() => {
      externalRefContainer.current = externalRef;
    });
    const refCleanup = (0, import_react20.useRef)(null);
    return (0, import_react20.useCallback)((instance) => {
      if (instance) {
        visualState.onMount?.(instance);
      }
      if (visualElement) {
        instance ? visualElement.mount(instance) : visualElement.unmount();
      }
      const ref = externalRefContainer.current;
      if (typeof ref === "function") {
        if (instance) {
          const cleanup = ref(instance);
          if (typeof cleanup === "function") {
            refCleanup.current = cleanup;
          }
        } else if (refCleanup.current) {
          refCleanup.current();
          refCleanup.current = null;
        } else {
          ref(instance);
        }
      } else if (ref) {
        ref.current = instance;
      }
    }, [visualElement]);
  }

  // ../../node_modules/framer-motion/dist/es/motion/utils/use-visual-element.mjs
  var import_react22 = __toESM(require_react2(), 1);

  // ../../node_modules/framer-motion/dist/es/render/dom/utils/camel-to-dash.mjs
  var camelToDash = (str) => str.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase();

  // ../../node_modules/framer-motion/dist/es/animation/optimized-appear/data-id.mjs
  var optimizedAppearDataId = "framerAppearId";
  var optimizedAppearDataAttribute = "data-" + camelToDash(optimizedAppearDataId);

  // ../../node_modules/framer-motion/dist/es/context/SwitchLayoutGroupContext.mjs
  var import_react21 = __toESM(require_react2(), 1);
  var SwitchLayoutGroupContext = (0, import_react21.createContext)({});

  // ../../node_modules/framer-motion/dist/es/utils/is-ref-object.mjs
  function isRefObject(ref) {
    return ref && typeof ref === "object" && Object.prototype.hasOwnProperty.call(ref, "current");
  }

  // ../../node_modules/framer-motion/dist/es/motion/utils/use-visual-element.mjs
  function useVisualElement(Component3, visualState, props, createVisualElement, ProjectionNodeConstructor, isSVG) {
    const { visualElement: parent } = (0, import_react22.useContext)(MotionContext);
    const lazyContext = (0, import_react22.useContext)(LazyContext);
    const presenceContext = (0, import_react22.useContext)(PresenceContext);
    const reducedMotionConfig = (0, import_react22.useContext)(MotionConfigContext).reducedMotion;
    const visualElementRef = (0, import_react22.useRef)(null);
    createVisualElement = createVisualElement || lazyContext.renderer;
    if (!visualElementRef.current && createVisualElement) {
      visualElementRef.current = createVisualElement(Component3, {
        visualState,
        parent,
        props,
        presenceContext,
        blockInitialAnimation: presenceContext ? presenceContext.initial === false : false,
        reducedMotionConfig,
        isSVG
      });
    }
    const visualElement = visualElementRef.current;
    const initialLayoutGroupConfig = (0, import_react22.useContext)(SwitchLayoutGroupContext);
    if (visualElement && !visualElement.projection && ProjectionNodeConstructor && (visualElement.type === "html" || visualElement.type === "svg")) {
      createProjectionNode(visualElementRef.current, props, ProjectionNodeConstructor, initialLayoutGroupConfig);
    }
    const isMounted = (0, import_react22.useRef)(false);
    (0, import_react22.useInsertionEffect)(() => {
      if (visualElement && isMounted.current) {
        visualElement.update(props, presenceContext);
      }
    });
    const optimisedAppearId = props[optimizedAppearDataAttribute];
    const wantsHandoff = (0, import_react22.useRef)(Boolean(optimisedAppearId) && !window.MotionHandoffIsComplete?.(optimisedAppearId) && window.MotionHasOptimisedAnimation?.(optimisedAppearId));
    useIsomorphicLayoutEffect(() => {
      if (!visualElement)
        return;
      isMounted.current = true;
      window.MotionIsMounted = true;
      visualElement.updateFeatures();
      visualElement.scheduleRenderMicrotask();
      if (wantsHandoff.current && visualElement.animationState) {
        visualElement.animationState.animateChanges();
      }
    });
    (0, import_react22.useEffect)(() => {
      if (!visualElement)
        return;
      if (!wantsHandoff.current && visualElement.animationState) {
        visualElement.animationState.animateChanges();
      }
      if (wantsHandoff.current) {
        queueMicrotask(() => {
          window.MotionHandoffMarkAsComplete?.(optimisedAppearId);
        });
        wantsHandoff.current = false;
      }
      visualElement.enteringChildren = void 0;
    });
    return visualElement;
  }
  function createProjectionNode(visualElement, props, ProjectionNodeConstructor, initialPromotionConfig) {
    const { layoutId, layout: layout2, drag: drag2, dragConstraints, layoutScroll, layoutRoot, layoutCrossfade } = props;
    visualElement.projection = new ProjectionNodeConstructor(visualElement.latestValues, props["data-framer-portal-id"] ? void 0 : getClosestProjectingNode(visualElement.parent));
    visualElement.projection.setOptions({
      layoutId,
      layout: layout2,
      alwaysMeasureLayout: Boolean(drag2) || dragConstraints && isRefObject(dragConstraints),
      visualElement,
      /**
       * TODO: Update options in an effect. This could be tricky as it'll be too late
       * to update by the time layout animations run.
       * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
       * ensuring it gets called if there's no potential layout animations.
       *
       */
      animationType: typeof layout2 === "string" ? layout2 : "both",
      initialPromotionConfig,
      crossfade: layoutCrossfade,
      layoutScroll,
      layoutRoot
    });
  }
  function getClosestProjectingNode(visualElement) {
    if (!visualElement)
      return void 0;
    return visualElement.options.allowProjection !== false ? visualElement.projection : getClosestProjectingNode(visualElement.parent);
  }

  // ../../node_modules/framer-motion/dist/es/motion/index.mjs
  function createMotionComponent(Component3, { forwardMotionProps = false, type } = {}, preloadedFeatures, createVisualElement) {
    preloadedFeatures && loadFeatures(preloadedFeatures);
    const isSVG = type ? type === "svg" : isSVGComponent(Component3);
    const useVisualState = isSVG ? useSVGVisualState : useHTMLVisualState;
    function MotionDOMComponent(props, externalRef) {
      let MeasureLayout2;
      const configAndProps = {
        ...(0, import_react23.useContext)(MotionConfigContext),
        ...props,
        layoutId: useLayoutId(props)
      };
      const { isStatic } = configAndProps;
      const context = useCreateMotionContext(props);
      const visualState = useVisualState(props, isStatic);
      if (!isStatic && isBrowser) {
        useStrictMode(configAndProps, preloadedFeatures);
        const layoutProjection = getProjectionFunctionality(configAndProps);
        MeasureLayout2 = layoutProjection.MeasureLayout;
        context.visualElement = useVisualElement(Component3, visualState, configAndProps, createVisualElement, layoutProjection.ProjectionNode, isSVG);
      }
      return (0, import_jsx_runtime6.jsxs)(MotionContext.Provider, { value: context, children: [MeasureLayout2 && context.visualElement ? (0, import_jsx_runtime6.jsx)(MeasureLayout2, { visualElement: context.visualElement, ...configAndProps }) : null, useRender(Component3, props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, forwardMotionProps, isSVG)] });
    }
    MotionDOMComponent.displayName = `motion.${typeof Component3 === "string" ? Component3 : `create(${Component3.displayName ?? Component3.name ?? ""})`}`;
    const ForwardRefMotionComponent = (0, import_react23.forwardRef)(MotionDOMComponent);
    ForwardRefMotionComponent[motionComponentSymbol] = Component3;
    return ForwardRefMotionComponent;
  }
  function useLayoutId({ layoutId }) {
    const layoutGroupId = (0, import_react23.useContext)(LayoutGroupContext).id;
    return layoutGroupId && layoutId !== void 0 ? layoutGroupId + "-" + layoutId : layoutId;
  }
  function useStrictMode(configAndProps, preloadedFeatures) {
    const isStrict = (0, import_react23.useContext)(LazyContext).strict;
    if (process.env.NODE_ENV !== "production" && preloadedFeatures && isStrict) {
      const strictMessage = "You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.";
      configAndProps.ignoreStrict ? warning(false, strictMessage, "lazy-strict-mode") : invariant(false, strictMessage, "lazy-strict-mode");
    }
  }
  function getProjectionFunctionality(props) {
    const { drag: drag2, layout: layout2 } = featureDefinitions;
    if (!drag2 && !layout2)
      return {};
    const combined = { ...drag2, ...layout2 };
    return {
      MeasureLayout: drag2?.isEnabled(props) || layout2?.isEnabled(props) ? combined.MeasureLayout : void 0,
      ProjectionNode: combined.ProjectionNode
    };
  }

  // ../../node_modules/framer-motion/dist/es/render/components/create-proxy.mjs
  function createMotionProxy(preloadedFeatures, createVisualElement) {
    if (typeof Proxy === "undefined") {
      return createMotionComponent;
    }
    const componentCache = /* @__PURE__ */ new Map();
    const factory = (Component3, options) => {
      return createMotionComponent(Component3, options, preloadedFeatures, createVisualElement);
    };
    const deprecatedFactoryFunction = (Component3, options) => {
      if (process.env.NODE_ENV !== "production") {
        warnOnce(false, "motion() is deprecated. Use motion.create() instead.");
      }
      return factory(Component3, options);
    };
    return new Proxy(deprecatedFactoryFunction, {
      /**
       * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
       * The prop name is passed through as `key` and we can use that to generate a `motion`
       * DOM component with that name.
       */
      get: (_target, key) => {
        if (key === "create")
          return factory;
        if (!componentCache.has(key)) {
          componentCache.set(key, createMotionComponent(key, void 0, preloadedFeatures, createVisualElement));
        }
        return componentCache.get(key);
      }
    });
  }

  // ../../node_modules/framer-motion/dist/es/render/dom/create-visual-element.mjs
  var import_react24 = __toESM(require_react2(), 1);

  // ../../node_modules/framer-motion/dist/es/projection/geometry/conversion.mjs
  function convertBoundingBoxToBox({ top, left, right, bottom }) {
    return {
      x: { min: left, max: right },
      y: { min: top, max: bottom }
    };
  }
  function convertBoxToBoundingBox({ x: x2, y: y2 }) {
    return { top: y2.min, right: x2.max, bottom: y2.max, left: x2.min };
  }
  function transformBoxPoints(point2, transformPoint2) {
    if (!transformPoint2)
      return point2;
    const topLeft = transformPoint2({ x: point2.left, y: point2.top });
    const bottomRight = transformPoint2({ x: point2.right, y: point2.bottom });
    return {
      top: topLeft.y,
      left: topLeft.x,
      bottom: bottomRight.y,
      right: bottomRight.x
    };
  }

  // ../../node_modules/framer-motion/dist/es/projection/utils/has-transform.mjs
  function isIdentityScale(scale2) {
    return scale2 === void 0 || scale2 === 1;
  }
  function hasScale({ scale: scale2, scaleX: scaleX2, scaleY: scaleY2 }) {
    return !isIdentityScale(scale2) || !isIdentityScale(scaleX2) || !isIdentityScale(scaleY2);
  }
  function hasTransform(values) {
    return hasScale(values) || has2DTranslate(values) || values.z || values.rotate || values.rotateX || values.rotateY || values.skewX || values.skewY;
  }
  function has2DTranslate(values) {
    return is2DTranslate(values.x) || is2DTranslate(values.y);
  }
  function is2DTranslate(value) {
    return value && value !== "0%";
  }

  // ../../node_modules/framer-motion/dist/es/projection/geometry/delta-apply.mjs
  function scalePoint(point2, scale2, originPoint) {
    const distanceFromOrigin = point2 - originPoint;
    const scaled = scale2 * distanceFromOrigin;
    return originPoint + scaled;
  }
  function applyPointDelta(point2, translate, scale2, originPoint, boxScale) {
    if (boxScale !== void 0) {
      point2 = scalePoint(point2, boxScale, originPoint);
    }
    return scalePoint(point2, scale2, originPoint) + translate;
  }
  function applyAxisDelta(axis, translate = 0, scale2 = 1, originPoint, boxScale) {
    axis.min = applyPointDelta(axis.min, translate, scale2, originPoint, boxScale);
    axis.max = applyPointDelta(axis.max, translate, scale2, originPoint, boxScale);
  }
  function applyBoxDelta(box, { x: x2, y: y2 }) {
    applyAxisDelta(box.x, x2.translate, x2.scale, x2.originPoint);
    applyAxisDelta(box.y, y2.translate, y2.scale, y2.originPoint);
  }
  var TREE_SCALE_SNAP_MIN = 0.999999999999;
  var TREE_SCALE_SNAP_MAX = 1.0000000000001;
  function applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false) {
    const treeLength = treePath.length;
    if (!treeLength)
      return;
    treeScale.x = treeScale.y = 1;
    let node;
    let delta;
    for (let i3 = 0; i3 < treeLength; i3++) {
      node = treePath[i3];
      delta = node.projectionDelta;
      const { visualElement } = node.options;
      if (visualElement && visualElement.props.style && visualElement.props.style.display === "contents") {
        continue;
      }
      if (isSharedTransition && node.options.layoutScroll && node.scroll && node !== node.root) {
        transformBox(box, {
          x: -node.scroll.offset.x,
          y: -node.scroll.offset.y
        });
      }
      if (delta) {
        treeScale.x *= delta.x.scale;
        treeScale.y *= delta.y.scale;
        applyBoxDelta(box, delta);
      }
      if (isSharedTransition && hasTransform(node.latestValues)) {
        transformBox(box, node.latestValues);
      }
    }
    if (treeScale.x < TREE_SCALE_SNAP_MAX && treeScale.x > TREE_SCALE_SNAP_MIN) {
      treeScale.x = 1;
    }
    if (treeScale.y < TREE_SCALE_SNAP_MAX && treeScale.y > TREE_SCALE_SNAP_MIN) {
      treeScale.y = 1;
    }
  }
  function translateAxis(axis, distance2) {
    axis.min = axis.min + distance2;
    axis.max = axis.max + distance2;
  }
  function transformAxis(axis, axisTranslate, axisScale, boxScale, axisOrigin = 0.5) {
    const originPoint = mixNumber(axis.min, axis.max, axisOrigin);
    applyAxisDelta(axis, axisTranslate, axisScale, originPoint, boxScale);
  }
  function transformBox(box, transform2) {
    transformAxis(box.x, transform2.x, transform2.scaleX, transform2.scale, transform2.originX);
    transformAxis(box.y, transform2.y, transform2.scaleY, transform2.scale, transform2.originY);
  }

  // ../../node_modules/framer-motion/dist/es/projection/utils/measure.mjs
  function measureViewportBox(instance, transformPoint2) {
    return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint2));
  }
  function measurePageBox(element, rootProjectionNode2, transformPagePoint) {
    const viewportBox = measureViewportBox(element, transformPagePoint);
    const { scroll: scroll2 } = rootProjectionNode2;
    if (scroll2) {
      translateAxis(viewportBox.x, scroll2.offset.x);
      translateAxis(viewportBox.y, scroll2.offset.y);
    }
    return viewportBox;
  }

  // ../../node_modules/framer-motion/dist/es/projection/geometry/models.mjs
  var createAxisDelta = () => ({
    translate: 0,
    scale: 1,
    origin: 0,
    originPoint: 0
  });
  var createDelta = () => ({
    x: createAxisDelta(),
    y: createAxisDelta()
  });
  var createAxis = () => ({ min: 0, max: 0 });
  var createBox = () => ({
    x: createAxis(),
    y: createAxis()
  });

  // ../../node_modules/framer-motion/dist/es/utils/reduced-motion/state.mjs
  var prefersReducedMotion = { current: null };
  var hasReducedMotionListener = { current: false };

  // ../../node_modules/framer-motion/dist/es/utils/reduced-motion/index.mjs
  function initPrefersReducedMotion() {
    hasReducedMotionListener.current = true;
    if (!isBrowser)
      return;
    if (window.matchMedia) {
      const motionMediaQuery = window.matchMedia("(prefers-reduced-motion)");
      const setReducedMotionPreferences = () => prefersReducedMotion.current = motionMediaQuery.matches;
      motionMediaQuery.addEventListener("change", setReducedMotionPreferences);
      setReducedMotionPreferences();
    } else {
      prefersReducedMotion.current = false;
    }
  }

  // ../../node_modules/framer-motion/dist/es/render/store.mjs
  var visualElementStore = /* @__PURE__ */ new WeakMap();

  // ../../node_modules/framer-motion/dist/es/render/utils/motion-values.mjs
  function updateMotionValuesFromProps(element, next, prev) {
    for (const key in next) {
      const nextValue = next[key];
      const prevValue = prev[key];
      if (isMotionValue(nextValue)) {
        element.addValue(key, nextValue);
      } else if (isMotionValue(prevValue)) {
        element.addValue(key, motionValue(nextValue, { owner: element }));
      } else if (prevValue !== nextValue) {
        if (element.hasValue(key)) {
          const existingValue = element.getValue(key);
          if (existingValue.liveStyle === true) {
            existingValue.jump(nextValue);
          } else if (!existingValue.hasAnimated) {
            existingValue.set(nextValue);
          }
        } else {
          const latestValue = element.getStaticValue(key);
          element.addValue(key, motionValue(latestValue !== void 0 ? latestValue : nextValue, { owner: element }));
        }
      }
    }
    for (const key in prev) {
      if (next[key] === void 0)
        element.removeValue(key);
    }
    return next;
  }

  // ../../node_modules/framer-motion/dist/es/render/VisualElement.mjs
  var propEventHandlers = [
    "AnimationStart",
    "AnimationComplete",
    "Update",
    "BeforeLayoutMeasure",
    "LayoutMeasure",
    "LayoutAnimationStart",
    "LayoutAnimationComplete"
  ];
  var VisualElement = class {
    /**
     * This method takes React props and returns found MotionValues. For example, HTML
     * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
     *
     * This isn't an abstract method as it needs calling in the constructor, but it is
     * intended to be one.
     */
    scrapeMotionValuesFromProps(_props, _prevProps, _visualElement) {
      return {};
    }
    constructor({ parent, props, presenceContext, reducedMotionConfig, blockInitialAnimation, visualState }, options = {}) {
      this.current = null;
      this.children = /* @__PURE__ */ new Set();
      this.isVariantNode = false;
      this.isControllingVariants = false;
      this.shouldReduceMotion = null;
      this.values = /* @__PURE__ */ new Map();
      this.KeyframeResolver = KeyframeResolver;
      this.features = {};
      this.valueSubscriptions = /* @__PURE__ */ new Map();
      this.prevMotionValues = {};
      this.events = {};
      this.propEventSubscriptions = {};
      this.notifyUpdate = () => this.notify("Update", this.latestValues);
      this.render = () => {
        if (!this.current)
          return;
        this.triggerBuild();
        this.renderInstance(this.current, this.renderState, this.props.style, this.projection);
      };
      this.renderScheduledAt = 0;
      this.scheduleRender = () => {
        const now2 = time.now();
        if (this.renderScheduledAt < now2) {
          this.renderScheduledAt = now2;
          frame.render(this.render, false, true);
        }
      };
      const { latestValues, renderState } = visualState;
      this.latestValues = latestValues;
      this.baseTarget = { ...latestValues };
      this.initialValues = props.initial ? { ...latestValues } : {};
      this.renderState = renderState;
      this.parent = parent;
      this.props = props;
      this.presenceContext = presenceContext;
      this.depth = parent ? parent.depth + 1 : 0;
      this.reducedMotionConfig = reducedMotionConfig;
      this.options = options;
      this.blockInitialAnimation = Boolean(blockInitialAnimation);
      this.isControllingVariants = isControllingVariants(props);
      this.isVariantNode = isVariantNode(props);
      if (this.isVariantNode) {
        this.variantChildren = /* @__PURE__ */ new Set();
      }
      this.manuallyAnimateOnMount = Boolean(parent && parent.current);
      const { willChange, ...initialMotionValues } = this.scrapeMotionValuesFromProps(props, {}, this);
      for (const key in initialMotionValues) {
        const value = initialMotionValues[key];
        if (latestValues[key] !== void 0 && isMotionValue(value)) {
          value.set(latestValues[key]);
        }
      }
    }
    mount(instance) {
      this.current = instance;
      visualElementStore.set(instance, this);
      if (this.projection && !this.projection.instance) {
        this.projection.mount(instance);
      }
      if (this.parent && this.isVariantNode && !this.isControllingVariants) {
        this.removeFromVariantTree = this.parent.addVariantChild(this);
      }
      this.values.forEach((value, key) => this.bindToMotionValue(key, value));
      if (this.reducedMotionConfig === "never") {
        this.shouldReduceMotion = false;
      } else if (this.reducedMotionConfig === "always") {
        this.shouldReduceMotion = true;
      } else {
        if (!hasReducedMotionListener.current) {
          initPrefersReducedMotion();
        }
        this.shouldReduceMotion = prefersReducedMotion.current;
      }
      if (process.env.NODE_ENV !== "production") {
        warnOnce(this.shouldReduceMotion !== true, "You have Reduced Motion enabled on your device. Animations may not appear as expected.", "reduced-motion-disabled");
      }
      this.parent?.addChild(this);
      this.update(this.props, this.presenceContext);
    }
    unmount() {
      this.projection && this.projection.unmount();
      cancelFrame(this.notifyUpdate);
      cancelFrame(this.render);
      this.valueSubscriptions.forEach((remove) => remove());
      this.valueSubscriptions.clear();
      this.removeFromVariantTree && this.removeFromVariantTree();
      this.parent?.removeChild(this);
      for (const key in this.events) {
        this.events[key].clear();
      }
      for (const key in this.features) {
        const feature = this.features[key];
        if (feature) {
          feature.unmount();
          feature.isMounted = false;
        }
      }
      this.current = null;
    }
    addChild(child) {
      this.children.add(child);
      this.enteringChildren ?? (this.enteringChildren = /* @__PURE__ */ new Set());
      this.enteringChildren.add(child);
    }
    removeChild(child) {
      this.children.delete(child);
      this.enteringChildren && this.enteringChildren.delete(child);
    }
    bindToMotionValue(key, value) {
      if (this.valueSubscriptions.has(key)) {
        this.valueSubscriptions.get(key)();
      }
      const valueIsTransform = transformProps.has(key);
      if (valueIsTransform && this.onBindTransform) {
        this.onBindTransform();
      }
      const removeOnChange = value.on("change", (latestValue) => {
        this.latestValues[key] = latestValue;
        this.props.onUpdate && frame.preRender(this.notifyUpdate);
        if (valueIsTransform && this.projection) {
          this.projection.isTransformDirty = true;
        }
        this.scheduleRender();
      });
      let removeSyncCheck;
      if (window.MotionCheckAppearSync) {
        removeSyncCheck = window.MotionCheckAppearSync(this, key, value);
      }
      this.valueSubscriptions.set(key, () => {
        removeOnChange();
        if (removeSyncCheck)
          removeSyncCheck();
        if (value.owner)
          value.stop();
      });
    }
    sortNodePosition(other) {
      if (!this.current || !this.sortInstanceNodePosition || this.type !== other.type) {
        return 0;
      }
      return this.sortInstanceNodePosition(this.current, other.current);
    }
    updateFeatures() {
      let key = "animation";
      for (key in featureDefinitions) {
        const featureDefinition = featureDefinitions[key];
        if (!featureDefinition)
          continue;
        const { isEnabled, Feature: FeatureConstructor } = featureDefinition;
        if (!this.features[key] && FeatureConstructor && isEnabled(this.props)) {
          this.features[key] = new FeatureConstructor(this);
        }
        if (this.features[key]) {
          const feature = this.features[key];
          if (feature.isMounted) {
            feature.update();
          } else {
            feature.mount();
            feature.isMounted = true;
          }
        }
      }
    }
    triggerBuild() {
      this.build(this.renderState, this.latestValues, this.props);
    }
    /**
     * Measure the current viewport box with or without transforms.
     * Only measures axis-aligned boxes, rotate and skew must be manually
     * removed with a re-render to work.
     */
    measureViewportBox() {
      return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox();
    }
    getStaticValue(key) {
      return this.latestValues[key];
    }
    setStaticValue(key, value) {
      this.latestValues[key] = value;
    }
    /**
     * Update the provided props. Ensure any newly-added motion values are
     * added to our map, old ones removed, and listeners updated.
     */
    update(props, presenceContext) {
      if (props.transformTemplate || this.props.transformTemplate) {
        this.scheduleRender();
      }
      this.prevProps = this.props;
      this.props = props;
      this.prevPresenceContext = this.presenceContext;
      this.presenceContext = presenceContext;
      for (let i3 = 0; i3 < propEventHandlers.length; i3++) {
        const key = propEventHandlers[i3];
        if (this.propEventSubscriptions[key]) {
          this.propEventSubscriptions[key]();
          delete this.propEventSubscriptions[key];
        }
        const listenerName = "on" + key;
        const listener = props[listenerName];
        if (listener) {
          this.propEventSubscriptions[key] = this.on(key, listener);
        }
      }
      this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props, this.prevProps, this), this.prevMotionValues);
      if (this.handleChildMotionValue) {
        this.handleChildMotionValue();
      }
    }
    getProps() {
      return this.props;
    }
    /**
     * Returns the variant definition with a given name.
     */
    getVariant(name) {
      return this.props.variants ? this.props.variants[name] : void 0;
    }
    /**
     * Returns the defined default transition on this component.
     */
    getDefaultTransition() {
      return this.props.transition;
    }
    getTransformPagePoint() {
      return this.props.transformPagePoint;
    }
    getClosestVariantNode() {
      return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
    }
    /**
     * Add a child visual element to our set of children.
     */
    addVariantChild(child) {
      const closestVariantNode = this.getClosestVariantNode();
      if (closestVariantNode) {
        closestVariantNode.variantChildren && closestVariantNode.variantChildren.add(child);
        return () => closestVariantNode.variantChildren.delete(child);
      }
    }
    /**
     * Add a motion value and bind it to this visual element.
     */
    addValue(key, value) {
      const existingValue = this.values.get(key);
      if (value !== existingValue) {
        if (existingValue)
          this.removeValue(key);
        this.bindToMotionValue(key, value);
        this.values.set(key, value);
        this.latestValues[key] = value.get();
      }
    }
    /**
     * Remove a motion value and unbind any active subscriptions.
     */
    removeValue(key) {
      this.values.delete(key);
      const unsubscribe = this.valueSubscriptions.get(key);
      if (unsubscribe) {
        unsubscribe();
        this.valueSubscriptions.delete(key);
      }
      delete this.latestValues[key];
      this.removeValueFromRenderState(key, this.renderState);
    }
    /**
     * Check whether we have a motion value for this key
     */
    hasValue(key) {
      return this.values.has(key);
    }
    getValue(key, defaultValue) {
      if (this.props.values && this.props.values[key]) {
        return this.props.values[key];
      }
      let value = this.values.get(key);
      if (value === void 0 && defaultValue !== void 0) {
        value = motionValue(defaultValue === null ? void 0 : defaultValue, { owner: this });
        this.addValue(key, value);
      }
      return value;
    }
    /**
     * If we're trying to animate to a previously unencountered value,
     * we need to check for it in our state and as a last resort read it
     * directly from the instance (which might have performance implications).
     */
    readValue(key, target) {
      let value = this.latestValues[key] !== void 0 || !this.current ? this.latestValues[key] : this.getBaseTargetFromProps(this.props, key) ?? this.readValueFromInstance(this.current, key, this.options);
      if (value !== void 0 && value !== null) {
        if (typeof value === "string" && (isNumericalString(value) || isZeroValueString(value))) {
          value = parseFloat(value);
        } else if (!findValueType(value) && complex.test(target)) {
          value = getAnimatableNone2(key, target);
        }
        this.setBaseTarget(key, isMotionValue(value) ? value.get() : value);
      }
      return isMotionValue(value) ? value.get() : value;
    }
    /**
     * Set the base target to later animate back to. This is currently
     * only hydrated on creation and when we first read a value.
     */
    setBaseTarget(key, value) {
      this.baseTarget[key] = value;
    }
    /**
     * Find the base target for a value thats been removed from all animation
     * props.
     */
    getBaseTarget(key) {
      const { initial } = this.props;
      let valueFromInitial;
      if (typeof initial === "string" || typeof initial === "object") {
        const variant = resolveVariantFromProps(this.props, initial, this.presenceContext?.custom);
        if (variant) {
          valueFromInitial = variant[key];
        }
      }
      if (initial && valueFromInitial !== void 0) {
        return valueFromInitial;
      }
      const target = this.getBaseTargetFromProps(this.props, key);
      if (target !== void 0 && !isMotionValue(target))
        return target;
      return this.initialValues[key] !== void 0 && valueFromInitial === void 0 ? void 0 : this.baseTarget[key];
    }
    on(eventName, callback) {
      if (!this.events[eventName]) {
        this.events[eventName] = new SubscriptionManager();
      }
      return this.events[eventName].add(callback);
    }
    notify(eventName, ...args) {
      if (this.events[eventName]) {
        this.events[eventName].notify(...args);
      }
    }
    scheduleRenderMicrotask() {
      microtask.render(this.render);
    }
  };

  // ../../node_modules/framer-motion/dist/es/render/dom/DOMVisualElement.mjs
  var DOMVisualElement = class extends VisualElement {
    constructor() {
      super(...arguments);
      this.KeyframeResolver = DOMKeyframesResolver;
    }
    sortInstanceNodePosition(a, b2) {
      return a.compareDocumentPosition(b2) & 2 ? 1 : -1;
    }
    getBaseTargetFromProps(props, key) {
      return props.style ? props.style[key] : void 0;
    }
    removeValueFromRenderState(key, { vars, style }) {
      delete vars[key];
      delete style[key];
    }
    handleChildMotionValue() {
      if (this.childSubscription) {
        this.childSubscription();
        delete this.childSubscription;
      }
      const { children } = this.props;
      if (isMotionValue(children)) {
        this.childSubscription = children.on("change", (latest) => {
          if (this.current) {
            this.current.textContent = `${latest}`;
          }
        });
      }
    }
  };

  // ../../node_modules/framer-motion/dist/es/render/html/utils/render.mjs
  function renderHTML(element, { style, vars }, styleProp, projection) {
    const elementStyle = element.style;
    let key;
    for (key in style) {
      elementStyle[key] = style[key];
    }
    projection?.applyProjectionStyles(elementStyle, styleProp);
    for (key in vars) {
      elementStyle.setProperty(key, vars[key]);
    }
  }

  // ../../node_modules/framer-motion/dist/es/render/html/HTMLVisualElement.mjs
  function getComputedStyle2(element) {
    return window.getComputedStyle(element);
  }
  var HTMLVisualElement = class extends DOMVisualElement {
    constructor() {
      super(...arguments);
      this.type = "html";
      this.renderInstance = renderHTML;
    }
    readValueFromInstance(instance, key) {
      if (transformProps.has(key)) {
        return this.projection?.isProjecting ? defaultTransformValue(key) : readTransformValue(instance, key);
      } else {
        const computedStyle = getComputedStyle2(instance);
        const value = (isCSSVariableName(key) ? computedStyle.getPropertyValue(key) : computedStyle[key]) || 0;
        return typeof value === "string" ? value.trim() : value;
      }
    }
    measureInstanceViewportBox(instance, { transformPagePoint }) {
      return measureViewportBox(instance, transformPagePoint);
    }
    build(renderState, latestValues, props) {
      buildHTMLStyles(renderState, latestValues, props.transformTemplate);
    }
    scrapeMotionValuesFromProps(props, prevProps, visualElement) {
      return scrapeMotionValuesFromProps(props, prevProps, visualElement);
    }
  };

  // ../../node_modules/framer-motion/dist/es/render/svg/utils/camel-case-attrs.mjs
  var camelCaseAttributes = /* @__PURE__ */ new Set([
    "baseFrequency",
    "diffuseConstant",
    "kernelMatrix",
    "kernelUnitLength",
    "keySplines",
    "keyTimes",
    "limitingConeAngle",
    "markerHeight",
    "markerWidth",
    "numOctaves",
    "targetX",
    "targetY",
    "surfaceScale",
    "specularConstant",
    "specularExponent",
    "stdDeviation",
    "tableValues",
    "viewBox",
    "gradientTransform",
    "pathLength",
    "startOffset",
    "textLength",
    "lengthAdjust"
  ]);

  // ../../node_modules/framer-motion/dist/es/render/svg/utils/render.mjs
  function renderSVG(element, renderState, _styleProp, projection) {
    renderHTML(element, renderState, void 0, projection);
    for (const key in renderState.attrs) {
      element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);
    }
  }

  // ../../node_modules/framer-motion/dist/es/render/svg/SVGVisualElement.mjs
  var SVGVisualElement = class extends DOMVisualElement {
    constructor() {
      super(...arguments);
      this.type = "svg";
      this.isSVGTag = false;
      this.measureInstanceViewportBox = createBox;
    }
    getBaseTargetFromProps(props, key) {
      return props[key];
    }
    readValueFromInstance(instance, key) {
      if (transformProps.has(key)) {
        const defaultType = getDefaultValueType(key);
        return defaultType ? defaultType.default || 0 : 0;
      }
      key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;
      return instance.getAttribute(key);
    }
    scrapeMotionValuesFromProps(props, prevProps, visualElement) {
      return scrapeMotionValuesFromProps2(props, prevProps, visualElement);
    }
    build(renderState, latestValues, props) {
      buildSVGAttrs(renderState, latestValues, this.isSVGTag, props.transformTemplate, props.style);
    }
    renderInstance(instance, renderState, styleProp, projection) {
      renderSVG(instance, renderState, styleProp, projection);
    }
    mount(instance) {
      this.isSVGTag = isSVGTag(instance.tagName);
      super.mount(instance);
    }
  };

  // ../../node_modules/framer-motion/dist/es/render/dom/create-visual-element.mjs
  var createDomVisualElement = (Component3, options) => {
    const isSVG = options.isSVG ?? isSVGComponent(Component3);
    return isSVG ? new SVGVisualElement(options) : new HTMLVisualElement(options, {
      allowProjection: Component3 !== import_react24.Fragment
    });
  };

  // ../../node_modules/framer-motion/dist/es/render/utils/resolve-dynamic-variants.mjs
  function resolveVariant(visualElement, definition, custom) {
    const props = visualElement.getProps();
    return resolveVariantFromProps(props, definition, custom !== void 0 ? custom : props.custom, visualElement);
  }

  // ../../node_modules/framer-motion/dist/es/animation/utils/is-keyframes-target.mjs
  var isKeyframesTarget = (v2) => {
    return Array.isArray(v2);
  };

  // ../../node_modules/framer-motion/dist/es/render/utils/setters.mjs
  function setMotionValue(visualElement, key, value) {
    if (visualElement.hasValue(key)) {
      visualElement.getValue(key).set(value);
    } else {
      visualElement.addValue(key, motionValue(value));
    }
  }
  function resolveFinalValueInKeyframes(v2) {
    return isKeyframesTarget(v2) ? v2[v2.length - 1] || 0 : v2;
  }
  function setTarget(visualElement, definition) {
    const resolved = resolveVariant(visualElement, definition);
    let { transitionEnd = {}, transition = {}, ...target } = resolved || {};
    target = { ...target, ...transitionEnd };
    for (const key in target) {
      const value = resolveFinalValueInKeyframes(target[key]);
      setMotionValue(visualElement, key, value);
    }
  }

  // ../../node_modules/framer-motion/dist/es/value/use-will-change/is.mjs
  function isWillChangeMotionValue(value) {
    return Boolean(isMotionValue(value) && value.add);
  }

  // ../../node_modules/framer-motion/dist/es/value/use-will-change/add-will-change.mjs
  function addValueToWillChange(visualElement, key) {
    const willChange = visualElement.getValue("willChange");
    if (isWillChangeMotionValue(willChange)) {
      return willChange.add(key);
    } else if (!willChange && MotionGlobalConfig.WillChange) {
      const newWillChange = new MotionGlobalConfig.WillChange("auto");
      visualElement.addValue("willChange", newWillChange);
      newWillChange.add(key);
    }
  }

  // ../../node_modules/framer-motion/dist/es/animation/optimized-appear/get-appear-id.mjs
  function getOptimisedAppearId(visualElement) {
    return visualElement.props[optimizedAppearDataAttribute];
  }

  // ../../node_modules/framer-motion/dist/es/animation/animators/waapi/utils/get-final-keyframe.mjs
  var isNotNull2 = (value) => value !== null;
  function getFinalKeyframe2(keyframes2, { repeat, repeatType = "loop" }, finalKeyframe) {
    const resolvedKeyframes = keyframes2.filter(isNotNull2);
    const index2 = repeat && repeatType !== "loop" && repeat % 2 === 1 ? 0 : resolvedKeyframes.length - 1;
    return !index2 || finalKeyframe === void 0 ? resolvedKeyframes[index2] : finalKeyframe;
  }

  // ../../node_modules/framer-motion/dist/es/animation/utils/default-transitions.mjs
  var underDampedSpring = {
    type: "spring",
    stiffness: 500,
    damping: 25,
    restSpeed: 10
  };
  var criticallyDampedSpring = (target) => ({
    type: "spring",
    stiffness: 550,
    damping: target === 0 ? 2 * Math.sqrt(550) : 30,
    restSpeed: 10
  });
  var keyframesTransition = {
    type: "keyframes",
    duration: 0.8
  };
  var ease = {
    type: "keyframes",
    ease: [0.25, 0.1, 0.35, 1],
    duration: 0.3
  };
  var getDefaultTransition = (valueKey, { keyframes: keyframes2 }) => {
    if (keyframes2.length > 2) {
      return keyframesTransition;
    } else if (transformProps.has(valueKey)) {
      return valueKey.startsWith("scale") ? criticallyDampedSpring(keyframes2[1]) : underDampedSpring;
    }
    return ease;
  };

  // ../../node_modules/framer-motion/dist/es/animation/utils/is-transition-defined.mjs
  function isTransitionDefined({ when, delay: _delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from, elapsed, ...transition }) {
    return !!Object.keys(transition).length;
  }

  // ../../node_modules/framer-motion/dist/es/animation/interfaces/motion-value.mjs
  var animateMotionValue = (name, value, target, transition = {}, element, isHandoff) => (onComplete) => {
    const valueTransition = getValueTransition(transition, name) || {};
    const delay2 = valueTransition.delay || transition.delay || 0;
    let { elapsed = 0 } = transition;
    elapsed = elapsed - secondsToMilliseconds(delay2);
    const options = {
      keyframes: Array.isArray(target) ? target : [null, target],
      ease: "easeOut",
      velocity: value.getVelocity(),
      ...valueTransition,
      delay: -elapsed,
      onUpdate: (v2) => {
        value.set(v2);
        valueTransition.onUpdate && valueTransition.onUpdate(v2);
      },
      onComplete: () => {
        onComplete();
        valueTransition.onComplete && valueTransition.onComplete();
      },
      name,
      motionValue: value,
      element: isHandoff ? void 0 : element
    };
    if (!isTransitionDefined(valueTransition)) {
      Object.assign(options, getDefaultTransition(name, options));
    }
    options.duration && (options.duration = secondsToMilliseconds(options.duration));
    options.repeatDelay && (options.repeatDelay = secondsToMilliseconds(options.repeatDelay));
    if (options.from !== void 0) {
      options.keyframes[0] = options.from;
    }
    let shouldSkip = false;
    if (options.type === false || options.duration === 0 && !options.repeatDelay) {
      makeAnimationInstant(options);
      if (options.delay === 0) {
        shouldSkip = true;
      }
    }
    if (MotionGlobalConfig.instantAnimations || MotionGlobalConfig.skipAnimations) {
      shouldSkip = true;
      makeAnimationInstant(options);
      options.delay = 0;
    }
    options.allowFlatten = !valueTransition.type && !valueTransition.ease;
    if (shouldSkip && !isHandoff && value.get() !== void 0) {
      const finalKeyframe = getFinalKeyframe2(options.keyframes, valueTransition);
      if (finalKeyframe !== void 0) {
        frame.update(() => {
          options.onUpdate(finalKeyframe);
          options.onComplete();
        });
        return;
      }
    }
    return valueTransition.isSync ? new JSAnimation(options) : new AsyncMotionValueAnimation(options);
  };

  // ../../node_modules/framer-motion/dist/es/animation/interfaces/visual-element-target.mjs
  function shouldBlockAnimation({ protectedKeys, needsAnimating }, key) {
    const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;
    needsAnimating[key] = false;
    return shouldBlock;
  }
  function animateTarget(visualElement, targetAndTransition, { delay: delay2 = 0, transitionOverride, type } = {}) {
    let { transition = visualElement.getDefaultTransition(), transitionEnd, ...target } = targetAndTransition;
    if (transitionOverride)
      transition = transitionOverride;
    const animations2 = [];
    const animationTypeState = type && visualElement.animationState && visualElement.animationState.getState()[type];
    for (const key in target) {
      const value = visualElement.getValue(key, visualElement.latestValues[key] ?? null);
      const valueTarget = target[key];
      if (valueTarget === void 0 || animationTypeState && shouldBlockAnimation(animationTypeState, key)) {
        continue;
      }
      const valueTransition = {
        delay: delay2,
        ...getValueTransition(transition || {}, key)
      };
      const currentValue = value.get();
      if (currentValue !== void 0 && !value.isAnimating && !Array.isArray(valueTarget) && valueTarget === currentValue && !valueTransition.velocity) {
        continue;
      }
      let isHandoff = false;
      if (window.MotionHandoffAnimation) {
        const appearId = getOptimisedAppearId(visualElement);
        if (appearId) {
          const startTime = window.MotionHandoffAnimation(appearId, key, frame);
          if (startTime !== null) {
            valueTransition.startTime = startTime;
            isHandoff = true;
          }
        }
      }
      addValueToWillChange(visualElement, key);
      value.start(animateMotionValue(key, value, valueTarget, visualElement.shouldReduceMotion && positionalKeys.has(key) ? { type: false } : valueTransition, visualElement, isHandoff));
      const animation = value.animation;
      if (animation) {
        animations2.push(animation);
      }
    }
    if (transitionEnd) {
      Promise.all(animations2).then(() => {
        frame.update(() => {
          transitionEnd && setTarget(visualElement, transitionEnd);
        });
      });
    }
    return animations2;
  }

  // ../../node_modules/framer-motion/dist/es/animation/utils/calc-child-stagger.mjs
  function calcChildStagger(children, child, delayChildren, staggerChildren = 0, staggerDirection = 1) {
    const index2 = Array.from(children).sort((a, b2) => a.sortNodePosition(b2)).indexOf(child);
    const numChildren = children.size;
    const maxStaggerDuration = (numChildren - 1) * staggerChildren;
    const delayIsFunction = typeof delayChildren === "function";
    return delayIsFunction ? delayChildren(index2, numChildren) : staggerDirection === 1 ? index2 * staggerChildren : maxStaggerDuration - index2 * staggerChildren;
  }

  // ../../node_modules/framer-motion/dist/es/animation/interfaces/visual-element-variant.mjs
  function animateVariant(visualElement, variant, options = {}) {
    const resolved = resolveVariant(visualElement, variant, options.type === "exit" ? visualElement.presenceContext?.custom : void 0);
    let { transition = visualElement.getDefaultTransition() || {} } = resolved || {};
    if (options.transitionOverride) {
      transition = options.transitionOverride;
    }
    const getAnimation = resolved ? () => Promise.all(animateTarget(visualElement, resolved, options)) : () => Promise.resolve();
    const getChildAnimations = visualElement.variantChildren && visualElement.variantChildren.size ? (forwardDelay = 0) => {
      const { delayChildren = 0, staggerChildren, staggerDirection } = transition;
      return animateChildren(visualElement, variant, forwardDelay, delayChildren, staggerChildren, staggerDirection, options);
    } : () => Promise.resolve();
    const { when } = transition;
    if (when) {
      const [first, last] = when === "beforeChildren" ? [getAnimation, getChildAnimations] : [getChildAnimations, getAnimation];
      return first().then(() => last());
    } else {
      return Promise.all([getAnimation(), getChildAnimations(options.delay)]);
    }
  }
  function animateChildren(visualElement, variant, delay2 = 0, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options) {
    const animations2 = [];
    for (const child of visualElement.variantChildren) {
      child.notify("AnimationStart", variant);
      animations2.push(animateVariant(child, variant, {
        ...options,
        delay: delay2 + (typeof delayChildren === "function" ? 0 : delayChildren) + calcChildStagger(visualElement.variantChildren, child, delayChildren, staggerChildren, staggerDirection)
      }).then(() => child.notify("AnimationComplete", variant)));
    }
    return Promise.all(animations2);
  }

  // ../../node_modules/framer-motion/dist/es/animation/interfaces/visual-element.mjs
  function animateVisualElement(visualElement, definition, options = {}) {
    visualElement.notify("AnimationStart", definition);
    let animation;
    if (Array.isArray(definition)) {
      const animations2 = definition.map((variant) => animateVariant(visualElement, variant, options));
      animation = Promise.all(animations2);
    } else if (typeof definition === "string") {
      animation = animateVariant(visualElement, definition, options);
    } else {
      const resolvedDefinition = typeof definition === "function" ? resolveVariant(visualElement, definition, options.custom) : definition;
      animation = Promise.all(animateTarget(visualElement, resolvedDefinition, options));
    }
    return animation.then(() => {
      visualElement.notify("AnimationComplete", definition);
    });
  }

  // ../../node_modules/framer-motion/dist/es/utils/shallow-compare.mjs
  function shallowCompare(next, prev) {
    if (!Array.isArray(prev))
      return false;
    const prevLength = prev.length;
    if (prevLength !== next.length)
      return false;
    for (let i3 = 0; i3 < prevLength; i3++) {
      if (prev[i3] !== next[i3])
        return false;
    }
    return true;
  }

  // ../../node_modules/framer-motion/dist/es/render/utils/get-variant-context.mjs
  var numVariantProps = variantProps.length;
  function getVariantContext(visualElement) {
    if (!visualElement)
      return void 0;
    if (!visualElement.isControllingVariants) {
      const context2 = visualElement.parent ? getVariantContext(visualElement.parent) || {} : {};
      if (visualElement.props.initial !== void 0) {
        context2.initial = visualElement.props.initial;
      }
      return context2;
    }
    const context = {};
    for (let i3 = 0; i3 < numVariantProps; i3++) {
      const name = variantProps[i3];
      const prop = visualElement.props[name];
      if (isVariantLabel(prop) || prop === false) {
        context[name] = prop;
      }
    }
    return context;
  }

  // ../../node_modules/framer-motion/dist/es/render/utils/animation-state.mjs
  var reversePriorityOrder = [...variantPriorityOrder].reverse();
  var numAnimationTypes = variantPriorityOrder.length;
  function animateList(visualElement) {
    return (animations2) => Promise.all(animations2.map(({ animation, options }) => animateVisualElement(visualElement, animation, options)));
  }
  function createAnimationState(visualElement) {
    let animate = animateList(visualElement);
    let state = createState();
    let isInitialRender = true;
    const buildResolvedTypeValues = (type) => (acc, definition) => {
      const resolved = resolveVariant(visualElement, definition, type === "exit" ? visualElement.presenceContext?.custom : void 0);
      if (resolved) {
        const { transition, transitionEnd, ...target } = resolved;
        acc = { ...acc, ...target, ...transitionEnd };
      }
      return acc;
    };
    function setAnimateFunction(makeAnimator) {
      animate = makeAnimator(visualElement);
    }
    function animateChanges(changedActiveType) {
      const { props } = visualElement;
      const context = getVariantContext(visualElement.parent) || {};
      const animations2 = [];
      const removedKeys = /* @__PURE__ */ new Set();
      let encounteredKeys = {};
      let removedVariantIndex = Infinity;
      for (let i3 = 0; i3 < numAnimationTypes; i3++) {
        const type = reversePriorityOrder[i3];
        const typeState = state[type];
        const prop = props[type] !== void 0 ? props[type] : context[type];
        const propIsVariant = isVariantLabel(prop);
        const activeDelta = type === changedActiveType ? typeState.isActive : null;
        if (activeDelta === false)
          removedVariantIndex = i3;
        let isInherited = prop === context[type] && prop !== props[type] && propIsVariant;
        if (isInherited && isInitialRender && visualElement.manuallyAnimateOnMount) {
          isInherited = false;
        }
        typeState.protectedKeys = { ...encounteredKeys };
        if (
          // If it isn't active and hasn't *just* been set as inactive
          !typeState.isActive && activeDelta === null || // If we didn't and don't have any defined prop for this animation type
          !prop && !typeState.prevProp || // Or if the prop doesn't define an animation
          isAnimationControls(prop) || typeof prop === "boolean"
        ) {
          continue;
        }
        const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);
        let shouldAnimateType = variantDidChange || // If we're making this variant active, we want to always make it active
        type === changedActiveType && typeState.isActive && !isInherited && propIsVariant || // If we removed a higher-priority variant (i is in reverse order)
        i3 > removedVariantIndex && propIsVariant;
        let handledRemovedValues = false;
        const definitionList = Array.isArray(prop) ? prop : [prop];
        let resolvedValues = definitionList.reduce(buildResolvedTypeValues(type), {});
        if (activeDelta === false)
          resolvedValues = {};
        const { prevResolvedValues = {} } = typeState;
        const allKeys = {
          ...prevResolvedValues,
          ...resolvedValues
        };
        const markToAnimate = (key) => {
          shouldAnimateType = true;
          if (removedKeys.has(key)) {
            handledRemovedValues = true;
            removedKeys.delete(key);
          }
          typeState.needsAnimating[key] = true;
          const motionValue2 = visualElement.getValue(key);
          if (motionValue2)
            motionValue2.liveStyle = false;
        };
        for (const key in allKeys) {
          const next = resolvedValues[key];
          const prev = prevResolvedValues[key];
          if (encounteredKeys.hasOwnProperty(key))
            continue;
          let valueHasChanged = false;
          if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {
            valueHasChanged = !shallowCompare(next, prev);
          } else {
            valueHasChanged = next !== prev;
          }
          if (valueHasChanged) {
            if (next !== void 0 && next !== null) {
              markToAnimate(key);
            } else {
              removedKeys.add(key);
            }
          } else if (next !== void 0 && removedKeys.has(key)) {
            markToAnimate(key);
          } else {
            typeState.protectedKeys[key] = true;
          }
        }
        typeState.prevProp = prop;
        typeState.prevResolvedValues = resolvedValues;
        if (typeState.isActive) {
          encounteredKeys = { ...encounteredKeys, ...resolvedValues };
        }
        if (isInitialRender && visualElement.blockInitialAnimation) {
          shouldAnimateType = false;
        }
        const willAnimateViaParent = isInherited && variantDidChange;
        const needsAnimating = !willAnimateViaParent || handledRemovedValues;
        if (shouldAnimateType && needsAnimating) {
          animations2.push(...definitionList.map((animation) => {
            const options = { type };
            if (typeof animation === "string" && isInitialRender && !willAnimateViaParent && visualElement.manuallyAnimateOnMount && visualElement.parent) {
              const { parent } = visualElement;
              const parentVariant = resolveVariant(parent, animation);
              if (parent.enteringChildren && parentVariant) {
                const { delayChildren } = parentVariant.transition || {};
                options.delay = calcChildStagger(parent.enteringChildren, visualElement, delayChildren);
              }
            }
            return {
              animation,
              options
            };
          }));
        }
      }
      if (removedKeys.size) {
        const fallbackAnimation = {};
        if (typeof props.initial !== "boolean") {
          const initialTransition = resolveVariant(visualElement, Array.isArray(props.initial) ? props.initial[0] : props.initial);
          if (initialTransition && initialTransition.transition) {
            fallbackAnimation.transition = initialTransition.transition;
          }
        }
        removedKeys.forEach((key) => {
          const fallbackTarget = visualElement.getBaseTarget(key);
          const motionValue2 = visualElement.getValue(key);
          if (motionValue2)
            motionValue2.liveStyle = true;
          fallbackAnimation[key] = fallbackTarget ?? null;
        });
        animations2.push({ animation: fallbackAnimation });
      }
      let shouldAnimate = Boolean(animations2.length);
      if (isInitialRender && (props.initial === false || props.initial === props.animate) && !visualElement.manuallyAnimateOnMount) {
        shouldAnimate = false;
      }
      isInitialRender = false;
      return shouldAnimate ? animate(animations2) : Promise.resolve();
    }
    function setActive(type, isActive) {
      if (state[type].isActive === isActive)
        return Promise.resolve();
      visualElement.variantChildren?.forEach((child) => child.animationState?.setActive(type, isActive));
      state[type].isActive = isActive;
      const animations2 = animateChanges(type);
      for (const key in state) {
        state[key].protectedKeys = {};
      }
      return animations2;
    }
    return {
      animateChanges,
      setActive,
      setAnimateFunction,
      getState: () => state,
      reset: () => {
        state = createState();
      }
    };
  }
  function checkVariantsDidChange(prev, next) {
    if (typeof next === "string") {
      return next !== prev;
    } else if (Array.isArray(next)) {
      return !shallowCompare(next, prev);
    }
    return false;
  }
  function createTypeState(isActive = false) {
    return {
      isActive,
      protectedKeys: {},
      needsAnimating: {},
      prevResolvedValues: {}
    };
  }
  function createState() {
    return {
      animate: createTypeState(true),
      whileInView: createTypeState(),
      whileHover: createTypeState(),
      whileTap: createTypeState(),
      whileDrag: createTypeState(),
      whileFocus: createTypeState(),
      exit: createTypeState()
    };
  }

  // ../../node_modules/framer-motion/dist/es/motion/features/Feature.mjs
  var Feature = class {
    constructor(node) {
      this.isMounted = false;
      this.node = node;
    }
    update() {
    }
  };

  // ../../node_modules/framer-motion/dist/es/motion/features/animation/index.mjs
  var AnimationFeature = class extends Feature {
    /**
     * We dynamically generate the AnimationState manager as it contains a reference
     * to the underlying animation library. We only want to load that if we load this,
     * so people can optionally code split it out using the `m` component.
     */
    constructor(node) {
      super(node);
      node.animationState || (node.animationState = createAnimationState(node));
    }
    updateAnimationControlsSubscription() {
      const { animate } = this.node.getProps();
      if (isAnimationControls(animate)) {
        this.unmountControls = animate.subscribe(this.node);
      }
    }
    /**
     * Subscribe any provided AnimationControls to the component's VisualElement
     */
    mount() {
      this.updateAnimationControlsSubscription();
    }
    update() {
      const { animate } = this.node.getProps();
      const { animate: prevAnimate } = this.node.prevProps || {};
      if (animate !== prevAnimate) {
        this.updateAnimationControlsSubscription();
      }
    }
    unmount() {
      this.node.animationState.reset();
      this.unmountControls?.();
    }
  };

  // ../../node_modules/framer-motion/dist/es/motion/features/animation/exit.mjs
  var id = 0;
  var ExitAnimationFeature = class extends Feature {
    constructor() {
      super(...arguments);
      this.id = id++;
    }
    update() {
      if (!this.node.presenceContext)
        return;
      const { isPresent, onExitComplete } = this.node.presenceContext;
      const { isPresent: prevIsPresent } = this.node.prevPresenceContext || {};
      if (!this.node.animationState || isPresent === prevIsPresent) {
        return;
      }
      const exitAnimation = this.node.animationState.setActive("exit", !isPresent);
      if (onExitComplete && !isPresent) {
        exitAnimation.then(() => {
          onExitComplete(this.id);
        });
      }
    }
    mount() {
      const { register, onExitComplete } = this.node.presenceContext || {};
      if (onExitComplete) {
        onExitComplete(this.id);
      }
      if (register) {
        this.unmount = register(this.id);
      }
    }
    unmount() {
    }
  };

  // ../../node_modules/framer-motion/dist/es/motion/features/animations.mjs
  var animations = {
    animation: {
      Feature: AnimationFeature
    },
    exit: {
      Feature: ExitAnimationFeature
    }
  };

  // ../../node_modules/framer-motion/dist/es/events/add-dom-event.mjs
  function addDomEvent(target, eventName, handler, options = { passive: true }) {
    target.addEventListener(eventName, handler, options);
    return () => target.removeEventListener(eventName, handler);
  }

  // ../../node_modules/framer-motion/dist/es/events/event-info.mjs
  function extractEventInfo(event) {
    return {
      point: {
        x: event.pageX,
        y: event.pageY
      }
    };
  }
  var addPointerInfo = (handler) => {
    return (event) => isPrimaryPointer(event) && handler(event, extractEventInfo(event));
  };

  // ../../node_modules/framer-motion/dist/es/events/add-pointer-event.mjs
  function addPointerEvent(target, eventName, handler, options) {
    return addDomEvent(target, eventName, addPointerInfo(handler), options);
  }

  // ../../node_modules/framer-motion/dist/es/projection/geometry/delta-calc.mjs
  var SCALE_PRECISION = 1e-4;
  var SCALE_MIN = 1 - SCALE_PRECISION;
  var SCALE_MAX = 1 + SCALE_PRECISION;
  var TRANSLATE_PRECISION = 0.01;
  var TRANSLATE_MIN = 0 - TRANSLATE_PRECISION;
  var TRANSLATE_MAX = 0 + TRANSLATE_PRECISION;
  function calcLength(axis) {
    return axis.max - axis.min;
  }
  function isNear(value, target, maxDistance) {
    return Math.abs(value - target) <= maxDistance;
  }
  function calcAxisDelta(delta, source, target, origin = 0.5) {
    delta.origin = origin;
    delta.originPoint = mixNumber(source.min, source.max, delta.origin);
    delta.scale = calcLength(target) / calcLength(source);
    delta.translate = mixNumber(target.min, target.max, delta.origin) - delta.originPoint;
    if (delta.scale >= SCALE_MIN && delta.scale <= SCALE_MAX || isNaN(delta.scale)) {
      delta.scale = 1;
    }
    if (delta.translate >= TRANSLATE_MIN && delta.translate <= TRANSLATE_MAX || isNaN(delta.translate)) {
      delta.translate = 0;
    }
  }
  function calcBoxDelta(delta, source, target, origin) {
    calcAxisDelta(delta.x, source.x, target.x, origin ? origin.originX : void 0);
    calcAxisDelta(delta.y, source.y, target.y, origin ? origin.originY : void 0);
  }
  function calcRelativeAxis(target, relative, parent) {
    target.min = parent.min + relative.min;
    target.max = target.min + calcLength(relative);
  }
  function calcRelativeBox(target, relative, parent) {
    calcRelativeAxis(target.x, relative.x, parent.x);
    calcRelativeAxis(target.y, relative.y, parent.y);
  }
  function calcRelativeAxisPosition(target, layout2, parent) {
    target.min = layout2.min - parent.min;
    target.max = target.min + calcLength(layout2);
  }
  function calcRelativePosition(target, layout2, parent) {
    calcRelativeAxisPosition(target.x, layout2.x, parent.x);
    calcRelativeAxisPosition(target.y, layout2.y, parent.y);
  }

  // ../../node_modules/framer-motion/dist/es/projection/utils/each-axis.mjs
  function eachAxis(callback) {
    return [callback("x"), callback("y")];
  }

  // ../../node_modules/framer-motion/dist/es/utils/get-context-window.mjs
  var getContextWindow = ({ current }) => {
    return current ? current.ownerDocument.defaultView : null;
  };

  // ../../node_modules/framer-motion/dist/es/utils/distance.mjs
  var distance = (a, b2) => Math.abs(a - b2);
  function distance2D(a, b2) {
    const xDelta = distance(a.x, b2.x);
    const yDelta = distance(a.y, b2.y);
    return Math.sqrt(xDelta ** 2 + yDelta ** 2);
  }

  // ../../node_modules/framer-motion/dist/es/gestures/pan/PanSession.mjs
  var PanSession = class {
    constructor(event, handlers, { transformPagePoint, contextWindow = window, dragSnapToOrigin = false, distanceThreshold = 3 } = {}) {
      this.startEvent = null;
      this.lastMoveEvent = null;
      this.lastMoveEventInfo = null;
      this.handlers = {};
      this.contextWindow = window;
      this.updatePoint = () => {
        if (!(this.lastMoveEvent && this.lastMoveEventInfo))
          return;
        const info2 = getPanInfo(this.lastMoveEventInfo, this.history);
        const isPanStarted = this.startEvent !== null;
        const isDistancePastThreshold = distance2D(info2.offset, { x: 0, y: 0 }) >= this.distanceThreshold;
        if (!isPanStarted && !isDistancePastThreshold)
          return;
        const { point: point3 } = info2;
        const { timestamp: timestamp2 } = frameData;
        this.history.push({ ...point3, timestamp: timestamp2 });
        const { onStart, onMove } = this.handlers;
        if (!isPanStarted) {
          onStart && onStart(this.lastMoveEvent, info2);
          this.startEvent = this.lastMoveEvent;
        }
        onMove && onMove(this.lastMoveEvent, info2);
      };
      this.handlePointerMove = (event2, info2) => {
        this.lastMoveEvent = event2;
        this.lastMoveEventInfo = transformPoint(info2, this.transformPagePoint);
        frame.update(this.updatePoint, true);
      };
      this.handlePointerUp = (event2, info2) => {
        this.end();
        const { onEnd, onSessionEnd, resumeAnimation } = this.handlers;
        if (this.dragSnapToOrigin || !this.startEvent) {
          resumeAnimation && resumeAnimation();
        }
        if (!(this.lastMoveEvent && this.lastMoveEventInfo))
          return;
        const panInfo = getPanInfo(event2.type === "pointercancel" ? this.lastMoveEventInfo : transformPoint(info2, this.transformPagePoint), this.history);
        if (this.startEvent && onEnd) {
          onEnd(event2, panInfo);
        }
        onSessionEnd && onSessionEnd(event2, panInfo);
      };
      if (!isPrimaryPointer(event))
        return;
      this.dragSnapToOrigin = dragSnapToOrigin;
      this.handlers = handlers;
      this.transformPagePoint = transformPagePoint;
      this.distanceThreshold = distanceThreshold;
      this.contextWindow = contextWindow || window;
      const info = extractEventInfo(event);
      const initialInfo = transformPoint(info, this.transformPagePoint);
      const { point: point2 } = initialInfo;
      const { timestamp } = frameData;
      this.history = [{ ...point2, timestamp }];
      const { onSessionStart } = handlers;
      onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));
      this.removeListeners = pipe(addPointerEvent(this.contextWindow, "pointermove", this.handlePointerMove), addPointerEvent(this.contextWindow, "pointerup", this.handlePointerUp), addPointerEvent(this.contextWindow, "pointercancel", this.handlePointerUp));
    }
    updateHandlers(handlers) {
      this.handlers = handlers;
    }
    end() {
      this.removeListeners && this.removeListeners();
      cancelFrame(this.updatePoint);
    }
  };
  function transformPoint(info, transformPagePoint) {
    return transformPagePoint ? { point: transformPagePoint(info.point) } : info;
  }
  function subtractPoint(a, b2) {
    return { x: a.x - b2.x, y: a.y - b2.y };
  }
  function getPanInfo({ point: point2 }, history) {
    return {
      point: point2,
      delta: subtractPoint(point2, lastDevicePoint(history)),
      offset: subtractPoint(point2, startDevicePoint(history)),
      velocity: getVelocity(history, 0.1)
    };
  }
  function startDevicePoint(history) {
    return history[0];
  }
  function lastDevicePoint(history) {
    return history[history.length - 1];
  }
  function getVelocity(history, timeDelta) {
    if (history.length < 2) {
      return { x: 0, y: 0 };
    }
    let i3 = history.length - 1;
    let timestampedPoint = null;
    const lastPoint = lastDevicePoint(history);
    while (i3 >= 0) {
      timestampedPoint = history[i3];
      if (lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta)) {
        break;
      }
      i3--;
    }
    if (!timestampedPoint) {
      return { x: 0, y: 0 };
    }
    const time2 = millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);
    if (time2 === 0) {
      return { x: 0, y: 0 };
    }
    const currentVelocity = {
      x: (lastPoint.x - timestampedPoint.x) / time2,
      y: (lastPoint.y - timestampedPoint.y) / time2
    };
    if (currentVelocity.x === Infinity) {
      currentVelocity.x = 0;
    }
    if (currentVelocity.y === Infinity) {
      currentVelocity.y = 0;
    }
    return currentVelocity;
  }

  // ../../node_modules/framer-motion/dist/es/gestures/drag/utils/constraints.mjs
  function applyConstraints(point2, { min: min3, max: max3 }, elastic) {
    if (min3 !== void 0 && point2 < min3) {
      point2 = elastic ? mixNumber(min3, point2, elastic.min) : Math.max(point2, min3);
    } else if (max3 !== void 0 && point2 > max3) {
      point2 = elastic ? mixNumber(max3, point2, elastic.max) : Math.min(point2, max3);
    }
    return point2;
  }
  function calcRelativeAxisConstraints(axis, min3, max3) {
    return {
      min: min3 !== void 0 ? axis.min + min3 : void 0,
      max: max3 !== void 0 ? axis.max + max3 - (axis.max - axis.min) : void 0
    };
  }
  function calcRelativeConstraints(layoutBox, { top, left, bottom, right }) {
    return {
      x: calcRelativeAxisConstraints(layoutBox.x, left, right),
      y: calcRelativeAxisConstraints(layoutBox.y, top, bottom)
    };
  }
  function calcViewportAxisConstraints(layoutAxis, constraintsAxis) {
    let min3 = constraintsAxis.min - layoutAxis.min;
    let max3 = constraintsAxis.max - layoutAxis.max;
    if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) {
      [min3, max3] = [max3, min3];
    }
    return { min: min3, max: max3 };
  }
  function calcViewportConstraints(layoutBox, constraintsBox) {
    return {
      x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),
      y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)
    };
  }
  function calcOrigin(source, target) {
    let origin = 0.5;
    const sourceLength = calcLength(source);
    const targetLength = calcLength(target);
    if (targetLength > sourceLength) {
      origin = progress(target.min, target.max - sourceLength, source.min);
    } else if (sourceLength > targetLength) {
      origin = progress(source.min, source.max - targetLength, target.min);
    }
    return clamp(0, 1, origin);
  }
  function rebaseAxisConstraints(layout2, constraints) {
    const relativeConstraints = {};
    if (constraints.min !== void 0) {
      relativeConstraints.min = constraints.min - layout2.min;
    }
    if (constraints.max !== void 0) {
      relativeConstraints.max = constraints.max - layout2.min;
    }
    return relativeConstraints;
  }
  var defaultElastic = 0.35;
  function resolveDragElastic(dragElastic = defaultElastic) {
    if (dragElastic === false) {
      dragElastic = 0;
    } else if (dragElastic === true) {
      dragElastic = defaultElastic;
    }
    return {
      x: resolveAxisElastic(dragElastic, "left", "right"),
      y: resolveAxisElastic(dragElastic, "top", "bottom")
    };
  }
  function resolveAxisElastic(dragElastic, minLabel, maxLabel) {
    return {
      min: resolvePointElastic(dragElastic, minLabel),
      max: resolvePointElastic(dragElastic, maxLabel)
    };
  }
  function resolvePointElastic(dragElastic, label) {
    return typeof dragElastic === "number" ? dragElastic : dragElastic[label] || 0;
  }

  // ../../node_modules/framer-motion/dist/es/gestures/drag/VisualElementDragControls.mjs
  var elementDragControls = /* @__PURE__ */ new WeakMap();
  var VisualElementDragControls = class {
    constructor(visualElement) {
      this.openDragLock = null;
      this.isDragging = false;
      this.currentDirection = null;
      this.originPoint = { x: 0, y: 0 };
      this.constraints = false;
      this.hasMutatedConstraints = false;
      this.elastic = createBox();
      this.latestPointerEvent = null;
      this.latestPanInfo = null;
      this.visualElement = visualElement;
    }
    start(originEvent, { snapToCursor = false, distanceThreshold } = {}) {
      const { presenceContext } = this.visualElement;
      if (presenceContext && presenceContext.isPresent === false)
        return;
      const onSessionStart = (event) => {
        if (snapToCursor) {
          this.stopAnimation();
          this.snapToCursor(extractEventInfo(event).point);
        } else {
          this.pauseAnimation();
        }
      };
      const onStart = (event, info) => {
        this.stopAnimation();
        const { drag: drag2, dragPropagation, onDragStart } = this.getProps();
        if (drag2 && !dragPropagation) {
          if (this.openDragLock)
            this.openDragLock();
          this.openDragLock = setDragLock(drag2);
          if (!this.openDragLock)
            return;
        }
        this.latestPointerEvent = event;
        this.latestPanInfo = info;
        this.isDragging = true;
        this.currentDirection = null;
        this.resolveConstraints();
        if (this.visualElement.projection) {
          this.visualElement.projection.isAnimationBlocked = true;
          this.visualElement.projection.target = void 0;
        }
        eachAxis((axis) => {
          let current = this.getAxisMotionValue(axis).get() || 0;
          if (percent.test(current)) {
            const { projection } = this.visualElement;
            if (projection && projection.layout) {
              const measuredAxis = projection.layout.layoutBox[axis];
              if (measuredAxis) {
                const length = calcLength(measuredAxis);
                current = length * (parseFloat(current) / 100);
              }
            }
          }
          this.originPoint[axis] = current;
        });
        if (onDragStart) {
          frame.postRender(() => onDragStart(event, info));
        }
        addValueToWillChange(this.visualElement, "transform");
        const { animationState } = this.visualElement;
        animationState && animationState.setActive("whileDrag", true);
      };
      const onMove = (event, info) => {
        this.latestPointerEvent = event;
        this.latestPanInfo = info;
        const { dragPropagation, dragDirectionLock, onDirectionLock, onDrag } = this.getProps();
        if (!dragPropagation && !this.openDragLock)
          return;
        const { offset: offset4 } = info;
        if (dragDirectionLock && this.currentDirection === null) {
          this.currentDirection = getCurrentDirection(offset4);
          if (this.currentDirection !== null) {
            onDirectionLock && onDirectionLock(this.currentDirection);
          }
          return;
        }
        this.updateAxis("x", info.point, offset4);
        this.updateAxis("y", info.point, offset4);
        this.visualElement.render();
        onDrag && onDrag(event, info);
      };
      const onSessionEnd = (event, info) => {
        this.latestPointerEvent = event;
        this.latestPanInfo = info;
        this.stop(event, info);
        this.latestPointerEvent = null;
        this.latestPanInfo = null;
      };
      const resumeAnimation = () => eachAxis((axis) => this.getAnimationState(axis) === "paused" && this.getAxisMotionValue(axis).animation?.play());
      const { dragSnapToOrigin } = this.getProps();
      this.panSession = new PanSession(originEvent, {
        onSessionStart,
        onStart,
        onMove,
        onSessionEnd,
        resumeAnimation
      }, {
        transformPagePoint: this.visualElement.getTransformPagePoint(),
        dragSnapToOrigin,
        distanceThreshold,
        contextWindow: getContextWindow(this.visualElement)
      });
    }
    /**
     * @internal
     */
    stop(event, panInfo) {
      const finalEvent = event || this.latestPointerEvent;
      const finalPanInfo = panInfo || this.latestPanInfo;
      const isDragging2 = this.isDragging;
      this.cancel();
      if (!isDragging2 || !finalPanInfo || !finalEvent)
        return;
      const { velocity } = finalPanInfo;
      this.startAnimation(velocity);
      const { onDragEnd } = this.getProps();
      if (onDragEnd) {
        frame.postRender(() => onDragEnd(finalEvent, finalPanInfo));
      }
    }
    /**
     * @internal
     */
    cancel() {
      this.isDragging = false;
      const { projection, animationState } = this.visualElement;
      if (projection) {
        projection.isAnimationBlocked = false;
      }
      this.panSession && this.panSession.end();
      this.panSession = void 0;
      const { dragPropagation } = this.getProps();
      if (!dragPropagation && this.openDragLock) {
        this.openDragLock();
        this.openDragLock = null;
      }
      animationState && animationState.setActive("whileDrag", false);
    }
    updateAxis(axis, _point, offset4) {
      const { drag: drag2 } = this.getProps();
      if (!offset4 || !shouldDrag(axis, drag2, this.currentDirection))
        return;
      const axisValue = this.getAxisMotionValue(axis);
      let next = this.originPoint[axis] + offset4[axis];
      if (this.constraints && this.constraints[axis]) {
        next = applyConstraints(next, this.constraints[axis], this.elastic[axis]);
      }
      axisValue.set(next);
    }
    resolveConstraints() {
      const { dragConstraints, dragElastic } = this.getProps();
      const layout2 = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(false) : this.visualElement.projection?.layout;
      const prevConstraints = this.constraints;
      if (dragConstraints && isRefObject(dragConstraints)) {
        if (!this.constraints) {
          this.constraints = this.resolveRefConstraints();
        }
      } else {
        if (dragConstraints && layout2) {
          this.constraints = calcRelativeConstraints(layout2.layoutBox, dragConstraints);
        } else {
          this.constraints = false;
        }
      }
      this.elastic = resolveDragElastic(dragElastic);
      if (prevConstraints !== this.constraints && layout2 && this.constraints && !this.hasMutatedConstraints) {
        eachAxis((axis) => {
          if (this.constraints !== false && this.getAxisMotionValue(axis)) {
            this.constraints[axis] = rebaseAxisConstraints(layout2.layoutBox[axis], this.constraints[axis]);
          }
        });
      }
    }
    resolveRefConstraints() {
      const { dragConstraints: constraints, onMeasureDragConstraints } = this.getProps();
      if (!constraints || !isRefObject(constraints))
        return false;
      const constraintsElement = constraints.current;
      invariant(constraintsElement !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.", "drag-constraints-ref");
      const { projection } = this.visualElement;
      if (!projection || !projection.layout)
        return false;
      const constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());
      let measuredConstraints = calcViewportConstraints(projection.layout.layoutBox, constraintsBox);
      if (onMeasureDragConstraints) {
        const userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));
        this.hasMutatedConstraints = !!userConstraints;
        if (userConstraints) {
          measuredConstraints = convertBoundingBoxToBox(userConstraints);
        }
      }
      return measuredConstraints;
    }
    startAnimation(velocity) {
      const { drag: drag2, dragMomentum, dragElastic, dragTransition, dragSnapToOrigin, onDragTransitionEnd } = this.getProps();
      const constraints = this.constraints || {};
      const momentumAnimations = eachAxis((axis) => {
        if (!shouldDrag(axis, drag2, this.currentDirection)) {
          return;
        }
        let transition = constraints && constraints[axis] || {};
        if (dragSnapToOrigin)
          transition = { min: 0, max: 0 };
        const bounceStiffness = dragElastic ? 200 : 1e6;
        const bounceDamping = dragElastic ? 40 : 1e7;
        const inertia2 = {
          type: "inertia",
          velocity: dragMomentum ? velocity[axis] : 0,
          bounceStiffness,
          bounceDamping,
          timeConstant: 750,
          restDelta: 1,
          restSpeed: 10,
          ...dragTransition,
          ...transition
        };
        return this.startAxisValueAnimation(axis, inertia2);
      });
      return Promise.all(momentumAnimations).then(onDragTransitionEnd);
    }
    startAxisValueAnimation(axis, transition) {
      const axisValue = this.getAxisMotionValue(axis);
      addValueToWillChange(this.visualElement, axis);
      return axisValue.start(animateMotionValue(axis, axisValue, 0, transition, this.visualElement, false));
    }
    stopAnimation() {
      eachAxis((axis) => this.getAxisMotionValue(axis).stop());
    }
    pauseAnimation() {
      eachAxis((axis) => this.getAxisMotionValue(axis).animation?.pause());
    }
    getAnimationState(axis) {
      return this.getAxisMotionValue(axis).animation?.state;
    }
    /**
     * Drag works differently depending on which props are provided.
     *
     * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
     * - Otherwise, we apply the delta to the x/y motion values.
     */
    getAxisMotionValue(axis) {
      const dragKey = `_drag${axis.toUpperCase()}`;
      const props = this.visualElement.getProps();
      const externalMotionValue = props[dragKey];
      return externalMotionValue ? externalMotionValue : this.visualElement.getValue(axis, (props.initial ? props.initial[axis] : void 0) || 0);
    }
    snapToCursor(point2) {
      eachAxis((axis) => {
        const { drag: drag2 } = this.getProps();
        if (!shouldDrag(axis, drag2, this.currentDirection))
          return;
        const { projection } = this.visualElement;
        const axisValue = this.getAxisMotionValue(axis);
        if (projection && projection.layout) {
          const { min: min3, max: max3 } = projection.layout.layoutBox[axis];
          const current = axisValue.get() || 0;
          axisValue.set(point2[axis] - mixNumber(min3, max3, 0.5) + current);
        }
      });
    }
    /**
     * When the viewport resizes we want to check if the measured constraints
     * have changed and, if so, reposition the element within those new constraints
     * relative to where it was before the resize.
     */
    scalePositionWithinConstraints() {
      if (!this.visualElement.current)
        return;
      const { drag: drag2, dragConstraints } = this.getProps();
      const { projection } = this.visualElement;
      if (!isRefObject(dragConstraints) || !projection || !this.constraints)
        return;
      this.stopAnimation();
      const boxProgress = { x: 0, y: 0 };
      eachAxis((axis) => {
        const axisValue = this.getAxisMotionValue(axis);
        if (axisValue && this.constraints !== false) {
          const latest = axisValue.get();
          boxProgress[axis] = calcOrigin({ min: latest, max: latest }, this.constraints[axis]);
        }
      });
      const { transformTemplate } = this.visualElement.getProps();
      this.visualElement.current.style.transform = transformTemplate ? transformTemplate({}, "") : "none";
      projection.root && projection.root.updateScroll();
      projection.updateLayout();
      this.resolveConstraints();
      eachAxis((axis) => {
        if (!shouldDrag(axis, drag2, null))
          return;
        const axisValue = this.getAxisMotionValue(axis);
        const { min: min3, max: max3 } = this.constraints[axis];
        axisValue.set(mixNumber(min3, max3, boxProgress[axis]));
      });
    }
    addListeners() {
      if (!this.visualElement.current)
        return;
      elementDragControls.set(this.visualElement, this);
      const element = this.visualElement.current;
      const stopPointerListener = addPointerEvent(element, "pointerdown", (event) => {
        const { drag: drag2, dragListener = true } = this.getProps();
        if (drag2 && dragListener && !isElementKeyboardAccessible(event.target)) {
          this.start(event);
        }
      });
      const measureDragConstraints = () => {
        const { dragConstraints } = this.getProps();
        if (isRefObject(dragConstraints) && dragConstraints.current) {
          this.constraints = this.resolveRefConstraints();
        }
      };
      const { projection } = this.visualElement;
      const stopMeasureLayoutListener = projection.addEventListener("measure", measureDragConstraints);
      if (projection && !projection.layout) {
        projection.root && projection.root.updateScroll();
        projection.updateLayout();
      }
      frame.read(measureDragConstraints);
      const stopResizeListener = addDomEvent(window, "resize", () => this.scalePositionWithinConstraints());
      const stopLayoutUpdateListener = projection.addEventListener("didUpdate", (({ delta, hasLayoutChanged }) => {
        if (this.isDragging && hasLayoutChanged) {
          eachAxis((axis) => {
            const motionValue2 = this.getAxisMotionValue(axis);
            if (!motionValue2)
              return;
            this.originPoint[axis] += delta[axis].translate;
            motionValue2.set(motionValue2.get() + delta[axis].translate);
          });
          this.visualElement.render();
        }
      }));
      return () => {
        stopResizeListener();
        stopPointerListener();
        stopMeasureLayoutListener();
        stopLayoutUpdateListener && stopLayoutUpdateListener();
      };
    }
    getProps() {
      const props = this.visualElement.getProps();
      const { drag: drag2 = false, dragDirectionLock = false, dragPropagation = false, dragConstraints = false, dragElastic = defaultElastic, dragMomentum = true } = props;
      return {
        ...props,
        drag: drag2,
        dragDirectionLock,
        dragPropagation,
        dragConstraints,
        dragElastic,
        dragMomentum
      };
    }
  };
  function shouldDrag(direction, drag2, currentDirection) {
    return (drag2 === true || drag2 === direction) && (currentDirection === null || currentDirection === direction);
  }
  function getCurrentDirection(offset4, lockThreshold = 10) {
    let direction = null;
    if (Math.abs(offset4.y) > lockThreshold) {
      direction = "y";
    } else if (Math.abs(offset4.x) > lockThreshold) {
      direction = "x";
    }
    return direction;
  }

  // ../../node_modules/framer-motion/dist/es/gestures/drag/index.mjs
  var DragGesture = class extends Feature {
    constructor(node) {
      super(node);
      this.removeGroupControls = noop;
      this.removeListeners = noop;
      this.controls = new VisualElementDragControls(node);
    }
    mount() {
      const { dragControls } = this.node.getProps();
      if (dragControls) {
        this.removeGroupControls = dragControls.subscribe(this.controls);
      }
      this.removeListeners = this.controls.addListeners() || noop;
    }
    update() {
      const { dragControls } = this.node.getProps();
      const { dragControls: prevDragControls } = this.node.prevProps || {};
      if (dragControls !== prevDragControls) {
        this.removeGroupControls();
        if (dragControls) {
          this.removeGroupControls = dragControls.subscribe(this.controls);
        }
      }
    }
    unmount() {
      this.removeGroupControls();
      this.removeListeners();
    }
  };

  // ../../node_modules/framer-motion/dist/es/gestures/pan/index.mjs
  var asyncHandler = (handler) => (event, info) => {
    if (handler) {
      frame.postRender(() => handler(event, info));
    }
  };
  var PanGesture = class extends Feature {
    constructor() {
      super(...arguments);
      this.removePointerDownListener = noop;
    }
    onPointerDown(pointerDownEvent) {
      this.session = new PanSession(pointerDownEvent, this.createPanHandlers(), {
        transformPagePoint: this.node.getTransformPagePoint(),
        contextWindow: getContextWindow(this.node)
      });
    }
    createPanHandlers() {
      const { onPanSessionStart, onPanStart, onPan, onPanEnd } = this.node.getProps();
      return {
        onSessionStart: asyncHandler(onPanSessionStart),
        onStart: asyncHandler(onPanStart),
        onMove: onPan,
        onEnd: (event, info) => {
          delete this.session;
          if (onPanEnd) {
            frame.postRender(() => onPanEnd(event, info));
          }
        }
      };
    }
    mount() {
      this.removePointerDownListener = addPointerEvent(this.node.current, "pointerdown", (event) => this.onPointerDown(event));
    }
    update() {
      this.session && this.session.updateHandlers(this.createPanHandlers());
    }
    unmount() {
      this.removePointerDownListener();
      this.session && this.session.end();
    }
  };

  // ../../node_modules/framer-motion/dist/es/motion/features/layout/MeasureLayout.mjs
  var import_jsx_runtime7 = __toESM(require_jsx_runtime2(), 1);
  var import_react25 = __toESM(require_react2(), 1);

  // ../../node_modules/framer-motion/dist/es/projection/node/state.mjs
  var globalProjectionState = {
    /**
     * Global flag as to whether the tree has animated since the last time
     * we resized the window
     */
    hasAnimatedSinceResize: true,
    /**
     * We set this to true once, on the first update. Any nodes added to the tree beyond that
     * update will be given a `data-projection-id` attribute.
     */
    hasEverUpdated: false
  };

  // ../../node_modules/framer-motion/dist/es/motion/features/layout/MeasureLayout.mjs
  var hasTakenAnySnapshot = false;
  var MeasureLayoutWithContext = class extends import_react25.Component {
    /**
     * This only mounts projection nodes for components that
     * need measuring, we might want to do it for all components
     * in order to incorporate transforms
     */
    componentDidMount() {
      const { visualElement, layoutGroup, switchLayoutGroup, layoutId } = this.props;
      const { projection } = visualElement;
      if (projection) {
        if (layoutGroup.group)
          layoutGroup.group.add(projection);
        if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {
          switchLayoutGroup.register(projection);
        }
        if (hasTakenAnySnapshot) {
          projection.root.didUpdate();
        }
        projection.addEventListener("animationComplete", () => {
          this.safeToRemove();
        });
        projection.setOptions({
          ...projection.options,
          onExitComplete: () => this.safeToRemove()
        });
      }
      globalProjectionState.hasEverUpdated = true;
    }
    getSnapshotBeforeUpdate(prevProps) {
      const { layoutDependency, visualElement, drag: drag2, isPresent } = this.props;
      const { projection } = visualElement;
      if (!projection)
        return null;
      projection.isPresent = isPresent;
      hasTakenAnySnapshot = true;
      if (drag2 || prevProps.layoutDependency !== layoutDependency || layoutDependency === void 0 || prevProps.isPresent !== isPresent) {
        projection.willUpdate();
      } else {
        this.safeToRemove();
      }
      if (prevProps.isPresent !== isPresent) {
        if (isPresent) {
          projection.promote();
        } else if (!projection.relegate()) {
          frame.postRender(() => {
            const stack = projection.getStack();
            if (!stack || !stack.members.length) {
              this.safeToRemove();
            }
          });
        }
      }
      return null;
    }
    componentDidUpdate() {
      const { projection } = this.props.visualElement;
      if (projection) {
        projection.root.didUpdate();
        microtask.postRender(() => {
          if (!projection.currentAnimation && projection.isLead()) {
            this.safeToRemove();
          }
        });
      }
    }
    componentWillUnmount() {
      const { visualElement, layoutGroup, switchLayoutGroup: promoteContext } = this.props;
      const { projection } = visualElement;
      hasTakenAnySnapshot = true;
      if (projection) {
        projection.scheduleCheckAfterUnmount();
        if (layoutGroup && layoutGroup.group)
          layoutGroup.group.remove(projection);
        if (promoteContext && promoteContext.deregister)
          promoteContext.deregister(projection);
      }
    }
    safeToRemove() {
      const { safeToRemove } = this.props;
      safeToRemove && safeToRemove();
    }
    render() {
      return null;
    }
  };
  function MeasureLayout(props) {
    const [isPresent, safeToRemove] = usePresence();
    const layoutGroup = (0, import_react25.useContext)(LayoutGroupContext);
    return (0, import_jsx_runtime7.jsx)(MeasureLayoutWithContext, { ...props, layoutGroup, switchLayoutGroup: (0, import_react25.useContext)(SwitchLayoutGroupContext), isPresent, safeToRemove });
  }

  // ../../node_modules/framer-motion/dist/es/animation/animate/single-value.mjs
  function animateSingleValue(value, keyframes2, options) {
    const motionValue$1 = isMotionValue(value) ? value : motionValue(value);
    motionValue$1.start(animateMotionValue("", motionValue$1, keyframes2, options));
    return motionValue$1.animation;
  }

  // ../../node_modules/framer-motion/dist/es/render/utils/compare-by-depth.mjs
  var compareByDepth = (a, b2) => a.depth - b2.depth;

  // ../../node_modules/framer-motion/dist/es/render/utils/flat-tree.mjs
  var FlatTree = class {
    constructor() {
      this.children = [];
      this.isDirty = false;
    }
    add(child) {
      addUniqueItem(this.children, child);
      this.isDirty = true;
    }
    remove(child) {
      removeItem(this.children, child);
      this.isDirty = true;
    }
    forEach(callback) {
      this.isDirty && this.children.sort(compareByDepth);
      this.isDirty = false;
      this.children.forEach(callback);
    }
  };

  // ../../node_modules/framer-motion/dist/es/utils/delay.mjs
  function delay(callback, timeout) {
    const start2 = time.now();
    const checkElapsed = ({ timestamp }) => {
      const elapsed = timestamp - start2;
      if (elapsed >= timeout) {
        cancelFrame(checkElapsed);
        callback(elapsed - timeout);
      }
    };
    frame.setup(checkElapsed, true);
    return () => cancelFrame(checkElapsed);
  }

  // ../../node_modules/framer-motion/dist/es/projection/animation/mix-values.mjs
  var borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"];
  var numBorders = borders.length;
  var asNumber2 = (value) => typeof value === "string" ? parseFloat(value) : value;
  var isPx = (value) => typeof value === "number" || px.test(value);
  function mixValues(target, follow, lead, progress2, shouldCrossfadeOpacity, isOnlyMember) {
    if (shouldCrossfadeOpacity) {
      target.opacity = mixNumber(0, lead.opacity ?? 1, easeCrossfadeIn(progress2));
      target.opacityExit = mixNumber(follow.opacity ?? 1, 0, easeCrossfadeOut(progress2));
    } else if (isOnlyMember) {
      target.opacity = mixNumber(follow.opacity ?? 1, lead.opacity ?? 1, progress2);
    }
    for (let i3 = 0; i3 < numBorders; i3++) {
      const borderLabel = `border${borders[i3]}Radius`;
      let followRadius = getRadius(follow, borderLabel);
      let leadRadius = getRadius(lead, borderLabel);
      if (followRadius === void 0 && leadRadius === void 0)
        continue;
      followRadius || (followRadius = 0);
      leadRadius || (leadRadius = 0);
      const canMix = followRadius === 0 || leadRadius === 0 || isPx(followRadius) === isPx(leadRadius);
      if (canMix) {
        target[borderLabel] = Math.max(mixNumber(asNumber2(followRadius), asNumber2(leadRadius), progress2), 0);
        if (percent.test(leadRadius) || percent.test(followRadius)) {
          target[borderLabel] += "%";
        }
      } else {
        target[borderLabel] = leadRadius;
      }
    }
    if (follow.rotate || lead.rotate) {
      target.rotate = mixNumber(follow.rotate || 0, lead.rotate || 0, progress2);
    }
  }
  function getRadius(values, radiusName) {
    return values[radiusName] !== void 0 ? values[radiusName] : values.borderRadius;
  }
  var easeCrossfadeIn = /* @__PURE__ */ compress(0, 0.5, circOut);
  var easeCrossfadeOut = /* @__PURE__ */ compress(0.5, 0.95, noop);
  function compress(min3, max3, easing) {
    return (p3) => {
      if (p3 < min3)
        return 0;
      if (p3 > max3)
        return 1;
      return easing(progress(min3, max3, p3));
    };
  }

  // ../../node_modules/framer-motion/dist/es/projection/geometry/copy.mjs
  function copyAxisInto(axis, originAxis) {
    axis.min = originAxis.min;
    axis.max = originAxis.max;
  }
  function copyBoxInto(box, originBox) {
    copyAxisInto(box.x, originBox.x);
    copyAxisInto(box.y, originBox.y);
  }
  function copyAxisDeltaInto(delta, originDelta) {
    delta.translate = originDelta.translate;
    delta.scale = originDelta.scale;
    delta.originPoint = originDelta.originPoint;
    delta.origin = originDelta.origin;
  }

  // ../../node_modules/framer-motion/dist/es/projection/geometry/delta-remove.mjs
  function removePointDelta(point2, translate, scale2, originPoint, boxScale) {
    point2 -= translate;
    point2 = scalePoint(point2, 1 / scale2, originPoint);
    if (boxScale !== void 0) {
      point2 = scalePoint(point2, 1 / boxScale, originPoint);
    }
    return point2;
  }
  function removeAxisDelta(axis, translate = 0, scale2 = 1, origin = 0.5, boxScale, originAxis = axis, sourceAxis = axis) {
    if (percent.test(translate)) {
      translate = parseFloat(translate);
      const relativeProgress = mixNumber(sourceAxis.min, sourceAxis.max, translate / 100);
      translate = relativeProgress - sourceAxis.min;
    }
    if (typeof translate !== "number")
      return;
    let originPoint = mixNumber(originAxis.min, originAxis.max, origin);
    if (axis === originAxis)
      originPoint -= translate;
    axis.min = removePointDelta(axis.min, translate, scale2, originPoint, boxScale);
    axis.max = removePointDelta(axis.max, translate, scale2, originPoint, boxScale);
  }
  function removeAxisTransforms(axis, transforms, [key, scaleKey, originKey], origin, sourceAxis) {
    removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale, origin, sourceAxis);
  }
  var xKeys = ["x", "scaleX", "originX"];
  var yKeys = ["y", "scaleY", "originY"];
  function removeBoxTransforms(box, transforms, originBox, sourceBox) {
    removeAxisTransforms(box.x, transforms, xKeys, originBox ? originBox.x : void 0, sourceBox ? sourceBox.x : void 0);
    removeAxisTransforms(box.y, transforms, yKeys, originBox ? originBox.y : void 0, sourceBox ? sourceBox.y : void 0);
  }

  // ../../node_modules/framer-motion/dist/es/projection/geometry/utils.mjs
  function isAxisDeltaZero(delta) {
    return delta.translate === 0 && delta.scale === 1;
  }
  function isDeltaZero(delta) {
    return isAxisDeltaZero(delta.x) && isAxisDeltaZero(delta.y);
  }
  function axisEquals(a, b2) {
    return a.min === b2.min && a.max === b2.max;
  }
  function boxEquals(a, b2) {
    return axisEquals(a.x, b2.x) && axisEquals(a.y, b2.y);
  }
  function axisEqualsRounded(a, b2) {
    return Math.round(a.min) === Math.round(b2.min) && Math.round(a.max) === Math.round(b2.max);
  }
  function boxEqualsRounded(a, b2) {
    return axisEqualsRounded(a.x, b2.x) && axisEqualsRounded(a.y, b2.y);
  }
  function aspectRatio(box) {
    return calcLength(box.x) / calcLength(box.y);
  }
  function axisDeltaEquals(a, b2) {
    return a.translate === b2.translate && a.scale === b2.scale && a.originPoint === b2.originPoint;
  }

  // ../../node_modules/framer-motion/dist/es/projection/shared/stack.mjs
  var NodeStack = class {
    constructor() {
      this.members = [];
    }
    add(node) {
      addUniqueItem(this.members, node);
      node.scheduleRender();
    }
    remove(node) {
      removeItem(this.members, node);
      if (node === this.prevLead) {
        this.prevLead = void 0;
      }
      if (node === this.lead) {
        const prevLead = this.members[this.members.length - 1];
        if (prevLead) {
          this.promote(prevLead);
        }
      }
    }
    relegate(node) {
      const indexOfNode = this.members.findIndex((member) => node === member);
      if (indexOfNode === 0)
        return false;
      let prevLead;
      for (let i3 = indexOfNode; i3 >= 0; i3--) {
        const member = this.members[i3];
        if (member.isPresent !== false) {
          prevLead = member;
          break;
        }
      }
      if (prevLead) {
        this.promote(prevLead);
        return true;
      } else {
        return false;
      }
    }
    promote(node, preserveFollowOpacity) {
      const prevLead = this.lead;
      if (node === prevLead)
        return;
      this.prevLead = prevLead;
      this.lead = node;
      node.show();
      if (prevLead) {
        prevLead.instance && prevLead.scheduleRender();
        node.scheduleRender();
        node.resumeFrom = prevLead;
        if (preserveFollowOpacity) {
          node.resumeFrom.preserveOpacity = true;
        }
        if (prevLead.snapshot) {
          node.snapshot = prevLead.snapshot;
          node.snapshot.latestValues = prevLead.animationValues || prevLead.latestValues;
        }
        if (node.root && node.root.isUpdating) {
          node.isLayoutDirty = true;
        }
        const { crossfade } = node.options;
        if (crossfade === false) {
          prevLead.hide();
        }
      }
    }
    exitAnimationComplete() {
      this.members.forEach((node) => {
        const { options, resumingFrom } = node;
        options.onExitComplete && options.onExitComplete();
        if (resumingFrom) {
          resumingFrom.options.onExitComplete && resumingFrom.options.onExitComplete();
        }
      });
    }
    scheduleRender() {
      this.members.forEach((node) => {
        node.instance && node.scheduleRender(false);
      });
    }
    /**
     * Clear any leads that have been removed this render to prevent them from being
     * used in future animations and to prevent memory leaks
     */
    removeLeadSnapshot() {
      if (this.lead && this.lead.snapshot) {
        this.lead.snapshot = void 0;
      }
    }
  };

  // ../../node_modules/framer-motion/dist/es/projection/styles/transform.mjs
  function buildProjectionTransform(delta, treeScale, latestTransform) {
    let transform2 = "";
    const xTranslate = delta.x.translate / treeScale.x;
    const yTranslate = delta.y.translate / treeScale.y;
    const zTranslate = latestTransform?.z || 0;
    if (xTranslate || yTranslate || zTranslate) {
      transform2 = `translate3d(${xTranslate}px, ${yTranslate}px, ${zTranslate}px) `;
    }
    if (treeScale.x !== 1 || treeScale.y !== 1) {
      transform2 += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `;
    }
    if (latestTransform) {
      const { transformPerspective, rotate: rotate2, rotateX, rotateY, skewX, skewY } = latestTransform;
      if (transformPerspective)
        transform2 = `perspective(${transformPerspective}px) ${transform2}`;
      if (rotate2)
        transform2 += `rotate(${rotate2}deg) `;
      if (rotateX)
        transform2 += `rotateX(${rotateX}deg) `;
      if (rotateY)
        transform2 += `rotateY(${rotateY}deg) `;
      if (skewX)
        transform2 += `skewX(${skewX}deg) `;
      if (skewY)
        transform2 += `skewY(${skewY}deg) `;
    }
    const elementScaleX = delta.x.scale * treeScale.x;
    const elementScaleY = delta.y.scale * treeScale.y;
    if (elementScaleX !== 1 || elementScaleY !== 1) {
      transform2 += `scale(${elementScaleX}, ${elementScaleY})`;
    }
    return transform2 || "none";
  }

  // ../../node_modules/framer-motion/dist/es/projection/node/create-projection-node.mjs
  var metrics = {
    nodes: 0,
    calculatedTargetDeltas: 0,
    calculatedProjections: 0
  };
  var transformAxes = ["", "X", "Y", "Z"];
  var animationTarget = 1e3;
  var id2 = 0;
  function resetDistortingTransform(key, visualElement, values, sharedAnimationValues) {
    const { latestValues } = visualElement;
    if (latestValues[key]) {
      values[key] = latestValues[key];
      visualElement.setStaticValue(key, 0);
      if (sharedAnimationValues) {
        sharedAnimationValues[key] = 0;
      }
    }
  }
  function cancelTreeOptimisedTransformAnimations(projectionNode) {
    projectionNode.hasCheckedOptimisedAppear = true;
    if (projectionNode.root === projectionNode)
      return;
    const { visualElement } = projectionNode.options;
    if (!visualElement)
      return;
    const appearId = getOptimisedAppearId(visualElement);
    if (window.MotionHasOptimisedAnimation(appearId, "transform")) {
      const { layout: layout2, layoutId } = projectionNode.options;
      window.MotionCancelOptimisedAnimation(appearId, "transform", frame, !(layout2 || layoutId));
    }
    const { parent } = projectionNode;
    if (parent && !parent.hasCheckedOptimisedAppear) {
      cancelTreeOptimisedTransformAnimations(parent);
    }
  }
  function createProjectionNode2({ attachResizeListener, defaultParent, measureScroll, checkIsScrollRoot, resetTransform }) {
    return class ProjectionNode {
      constructor(latestValues = {}, parent = defaultParent?.()) {
        this.id = id2++;
        this.animationId = 0;
        this.animationCommitId = 0;
        this.children = /* @__PURE__ */ new Set();
        this.options = {};
        this.isTreeAnimating = false;
        this.isAnimationBlocked = false;
        this.isLayoutDirty = false;
        this.isProjectionDirty = false;
        this.isSharedProjectionDirty = false;
        this.isTransformDirty = false;
        this.updateManuallyBlocked = false;
        this.updateBlockedByResize = false;
        this.isUpdating = false;
        this.isSVG = false;
        this.needsReset = false;
        this.shouldResetTransform = false;
        this.hasCheckedOptimisedAppear = false;
        this.treeScale = { x: 1, y: 1 };
        this.eventHandlers = /* @__PURE__ */ new Map();
        this.hasTreeAnimated = false;
        this.layoutVersion = 0;
        this.updateScheduled = false;
        this.scheduleUpdate = () => this.update();
        this.projectionUpdateScheduled = false;
        this.checkUpdateFailed = () => {
          if (this.isUpdating) {
            this.isUpdating = false;
            this.clearAllSnapshots();
          }
        };
        this.updateProjection = () => {
          this.projectionUpdateScheduled = false;
          if (statsBuffer.value) {
            metrics.nodes = metrics.calculatedTargetDeltas = metrics.calculatedProjections = 0;
          }
          this.nodes.forEach(propagateDirtyNodes);
          this.nodes.forEach(resolveTargetDelta);
          this.nodes.forEach(calcProjection);
          this.nodes.forEach(cleanDirtyNodes);
          if (statsBuffer.addProjectionMetrics) {
            statsBuffer.addProjectionMetrics(metrics);
          }
        };
        this.resolvedRelativeTargetAt = 0;
        this.linkedParentVersion = 0;
        this.hasProjected = false;
        this.isVisible = true;
        this.animationProgress = 0;
        this.sharedNodes = /* @__PURE__ */ new Map();
        this.latestValues = latestValues;
        this.root = parent ? parent.root || parent : this;
        this.path = parent ? [...parent.path, parent] : [];
        this.parent = parent;
        this.depth = parent ? parent.depth + 1 : 0;
        for (let i3 = 0; i3 < this.path.length; i3++) {
          this.path[i3].shouldResetTransform = true;
        }
        if (this.root === this)
          this.nodes = new FlatTree();
      }
      addEventListener(name, handler) {
        if (!this.eventHandlers.has(name)) {
          this.eventHandlers.set(name, new SubscriptionManager());
        }
        return this.eventHandlers.get(name).add(handler);
      }
      notifyListeners(name, ...args) {
        const subscriptionManager = this.eventHandlers.get(name);
        subscriptionManager && subscriptionManager.notify(...args);
      }
      hasListeners(name) {
        return this.eventHandlers.has(name);
      }
      /**
       * Lifecycles
       */
      mount(instance) {
        if (this.instance)
          return;
        this.isSVG = isSVGElement(instance) && !isSVGSVGElement(instance);
        this.instance = instance;
        const { layoutId, layout: layout2, visualElement } = this.options;
        if (visualElement && !visualElement.current) {
          visualElement.mount(instance);
        }
        this.root.nodes.add(this);
        this.parent && this.parent.children.add(this);
        if (this.root.hasTreeAnimated && (layout2 || layoutId)) {
          this.isLayoutDirty = true;
        }
        if (attachResizeListener) {
          let cancelDelay;
          let innerWidth = 0;
          const resizeUnblockUpdate = () => this.root.updateBlockedByResize = false;
          frame.read(() => {
            innerWidth = window.innerWidth;
          });
          attachResizeListener(instance, () => {
            const newInnerWidth = window.innerWidth;
            if (newInnerWidth === innerWidth)
              return;
            innerWidth = newInnerWidth;
            this.root.updateBlockedByResize = true;
            cancelDelay && cancelDelay();
            cancelDelay = delay(resizeUnblockUpdate, 250);
            if (globalProjectionState.hasAnimatedSinceResize) {
              globalProjectionState.hasAnimatedSinceResize = false;
              this.nodes.forEach(finishAnimation);
            }
          });
        }
        if (layoutId) {
          this.root.registerSharedNode(layoutId, this);
        }
        if (this.options.animate !== false && visualElement && (layoutId || layout2)) {
          this.addEventListener("didUpdate", ({ delta, hasLayoutChanged, hasRelativeLayoutChanged, layout: newLayout }) => {
            if (this.isTreeAnimationBlocked()) {
              this.target = void 0;
              this.relativeTarget = void 0;
              return;
            }
            const layoutTransition = this.options.transition || visualElement.getDefaultTransition() || defaultLayoutTransition;
            const { onLayoutAnimationStart, onLayoutAnimationComplete } = visualElement.getProps();
            const hasTargetChanged = !this.targetLayout || !boxEqualsRounded(this.targetLayout, newLayout);
            const hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeLayoutChanged;
            if (this.options.layoutRoot || this.resumeFrom || hasOnlyRelativeTargetChanged || hasLayoutChanged && (hasTargetChanged || !this.currentAnimation)) {
              if (this.resumeFrom) {
                this.resumingFrom = this.resumeFrom;
                this.resumingFrom.resumingFrom = void 0;
              }
              const animationOptions = {
                ...getValueTransition(layoutTransition, "layout"),
                onPlay: onLayoutAnimationStart,
                onComplete: onLayoutAnimationComplete
              };
              if (visualElement.shouldReduceMotion || this.options.layoutRoot) {
                animationOptions.delay = 0;
                animationOptions.type = false;
              }
              this.startAnimation(animationOptions);
              this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);
            } else {
              if (!hasLayoutChanged) {
                finishAnimation(this);
              }
              if (this.isLead() && this.options.onExitComplete) {
                this.options.onExitComplete();
              }
            }
            this.targetLayout = newLayout;
          });
        }
      }
      unmount() {
        this.options.layoutId && this.willUpdate();
        this.root.nodes.remove(this);
        const stack = this.getStack();
        stack && stack.remove(this);
        this.parent && this.parent.children.delete(this);
        this.instance = void 0;
        this.eventHandlers.clear();
        cancelFrame(this.updateProjection);
      }
      // only on the root
      blockUpdate() {
        this.updateManuallyBlocked = true;
      }
      unblockUpdate() {
        this.updateManuallyBlocked = false;
      }
      isUpdateBlocked() {
        return this.updateManuallyBlocked || this.updateBlockedByResize;
      }
      isTreeAnimationBlocked() {
        return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || false;
      }
      // Note: currently only running on root node
      startUpdate() {
        if (this.isUpdateBlocked())
          return;
        this.isUpdating = true;
        this.nodes && this.nodes.forEach(resetSkewAndRotation);
        this.animationId++;
      }
      getTransformTemplate() {
        const { visualElement } = this.options;
        return visualElement && visualElement.getProps().transformTemplate;
      }
      willUpdate(shouldNotifyListeners = true) {
        this.root.hasTreeAnimated = true;
        if (this.root.isUpdateBlocked()) {
          this.options.onExitComplete && this.options.onExitComplete();
          return;
        }
        if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear) {
          cancelTreeOptimisedTransformAnimations(this);
        }
        !this.root.isUpdating && this.root.startUpdate();
        if (this.isLayoutDirty)
          return;
        this.isLayoutDirty = true;
        for (let i3 = 0; i3 < this.path.length; i3++) {
          const node = this.path[i3];
          node.shouldResetTransform = true;
          node.updateScroll("snapshot");
          if (node.options.layoutRoot) {
            node.willUpdate(false);
          }
        }
        const { layoutId, layout: layout2 } = this.options;
        if (layoutId === void 0 && !layout2)
          return;
        const transformTemplate = this.getTransformTemplate();
        this.prevTransformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : void 0;
        this.updateSnapshot();
        shouldNotifyListeners && this.notifyListeners("willUpdate");
      }
      update() {
        this.updateScheduled = false;
        const updateWasBlocked = this.isUpdateBlocked();
        if (updateWasBlocked) {
          this.unblockUpdate();
          this.clearAllSnapshots();
          this.nodes.forEach(clearMeasurements);
          return;
        }
        if (this.animationId <= this.animationCommitId) {
          this.nodes.forEach(clearIsLayoutDirty);
          return;
        }
        this.animationCommitId = this.animationId;
        if (!this.isUpdating) {
          this.nodes.forEach(clearIsLayoutDirty);
        } else {
          this.isUpdating = false;
          this.nodes.forEach(resetTransformStyle);
          this.nodes.forEach(updateLayout);
          this.nodes.forEach(notifyLayoutUpdate);
        }
        this.clearAllSnapshots();
        const now2 = time.now();
        frameData.delta = clamp(0, 1e3 / 60, now2 - frameData.timestamp);
        frameData.timestamp = now2;
        frameData.isProcessing = true;
        frameSteps.update.process(frameData);
        frameSteps.preRender.process(frameData);
        frameSteps.render.process(frameData);
        frameData.isProcessing = false;
      }
      didUpdate() {
        if (!this.updateScheduled) {
          this.updateScheduled = true;
          microtask.read(this.scheduleUpdate);
        }
      }
      clearAllSnapshots() {
        this.nodes.forEach(clearSnapshot);
        this.sharedNodes.forEach(removeLeadSnapshots);
      }
      scheduleUpdateProjection() {
        if (!this.projectionUpdateScheduled) {
          this.projectionUpdateScheduled = true;
          frame.preRender(this.updateProjection, false, true);
        }
      }
      scheduleCheckAfterUnmount() {
        frame.postRender(() => {
          if (this.isLayoutDirty) {
            this.root.didUpdate();
          } else {
            this.root.checkUpdateFailed();
          }
        });
      }
      /**
       * Update measurements
       */
      updateSnapshot() {
        if (this.snapshot || !this.instance)
          return;
        this.snapshot = this.measure();
        if (this.snapshot && !calcLength(this.snapshot.measuredBox.x) && !calcLength(this.snapshot.measuredBox.y)) {
          this.snapshot = void 0;
        }
      }
      updateLayout() {
        if (!this.instance)
          return;
        this.updateScroll();
        if (!(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty) {
          return;
        }
        if (this.resumeFrom && !this.resumeFrom.instance) {
          for (let i3 = 0; i3 < this.path.length; i3++) {
            const node = this.path[i3];
            node.updateScroll();
          }
        }
        const prevLayout = this.layout;
        this.layout = this.measure(false);
        this.layoutVersion++;
        this.layoutCorrected = createBox();
        this.isLayoutDirty = false;
        this.projectionDelta = void 0;
        this.notifyListeners("measure", this.layout.layoutBox);
        const { visualElement } = this.options;
        visualElement && visualElement.notify("LayoutMeasure", this.layout.layoutBox, prevLayout ? prevLayout.layoutBox : void 0);
      }
      updateScroll(phase = "measure") {
        let needsMeasurement = Boolean(this.options.layoutScroll && this.instance);
        if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === phase) {
          needsMeasurement = false;
        }
        if (needsMeasurement && this.instance) {
          const isRoot = checkIsScrollRoot(this.instance);
          this.scroll = {
            animationId: this.root.animationId,
            phase,
            isRoot,
            offset: measureScroll(this.instance),
            wasRoot: this.scroll ? this.scroll.isRoot : isRoot
          };
        }
      }
      resetTransform() {
        if (!resetTransform)
          return;
        const isResetRequested = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout;
        const hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta);
        const transformTemplate = this.getTransformTemplate();
        const transformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : void 0;
        const transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;
        if (isResetRequested && this.instance && (hasProjection || hasTransform(this.latestValues) || transformTemplateHasChanged)) {
          resetTransform(this.instance, transformTemplateValue);
          this.shouldResetTransform = false;
          this.scheduleRender();
        }
      }
      measure(removeTransform = true) {
        const pageBox = this.measurePageBox();
        let layoutBox = this.removeElementScroll(pageBox);
        if (removeTransform) {
          layoutBox = this.removeTransform(layoutBox);
        }
        roundBox(layoutBox);
        return {
          animationId: this.root.animationId,
          measuredBox: pageBox,
          layoutBox,
          latestValues: {},
          source: this.id
        };
      }
      measurePageBox() {
        const { visualElement } = this.options;
        if (!visualElement)
          return createBox();
        const box = visualElement.measureViewportBox();
        const wasInScrollRoot = this.scroll?.wasRoot || this.path.some(checkNodeWasScrollRoot);
        if (!wasInScrollRoot) {
          const { scroll: scroll2 } = this.root;
          if (scroll2) {
            translateAxis(box.x, scroll2.offset.x);
            translateAxis(box.y, scroll2.offset.y);
          }
        }
        return box;
      }
      removeElementScroll(box) {
        const boxWithoutScroll = createBox();
        copyBoxInto(boxWithoutScroll, box);
        if (this.scroll?.wasRoot) {
          return boxWithoutScroll;
        }
        for (let i3 = 0; i3 < this.path.length; i3++) {
          const node = this.path[i3];
          const { scroll: scroll2, options } = node;
          if (node !== this.root && scroll2 && options.layoutScroll) {
            if (scroll2.wasRoot) {
              copyBoxInto(boxWithoutScroll, box);
            }
            translateAxis(boxWithoutScroll.x, scroll2.offset.x);
            translateAxis(boxWithoutScroll.y, scroll2.offset.y);
          }
        }
        return boxWithoutScroll;
      }
      applyTransform(box, transformOnly = false) {
        const withTransforms = createBox();
        copyBoxInto(withTransforms, box);
        for (let i3 = 0; i3 < this.path.length; i3++) {
          const node = this.path[i3];
          if (!transformOnly && node.options.layoutScroll && node.scroll && node !== node.root) {
            transformBox(withTransforms, {
              x: -node.scroll.offset.x,
              y: -node.scroll.offset.y
            });
          }
          if (!hasTransform(node.latestValues))
            continue;
          transformBox(withTransforms, node.latestValues);
        }
        if (hasTransform(this.latestValues)) {
          transformBox(withTransforms, this.latestValues);
        }
        return withTransforms;
      }
      removeTransform(box) {
        const boxWithoutTransform = createBox();
        copyBoxInto(boxWithoutTransform, box);
        for (let i3 = 0; i3 < this.path.length; i3++) {
          const node = this.path[i3];
          if (!node.instance)
            continue;
          if (!hasTransform(node.latestValues))
            continue;
          hasScale(node.latestValues) && node.updateSnapshot();
          const sourceBox = createBox();
          const nodeBox = node.measurePageBox();
          copyBoxInto(sourceBox, nodeBox);
          removeBoxTransforms(boxWithoutTransform, node.latestValues, node.snapshot ? node.snapshot.layoutBox : void 0, sourceBox);
        }
        if (hasTransform(this.latestValues)) {
          removeBoxTransforms(boxWithoutTransform, this.latestValues);
        }
        return boxWithoutTransform;
      }
      setTargetDelta(delta) {
        this.targetDelta = delta;
        this.root.scheduleUpdateProjection();
        this.isProjectionDirty = true;
      }
      setOptions(options) {
        this.options = {
          ...this.options,
          ...options,
          crossfade: options.crossfade !== void 0 ? options.crossfade : true
        };
      }
      clearMeasurements() {
        this.scroll = void 0;
        this.layout = void 0;
        this.snapshot = void 0;
        this.prevTransformTemplateValue = void 0;
        this.targetDelta = void 0;
        this.target = void 0;
        this.isLayoutDirty = false;
      }
      forceRelativeParentToResolveTarget() {
        if (!this.relativeParent)
          return;
        if (this.relativeParent.resolvedRelativeTargetAt !== frameData.timestamp) {
          this.relativeParent.resolveTargetDelta(true);
        }
      }
      resolveTargetDelta(forceRecalculation = false) {
        const lead = this.getLead();
        this.isProjectionDirty || (this.isProjectionDirty = lead.isProjectionDirty);
        this.isTransformDirty || (this.isTransformDirty = lead.isTransformDirty);
        this.isSharedProjectionDirty || (this.isSharedProjectionDirty = lead.isSharedProjectionDirty);
        const isShared = Boolean(this.resumingFrom) || this !== lead;
        const canSkip = !(forceRecalculation || isShared && this.isSharedProjectionDirty || this.isProjectionDirty || this.parent?.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize);
        if (canSkip)
          return;
        const { layout: layout2, layoutId } = this.options;
        if (!this.layout || !(layout2 || layoutId))
          return;
        this.resolvedRelativeTargetAt = frameData.timestamp;
        const relativeParent = this.getClosestProjectingParent();
        if (relativeParent && this.linkedParentVersion !== relativeParent.layoutVersion && !relativeParent.options.layoutRoot) {
          this.removeRelativeTarget();
        }
        if (!this.targetDelta && !this.relativeTarget) {
          if (relativeParent && relativeParent.layout) {
            this.createRelativeTarget(relativeParent, this.layout.layoutBox, relativeParent.layout.layoutBox);
          } else {
            this.removeRelativeTarget();
          }
        }
        if (!this.relativeTarget && !this.targetDelta)
          return;
        if (!this.target) {
          this.target = createBox();
          this.targetWithTransforms = createBox();
        }
        if (this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target) {
          this.forceRelativeParentToResolveTarget();
          calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target);
        } else if (this.targetDelta) {
          if (Boolean(this.resumingFrom)) {
            this.target = this.applyTransform(this.layout.layoutBox);
          } else {
            copyBoxInto(this.target, this.layout.layoutBox);
          }
          applyBoxDelta(this.target, this.targetDelta);
        } else {
          copyBoxInto(this.target, this.layout.layoutBox);
        }
        if (this.attemptToResolveRelativeTarget) {
          this.attemptToResolveRelativeTarget = false;
          if (relativeParent && Boolean(relativeParent.resumingFrom) === Boolean(this.resumingFrom) && !relativeParent.options.layoutScroll && relativeParent.target && this.animationProgress !== 1) {
            this.createRelativeTarget(relativeParent, this.target, relativeParent.target);
          } else {
            this.relativeParent = this.relativeTarget = void 0;
          }
        }
        if (statsBuffer.value) {
          metrics.calculatedTargetDeltas++;
        }
      }
      getClosestProjectingParent() {
        if (!this.parent || hasScale(this.parent.latestValues) || has2DTranslate(this.parent.latestValues)) {
          return void 0;
        }
        if (this.parent.isProjecting()) {
          return this.parent;
        } else {
          return this.parent.getClosestProjectingParent();
        }
      }
      isProjecting() {
        return Boolean((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
      }
      createRelativeTarget(relativeParent, layout2, parentLayout) {
        this.relativeParent = relativeParent;
        this.linkedParentVersion = relativeParent.layoutVersion;
        this.forceRelativeParentToResolveTarget();
        this.relativeTarget = createBox();
        this.relativeTargetOrigin = createBox();
        calcRelativePosition(this.relativeTargetOrigin, layout2, parentLayout);
        copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
      }
      removeRelativeTarget() {
        this.relativeParent = this.relativeTarget = void 0;
      }
      calcProjection() {
        const lead = this.getLead();
        const isShared = Boolean(this.resumingFrom) || this !== lead;
        let canSkip = true;
        if (this.isProjectionDirty || this.parent?.isProjectionDirty) {
          canSkip = false;
        }
        if (isShared && (this.isSharedProjectionDirty || this.isTransformDirty)) {
          canSkip = false;
        }
        if (this.resolvedRelativeTargetAt === frameData.timestamp) {
          canSkip = false;
        }
        if (canSkip)
          return;
        const { layout: layout2, layoutId } = this.options;
        this.isTreeAnimating = Boolean(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation);
        if (!this.isTreeAnimating) {
          this.targetDelta = this.relativeTarget = void 0;
        }
        if (!this.layout || !(layout2 || layoutId))
          return;
        copyBoxInto(this.layoutCorrected, this.layout.layoutBox);
        const prevTreeScaleX = this.treeScale.x;
        const prevTreeScaleY = this.treeScale.y;
        applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, isShared);
        if (lead.layout && !lead.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1)) {
          lead.target = lead.layout.layoutBox;
          lead.targetWithTransforms = createBox();
        }
        const { target } = lead;
        if (!target) {
          if (this.prevProjectionDelta) {
            this.createProjectionDeltas();
            this.scheduleRender();
          }
          return;
        }
        if (!this.projectionDelta || !this.prevProjectionDelta) {
          this.createProjectionDeltas();
        } else {
          copyAxisDeltaInto(this.prevProjectionDelta.x, this.projectionDelta.x);
          copyAxisDeltaInto(this.prevProjectionDelta.y, this.projectionDelta.y);
        }
        calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues);
        if (this.treeScale.x !== prevTreeScaleX || this.treeScale.y !== prevTreeScaleY || !axisDeltaEquals(this.projectionDelta.x, this.prevProjectionDelta.x) || !axisDeltaEquals(this.projectionDelta.y, this.prevProjectionDelta.y)) {
          this.hasProjected = true;
          this.scheduleRender();
          this.notifyListeners("projectionUpdate", target);
        }
        if (statsBuffer.value) {
          metrics.calculatedProjections++;
        }
      }
      hide() {
        this.isVisible = false;
      }
      show() {
        this.isVisible = true;
      }
      scheduleRender(notifyAll2 = true) {
        this.options.visualElement?.scheduleRender();
        if (notifyAll2) {
          const stack = this.getStack();
          stack && stack.scheduleRender();
        }
        if (this.resumingFrom && !this.resumingFrom.instance) {
          this.resumingFrom = void 0;
        }
      }
      createProjectionDeltas() {
        this.prevProjectionDelta = createDelta();
        this.projectionDelta = createDelta();
        this.projectionDeltaWithTransform = createDelta();
      }
      setAnimationOrigin(delta, hasOnlyRelativeTargetChanged = false) {
        const snapshot = this.snapshot;
        const snapshotLatestValues = snapshot ? snapshot.latestValues : {};
        const mixedValues = { ...this.latestValues };
        const targetDelta = createDelta();
        if (!this.relativeParent || !this.relativeParent.options.layoutRoot) {
          this.relativeTarget = this.relativeTargetOrigin = void 0;
        }
        this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;
        const relativeLayout = createBox();
        const snapshotSource = snapshot ? snapshot.source : void 0;
        const layoutSource = this.layout ? this.layout.source : void 0;
        const isSharedLayoutAnimation = snapshotSource !== layoutSource;
        const stack = this.getStack();
        const isOnlyMember = !stack || stack.members.length <= 1;
        const shouldCrossfadeOpacity = Boolean(isSharedLayoutAnimation && !isOnlyMember && this.options.crossfade === true && !this.path.some(hasOpacityCrossfade));
        this.animationProgress = 0;
        let prevRelativeTarget;
        this.mixTargetDelta = (latest) => {
          const progress2 = latest / 1e3;
          mixAxisDelta(targetDelta.x, delta.x, progress2);
          mixAxisDelta(targetDelta.y, delta.y, progress2);
          this.setTargetDelta(targetDelta);
          if (this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout) {
            calcRelativePosition(relativeLayout, this.layout.layoutBox, this.relativeParent.layout.layoutBox);
            mixBox(this.relativeTarget, this.relativeTargetOrigin, relativeLayout, progress2);
            if (prevRelativeTarget && boxEquals(this.relativeTarget, prevRelativeTarget)) {
              this.isProjectionDirty = false;
            }
            if (!prevRelativeTarget)
              prevRelativeTarget = createBox();
            copyBoxInto(prevRelativeTarget, this.relativeTarget);
          }
          if (isSharedLayoutAnimation) {
            this.animationValues = mixedValues;
            mixValues(mixedValues, snapshotLatestValues, this.latestValues, progress2, shouldCrossfadeOpacity, isOnlyMember);
          }
          this.root.scheduleUpdateProjection();
          this.scheduleRender();
          this.animationProgress = progress2;
        };
        this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
      }
      startAnimation(options) {
        this.notifyListeners("animationStart");
        this.currentAnimation?.stop();
        this.resumingFrom?.currentAnimation?.stop();
        if (this.pendingAnimation) {
          cancelFrame(this.pendingAnimation);
          this.pendingAnimation = void 0;
        }
        this.pendingAnimation = frame.update(() => {
          globalProjectionState.hasAnimatedSinceResize = true;
          activeAnimations.layout++;
          this.motionValue || (this.motionValue = motionValue(0));
          this.currentAnimation = animateSingleValue(this.motionValue, [0, 1e3], {
            ...options,
            velocity: 0,
            isSync: true,
            onUpdate: (latest) => {
              this.mixTargetDelta(latest);
              options.onUpdate && options.onUpdate(latest);
            },
            onStop: () => {
              activeAnimations.layout--;
            },
            onComplete: () => {
              activeAnimations.layout--;
              options.onComplete && options.onComplete();
              this.completeAnimation();
            }
          });
          if (this.resumingFrom) {
            this.resumingFrom.currentAnimation = this.currentAnimation;
          }
          this.pendingAnimation = void 0;
        });
      }
      completeAnimation() {
        if (this.resumingFrom) {
          this.resumingFrom.currentAnimation = void 0;
          this.resumingFrom.preserveOpacity = void 0;
        }
        const stack = this.getStack();
        stack && stack.exitAnimationComplete();
        this.resumingFrom = this.currentAnimation = this.animationValues = void 0;
        this.notifyListeners("animationComplete");
      }
      finishAnimation() {
        if (this.currentAnimation) {
          this.mixTargetDelta && this.mixTargetDelta(animationTarget);
          this.currentAnimation.stop();
        }
        this.completeAnimation();
      }
      applyTransformsToTarget() {
        const lead = this.getLead();
        let { targetWithTransforms, target, layout: layout2, latestValues } = lead;
        if (!targetWithTransforms || !target || !layout2)
          return;
        if (this !== lead && this.layout && layout2 && shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, layout2.layoutBox)) {
          target = this.target || createBox();
          const xLength = calcLength(this.layout.layoutBox.x);
          target.x.min = lead.target.x.min;
          target.x.max = target.x.min + xLength;
          const yLength = calcLength(this.layout.layoutBox.y);
          target.y.min = lead.target.y.min;
          target.y.max = target.y.min + yLength;
        }
        copyBoxInto(targetWithTransforms, target);
        transformBox(targetWithTransforms, latestValues);
        calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);
      }
      registerSharedNode(layoutId, node) {
        if (!this.sharedNodes.has(layoutId)) {
          this.sharedNodes.set(layoutId, new NodeStack());
        }
        const stack = this.sharedNodes.get(layoutId);
        stack.add(node);
        const config2 = node.options.initialPromotionConfig;
        node.promote({
          transition: config2 ? config2.transition : void 0,
          preserveFollowOpacity: config2 && config2.shouldPreserveFollowOpacity ? config2.shouldPreserveFollowOpacity(node) : void 0
        });
      }
      isLead() {
        const stack = this.getStack();
        return stack ? stack.lead === this : true;
      }
      getLead() {
        const { layoutId } = this.options;
        return layoutId ? this.getStack()?.lead || this : this;
      }
      getPrevLead() {
        const { layoutId } = this.options;
        return layoutId ? this.getStack()?.prevLead : void 0;
      }
      getStack() {
        const { layoutId } = this.options;
        if (layoutId)
          return this.root.sharedNodes.get(layoutId);
      }
      promote({ needsReset, transition, preserveFollowOpacity } = {}) {
        const stack = this.getStack();
        if (stack)
          stack.promote(this, preserveFollowOpacity);
        if (needsReset) {
          this.projectionDelta = void 0;
          this.needsReset = true;
        }
        if (transition)
          this.setOptions({ transition });
      }
      relegate() {
        const stack = this.getStack();
        if (stack) {
          return stack.relegate(this);
        } else {
          return false;
        }
      }
      resetSkewAndRotation() {
        const { visualElement } = this.options;
        if (!visualElement)
          return;
        let hasDistortingTransform = false;
        const { latestValues } = visualElement;
        if (latestValues.z || latestValues.rotate || latestValues.rotateX || latestValues.rotateY || latestValues.rotateZ || latestValues.skewX || latestValues.skewY) {
          hasDistortingTransform = true;
        }
        if (!hasDistortingTransform)
          return;
        const resetValues = {};
        if (latestValues.z) {
          resetDistortingTransform("z", visualElement, resetValues, this.animationValues);
        }
        for (let i3 = 0; i3 < transformAxes.length; i3++) {
          resetDistortingTransform(`rotate${transformAxes[i3]}`, visualElement, resetValues, this.animationValues);
          resetDistortingTransform(`skew${transformAxes[i3]}`, visualElement, resetValues, this.animationValues);
        }
        visualElement.render();
        for (const key in resetValues) {
          visualElement.setStaticValue(key, resetValues[key]);
          if (this.animationValues) {
            this.animationValues[key] = resetValues[key];
          }
        }
        visualElement.scheduleRender();
      }
      applyProjectionStyles(targetStyle, styleProp) {
        if (!this.instance || this.isSVG)
          return;
        if (!this.isVisible) {
          targetStyle.visibility = "hidden";
          return;
        }
        const transformTemplate = this.getTransformTemplate();
        if (this.needsReset) {
          this.needsReset = false;
          targetStyle.visibility = "";
          targetStyle.opacity = "";
          targetStyle.pointerEvents = resolveMotionValue(styleProp?.pointerEvents) || "";
          targetStyle.transform = transformTemplate ? transformTemplate(this.latestValues, "") : "none";
          return;
        }
        const lead = this.getLead();
        if (!this.projectionDelta || !this.layout || !lead.target) {
          if (this.options.layoutId) {
            targetStyle.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1;
            targetStyle.pointerEvents = resolveMotionValue(styleProp?.pointerEvents) || "";
          }
          if (this.hasProjected && !hasTransform(this.latestValues)) {
            targetStyle.transform = transformTemplate ? transformTemplate({}, "") : "none";
            this.hasProjected = false;
          }
          return;
        }
        targetStyle.visibility = "";
        const valuesToRender = lead.animationValues || lead.latestValues;
        this.applyTransformsToTarget();
        let transform2 = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender);
        if (transformTemplate) {
          transform2 = transformTemplate(valuesToRender, transform2);
        }
        targetStyle.transform = transform2;
        const { x: x2, y: y2 } = this.projectionDelta;
        targetStyle.transformOrigin = `${x2.origin * 100}% ${y2.origin * 100}% 0`;
        if (lead.animationValues) {
          targetStyle.opacity = lead === this ? valuesToRender.opacity ?? this.latestValues.opacity ?? 1 : this.preserveOpacity ? this.latestValues.opacity : valuesToRender.opacityExit;
        } else {
          targetStyle.opacity = lead === this ? valuesToRender.opacity !== void 0 ? valuesToRender.opacity : "" : valuesToRender.opacityExit !== void 0 ? valuesToRender.opacityExit : 0;
        }
        for (const key in scaleCorrectors) {
          if (valuesToRender[key] === void 0)
            continue;
          const { correct, applyTo, isCSSVariable } = scaleCorrectors[key];
          const corrected = transform2 === "none" ? valuesToRender[key] : correct(valuesToRender[key], lead);
          if (applyTo) {
            const num = applyTo.length;
            for (let i3 = 0; i3 < num; i3++) {
              targetStyle[applyTo[i3]] = corrected;
            }
          } else {
            if (isCSSVariable) {
              this.options.visualElement.renderState.vars[key] = corrected;
            } else {
              targetStyle[key] = corrected;
            }
          }
        }
        if (this.options.layoutId) {
          targetStyle.pointerEvents = lead === this ? resolveMotionValue(styleProp?.pointerEvents) || "" : "none";
        }
      }
      clearSnapshot() {
        this.resumeFrom = this.snapshot = void 0;
      }
      // Only run on root
      resetTree() {
        this.root.nodes.forEach((node) => node.currentAnimation?.stop());
        this.root.nodes.forEach(clearMeasurements);
        this.root.sharedNodes.clear();
      }
    };
  }
  function updateLayout(node) {
    node.updateLayout();
  }
  function notifyLayoutUpdate(node) {
    const snapshot = node.resumeFrom?.snapshot || node.snapshot;
    if (node.isLead() && node.layout && snapshot && node.hasListeners("didUpdate")) {
      const { layoutBox: layout2, measuredBox: measuredLayout } = node.layout;
      const { animationType } = node.options;
      const isShared = snapshot.source !== node.layout.source;
      if (animationType === "size") {
        eachAxis((axis) => {
          const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];
          const length = calcLength(axisSnapshot);
          axisSnapshot.min = layout2[axis].min;
          axisSnapshot.max = axisSnapshot.min + length;
        });
      } else if (shouldAnimatePositionOnly(animationType, snapshot.layoutBox, layout2)) {
        eachAxis((axis) => {
          const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];
          const length = calcLength(layout2[axis]);
          axisSnapshot.max = axisSnapshot.min + length;
          if (node.relativeTarget && !node.currentAnimation) {
            node.isProjectionDirty = true;
            node.relativeTarget[axis].max = node.relativeTarget[axis].min + length;
          }
        });
      }
      const layoutDelta = createDelta();
      calcBoxDelta(layoutDelta, layout2, snapshot.layoutBox);
      const visualDelta = createDelta();
      if (isShared) {
        calcBoxDelta(visualDelta, node.applyTransform(measuredLayout, true), snapshot.measuredBox);
      } else {
        calcBoxDelta(visualDelta, layout2, snapshot.layoutBox);
      }
      const hasLayoutChanged = !isDeltaZero(layoutDelta);
      let hasRelativeLayoutChanged = false;
      if (!node.resumeFrom) {
        const relativeParent = node.getClosestProjectingParent();
        if (relativeParent && !relativeParent.resumeFrom) {
          const { snapshot: parentSnapshot, layout: parentLayout } = relativeParent;
          if (parentSnapshot && parentLayout) {
            const relativeSnapshot = createBox();
            calcRelativePosition(relativeSnapshot, snapshot.layoutBox, parentSnapshot.layoutBox);
            const relativeLayout = createBox();
            calcRelativePosition(relativeLayout, layout2, parentLayout.layoutBox);
            if (!boxEqualsRounded(relativeSnapshot, relativeLayout)) {
              hasRelativeLayoutChanged = true;
            }
            if (relativeParent.options.layoutRoot) {
              node.relativeTarget = relativeLayout;
              node.relativeTargetOrigin = relativeSnapshot;
              node.relativeParent = relativeParent;
            }
          }
        }
      }
      node.notifyListeners("didUpdate", {
        layout: layout2,
        snapshot,
        delta: visualDelta,
        layoutDelta,
        hasLayoutChanged,
        hasRelativeLayoutChanged
      });
    } else if (node.isLead()) {
      const { onExitComplete } = node.options;
      onExitComplete && onExitComplete();
    }
    node.options.transition = void 0;
  }
  function propagateDirtyNodes(node) {
    if (statsBuffer.value) {
      metrics.nodes++;
    }
    if (!node.parent)
      return;
    if (!node.isProjecting()) {
      node.isProjectionDirty = node.parent.isProjectionDirty;
    }
    node.isSharedProjectionDirty || (node.isSharedProjectionDirty = Boolean(node.isProjectionDirty || node.parent.isProjectionDirty || node.parent.isSharedProjectionDirty));
    node.isTransformDirty || (node.isTransformDirty = node.parent.isTransformDirty);
  }
  function cleanDirtyNodes(node) {
    node.isProjectionDirty = node.isSharedProjectionDirty = node.isTransformDirty = false;
  }
  function clearSnapshot(node) {
    node.clearSnapshot();
  }
  function clearMeasurements(node) {
    node.clearMeasurements();
  }
  function clearIsLayoutDirty(node) {
    node.isLayoutDirty = false;
  }
  function resetTransformStyle(node) {
    const { visualElement } = node.options;
    if (visualElement && visualElement.getProps().onBeforeLayoutMeasure) {
      visualElement.notify("BeforeLayoutMeasure");
    }
    node.resetTransform();
  }
  function finishAnimation(node) {
    node.finishAnimation();
    node.targetDelta = node.relativeTarget = node.target = void 0;
    node.isProjectionDirty = true;
  }
  function resolveTargetDelta(node) {
    node.resolveTargetDelta();
  }
  function calcProjection(node) {
    node.calcProjection();
  }
  function resetSkewAndRotation(node) {
    node.resetSkewAndRotation();
  }
  function removeLeadSnapshots(stack) {
    stack.removeLeadSnapshot();
  }
  function mixAxisDelta(output, delta, p3) {
    output.translate = mixNumber(delta.translate, 0, p3);
    output.scale = mixNumber(delta.scale, 1, p3);
    output.origin = delta.origin;
    output.originPoint = delta.originPoint;
  }
  function mixAxis(output, from, to2, p3) {
    output.min = mixNumber(from.min, to2.min, p3);
    output.max = mixNumber(from.max, to2.max, p3);
  }
  function mixBox(output, from, to2, p3) {
    mixAxis(output.x, from.x, to2.x, p3);
    mixAxis(output.y, from.y, to2.y, p3);
  }
  function hasOpacityCrossfade(node) {
    return node.animationValues && node.animationValues.opacityExit !== void 0;
  }
  var defaultLayoutTransition = {
    duration: 0.45,
    ease: [0.4, 0, 0.1, 1]
  };
  var userAgentContains = (string) => typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(string);
  var roundPoint = userAgentContains("applewebkit/") && !userAgentContains("chrome/") ? Math.round : noop;
  function roundAxis(axis) {
    axis.min = roundPoint(axis.min);
    axis.max = roundPoint(axis.max);
  }
  function roundBox(box) {
    roundAxis(box.x);
    roundAxis(box.y);
  }
  function shouldAnimatePositionOnly(animationType, snapshot, layout2) {
    return animationType === "position" || animationType === "preserve-aspect" && !isNear(aspectRatio(snapshot), aspectRatio(layout2), 0.2);
  }
  function checkNodeWasScrollRoot(node) {
    return node !== node.root && node.scroll?.wasRoot;
  }

  // ../../node_modules/framer-motion/dist/es/projection/node/DocumentProjectionNode.mjs
  var DocumentProjectionNode = createProjectionNode2({
    attachResizeListener: (ref, notify) => addDomEvent(ref, "resize", notify),
    measureScroll: () => ({
      x: document.documentElement.scrollLeft || document.body.scrollLeft,
      y: document.documentElement.scrollTop || document.body.scrollTop
    }),
    checkIsScrollRoot: () => true
  });

  // ../../node_modules/framer-motion/dist/es/projection/node/HTMLProjectionNode.mjs
  var rootProjectionNode = {
    current: void 0
  };
  var HTMLProjectionNode = createProjectionNode2({
    measureScroll: (instance) => ({
      x: instance.scrollLeft,
      y: instance.scrollTop
    }),
    defaultParent: () => {
      if (!rootProjectionNode.current) {
        const documentNode = new DocumentProjectionNode({});
        documentNode.mount(window);
        documentNode.setOptions({ layoutScroll: true });
        rootProjectionNode.current = documentNode;
      }
      return rootProjectionNode.current;
    },
    resetTransform: (instance, value) => {
      instance.style.transform = value !== void 0 ? value : "none";
    },
    checkIsScrollRoot: (instance) => Boolean(window.getComputedStyle(instance).position === "fixed")
  });

  // ../../node_modules/framer-motion/dist/es/motion/features/drag.mjs
  var drag = {
    pan: {
      Feature: PanGesture
    },
    drag: {
      Feature: DragGesture,
      ProjectionNode: HTMLProjectionNode,
      MeasureLayout
    }
  };

  // ../../node_modules/framer-motion/dist/es/gestures/hover.mjs
  function handleHoverEvent(node, event, lifecycle) {
    const { props } = node;
    if (node.animationState && props.whileHover) {
      node.animationState.setActive("whileHover", lifecycle === "Start");
    }
    const eventName = "onHover" + lifecycle;
    const callback = props[eventName];
    if (callback) {
      frame.postRender(() => callback(event, extractEventInfo(event)));
    }
  }
  var HoverGesture = class extends Feature {
    mount() {
      const { current } = this.node;
      if (!current)
        return;
      this.unmount = hover(current, (_element, startEvent) => {
        handleHoverEvent(this.node, startEvent, "Start");
        return (endEvent) => handleHoverEvent(this.node, endEvent, "End");
      });
    }
    unmount() {
    }
  };

  // ../../node_modules/framer-motion/dist/es/gestures/focus.mjs
  var FocusGesture = class extends Feature {
    constructor() {
      super(...arguments);
      this.isActive = false;
    }
    onFocus() {
      let isFocusVisible = false;
      try {
        isFocusVisible = this.node.current.matches(":focus-visible");
      } catch (e2) {
        isFocusVisible = true;
      }
      if (!isFocusVisible || !this.node.animationState)
        return;
      this.node.animationState.setActive("whileFocus", true);
      this.isActive = true;
    }
    onBlur() {
      if (!this.isActive || !this.node.animationState)
        return;
      this.node.animationState.setActive("whileFocus", false);
      this.isActive = false;
    }
    mount() {
      this.unmount = pipe(addDomEvent(this.node.current, "focus", () => this.onFocus()), addDomEvent(this.node.current, "blur", () => this.onBlur()));
    }
    unmount() {
    }
  };

  // ../../node_modules/framer-motion/dist/es/gestures/press.mjs
  function handlePressEvent(node, event, lifecycle) {
    const { props } = node;
    if (node.current instanceof HTMLButtonElement && node.current.disabled) {
      return;
    }
    if (node.animationState && props.whileTap) {
      node.animationState.setActive("whileTap", lifecycle === "Start");
    }
    const eventName = "onTap" + (lifecycle === "End" ? "" : lifecycle);
    const callback = props[eventName];
    if (callback) {
      frame.postRender(() => callback(event, extractEventInfo(event)));
    }
  }
  var PressGesture = class extends Feature {
    mount() {
      const { current } = this.node;
      if (!current)
        return;
      this.unmount = press(current, (_element, startEvent) => {
        handlePressEvent(this.node, startEvent, "Start");
        return (endEvent, { success }) => handlePressEvent(this.node, endEvent, success ? "End" : "Cancel");
      }, { useGlobalTarget: this.node.props.globalTapTarget });
    }
    unmount() {
    }
  };

  // ../../node_modules/framer-motion/dist/es/motion/features/viewport/observers.mjs
  var observerCallbacks = /* @__PURE__ */ new WeakMap();
  var observers = /* @__PURE__ */ new WeakMap();
  var fireObserverCallback = (entry) => {
    const callback = observerCallbacks.get(entry.target);
    callback && callback(entry);
  };
  var fireAllObserverCallbacks = (entries) => {
    entries.forEach(fireObserverCallback);
  };
  function initIntersectionObserver({ root, ...options }) {
    const lookupRoot = root || document;
    if (!observers.has(lookupRoot)) {
      observers.set(lookupRoot, {});
    }
    const rootObservers = observers.get(lookupRoot);
    const key = JSON.stringify(options);
    if (!rootObservers[key]) {
      rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, { root, ...options });
    }
    return rootObservers[key];
  }
  function observeIntersection(element, options, callback) {
    const rootInteresectionObserver = initIntersectionObserver(options);
    observerCallbacks.set(element, callback);
    rootInteresectionObserver.observe(element);
    return () => {
      observerCallbacks.delete(element);
      rootInteresectionObserver.unobserve(element);
    };
  }

  // ../../node_modules/framer-motion/dist/es/motion/features/viewport/index.mjs
  var thresholdNames = {
    some: 0,
    all: 1
  };
  var InViewFeature = class extends Feature {
    constructor() {
      super(...arguments);
      this.hasEnteredView = false;
      this.isInView = false;
    }
    startObserver() {
      this.unmount();
      const { viewport = {} } = this.node.getProps();
      const { root, margin: rootMargin, amount = "some", once: once2 } = viewport;
      const options = {
        root: root ? root.current : void 0,
        rootMargin,
        threshold: typeof amount === "number" ? amount : thresholdNames[amount]
      };
      const onIntersectionUpdate = (entry) => {
        const { isIntersecting } = entry;
        if (this.isInView === isIntersecting)
          return;
        this.isInView = isIntersecting;
        if (once2 && !isIntersecting && this.hasEnteredView) {
          return;
        } else if (isIntersecting) {
          this.hasEnteredView = true;
        }
        if (this.node.animationState) {
          this.node.animationState.setActive("whileInView", isIntersecting);
        }
        const { onViewportEnter, onViewportLeave } = this.node.getProps();
        const callback = isIntersecting ? onViewportEnter : onViewportLeave;
        callback && callback(entry);
      };
      return observeIntersection(this.node.current, options, onIntersectionUpdate);
    }
    mount() {
      this.startObserver();
    }
    update() {
      if (typeof IntersectionObserver === "undefined")
        return;
      const { props, prevProps } = this.node;
      const hasOptionsChanged = ["amount", "margin", "root"].some(hasViewportOptionChanged(props, prevProps));
      if (hasOptionsChanged) {
        this.startObserver();
      }
    }
    unmount() {
    }
  };
  function hasViewportOptionChanged({ viewport = {} }, { viewport: prevViewport = {} } = {}) {
    return (name) => viewport[name] !== prevViewport[name];
  }

  // ../../node_modules/framer-motion/dist/es/motion/features/gestures.mjs
  var gestureAnimations = {
    inView: {
      Feature: InViewFeature
    },
    tap: {
      Feature: PressGesture
    },
    focus: {
      Feature: FocusGesture
    },
    hover: {
      Feature: HoverGesture
    }
  };

  // ../../node_modules/framer-motion/dist/es/motion/features/layout.mjs
  var layout = {
    layout: {
      ProjectionNode: HTMLProjectionNode,
      MeasureLayout
    }
  };

  // ../../node_modules/framer-motion/dist/es/render/components/motion/feature-bundle.mjs
  var featureBundle = {
    ...animations,
    ...gestureAnimations,
    ...drag,
    ...layout
  };

  // ../../node_modules/framer-motion/dist/es/render/components/motion/proxy.mjs
  var motion = /* @__PURE__ */ createMotionProxy(featureBundle, createDomVisualElement);

  // ../../node_modules/framer-motion/dist/es/value/use-scroll.mjs
  var import_react26 = __toESM(require_react2(), 1);

  // ../../node_modules/framer-motion/dist/es/render/dom/scroll/info.mjs
  var maxElapsed2 = 50;
  var createAxisInfo = () => ({
    current: 0,
    offset: [],
    progress: 0,
    scrollLength: 0,
    targetOffset: 0,
    targetLength: 0,
    containerLength: 0,
    velocity: 0
  });
  var createScrollInfo = () => ({
    time: 0,
    x: createAxisInfo(),
    y: createAxisInfo()
  });
  var keys = {
    x: {
      length: "Width",
      position: "Left"
    },
    y: {
      length: "Height",
      position: "Top"
    }
  };
  function updateAxisInfo(element, axisName, info, time2) {
    const axis = info[axisName];
    const { length, position } = keys[axisName];
    const prev = axis.current;
    const prevTime = info.time;
    axis.current = element[`scroll${position}`];
    axis.scrollLength = element[`scroll${length}`] - element[`client${length}`];
    axis.offset.length = 0;
    axis.offset[0] = 0;
    axis.offset[1] = axis.scrollLength;
    axis.progress = progress(0, axis.scrollLength, axis.current);
    const elapsed = time2 - prevTime;
    axis.velocity = elapsed > maxElapsed2 ? 0 : velocityPerSecond(axis.current - prev, elapsed);
  }
  function updateScrollInfo(element, info, time2) {
    updateAxisInfo(element, "x", info, time2);
    updateAxisInfo(element, "y", info, time2);
    info.time = time2;
  }

  // ../../node_modules/framer-motion/dist/es/render/dom/scroll/offsets/inset.mjs
  function calcInset(element, container) {
    const inset = { x: 0, y: 0 };
    let current = element;
    while (current && current !== container) {
      if (isHTMLElement(current)) {
        inset.x += current.offsetLeft;
        inset.y += current.offsetTop;
        current = current.offsetParent;
      } else if (current.tagName === "svg") {
        const svgBoundingBox = current.getBoundingClientRect();
        current = current.parentElement;
        const parentBoundingBox = current.getBoundingClientRect();
        inset.x += svgBoundingBox.left - parentBoundingBox.left;
        inset.y += svgBoundingBox.top - parentBoundingBox.top;
      } else if (current instanceof SVGGraphicsElement) {
        const { x: x2, y: y2 } = current.getBBox();
        inset.x += x2;
        inset.y += y2;
        let svg = null;
        let parent = current.parentNode;
        while (!svg) {
          if (parent.tagName === "svg") {
            svg = parent;
          }
          parent = current.parentNode;
        }
        current = svg;
      } else {
        break;
      }
    }
    return inset;
  }

  // ../../node_modules/framer-motion/dist/es/render/dom/scroll/offsets/edge.mjs
  var namedEdges = {
    start: 0,
    center: 0.5,
    end: 1
  };
  function resolveEdge(edge, length, inset = 0) {
    let delta = 0;
    if (edge in namedEdges) {
      edge = namedEdges[edge];
    }
    if (typeof edge === "string") {
      const asNumber3 = parseFloat(edge);
      if (edge.endsWith("px")) {
        delta = asNumber3;
      } else if (edge.endsWith("%")) {
        edge = asNumber3 / 100;
      } else if (edge.endsWith("vw")) {
        delta = asNumber3 / 100 * document.documentElement.clientWidth;
      } else if (edge.endsWith("vh")) {
        delta = asNumber3 / 100 * document.documentElement.clientHeight;
      } else {
        edge = asNumber3;
      }
    }
    if (typeof edge === "number") {
      delta = length * edge;
    }
    return inset + delta;
  }

  // ../../node_modules/framer-motion/dist/es/render/dom/scroll/offsets/offset.mjs
  var defaultOffset2 = [0, 0];
  function resolveOffset(offset4, containerLength, targetLength, targetInset) {
    let offsetDefinition = Array.isArray(offset4) ? offset4 : defaultOffset2;
    let targetPoint = 0;
    let containerPoint = 0;
    if (typeof offset4 === "number") {
      offsetDefinition = [offset4, offset4];
    } else if (typeof offset4 === "string") {
      offset4 = offset4.trim();
      if (offset4.includes(" ")) {
        offsetDefinition = offset4.split(" ");
      } else {
        offsetDefinition = [offset4, namedEdges[offset4] ? offset4 : `0`];
      }
    }
    targetPoint = resolveEdge(offsetDefinition[0], targetLength, targetInset);
    containerPoint = resolveEdge(offsetDefinition[1], containerLength);
    return targetPoint - containerPoint;
  }

  // ../../node_modules/framer-motion/dist/es/render/dom/scroll/offsets/presets.mjs
  var ScrollOffset = {
    Enter: [
      [0, 1],
      [1, 1]
    ],
    Exit: [
      [0, 0],
      [1, 0]
    ],
    Any: [
      [1, 0],
      [0, 1]
    ],
    All: [
      [0, 0],
      [1, 1]
    ]
  };

  // ../../node_modules/framer-motion/dist/es/render/dom/scroll/offsets/index.mjs
  var point = { x: 0, y: 0 };
  function getTargetSize(target) {
    return "getBBox" in target && target.tagName !== "svg" ? target.getBBox() : { width: target.clientWidth, height: target.clientHeight };
  }
  function resolveOffsets(container, info, options) {
    const { offset: offsetDefinition = ScrollOffset.All } = options;
    const { target = container, axis = "y" } = options;
    const lengthLabel = axis === "y" ? "height" : "width";
    const inset = target !== container ? calcInset(target, container) : point;
    const targetSize = target === container ? { width: container.scrollWidth, height: container.scrollHeight } : getTargetSize(target);
    const containerSize = {
      width: container.clientWidth,
      height: container.clientHeight
    };
    info[axis].offset.length = 0;
    let hasChanged = !info[axis].interpolate;
    const numOffsets = offsetDefinition.length;
    for (let i3 = 0; i3 < numOffsets; i3++) {
      const offset4 = resolveOffset(offsetDefinition[i3], containerSize[lengthLabel], targetSize[lengthLabel], inset[axis]);
      if (!hasChanged && offset4 !== info[axis].interpolatorOffsets[i3]) {
        hasChanged = true;
      }
      info[axis].offset[i3] = offset4;
    }
    if (hasChanged) {
      info[axis].interpolate = interpolate(info[axis].offset, defaultOffset(offsetDefinition), { clamp: false });
      info[axis].interpolatorOffsets = [...info[axis].offset];
    }
    info[axis].progress = clamp(0, 1, info[axis].interpolate(info[axis].current));
  }

  // ../../node_modules/framer-motion/dist/es/render/dom/scroll/on-scroll-handler.mjs
  function measure(container, target = container, info) {
    info.x.targetOffset = 0;
    info.y.targetOffset = 0;
    if (target !== container) {
      let node = target;
      while (node && node !== container) {
        info.x.targetOffset += node.offsetLeft;
        info.y.targetOffset += node.offsetTop;
        node = node.offsetParent;
      }
    }
    info.x.targetLength = target === container ? target.scrollWidth : target.clientWidth;
    info.y.targetLength = target === container ? target.scrollHeight : target.clientHeight;
    info.x.containerLength = container.clientWidth;
    info.y.containerLength = container.clientHeight;
    if (process.env.NODE_ENV !== "production") {
      if (container && target && target !== container) {
        warnOnce(getComputedStyle(container).position !== "static", "Please ensure that the container has a non-static position, like 'relative', 'fixed', or 'absolute' to ensure scroll offset is calculated correctly.");
      }
    }
  }
  function createOnScrollHandler(element, onScroll2, info, options = {}) {
    return {
      measure: (time2) => {
        measure(element, options.target, info);
        updateScrollInfo(element, info, time2);
        if (options.offset || options.target) {
          resolveOffsets(element, info, options);
        }
      },
      notify: () => onScroll2(info)
    };
  }

  // ../../node_modules/framer-motion/dist/es/render/dom/scroll/track.mjs
  var scrollListeners = /* @__PURE__ */ new WeakMap();
  var resizeListeners = /* @__PURE__ */ new WeakMap();
  var onScrollHandlers = /* @__PURE__ */ new WeakMap();
  var getEventTarget = (element) => element === document.scrollingElement ? window : element;
  function scrollInfo(onScroll2, { container = document.scrollingElement, ...options } = {}) {
    if (!container)
      return noop;
    let containerHandlers = onScrollHandlers.get(container);
    if (!containerHandlers) {
      containerHandlers = /* @__PURE__ */ new Set();
      onScrollHandlers.set(container, containerHandlers);
    }
    const info = createScrollInfo();
    const containerHandler = createOnScrollHandler(container, onScroll2, info, options);
    containerHandlers.add(containerHandler);
    if (!scrollListeners.has(container)) {
      const measureAll = () => {
        for (const handler of containerHandlers) {
          handler.measure(frameData.timestamp);
        }
        frame.preUpdate(notifyAll2);
      };
      const notifyAll2 = () => {
        for (const handler of containerHandlers) {
          handler.notify();
        }
      };
      const listener2 = () => frame.read(measureAll);
      scrollListeners.set(container, listener2);
      const target = getEventTarget(container);
      window.addEventListener("resize", listener2, { passive: true });
      if (container !== document.documentElement) {
        resizeListeners.set(container, resize(container, listener2));
      }
      target.addEventListener("scroll", listener2, { passive: true });
      listener2();
    }
    const listener = scrollListeners.get(container);
    frame.read(listener, false, true);
    return () => {
      cancelFrame(listener);
      const currentHandlers = onScrollHandlers.get(container);
      if (!currentHandlers)
        return;
      currentHandlers.delete(containerHandler);
      if (currentHandlers.size)
        return;
      const scrollListener = scrollListeners.get(container);
      scrollListeners.delete(container);
      if (scrollListener) {
        getEventTarget(container).removeEventListener("scroll", scrollListener);
        resizeListeners.get(container)?.();
        window.removeEventListener("resize", scrollListener);
      }
    };
  }

  // ../../node_modules/framer-motion/dist/es/render/dom/scroll/utils/get-timeline.mjs
  var timelineCache = /* @__PURE__ */ new Map();
  function scrollTimelineFallback(options) {
    const currentTime = { value: 0 };
    const cancel = scrollInfo((info) => {
      currentTime.value = info[options.axis].progress * 100;
    }, options);
    return { currentTime, cancel };
  }
  function getTimeline({ source, container, ...options }) {
    const { axis } = options;
    if (source)
      container = source;
    const containerCache = timelineCache.get(container) ?? /* @__PURE__ */ new Map();
    timelineCache.set(container, containerCache);
    const targetKey = options.target ?? "self";
    const targetCache = containerCache.get(targetKey) ?? {};
    const axisKey = axis + (options.offset ?? []).join(",");
    if (!targetCache[axisKey]) {
      targetCache[axisKey] = !options.target && supportsScrollTimeline() ? new ScrollTimeline({ source: container, axis }) : scrollTimelineFallback({ container, ...options });
    }
    return targetCache[axisKey];
  }

  // ../../node_modules/framer-motion/dist/es/render/dom/scroll/attach-animation.mjs
  function attachToAnimation(animation, options) {
    const timeline = getTimeline(options);
    return animation.attachTimeline({
      timeline: options.target ? void 0 : timeline,
      observe: (valueAnimation) => {
        valueAnimation.pause();
        return observeTimeline((progress2) => {
          valueAnimation.time = valueAnimation.iterationDuration * progress2;
        }, timeline);
      }
    });
  }

  // ../../node_modules/framer-motion/dist/es/render/dom/scroll/attach-function.mjs
  function isOnScrollWithInfo(onScroll2) {
    return onScroll2.length === 2;
  }
  function attachToFunction(onScroll2, options) {
    if (isOnScrollWithInfo(onScroll2)) {
      return scrollInfo((info) => {
        onScroll2(info[options.axis].progress, info);
      }, options);
    } else {
      return observeTimeline(onScroll2, getTimeline(options));
    }
  }

  // ../../node_modules/framer-motion/dist/es/render/dom/scroll/index.mjs
  function scroll(onScroll2, { axis = "y", container = document.scrollingElement, ...options } = {}) {
    if (!container)
      return noop;
    const optionsWithDefaults = { axis, container, ...options };
    return typeof onScroll2 === "function" ? attachToFunction(onScroll2, optionsWithDefaults) : attachToAnimation(onScroll2, optionsWithDefaults);
  }

  // ../../node_modules/framer-motion/dist/es/value/use-scroll.mjs
  var createScrollMotionValues = () => ({
    scrollX: motionValue(0),
    scrollY: motionValue(0),
    scrollXProgress: motionValue(0),
    scrollYProgress: motionValue(0)
  });
  var isRefPending = (ref) => {
    if (!ref)
      return false;
    return !ref.current;
  };
  function useScroll({ container, target, ...options } = {}) {
    const values = useConstant(createScrollMotionValues);
    const scrollAnimation = (0, import_react26.useRef)(null);
    const needsStart = (0, import_react26.useRef)(false);
    const start2 = (0, import_react26.useCallback)(() => {
      scrollAnimation.current = scroll((_progress, { x: x2, y: y2 }) => {
        values.scrollX.set(x2.current);
        values.scrollXProgress.set(x2.progress);
        values.scrollY.set(y2.current);
        values.scrollYProgress.set(y2.progress);
      }, {
        ...options,
        container: container?.current || void 0,
        target: target?.current || void 0
      });
      return () => {
        scrollAnimation.current?.();
      };
    }, [container, target, JSON.stringify(options.offset)]);
    useIsomorphicLayoutEffect(() => {
      needsStart.current = false;
      if (isRefPending(container) || isRefPending(target)) {
        needsStart.current = true;
        return;
      } else {
        return start2();
      }
    }, [start2]);
    (0, import_react26.useEffect)(() => {
      if (needsStart.current) {
        invariant(!isRefPending(container), "Container ref is defined but not hydrated", "use-scroll-ref");
        invariant(!isRefPending(target), "Target ref is defined but not hydrated", "use-scroll-ref");
        return start2();
      } else {
        return;
      }
    }, [start2]);
    return values;
  }

  // ../../node_modules/framer-motion/dist/es/value/use-motion-value.mjs
  var import_react27 = __toESM(require_react2(), 1);
  function useMotionValue(initial) {
    const value = useConstant(() => motionValue(initial));
    const { isStatic } = (0, import_react27.useContext)(MotionConfigContext);
    if (isStatic) {
      const [, setLatest] = (0, import_react27.useState)(initial);
      (0, import_react27.useEffect)(() => value.on("change", setLatest), []);
    }
    return value;
  }

  // ../../node_modules/framer-motion/dist/es/value/use-combine-values.mjs
  function useCombineMotionValues(values, combineValues) {
    const value = useMotionValue(combineValues());
    const updateValue = () => value.set(combineValues());
    updateValue();
    useIsomorphicLayoutEffect(() => {
      const scheduleUpdate = () => frame.preRender(updateValue, false, true);
      const subscriptions = values.map((v2) => v2.on("change", scheduleUpdate));
      return () => {
        subscriptions.forEach((unsubscribe) => unsubscribe());
        cancelFrame(updateValue);
      };
    });
    return value;
  }

  // ../../node_modules/framer-motion/dist/es/value/use-spring.mjs
  var import_react28 = __toESM(require_react2(), 1);

  // ../../node_modules/framer-motion/dist/es/value/use-computed.mjs
  function useComputed(compute) {
    collectMotionValues.current = [];
    compute();
    const value = useCombineMotionValues(collectMotionValues.current, compute);
    collectMotionValues.current = void 0;
    return value;
  }

  // ../../node_modules/framer-motion/dist/es/value/use-transform.mjs
  function useTransform(input, inputRangeOrTransformer, outputRange, options) {
    if (typeof input === "function") {
      return useComputed(input);
    }
    const transformer = typeof inputRangeOrTransformer === "function" ? inputRangeOrTransformer : transform(inputRangeOrTransformer, outputRange, options);
    return Array.isArray(input) ? useListTransform(input, transformer) : useListTransform([input], ([latest]) => transformer(latest));
  }
  function useListTransform(values, transformer) {
    const latest = useConstant(() => []);
    return useCombineMotionValues(values, () => {
      latest.length = 0;
      const numValues = values.length;
      for (let i3 = 0; i3 < numValues; i3++) {
        latest[i3] = values[i3].get();
      }
      return transformer(latest);
    });
  }

  // ../../node_modules/framer-motion/dist/es/value/use-spring.mjs
  function useSpring(source, options = {}) {
    const { isStatic } = (0, import_react28.useContext)(MotionConfigContext);
    const getFromSource = () => isMotionValue(source) ? source.get() : source;
    if (isStatic) {
      return useTransform(getFromSource);
    }
    const value = useMotionValue(getFromSource());
    (0, import_react28.useInsertionEffect)(() => {
      return attachSpring(value, source, options);
    }, [value, JSON.stringify(options)]);
    return value;
  }

  // ../../node_modules/framer-motion/dist/es/utils/use-in-view.mjs
  var import_react29 = __toESM(require_react2(), 1);

  // ../../node_modules/framer-motion/dist/es/render/dom/viewport/index.mjs
  var thresholds = {
    some: 0,
    all: 1
  };
  function inView(elementOrSelector, onStart, { root, margin: rootMargin, amount = "some" } = {}) {
    const elements = resolveElements(elementOrSelector);
    const activeIntersections = /* @__PURE__ */ new WeakMap();
    const onIntersectionChange = (entries) => {
      entries.forEach((entry) => {
        const onEnd = activeIntersections.get(entry.target);
        if (entry.isIntersecting === Boolean(onEnd))
          return;
        if (entry.isIntersecting) {
          const newOnEnd = onStart(entry.target, entry);
          if (typeof newOnEnd === "function") {
            activeIntersections.set(entry.target, newOnEnd);
          } else {
            observer2.unobserve(entry.target);
          }
        } else if (typeof onEnd === "function") {
          onEnd(entry);
          activeIntersections.delete(entry.target);
        }
      });
    };
    const observer2 = new IntersectionObserver(onIntersectionChange, {
      root,
      rootMargin,
      threshold: typeof amount === "number" ? amount : thresholds[amount]
    });
    elements.forEach((element) => observer2.observe(element));
    return () => observer2.disconnect();
  }

  // ../../node_modules/framer-motion/dist/es/utils/use-in-view.mjs
  function useInView(ref, { root, margin, amount, once: once2 = false, initial = false } = {}) {
    const [isInView, setInView] = (0, import_react29.useState)(initial);
    (0, import_react29.useEffect)(() => {
      if (!ref.current || once2 && isInView)
        return;
      const onEnter = () => {
        setInView(true);
        return once2 ? void 0 : () => setInView(false);
      };
      const options = {
        root: root && root.current || void 0,
        margin,
        amount
      };
      return inView(ref.current, onEnter, options);
    }, [root, ref, margin, once2, amount]);
    return isInView;
  }

  // src/components/AnimatedBeam.tsx
  var import_react30 = __toESM(require_react());
  var import_jsx_runtime8 = __toESM(require_jsx_runtime());
  var AnimatedBeam = ({
    className,
    containerRef,
    fromRef,
    toRef,
    curvature = 0,
    reverse = false,
    duration = Math.random() * 3 + 4,
    delay: delay2 = 0,
    pathColor = "gray",
    pathWidth = 2,
    pathOpacity = 0.2,
    gradientStartColor = "#ffaa40",
    gradientStopColor = "#9c40ff",
    startXOffset = 0,
    startYOffset = 0,
    endXOffset = 0,
    endYOffset = 0
  }) => {
    const id3 = (0, import_react30.useId)();
    const [pathD, setPathD] = (0, import_react30.useState)("");
    const [svgDimensions, setSvgDimensions] = (0, import_react30.useState)({ width: 0, height: 0 });
    (0, import_react30.useEffect)(() => {
      const updatePath = () => {
        if (containerRef.current && fromRef.current && toRef.current) {
          const containerRect = containerRef.current.getBoundingClientRect();
          const rectA = fromRef.current.getBoundingClientRect();
          const rectB = toRef.current.getBoundingClientRect();
          const svgWidth = containerRect.width;
          const svgHeight = containerRect.height;
          setSvgDimensions({ width: svgWidth, height: svgHeight });
          const startX = rectA.left - containerRect.left + rectA.width / 2 + startXOffset;
          const startY = rectA.top - containerRect.top + rectA.height / 2 + startYOffset;
          const endX = rectB.left - containerRect.left + rectB.width / 2 + endXOffset;
          const endY = rectB.top - containerRect.top + rectB.height / 2 + endYOffset;
          const controlY = startY - curvature;
          const d = `M ${startX},${startY} Q ${(startX + endX) / 2},${controlY} ${endX},${endY}`;
          setPathD(d);
        }
      };
      updatePath();
      const resizeObserver = new ResizeObserver(updatePath);
      if (containerRef.current) {
        resizeObserver.observe(containerRef.current);
      }
      return () => resizeObserver.disconnect();
    }, [
      containerRef,
      fromRef,
      toRef,
      curvature,
      startXOffset,
      startYOffset,
      endXOffset,
      endYOffset
    ]);
    return /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(
      "svg",
      {
        fill: "none",
        width: svgDimensions.width,
        height: svgDimensions.height,
        xmlns: "http://www.w3.org/2000/svg",
        className: cn(
          "pointer-events-none absolute left-0 top-0 transform-gpu stroke-2",
          className
        ),
        viewBox: `0 0 ${svgDimensions.width} ${svgDimensions.height}`,
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
            "path",
            {
              d: pathD,
              stroke: pathColor,
              strokeWidth: pathWidth,
              strokeOpacity: pathOpacity,
              strokeLinecap: "round"
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
            "path",
            {
              d: pathD,
              stroke: `url(#${id3})`,
              strokeWidth: pathWidth,
              strokeOpacity: "1",
              strokeLinecap: "round"
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("defs", { children: /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(
            motion.linearGradient,
            {
              className: "transform-gpu",
              id: id3,
              gradientUnits: "userSpaceOnUse",
              initial: {
                x1: "0%",
                x2: "0%",
                y1: "0%",
                y2: "0%"
              },
              animate: {
                x1: reverse ? ["90%", "-10%"] : ["0%", "100%"],
                x2: reverse ? ["90%", "-10%"] : ["0%", "100%"],
                y1: ["0%", "0%"],
                y2: ["0%", "0%"]
              },
              transition: {
                delay: delay2,
                duration,
                ease: [0.16, 1, 0.3, 1],
                repeat: Infinity,
                repeatDelay: 0.5
              },
              children: [
                /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("stop", { stopColor: gradientStartColor, stopOpacity: "0" }),
                /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("stop", { stopColor: gradientStartColor }),
                /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("stop", { stopColor: gradientStopColor, offset: "32.5%" }),
                /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("stop", { stopColor: gradientStopColor, stopOpacity: "0" })
              ]
            }
          ) })
        ]
      }
    );
  };

  // src/components/AnimatedGradientText.tsx
  var import_jsx_runtime9 = __toESM(require_jsx_runtime());
  function AnimatedGradientText({
    children,
    className,
    ...props
  }) {
    return /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)(
      "div",
      {
        className: cn(
          "group relative mx-auto flex max-w-fit flex-row items-center justify-center rounded-2xl bg-white/40 px-4 py-1.5 text-sm font-medium shadow-[inset_0_-8px_10px_#8fdfff1f] backdrop-blur-sm transition-shadow duration-500 ease-out hover:shadow-[inset_0_-5px_10px_#8fdfff3f] dark:bg-black/40",
          className
        ),
        ...props,
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
            "div",
            {
              className: cn(
                "absolute inset-0 block h-full w-full animate-shimmer bg-[linear-gradient(110deg,transparent,45%,var(--color-shimmer,rgba(167,139,250,0.5)),55%,transparent)] bg-[length:200%_100%]"
              )
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("span", { className: "relative z-10", children })
        ]
      }
    );
  }

  // src/components/AuroraBackground.tsx
  var import_jsx_runtime10 = __toESM(require_jsx_runtime());
  var AuroraBackground = ({
    className,
    children,
    showRadialGradient = true,
    ...props
  }) => {
    return /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("main", { children: /* @__PURE__ */ (0, import_jsx_runtime10.jsxs)(
      "div",
      {
        className: cn(
          "relative flex flex-col h-[100vh] items-center justify-center bg-zinc-50 dark:bg-zinc-900 transition-bg",
          className
        ),
        ...props,
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("div", { className: "absolute inset-0 overflow-hidden", children: /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(
            "div",
            {
              className: cn(
                `
            [--white-gradient:repeating-linear-gradient(100deg,var(--white)_0%,var(--white)_7%,var(--transparent)_10%,var(--transparent)_12%,var(--white)_16%)]
            [--dark-gradient:repeating-linear-gradient(100deg,var(--black)_0%,var(--black)_7%,var(--transparent)_10%,var(--transparent)_12%,var(--black)_16%)]
            [--aurora:repeating-linear-gradient(100deg,var(--blue-500)_10%,var(--indigo-300)_15%,var(--blue-300)_20%,var(--violet-200)_25%,var(--blue-400)_30%)]
            [background-image:var(--white-gradient),var(--aurora)]
            dark:[background-image:var(--dark-gradient),var(--aurora)]
            [background-size:300%,_200%]
            [background-position:50%_50%,50%_50%]
            filter blur-[10px] invert dark:invert-0
            after:content-[""] after:absolute after:inset-0 after:[background-image:var(--white-gradient),var(--aurora)] 
            after:dark:[background-image:var(--dark-gradient),var(--aurora)]
            after:[background-size:200%,_100%] 
            after:animate-aurora after:[background-attachment:fixed] after:mix-blend-difference
            pointer-events-none
            absolute -inset-[10px] opacity-50 will-change-transform`,
                showRadialGradient && `[mask-image:radial-gradient(ellipse_at_100%_0%,black_10%,transparent_70%)]`
              )
            }
          ) }),
          children
        ]
      }
    ) });
  };

  // src/components/Avatar.tsx
  var React12 = __toESM(require_react());

  // ../../node_modules/@radix-ui/react-avatar/dist/index.mjs
  var React11 = __toESM(require_react2(), 1);

  // ../../node_modules/@radix-ui/react-avatar/node_modules/@radix-ui/react-context/dist/index.mjs
  var React5 = __toESM(require_react2(), 1);
  var import_jsx_runtime11 = __toESM(require_jsx_runtime2(), 1);
  function createContextScope(scopeName, createContextScopeDeps = []) {
    let defaultContexts = [];
    function createContext32(rootComponentName, defaultContext) {
      const BaseContext = React5.createContext(defaultContext);
      BaseContext.displayName = rootComponentName + "Context";
      const index2 = defaultContexts.length;
      defaultContexts = [...defaultContexts, defaultContext];
      const Provider2 = (props) => {
        const { scope, children, ...context } = props;
        const Context = scope?.[scopeName]?.[index2] || BaseContext;
        const value = React5.useMemo(() => context, Object.values(context));
        return /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(Context.Provider, { value, children });
      };
      Provider2.displayName = rootComponentName + "Provider";
      function useContext25(consumerName, scope) {
        const Context = scope?.[scopeName]?.[index2] || BaseContext;
        const context = React5.useContext(Context);
        if (context) return context;
        if (defaultContext !== void 0) return defaultContext;
        throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
      }
      return [Provider2, useContext25];
    }
    const createScope = () => {
      const scopeContexts = defaultContexts.map((defaultContext) => {
        return React5.createContext(defaultContext);
      });
      return function useScope(scope) {
        const contexts = scope?.[scopeName] || scopeContexts;
        return React5.useMemo(
          () => ({ [`__scope${scopeName}`]: { ...scope, [scopeName]: contexts } }),
          [scope, contexts]
        );
      };
    };
    createScope.scopeName = scopeName;
    return [createContext32, composeContextScopes(createScope, ...createContextScopeDeps)];
  }
  function composeContextScopes(...scopes) {
    const baseScope = scopes[0];
    if (scopes.length === 1) return baseScope;
    const createScope = () => {
      const scopeHooks = scopes.map((createScope2) => ({
        useScope: createScope2(),
        scopeName: createScope2.scopeName
      }));
      return function useComposedScopes(overrideScopes) {
        const nextScopes = scopeHooks.reduce((nextScopes2, { useScope, scopeName }) => {
          const scopeProps = useScope(overrideScopes);
          const currentScope = scopeProps[`__scope${scopeName}`];
          return { ...nextScopes2, ...currentScope };
        }, {});
        return React5.useMemo(() => ({ [`__scope${baseScope.scopeName}`]: nextScopes }), [nextScopes]);
      };
    };
    createScope.scopeName = baseScope.scopeName;
    return createScope;
  }

  // ../../node_modules/@radix-ui/react-use-callback-ref/dist/index.mjs
  var React6 = __toESM(require_react2(), 1);
  function useCallbackRef(callback) {
    const callbackRef = React6.useRef(callback);
    React6.useEffect(() => {
      callbackRef.current = callback;
    });
    return React6.useMemo(() => (...args) => callbackRef.current?.(...args), []);
  }

  // ../../node_modules/@radix-ui/react-use-layout-effect/dist/index.mjs
  var React7 = __toESM(require_react2(), 1);
  var useLayoutEffect22 = globalThis?.document ? React7.useLayoutEffect : () => {
  };

  // ../../node_modules/@radix-ui/react-avatar/node_modules/@radix-ui/react-primitive/dist/index.mjs
  var React10 = __toESM(require_react2(), 1);
  var ReactDOM = __toESM(require_react_dom(), 1);

  // ../../node_modules/@radix-ui/react-avatar/node_modules/@radix-ui/react-slot/dist/index.mjs
  var React9 = __toESM(require_react2(), 1);

  // ../../node_modules/@radix-ui/react-compose-refs/dist/index.mjs
  var React8 = __toESM(require_react2(), 1);
  function setRef2(ref, value) {
    if (typeof ref === "function") {
      return ref(value);
    } else if (ref !== null && ref !== void 0) {
      ref.current = value;
    }
  }
  function composeRefs2(...refs) {
    return (node) => {
      let hasCleanup = false;
      const cleanups = refs.map((ref) => {
        const cleanup = setRef2(ref, node);
        if (!hasCleanup && typeof cleanup == "function") {
          hasCleanup = true;
        }
        return cleanup;
      });
      if (hasCleanup) {
        return () => {
          for (let i3 = 0; i3 < cleanups.length; i3++) {
            const cleanup = cleanups[i3];
            if (typeof cleanup == "function") {
              cleanup();
            } else {
              setRef2(refs[i3], null);
            }
          }
        };
      }
    };
  }
  function useComposedRefs2(...refs) {
    return React8.useCallback(composeRefs2(...refs), refs);
  }

  // ../../node_modules/@radix-ui/react-avatar/node_modules/@radix-ui/react-slot/dist/index.mjs
  var import_jsx_runtime12 = __toESM(require_jsx_runtime2(), 1);
  var REACT_LAZY_TYPE = /* @__PURE__ */ Symbol.for("react.lazy");
  var use = React9[" use ".trim().toString()];
  function isPromiseLike(value) {
    return typeof value === "object" && value !== null && "then" in value;
  }
  function isLazyComponent(element) {
    return element != null && typeof element === "object" && "$$typeof" in element && element.$$typeof === REACT_LAZY_TYPE && "_payload" in element && isPromiseLike(element._payload);
  }
  // @__NO_SIDE_EFFECTS__
  function createSlot(ownerName) {
    const SlotClone = /* @__PURE__ */ createSlotClone(ownerName);
    const Slot2 = React9.forwardRef((props, forwardedRef) => {
      let { children, ...slotProps } = props;
      if (isLazyComponent(children) && typeof use === "function") {
        children = use(children._payload);
      }
      const childrenArray = React9.Children.toArray(children);
      const slottable = childrenArray.find(isSlottable);
      if (slottable) {
        const newElement = slottable.props.children;
        const newChildren = childrenArray.map((child) => {
          if (child === slottable) {
            if (React9.Children.count(newElement) > 1) return React9.Children.only(null);
            return React9.isValidElement(newElement) ? newElement.props.children : null;
          } else {
            return child;
          }
        });
        return /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children: React9.isValidElement(newElement) ? React9.cloneElement(newElement, void 0, newChildren) : null });
      }
      return /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children });
    });
    Slot2.displayName = `${ownerName}.Slot`;
    return Slot2;
  }
  // @__NO_SIDE_EFFECTS__
  function createSlotClone(ownerName) {
    const SlotClone = React9.forwardRef((props, forwardedRef) => {
      let { children, ...slotProps } = props;
      if (isLazyComponent(children) && typeof use === "function") {
        children = use(children._payload);
      }
      if (React9.isValidElement(children)) {
        const childrenRef = getElementRef(children);
        const props2 = mergeProps(slotProps, children.props);
        if (children.type !== React9.Fragment) {
          props2.ref = forwardedRef ? composeRefs2(forwardedRef, childrenRef) : childrenRef;
        }
        return React9.cloneElement(children, props2);
      }
      return React9.Children.count(children) > 1 ? React9.Children.only(null) : null;
    });
    SlotClone.displayName = `${ownerName}.SlotClone`;
    return SlotClone;
  }
  var SLOTTABLE_IDENTIFIER = /* @__PURE__ */ Symbol("radix.slottable");
  function isSlottable(child) {
    return React9.isValidElement(child) && typeof child.type === "function" && "__radixId" in child.type && child.type.__radixId === SLOTTABLE_IDENTIFIER;
  }
  function mergeProps(slotProps, childProps) {
    const overrideProps = { ...childProps };
    for (const propName in childProps) {
      const slotPropValue = slotProps[propName];
      const childPropValue = childProps[propName];
      const isHandler = /^on[A-Z]/.test(propName);
      if (isHandler) {
        if (slotPropValue && childPropValue) {
          overrideProps[propName] = (...args) => {
            const result = childPropValue(...args);
            slotPropValue(...args);
            return result;
          };
        } else if (slotPropValue) {
          overrideProps[propName] = slotPropValue;
        }
      } else if (propName === "style") {
        overrideProps[propName] = { ...slotPropValue, ...childPropValue };
      } else if (propName === "className") {
        overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
      }
    }
    return { ...slotProps, ...overrideProps };
  }
  function getElementRef(element) {
    let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get;
    let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
    if (mayWarn) {
      return element.ref;
    }
    getter = Object.getOwnPropertyDescriptor(element, "ref")?.get;
    mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
    if (mayWarn) {
      return element.props.ref;
    }
    return element.props.ref || element.ref;
  }

  // ../../node_modules/@radix-ui/react-avatar/node_modules/@radix-ui/react-primitive/dist/index.mjs
  var import_jsx_runtime13 = __toESM(require_jsx_runtime2(), 1);
  var NODES = [
    "a",
    "button",
    "div",
    "form",
    "h2",
    "h3",
    "img",
    "input",
    "label",
    "li",
    "nav",
    "ol",
    "p",
    "select",
    "span",
    "svg",
    "ul"
  ];
  var Primitive = NODES.reduce((primitive, node) => {
    const Slot2 = createSlot(`Primitive.${node}`);
    const Node2 = React10.forwardRef((props, forwardedRef) => {
      const { asChild, ...primitiveProps } = props;
      const Comp = asChild ? Slot2 : node;
      if (typeof window !== "undefined") {
        window[/* @__PURE__ */ Symbol.for("radix-ui")] = true;
      }
      return /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(Comp, { ...primitiveProps, ref: forwardedRef });
    });
    Node2.displayName = `Primitive.${node}`;
    return { ...primitive, [node]: Node2 };
  }, {});

  // ../../node_modules/@radix-ui/react-use-is-hydrated/dist/index.mjs
  var import_shim = __toESM(require_shim(), 1);
  function useIsHydrated() {
    return (0, import_shim.useSyncExternalStore)(
      subscribe,
      () => true,
      () => false
    );
  }
  function subscribe() {
    return () => {
    };
  }

  // ../../node_modules/@radix-ui/react-avatar/dist/index.mjs
  var import_jsx_runtime14 = __toESM(require_jsx_runtime2(), 1);
  var AVATAR_NAME = "Avatar";
  var [createAvatarContext, createAvatarScope] = createContextScope(AVATAR_NAME);
  var [AvatarProvider, useAvatarContext] = createAvatarContext(AVATAR_NAME);
  var Avatar = React11.forwardRef(
    (props, forwardedRef) => {
      const { __scopeAvatar, ...avatarProps } = props;
      const [imageLoadingStatus, setImageLoadingStatus] = React11.useState("idle");
      return /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(
        AvatarProvider,
        {
          scope: __scopeAvatar,
          imageLoadingStatus,
          onImageLoadingStatusChange: setImageLoadingStatus,
          children: /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(Primitive.span, { ...avatarProps, ref: forwardedRef })
        }
      );
    }
  );
  Avatar.displayName = AVATAR_NAME;
  var IMAGE_NAME = "AvatarImage";
  var AvatarImage = React11.forwardRef(
    (props, forwardedRef) => {
      const { __scopeAvatar, src, onLoadingStatusChange = () => {
      }, ...imageProps } = props;
      const context = useAvatarContext(IMAGE_NAME, __scopeAvatar);
      const imageLoadingStatus = useImageLoadingStatus(src, imageProps);
      const handleLoadingStatusChange = useCallbackRef((status) => {
        onLoadingStatusChange(status);
        context.onImageLoadingStatusChange(status);
      });
      useLayoutEffect22(() => {
        if (imageLoadingStatus !== "idle") {
          handleLoadingStatusChange(imageLoadingStatus);
        }
      }, [imageLoadingStatus, handleLoadingStatusChange]);
      return imageLoadingStatus === "loaded" ? /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(Primitive.img, { ...imageProps, ref: forwardedRef, src }) : null;
    }
  );
  AvatarImage.displayName = IMAGE_NAME;
  var FALLBACK_NAME = "AvatarFallback";
  var AvatarFallback = React11.forwardRef(
    (props, forwardedRef) => {
      const { __scopeAvatar, delayMs, ...fallbackProps } = props;
      const context = useAvatarContext(FALLBACK_NAME, __scopeAvatar);
      const [canRender, setCanRender] = React11.useState(delayMs === void 0);
      React11.useEffect(() => {
        if (delayMs !== void 0) {
          const timerId = window.setTimeout(() => setCanRender(true), delayMs);
          return () => window.clearTimeout(timerId);
        }
      }, [delayMs]);
      return canRender && context.imageLoadingStatus !== "loaded" ? /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(Primitive.span, { ...fallbackProps, ref: forwardedRef }) : null;
    }
  );
  AvatarFallback.displayName = FALLBACK_NAME;
  function resolveLoadingStatus(image, src) {
    if (!image) {
      return "idle";
    }
    if (!src) {
      return "error";
    }
    if (image.src !== src) {
      image.src = src;
    }
    return image.complete && image.naturalWidth > 0 ? "loaded" : "loading";
  }
  function useImageLoadingStatus(src, { referrerPolicy, crossOrigin }) {
    const isHydrated = useIsHydrated();
    const imageRef = React11.useRef(null);
    const image = (() => {
      if (!isHydrated) return null;
      if (!imageRef.current) {
        imageRef.current = new window.Image();
      }
      return imageRef.current;
    })();
    const [loadingStatus, setLoadingStatus] = React11.useState(
      () => resolveLoadingStatus(image, src)
    );
    useLayoutEffect22(() => {
      setLoadingStatus(resolveLoadingStatus(image, src));
    }, [image, src]);
    useLayoutEffect22(() => {
      const updateStatus = (status) => () => {
        setLoadingStatus(status);
      };
      if (!image) return;
      const handleLoad = updateStatus("loaded");
      const handleError = updateStatus("error");
      image.addEventListener("load", handleLoad);
      image.addEventListener("error", handleError);
      if (referrerPolicy) {
        image.referrerPolicy = referrerPolicy;
      }
      if (typeof crossOrigin === "string") {
        image.crossOrigin = crossOrigin;
      }
      return () => {
        image.removeEventListener("load", handleLoad);
        image.removeEventListener("error", handleError);
      };
    }, [image, crossOrigin, referrerPolicy]);
    return loadingStatus;
  }
  var Root = Avatar;
  var Image2 = AvatarImage;
  var Fallback = AvatarFallback;

  // src/components/Avatar.tsx
  var import_jsx_runtime15 = __toESM(require_jsx_runtime());
  var Avatar2 = React12.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(
    Root,
    {
      ref,
      className: cn(
        "relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full",
        className
      ),
      ...props
    }
  ));
  Avatar2.displayName = Root.displayName;
  var AvatarImage2 = React12.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(
    Image2,
    {
      ref,
      className: cn("aspect-square h-full w-full", className),
      ...props
    }
  ));
  AvatarImage2.displayName = Image2.displayName;
  var AvatarFallback2 = React12.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(
    Fallback,
    {
      ref,
      className: cn(
        "flex h-full w-full items-center justify-center rounded-full bg-muted",
        className
      ),
      ...props
    }
  ));
  AvatarFallback2.displayName = Fallback.displayName;

  // src/components/Badge.tsx
  var import_jsx_runtime16 = __toESM(require_jsx_runtime());
  function Badge({
    children,
    variant = "default",
    size: size4 = "md",
    className,
    design = "solid"
  }) {
    return /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(
      "span",
      {
        className: cn(
          "inline-flex items-center rounded-full font-medium transition-colors border border-transparent",
          // Solid Design (Default)
          design === "solid" && {
            "bg-muted text-foreground": variant === "default",
            "bg-success/20 text-success": variant === "success",
            "bg-warning/20 text-warning": variant === "warning",
            "bg-destructive/20 text-destructive": variant === "error",
            "bg-info/20 text-info": variant === "info"
          },
          // Soft Design
          design === "soft" && {
            "bg-muted/50 text-foreground/80": variant === "default",
            "bg-green-500/10 text-green-600 dark:text-green-400": variant === "success",
            "bg-yellow-500/10 text-yellow-600 dark:text-yellow-400": variant === "warning",
            "bg-red-500/10 text-red-600 dark:text-red-400": variant === "error",
            "bg-blue-500/10 text-blue-600 dark:text-blue-400": variant === "info"
          },
          // Outline Design
          design === "outline" && "bg-transparent border-current",
          design === "outline" && {
            "text-foreground border-border": variant === "default",
            "text-success border-success/50": variant === "success",
            "text-warning border-warning/50": variant === "warning",
            "text-destructive border-destructive/50": variant === "error",
            "text-info border-info/50": variant === "info"
          },
          {
            "px-2 py-0.5 text-xs": size4 === "sm",
            "px-2.5 py-1 text-sm": size4 === "md"
          },
          className
        ),
        children
      }
    );
  }

  // src/components/BentoGrid.tsx
  var import_jsx_runtime17 = __toESM(require_jsx_runtime());
  var BentoGrid = ({
    className,
    children
  }) => {
    return /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(
      "div",
      {
        className: cn(
          "grid md:auto-rows-[18rem] grid-cols-1 md:grid-cols-3 gap-4 max-w-7xl mx-auto ",
          className
        ),
        children
      }
    );
  };
  var BentoGridItem = ({
    className,
    title,
    description,
    header,
    icon
  }) => {
    return /* @__PURE__ */ (0, import_jsx_runtime17.jsxs)(
      "div",
      {
        className: cn(
          "row-span-1 rounded-xl group/bento hover:shadow-xl transition duration-200 shadow-input dark:shadow-none p-4 dark:bg-black dark:border-white/[0.2] bg-white border border-transparent justify-between flex flex-col space-y-4",
          className
        ),
        children: [
          header,
          /* @__PURE__ */ (0, import_jsx_runtime17.jsxs)("div", { className: "group-hover/bento:translate-x-2 transition duration-200", children: [
            icon,
            /* @__PURE__ */ (0, import_jsx_runtime17.jsx)("div", { className: "font-sans font-bold text-neutral-600 dark:text-neutral-200 mb-2 mt-2", children: title }),
            /* @__PURE__ */ (0, import_jsx_runtime17.jsx)("div", { className: "font-sans font-normal text-neutral-600 text-xs dark:text-neutral-300", children: description })
          ] })
        ]
      }
    );
  };

  // src/components/BlurText.tsx
  var import_react31 = __toESM(require_react());
  var import_jsx_runtime18 = __toESM(require_jsx_runtime());
  function BlurText({
    text,
    className,
    delay: delay2 = 0,
    wordDelay = 50
  }) {
    const [isVisible, setIsVisible] = (0, import_react31.useState)(false);
    const ref = (0, import_react31.useRef)(null);
    const words = text.split(" ");
    (0, import_react31.useEffect)(() => {
      const observer2 = new IntersectionObserver(
        ([entry]) => {
          if (entry.isIntersecting) {
            setTimeout(() => {
              setIsVisible(true);
            }, delay2);
            observer2.unobserve(entry.target);
          }
        },
        { threshold: 0.1 }
      );
      if (ref.current) {
        observer2.observe(ref.current);
      }
      return () => {
        if (ref.current) {
          observer2.unobserve(ref.current);
        }
      };
    }, [delay2]);
    return /* @__PURE__ */ (0, import_jsx_runtime18.jsx)("div", { ref, className: cn("inline-block", className), children: words.map((word, wordIndex) => /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
      "span",
      {
        className: "inline-block mr-[0.25em] overflow-hidden",
        style: { verticalAlign: "top" },
        children: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
          "span",
          {
            className: cn(
              "inline-block transition-all duration-700 ease-[cubic-bezier(0.2,0.8,0.2,1)]",
              isVisible ? "opacity-100 blur-0 translate-y-0" : "opacity-0 blur-[10px] translate-y-4"
            ),
            style: {
              transitionDelay: `${wordIndex * wordDelay}ms`
            },
            children: word
          }
        )
      },
      wordIndex
    )) });
  }

  // src/components/BorderBeam.tsx
  var import_jsx_runtime19 = __toESM(require_jsx_runtime());
  function BorderBeam({
    className,
    size: size4 = 200,
    duration = 15,
    anchor = 90,
    borderWidth = 1.5,
    colorFrom = "#ffaa40",
    colorTo = "#9c40ff",
    delay: delay2 = 0
  }) {
    return /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(
      "div",
      {
        style: {
          "--size": size4,
          "--duration": duration,
          "--anchor": anchor,
          "--border-width": borderWidth,
          "--color-from": colorFrom,
          "--color-to": colorTo,
          "--delay": delay2
        },
        className: cn(
          "pointer-events-none absolute inset-0 rounded-[inherit] [border:calc(var(--border-width)*1px)_solid_transparent]",
          // Mask styles
          "![mask-clip:padding-box,border-box] ![mask-composite:intersect] [mask:linear-gradient(transparent,transparent),linear-gradient(white,white)]",
          // Pseudo element for the beam
          "after:absolute after:aspect-square after:w-[calc(var(--size)*1px)] after:animate-border-beam after:[animation-delay:calc(var(--delay)*1s)] after:[background:linear-gradient(to_left,var(--color-from),var(--color-to),transparent)] after:[offset-anchor:calc(var(--anchor)*1%)_50%] after:[offset-path:rect(0_auto_auto_0_round_calc(var(--size)*1px))]",
          className
        )
      }
    );
  }

  // src/components/Breadcrumb.tsx
  var import_link = __toESM(require_link2());
  var import_jsx_runtime20 = __toESM(require_jsx_runtime());
  var Breadcrumb = ({
    items,
    separator = "chevron",
    className
  }) => {
    const separators = {
      chevron: /* @__PURE__ */ (0, import_jsx_runtime20.jsx)("svg", { className: "w-4 h-4", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", strokeWidth: 2, children: /* @__PURE__ */ (0, import_jsx_runtime20.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M9 5l7 7-7 7" }) }),
      slash: /* @__PURE__ */ (0, import_jsx_runtime20.jsx)("span", { className: "text-lg", children: "/" }),
      dot: /* @__PURE__ */ (0, import_jsx_runtime20.jsx)("span", { className: "text-xs", children: "\u2022" })
    };
    return /* @__PURE__ */ (0, import_jsx_runtime20.jsx)("nav", { "aria-label": "Breadcrumb", className: cn("flex items-center", className), children: /* @__PURE__ */ (0, import_jsx_runtime20.jsx)("ol", { className: "flex items-center gap-1.5", children: items.map((item, index2) => {
      const isLast = index2 === items.length - 1;
      return /* @__PURE__ */ (0, import_jsx_runtime20.jsxs)("li", { className: "flex items-center gap-1.5", children: [
        item.href && !isLast ? /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(
          import_link.default,
          {
            href: item.href,
            className: "text-sm text-muted-foreground hover:text-foreground transition-colors",
            children: item.label
          }
        ) : /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(
          "span",
          {
            className: cn(
              "text-sm",
              isLast ? "text-foreground font-medium" : "text-muted-foreground"
            ),
            children: item.label
          }
        ),
        !isLast && /* @__PURE__ */ (0, import_jsx_runtime20.jsx)("span", { className: "text-muted-foreground/50", children: separators[separator] })
      ] }, index2);
    }) }) });
  };

  // src/components/Button.tsx
  var import_react32 = __toESM(require_react());

  // ../../node_modules/clsx/dist/clsx.mjs
  function r2(e2) {
    var t3, f2, n2 = "";
    if ("string" == typeof e2 || "number" == typeof e2) n2 += e2;
    else if ("object" == typeof e2) if (Array.isArray(e2)) {
      var o = e2.length;
      for (t3 = 0; t3 < o; t3++) e2[t3] && (f2 = r2(e2[t3])) && (n2 && (n2 += " "), n2 += f2);
    } else for (f2 in e2) e2[f2] && (n2 && (n2 += " "), n2 += f2);
    return n2;
  }
  function clsx2() {
    for (var e2, t3, f2 = 0, n2 = "", o = arguments.length; f2 < o; f2++) (e2 = arguments[f2]) && (t3 = r2(e2)) && (n2 && (n2 += " "), n2 += t3);
    return n2;
  }

  // ../../node_modules/class-variance-authority/dist/index.mjs
  var falsyToString = (value) => typeof value === "boolean" ? `${value}` : value === 0 ? "0" : value;
  var cx = clsx2;
  var cva = (base, config2) => (props) => {
    var _config_compoundVariants;
    if ((config2 === null || config2 === void 0 ? void 0 : config2.variants) == null) return cx(base, props === null || props === void 0 ? void 0 : props.class, props === null || props === void 0 ? void 0 : props.className);
    const { variants, defaultVariants } = config2;
    const getVariantClassNames = Object.keys(variants).map((variant) => {
      const variantProp = props === null || props === void 0 ? void 0 : props[variant];
      const defaultVariantProp = defaultVariants === null || defaultVariants === void 0 ? void 0 : defaultVariants[variant];
      if (variantProp === null) return null;
      const variantKey = falsyToString(variantProp) || falsyToString(defaultVariantProp);
      return variants[variant][variantKey];
    });
    const propsWithoutUndefined = props && Object.entries(props).reduce((acc, param) => {
      let [key, value] = param;
      if (value === void 0) {
        return acc;
      }
      acc[key] = value;
      return acc;
    }, {});
    const getCompoundVariantClassNames = config2 === null || config2 === void 0 ? void 0 : (_config_compoundVariants = config2.compoundVariants) === null || _config_compoundVariants === void 0 ? void 0 : _config_compoundVariants.reduce((acc, param) => {
      let { class: cvClass, className: cvClassName, ...compoundVariantOptions } = param;
      return Object.entries(compoundVariantOptions).every((param2) => {
        let [key, value] = param2;
        return Array.isArray(value) ? value.includes({
          ...defaultVariants,
          ...propsWithoutUndefined
        }[key]) : {
          ...defaultVariants,
          ...propsWithoutUndefined
        }[key] === value;
      }) ? [
        ...acc,
        cvClass,
        cvClassName
      ] : acc;
    }, []);
    return cx(base, getVariantClassNames, getCompoundVariantClassNames, props === null || props === void 0 ? void 0 : props.class, props === null || props === void 0 ? void 0 : props.className);
  };

  // src/components/Button.tsx
  var import_jsx_runtime21 = __toESM(require_jsx_runtime());
  var buttonVariants = cva(
    "inline-flex items-center justify-center rounded-[2rem] font-medium transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 hover:scale-[1.02] active:scale-[0.98]",
    {
      variants: {
        variant: {
          primary: "bg-primary text-primary-foreground hover:bg-primary/90 shadow-md shadow-primary/20 hover:shadow-lg hover:shadow-primary/30",
          secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
          outline: "border border-border bg-transparent hover:bg-muted",
          ghost: "bg-transparent hover:bg-muted",
          destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90",
          link: "text-primary underline-offset-4 hover:underline",
          gradient: "bg-gradient-to-r from-violet-600 to-indigo-600 text-white hover:from-violet-700 hover:to-indigo-700 shadow-lg hover:shadow-violet-500/25 border-none",
          neon: "bg-transparent border border-cyan-400 text-cyan-400 shadow-[0_0_10px_rgba(34,211,238,0.2)] hover:shadow-[0_0_20px_rgba(34,211,238,0.4)] hover:bg-cyan-950/30",
          soft: "bg-violet-100 text-violet-700 hover:bg-violet-200 dark:bg-violet-900/30 dark:text-violet-300 dark:hover:bg-violet-900/50"
        },
        size: {
          default: "h-10 px-4 py-2",
          sm: "h-8 px-3 text-sm",
          md: "h-10 px-4 text-sm",
          lg: "h-12 px-6 text-base",
          icon: "h-9 w-9"
        }
      },
      defaultVariants: {
        variant: "primary",
        size: "md"
      }
    }
  );
  var Button = (0, import_react32.forwardRef)(
    ({ className, variant, size: size4, ...props }, ref) => {
      return /* @__PURE__ */ (0, import_jsx_runtime21.jsx)(
        "button",
        {
          className: cn(buttonVariants({ variant, size: size4, className })),
          ref,
          ...props
        }
      );
    }
  );
  Button.displayName = "Button";

  // ../../node_modules/@date-fns/tz/tzName/index.js
  function tzName(timeZone, date, format2 = "long") {
    return new Intl.DateTimeFormat("en-US", {
      // Enforces engine to render the time. Without the option JavaScriptCore omits it.
      hour: "numeric",
      timeZone,
      timeZoneName: format2
    }).format(date).split(/\s/g).slice(2).join(" ");
  }

  // ../../node_modules/@date-fns/tz/tzOffset/index.js
  var offsetFormatCache = {};
  var offsetCache = {};
  function tzOffset(timeZone, date) {
    try {
      const format2 = offsetFormatCache[timeZone] || (offsetFormatCache[timeZone] = new Intl.DateTimeFormat("en-US", {
        timeZone,
        timeZoneName: "longOffset"
      }).format);
      const offsetStr = format2(date).split("GMT")[1];
      if (offsetStr in offsetCache) return offsetCache[offsetStr];
      return calcOffset(offsetStr, offsetStr.split(":"));
    } catch {
      if (timeZone in offsetCache) return offsetCache[timeZone];
      const captures = timeZone?.match(offsetRe);
      if (captures) return calcOffset(timeZone, captures.slice(1));
      return NaN;
    }
  }
  var offsetRe = /([+-]\d\d):?(\d\d)?/;
  function calcOffset(cacheStr, values) {
    const hours = +(values[0] || 0);
    const minutes = +(values[1] || 0);
    const seconds = +(values[2] || 0) / 60;
    return offsetCache[cacheStr] = hours * 60 + minutes > 0 ? hours * 60 + minutes + seconds : hours * 60 - minutes - seconds;
  }

  // ../../node_modules/@date-fns/tz/date/mini.js
  var TZDateMini = class _TZDateMini extends Date {
    //#region static
    constructor(...args) {
      super();
      if (args.length > 1 && typeof args[args.length - 1] === "string") {
        this.timeZone = args.pop();
      }
      this.internal = /* @__PURE__ */ new Date();
      if (isNaN(tzOffset(this.timeZone, this))) {
        this.setTime(NaN);
      } else {
        if (!args.length) {
          this.setTime(Date.now());
        } else if (typeof args[0] === "number" && (args.length === 1 || args.length === 2 && typeof args[1] !== "number")) {
          this.setTime(args[0]);
        } else if (typeof args[0] === "string") {
          this.setTime(+new Date(args[0]));
        } else if (args[0] instanceof Date) {
          this.setTime(+args[0]);
        } else {
          this.setTime(+new Date(...args));
          adjustToSystemTZ(this, NaN);
          syncToInternal(this);
        }
      }
    }
    static tz(tz, ...args) {
      return args.length ? new _TZDateMini(...args, tz) : new _TZDateMini(Date.now(), tz);
    }
    //#endregion
    //#region time zone
    withTimeZone(timeZone) {
      return new _TZDateMini(+this, timeZone);
    }
    getTimezoneOffset() {
      const offset4 = -tzOffset(this.timeZone, this);
      return offset4 > 0 ? Math.floor(offset4) : Math.ceil(offset4);
    }
    //#endregion
    //#region time
    setTime(time2) {
      Date.prototype.setTime.apply(this, arguments);
      syncToInternal(this);
      return +this;
    }
    //#endregion
    //#region date-fns integration
    [/* @__PURE__ */ Symbol.for("constructDateFrom")](date) {
      return new _TZDateMini(+new Date(date), this.timeZone);
    }
    //#endregion
  };
  var re = /^(get|set)(?!UTC)/;
  Object.getOwnPropertyNames(Date.prototype).forEach((method) => {
    if (!re.test(method)) return;
    const utcMethod = method.replace(re, "$1UTC");
    if (!TZDateMini.prototype[utcMethod]) return;
    if (method.startsWith("get")) {
      TZDateMini.prototype[method] = function() {
        return this.internal[utcMethod]();
      };
    } else {
      TZDateMini.prototype[method] = function() {
        Date.prototype[utcMethod].apply(this.internal, arguments);
        syncFromInternal(this);
        return +this;
      };
      TZDateMini.prototype[utcMethod] = function() {
        Date.prototype[utcMethod].apply(this, arguments);
        syncToInternal(this);
        return +this;
      };
    }
  });
  function syncToInternal(date) {
    date.internal.setTime(+date);
    date.internal.setUTCSeconds(date.internal.getUTCSeconds() - Math.round(-tzOffset(date.timeZone, date) * 60));
  }
  function syncFromInternal(date) {
    Date.prototype.setFullYear.call(date, date.internal.getUTCFullYear(), date.internal.getUTCMonth(), date.internal.getUTCDate());
    Date.prototype.setHours.call(date, date.internal.getUTCHours(), date.internal.getUTCMinutes(), date.internal.getUTCSeconds(), date.internal.getUTCMilliseconds());
    adjustToSystemTZ(date);
  }
  function adjustToSystemTZ(date) {
    const baseOffset = tzOffset(date.timeZone, date);
    const offset4 = baseOffset > 0 ? Math.floor(baseOffset) : Math.ceil(baseOffset);
    const prevHour = /* @__PURE__ */ new Date(+date);
    prevHour.setUTCHours(prevHour.getUTCHours() - 1);
    const systemOffset = -(/* @__PURE__ */ new Date(+date)).getTimezoneOffset();
    const prevHourSystemOffset = -(/* @__PURE__ */ new Date(+prevHour)).getTimezoneOffset();
    const systemDSTChange = systemOffset - prevHourSystemOffset;
    const dstShift = Date.prototype.getHours.apply(date) !== date.internal.getUTCHours();
    if (systemDSTChange && dstShift) date.internal.setUTCMinutes(date.internal.getUTCMinutes() + systemDSTChange);
    const offsetDiff = systemOffset - offset4;
    if (offsetDiff) Date.prototype.setUTCMinutes.call(date, Date.prototype.getUTCMinutes.call(date) + offsetDiff);
    const systemDate = /* @__PURE__ */ new Date(+date);
    systemDate.setUTCSeconds(0);
    const systemSecondsOffset = systemOffset > 0 ? systemDate.getSeconds() : (systemDate.getSeconds() - 60) % 60;
    const secondsOffset = Math.round(-(tzOffset(date.timeZone, date) * 60)) % 60;
    if (secondsOffset || systemSecondsOffset) {
      date.internal.setUTCSeconds(date.internal.getUTCSeconds() + secondsOffset);
      Date.prototype.setUTCSeconds.call(date, Date.prototype.getUTCSeconds.call(date) + secondsOffset + systemSecondsOffset);
    }
    const postBaseOffset = tzOffset(date.timeZone, date);
    const postOffset = postBaseOffset > 0 ? Math.floor(postBaseOffset) : Math.ceil(postBaseOffset);
    const postSystemOffset = -(/* @__PURE__ */ new Date(+date)).getTimezoneOffset();
    const postOffsetDiff = postSystemOffset - postOffset;
    const offsetChanged = postOffset !== offset4;
    const postDiff = postOffsetDiff - offsetDiff;
    if (offsetChanged && postDiff) {
      Date.prototype.setUTCMinutes.call(date, Date.prototype.getUTCMinutes.call(date) + postDiff);
      const newBaseOffset = tzOffset(date.timeZone, date);
      const newOffset = newBaseOffset > 0 ? Math.floor(newBaseOffset) : Math.ceil(newBaseOffset);
      const offsetChange = postOffset - newOffset;
      if (offsetChange) {
        date.internal.setUTCMinutes(date.internal.getUTCMinutes() + offsetChange);
        Date.prototype.setUTCMinutes.call(date, Date.prototype.getUTCMinutes.call(date) + offsetChange);
      }
    }
  }

  // ../../node_modules/@date-fns/tz/date/index.js
  var TZDate = class _TZDate extends TZDateMini {
    //#region static
    static tz(tz, ...args) {
      return args.length ? new _TZDate(...args, tz) : new _TZDate(Date.now(), tz);
    }
    //#endregion
    //#region representation
    toISOString() {
      const [sign, hours, minutes] = this.tzComponents();
      const tz = `${sign}${hours}:${minutes}`;
      return this.internal.toISOString().slice(0, -1) + tz;
    }
    toString() {
      return `${this.toDateString()} ${this.toTimeString()}`;
    }
    toDateString() {
      const [day, date, month, year] = this.internal.toUTCString().split(" ");
      return `${day?.slice(0, -1)} ${month} ${date} ${year}`;
    }
    toTimeString() {
      const time2 = this.internal.toUTCString().split(" ")[4];
      const [sign, hours, minutes] = this.tzComponents();
      return `${time2} GMT${sign}${hours}${minutes} (${tzName(this.timeZone, this)})`;
    }
    toLocaleString(locales, options) {
      return Date.prototype.toLocaleString.call(this, locales, {
        ...options,
        timeZone: options?.timeZone || this.timeZone
      });
    }
    toLocaleDateString(locales, options) {
      return Date.prototype.toLocaleDateString.call(this, locales, {
        ...options,
        timeZone: options?.timeZone || this.timeZone
      });
    }
    toLocaleTimeString(locales, options) {
      return Date.prototype.toLocaleTimeString.call(this, locales, {
        ...options,
        timeZone: options?.timeZone || this.timeZone
      });
    }
    //#endregion
    //#region private
    tzComponents() {
      const offset4 = this.getTimezoneOffset();
      const sign = offset4 > 0 ? "-" : "+";
      const hours = String(Math.floor(Math.abs(offset4) / 60)).padStart(2, "0");
      const minutes = String(Math.abs(offset4) % 60).padStart(2, "0");
      return [sign, hours, minutes];
    }
    //#endregion
    withTimeZone(timeZone) {
      return new _TZDate(+this, timeZone);
    }
    //#region date-fns integration
    [/* @__PURE__ */ Symbol.for("constructDateFrom")](date) {
      return new _TZDate(+new Date(date), this.timeZone);
    }
    //#endregion
  };

  // ../../node_modules/date-fns/constants.js
  var daysInYear = 365.2425;
  var maxTime = Math.pow(10, 8) * 24 * 60 * 60 * 1e3;
  var minTime = -maxTime;
  var millisecondsInWeek = 6048e5;
  var millisecondsInDay = 864e5;
  var secondsInHour = 3600;
  var secondsInDay = secondsInHour * 24;
  var secondsInWeek = secondsInDay * 7;
  var secondsInYear = secondsInDay * daysInYear;
  var secondsInMonth = secondsInYear / 12;
  var secondsInQuarter = secondsInMonth * 3;
  var constructFromSymbol = /* @__PURE__ */ Symbol.for("constructDateFrom");

  // ../../node_modules/date-fns/constructFrom.js
  function constructFrom(date, value) {
    if (typeof date === "function") return date(value);
    if (date && typeof date === "object" && constructFromSymbol in date)
      return date[constructFromSymbol](value);
    if (date instanceof Date) return new date.constructor(value);
    return new Date(value);
  }

  // ../../node_modules/date-fns/toDate.js
  function toDate(argument, context) {
    return constructFrom(context || argument, argument);
  }

  // ../../node_modules/date-fns/addDays.js
  function addDays(date, amount, options) {
    const _date = toDate(date, options?.in);
    if (isNaN(amount)) return constructFrom(options?.in || date, NaN);
    if (!amount) return _date;
    _date.setDate(_date.getDate() + amount);
    return _date;
  }

  // ../../node_modules/date-fns/addMonths.js
  function addMonths(date, amount, options) {
    const _date = toDate(date, options?.in);
    if (isNaN(amount)) return constructFrom(options?.in || date, NaN);
    if (!amount) {
      return _date;
    }
    const dayOfMonth = _date.getDate();
    const endOfDesiredMonth = constructFrom(options?.in || date, _date.getTime());
    endOfDesiredMonth.setMonth(_date.getMonth() + amount + 1, 0);
    const daysInMonth = endOfDesiredMonth.getDate();
    if (dayOfMonth >= daysInMonth) {
      return endOfDesiredMonth;
    } else {
      _date.setFullYear(
        endOfDesiredMonth.getFullYear(),
        endOfDesiredMonth.getMonth(),
        dayOfMonth
      );
      return _date;
    }
  }

  // ../../node_modules/date-fns/_lib/defaultOptions.js
  var defaultOptions = {};
  function getDefaultOptions() {
    return defaultOptions;
  }

  // ../../node_modules/date-fns/startOfWeek.js
  function startOfWeek(date, options) {
    const defaultOptions2 = getDefaultOptions();
    const weekStartsOn = options?.weekStartsOn ?? options?.locale?.options?.weekStartsOn ?? defaultOptions2.weekStartsOn ?? defaultOptions2.locale?.options?.weekStartsOn ?? 0;
    const _date = toDate(date, options?.in);
    const day = _date.getDay();
    const diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
    _date.setDate(_date.getDate() - diff);
    _date.setHours(0, 0, 0, 0);
    return _date;
  }

  // ../../node_modules/date-fns/startOfISOWeek.js
  function startOfISOWeek(date, options) {
    return startOfWeek(date, { ...options, weekStartsOn: 1 });
  }

  // ../../node_modules/date-fns/getISOWeekYear.js
  function getISOWeekYear(date, options) {
    const _date = toDate(date, options?.in);
    const year = _date.getFullYear();
    const fourthOfJanuaryOfNextYear = constructFrom(_date, 0);
    fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);
    fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
    const startOfNextYear = startOfISOWeek(fourthOfJanuaryOfNextYear);
    const fourthOfJanuaryOfThisYear = constructFrom(_date, 0);
    fourthOfJanuaryOfThisYear.setFullYear(year, 0, 4);
    fourthOfJanuaryOfThisYear.setHours(0, 0, 0, 0);
    const startOfThisYear = startOfISOWeek(fourthOfJanuaryOfThisYear);
    if (_date.getTime() >= startOfNextYear.getTime()) {
      return year + 1;
    } else if (_date.getTime() >= startOfThisYear.getTime()) {
      return year;
    } else {
      return year - 1;
    }
  }

  // ../../node_modules/date-fns/_lib/getTimezoneOffsetInMilliseconds.js
  function getTimezoneOffsetInMilliseconds(date) {
    const _date = toDate(date);
    const utcDate = new Date(
      Date.UTC(
        _date.getFullYear(),
        _date.getMonth(),
        _date.getDate(),
        _date.getHours(),
        _date.getMinutes(),
        _date.getSeconds(),
        _date.getMilliseconds()
      )
    );
    utcDate.setUTCFullYear(_date.getFullYear());
    return +date - +utcDate;
  }

  // ../../node_modules/date-fns/_lib/normalizeDates.js
  function normalizeDates(context, ...dates) {
    const normalize = constructFrom.bind(
      null,
      context || dates.find((date) => typeof date === "object")
    );
    return dates.map(normalize);
  }

  // ../../node_modules/date-fns/startOfDay.js
  function startOfDay(date, options) {
    const _date = toDate(date, options?.in);
    _date.setHours(0, 0, 0, 0);
    return _date;
  }

  // ../../node_modules/date-fns/differenceInCalendarDays.js
  function differenceInCalendarDays(laterDate, earlierDate, options) {
    const [laterDate_, earlierDate_] = normalizeDates(
      options?.in,
      laterDate,
      earlierDate
    );
    const laterStartOfDay = startOfDay(laterDate_);
    const earlierStartOfDay = startOfDay(earlierDate_);
    const laterTimestamp = +laterStartOfDay - getTimezoneOffsetInMilliseconds(laterStartOfDay);
    const earlierTimestamp = +earlierStartOfDay - getTimezoneOffsetInMilliseconds(earlierStartOfDay);
    return Math.round((laterTimestamp - earlierTimestamp) / millisecondsInDay);
  }

  // ../../node_modules/date-fns/startOfISOWeekYear.js
  function startOfISOWeekYear(date, options) {
    const year = getISOWeekYear(date, options);
    const fourthOfJanuary = constructFrom(options?.in || date, 0);
    fourthOfJanuary.setFullYear(year, 0, 4);
    fourthOfJanuary.setHours(0, 0, 0, 0);
    return startOfISOWeek(fourthOfJanuary);
  }

  // ../../node_modules/date-fns/addWeeks.js
  function addWeeks(date, amount, options) {
    return addDays(date, amount * 7, options);
  }

  // ../../node_modules/date-fns/addYears.js
  function addYears(date, amount, options) {
    return addMonths(date, amount * 12, options);
  }

  // ../../node_modules/date-fns/max.js
  function max(dates, options) {
    let result;
    let context = options?.in;
    dates.forEach((date) => {
      if (!context && typeof date === "object")
        context = constructFrom.bind(null, date);
      const date_ = toDate(date, context);
      if (!result || result < date_ || isNaN(+date_)) result = date_;
    });
    return constructFrom(context, result || NaN);
  }

  // ../../node_modules/date-fns/min.js
  function min(dates, options) {
    let result;
    let context = options?.in;
    dates.forEach((date) => {
      if (!context && typeof date === "object")
        context = constructFrom.bind(null, date);
      const date_ = toDate(date, context);
      if (!result || result > date_ || isNaN(+date_)) result = date_;
    });
    return constructFrom(context, result || NaN);
  }

  // ../../node_modules/date-fns/isSameDay.js
  function isSameDay(laterDate, earlierDate, options) {
    const [dateLeft_, dateRight_] = normalizeDates(
      options?.in,
      laterDate,
      earlierDate
    );
    return +startOfDay(dateLeft_) === +startOfDay(dateRight_);
  }

  // ../../node_modules/date-fns/isDate.js
  function isDate(value) {
    return value instanceof Date || typeof value === "object" && Object.prototype.toString.call(value) === "[object Date]";
  }

  // ../../node_modules/date-fns/isValid.js
  function isValid(date) {
    return !(!isDate(date) && typeof date !== "number" || isNaN(+toDate(date)));
  }

  // ../../node_modules/date-fns/differenceInCalendarMonths.js
  function differenceInCalendarMonths(laterDate, earlierDate, options) {
    const [laterDate_, earlierDate_] = normalizeDates(
      options?.in,
      laterDate,
      earlierDate
    );
    const yearsDiff = laterDate_.getFullYear() - earlierDate_.getFullYear();
    const monthsDiff = laterDate_.getMonth() - earlierDate_.getMonth();
    return yearsDiff * 12 + monthsDiff;
  }

  // ../../node_modules/date-fns/endOfMonth.js
  function endOfMonth(date, options) {
    const _date = toDate(date, options?.in);
    const month = _date.getMonth();
    _date.setFullYear(_date.getFullYear(), month + 1, 0);
    _date.setHours(23, 59, 59, 999);
    return _date;
  }

  // ../../node_modules/date-fns/_lib/normalizeInterval.js
  function normalizeInterval(context, interval) {
    const [start2, end] = normalizeDates(context, interval.start, interval.end);
    return { start: start2, end };
  }

  // ../../node_modules/date-fns/eachMonthOfInterval.js
  function eachMonthOfInterval(interval, options) {
    const { start: start2, end } = normalizeInterval(options?.in, interval);
    let reversed = +start2 > +end;
    const endTime = reversed ? +start2 : +end;
    const date = reversed ? end : start2;
    date.setHours(0, 0, 0, 0);
    date.setDate(1);
    let step = options?.step ?? 1;
    if (!step) return [];
    if (step < 0) {
      step = -step;
      reversed = !reversed;
    }
    const dates = [];
    while (+date <= endTime) {
      dates.push(constructFrom(start2, date));
      date.setMonth(date.getMonth() + step);
    }
    return reversed ? dates.reverse() : dates;
  }

  // ../../node_modules/date-fns/startOfMonth.js
  function startOfMonth(date, options) {
    const _date = toDate(date, options?.in);
    _date.setDate(1);
    _date.setHours(0, 0, 0, 0);
    return _date;
  }

  // ../../node_modules/date-fns/endOfYear.js
  function endOfYear(date, options) {
    const _date = toDate(date, options?.in);
    const year = _date.getFullYear();
    _date.setFullYear(year + 1, 0, 0);
    _date.setHours(23, 59, 59, 999);
    return _date;
  }

  // ../../node_modules/date-fns/startOfYear.js
  function startOfYear(date, options) {
    const date_ = toDate(date, options?.in);
    date_.setFullYear(date_.getFullYear(), 0, 1);
    date_.setHours(0, 0, 0, 0);
    return date_;
  }

  // ../../node_modules/date-fns/eachYearOfInterval.js
  function eachYearOfInterval(interval, options) {
    const { start: start2, end } = normalizeInterval(options?.in, interval);
    let reversed = +start2 > +end;
    const endTime = reversed ? +start2 : +end;
    const date = reversed ? end : start2;
    date.setHours(0, 0, 0, 0);
    date.setMonth(0, 1);
    let step = options?.step ?? 1;
    if (!step) return [];
    if (step < 0) {
      step = -step;
      reversed = !reversed;
    }
    const dates = [];
    while (+date <= endTime) {
      dates.push(constructFrom(start2, date));
      date.setFullYear(date.getFullYear() + step);
    }
    return reversed ? dates.reverse() : dates;
  }

  // ../../node_modules/date-fns/endOfWeek.js
  function endOfWeek(date, options) {
    const defaultOptions2 = getDefaultOptions();
    const weekStartsOn = options?.weekStartsOn ?? options?.locale?.options?.weekStartsOn ?? defaultOptions2.weekStartsOn ?? defaultOptions2.locale?.options?.weekStartsOn ?? 0;
    const _date = toDate(date, options?.in);
    const day = _date.getDay();
    const diff = (day < weekStartsOn ? -7 : 0) + 6 - (day - weekStartsOn);
    _date.setDate(_date.getDate() + diff);
    _date.setHours(23, 59, 59, 999);
    return _date;
  }

  // ../../node_modules/date-fns/endOfISOWeek.js
  function endOfISOWeek(date, options) {
    return endOfWeek(date, { ...options, weekStartsOn: 1 });
  }

  // ../../node_modules/date-fns/locale/en-US/_lib/formatDistance.js
  var formatDistanceLocale = {
    lessThanXSeconds: {
      one: "less than a second",
      other: "less than {{count}} seconds"
    },
    xSeconds: {
      one: "1 second",
      other: "{{count}} seconds"
    },
    halfAMinute: "half a minute",
    lessThanXMinutes: {
      one: "less than a minute",
      other: "less than {{count}} minutes"
    },
    xMinutes: {
      one: "1 minute",
      other: "{{count}} minutes"
    },
    aboutXHours: {
      one: "about 1 hour",
      other: "about {{count}} hours"
    },
    xHours: {
      one: "1 hour",
      other: "{{count}} hours"
    },
    xDays: {
      one: "1 day",
      other: "{{count}} days"
    },
    aboutXWeeks: {
      one: "about 1 week",
      other: "about {{count}} weeks"
    },
    xWeeks: {
      one: "1 week",
      other: "{{count}} weeks"
    },
    aboutXMonths: {
      one: "about 1 month",
      other: "about {{count}} months"
    },
    xMonths: {
      one: "1 month",
      other: "{{count}} months"
    },
    aboutXYears: {
      one: "about 1 year",
      other: "about {{count}} years"
    },
    xYears: {
      one: "1 year",
      other: "{{count}} years"
    },
    overXYears: {
      one: "over 1 year",
      other: "over {{count}} years"
    },
    almostXYears: {
      one: "almost 1 year",
      other: "almost {{count}} years"
    }
  };
  var formatDistance = (token, count3, options) => {
    let result;
    const tokenValue = formatDistanceLocale[token];
    if (typeof tokenValue === "string") {
      result = tokenValue;
    } else if (count3 === 1) {
      result = tokenValue.one;
    } else {
      result = tokenValue.other.replace("{{count}}", count3.toString());
    }
    if (options?.addSuffix) {
      if (options.comparison && options.comparison > 0) {
        return "in " + result;
      } else {
        return result + " ago";
      }
    }
    return result;
  };

  // ../../node_modules/date-fns/locale/_lib/buildFormatLongFn.js
  function buildFormatLongFn(args) {
    return (options = {}) => {
      const width = options.width ? String(options.width) : args.defaultWidth;
      const format2 = args.formats[width] || args.formats[args.defaultWidth];
      return format2;
    };
  }

  // ../../node_modules/date-fns/locale/en-US/_lib/formatLong.js
  var dateFormats = {
    full: "EEEE, MMMM do, y",
    long: "MMMM do, y",
    medium: "MMM d, y",
    short: "MM/dd/yyyy"
  };
  var timeFormats = {
    full: "h:mm:ss a zzzz",
    long: "h:mm:ss a z",
    medium: "h:mm:ss a",
    short: "h:mm a"
  };
  var dateTimeFormats = {
    full: "{{date}} 'at' {{time}}",
    long: "{{date}} 'at' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
  };
  var formatLong = {
    date: buildFormatLongFn({
      formats: dateFormats,
      defaultWidth: "full"
    }),
    time: buildFormatLongFn({
      formats: timeFormats,
      defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
      formats: dateTimeFormats,
      defaultWidth: "full"
    })
  };

  // ../../node_modules/date-fns/locale/en-US/_lib/formatRelative.js
  var formatRelativeLocale = {
    lastWeek: "'last' eeee 'at' p",
    yesterday: "'yesterday at' p",
    today: "'today at' p",
    tomorrow: "'tomorrow at' p",
    nextWeek: "eeee 'at' p",
    other: "P"
  };
  var formatRelative = (token, _date, _baseDate, _options) => formatRelativeLocale[token];

  // ../../node_modules/date-fns/locale/_lib/buildLocalizeFn.js
  function buildLocalizeFn(args) {
    return (value, options) => {
      const context = options?.context ? String(options.context) : "standalone";
      let valuesArray;
      if (context === "formatting" && args.formattingValues) {
        const defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
        const width = options?.width ? String(options.width) : defaultWidth;
        valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
      } else {
        const defaultWidth = args.defaultWidth;
        const width = options?.width ? String(options.width) : args.defaultWidth;
        valuesArray = args.values[width] || args.values[defaultWidth];
      }
      const index2 = args.argumentCallback ? args.argumentCallback(value) : value;
      return valuesArray[index2];
    };
  }

  // ../../node_modules/date-fns/locale/en-US/_lib/localize.js
  var eraValues = {
    narrow: ["B", "A"],
    abbreviated: ["BC", "AD"],
    wide: ["Before Christ", "Anno Domini"]
  };
  var quarterValues = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["Q1", "Q2", "Q3", "Q4"],
    wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
  };
  var monthValues = {
    narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
    abbreviated: [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ],
    wide: [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December"
    ]
  };
  var dayValues = {
    narrow: ["S", "M", "T", "W", "T", "F", "S"],
    short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
    abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    wide: [
      "Sunday",
      "Monday",
      "Tuesday",
      "Wednesday",
      "Thursday",
      "Friday",
      "Saturday"
    ]
  };
  var dayPeriodValues = {
    narrow: {
      am: "a",
      pm: "p",
      midnight: "mi",
      noon: "n",
      morning: "morning",
      afternoon: "afternoon",
      evening: "evening",
      night: "night"
    },
    abbreviated: {
      am: "AM",
      pm: "PM",
      midnight: "midnight",
      noon: "noon",
      morning: "morning",
      afternoon: "afternoon",
      evening: "evening",
      night: "night"
    },
    wide: {
      am: "a.m.",
      pm: "p.m.",
      midnight: "midnight",
      noon: "noon",
      morning: "morning",
      afternoon: "afternoon",
      evening: "evening",
      night: "night"
    }
  };
  var formattingDayPeriodValues = {
    narrow: {
      am: "a",
      pm: "p",
      midnight: "mi",
      noon: "n",
      morning: "in the morning",
      afternoon: "in the afternoon",
      evening: "in the evening",
      night: "at night"
    },
    abbreviated: {
      am: "AM",
      pm: "PM",
      midnight: "midnight",
      noon: "noon",
      morning: "in the morning",
      afternoon: "in the afternoon",
      evening: "in the evening",
      night: "at night"
    },
    wide: {
      am: "a.m.",
      pm: "p.m.",
      midnight: "midnight",
      noon: "noon",
      morning: "in the morning",
      afternoon: "in the afternoon",
      evening: "in the evening",
      night: "at night"
    }
  };
  var ordinalNumber = (dirtyNumber, _options) => {
    const number2 = Number(dirtyNumber);
    const rem100 = number2 % 100;
    if (rem100 > 20 || rem100 < 10) {
      switch (rem100 % 10) {
        case 1:
          return number2 + "st";
        case 2:
          return number2 + "nd";
        case 3:
          return number2 + "rd";
      }
    }
    return number2 + "th";
  };
  var localize = {
    ordinalNumber,
    era: buildLocalizeFn({
      values: eraValues,
      defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
      values: quarterValues,
      defaultWidth: "wide",
      argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
      values: monthValues,
      defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
      values: dayValues,
      defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
      values: dayPeriodValues,
      defaultWidth: "wide",
      formattingValues: formattingDayPeriodValues,
      defaultFormattingWidth: "wide"
    })
  };

  // ../../node_modules/date-fns/locale/_lib/buildMatchFn.js
  function buildMatchFn(args) {
    return (string, options = {}) => {
      const width = options.width;
      const matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
      const matchResult = string.match(matchPattern);
      if (!matchResult) {
        return null;
      }
      const matchedString = matchResult[0];
      const parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
      const key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, (pattern) => pattern.test(matchedString)) : (
        // [TODO] -- I challenge you to fix the type
        findKey(parsePatterns, (pattern) => pattern.test(matchedString))
      );
      let value;
      value = args.valueCallback ? args.valueCallback(key) : key;
      value = options.valueCallback ? (
        // [TODO] -- I challenge you to fix the type
        options.valueCallback(value)
      ) : value;
      const rest = string.slice(matchedString.length);
      return { value, rest };
    };
  }
  function findKey(object, predicate) {
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key) && predicate(object[key])) {
        return key;
      }
    }
    return void 0;
  }
  function findIndex(array, predicate) {
    for (let key = 0; key < array.length; key++) {
      if (predicate(array[key])) {
        return key;
      }
    }
    return void 0;
  }

  // ../../node_modules/date-fns/locale/_lib/buildMatchPatternFn.js
  function buildMatchPatternFn(args) {
    return (string, options = {}) => {
      const matchResult = string.match(args.matchPattern);
      if (!matchResult) return null;
      const matchedString = matchResult[0];
      const parseResult = string.match(args.parsePattern);
      if (!parseResult) return null;
      let value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
      value = options.valueCallback ? options.valueCallback(value) : value;
      const rest = string.slice(matchedString.length);
      return { value, rest };
    };
  }

  // ../../node_modules/date-fns/locale/en-US/_lib/match.js
  var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
  var parseOrdinalNumberPattern = /\d+/i;
  var matchEraPatterns = {
    narrow: /^(b|a)/i,
    abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
    wide: /^(before christ|before common era|anno domini|common era)/i
  };
  var parseEraPatterns = {
    any: [/^b/i, /^(a|c)/i]
  };
  var matchQuarterPatterns = {
    narrow: /^[1234]/i,
    abbreviated: /^q[1234]/i,
    wide: /^[1234](th|st|nd|rd)? quarter/i
  };
  var parseQuarterPatterns = {
    any: [/1/i, /2/i, /3/i, /4/i]
  };
  var matchMonthPatterns = {
    narrow: /^[jfmasond]/i,
    abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
    wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
  };
  var parseMonthPatterns = {
    narrow: [
      /^j/i,
      /^f/i,
      /^m/i,
      /^a/i,
      /^m/i,
      /^j/i,
      /^j/i,
      /^a/i,
      /^s/i,
      /^o/i,
      /^n/i,
      /^d/i
    ],
    any: [
      /^ja/i,
      /^f/i,
      /^mar/i,
      /^ap/i,
      /^may/i,
      /^jun/i,
      /^jul/i,
      /^au/i,
      /^s/i,
      /^o/i,
      /^n/i,
      /^d/i
    ]
  };
  var matchDayPatterns = {
    narrow: /^[smtwf]/i,
    short: /^(su|mo|tu|we|th|fr|sa)/i,
    abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
    wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
  };
  var parseDayPatterns = {
    narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
    any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
  };
  var matchDayPeriodPatterns = {
    narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
    any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
  };
  var parseDayPeriodPatterns = {
    any: {
      am: /^a/i,
      pm: /^p/i,
      midnight: /^mi/i,
      noon: /^no/i,
      morning: /morning/i,
      afternoon: /afternoon/i,
      evening: /evening/i,
      night: /night/i
    }
  };
  var match = {
    ordinalNumber: buildMatchPatternFn({
      matchPattern: matchOrdinalNumberPattern,
      parsePattern: parseOrdinalNumberPattern,
      valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
      matchPatterns: matchEraPatterns,
      defaultMatchWidth: "wide",
      parsePatterns: parseEraPatterns,
      defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
      matchPatterns: matchQuarterPatterns,
      defaultMatchWidth: "wide",
      parsePatterns: parseQuarterPatterns,
      defaultParseWidth: "any",
      valueCallback: (index2) => index2 + 1
    }),
    month: buildMatchFn({
      matchPatterns: matchMonthPatterns,
      defaultMatchWidth: "wide",
      parsePatterns: parseMonthPatterns,
      defaultParseWidth: "any"
    }),
    day: buildMatchFn({
      matchPatterns: matchDayPatterns,
      defaultMatchWidth: "wide",
      parsePatterns: parseDayPatterns,
      defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
      matchPatterns: matchDayPeriodPatterns,
      defaultMatchWidth: "any",
      parsePatterns: parseDayPeriodPatterns,
      defaultParseWidth: "any"
    })
  };

  // ../../node_modules/date-fns/locale/en-US.js
  var enUS = {
    code: "en-US",
    formatDistance,
    formatLong,
    formatRelative,
    localize,
    match,
    options: {
      weekStartsOn: 0,
      firstWeekContainsDate: 1
    }
  };

  // ../../node_modules/date-fns/getDayOfYear.js
  function getDayOfYear(date, options) {
    const _date = toDate(date, options?.in);
    const diff = differenceInCalendarDays(_date, startOfYear(_date));
    const dayOfYear = diff + 1;
    return dayOfYear;
  }

  // ../../node_modules/date-fns/getISOWeek.js
  function getISOWeek(date, options) {
    const _date = toDate(date, options?.in);
    const diff = +startOfISOWeek(_date) - +startOfISOWeekYear(_date);
    return Math.round(diff / millisecondsInWeek) + 1;
  }

  // ../../node_modules/date-fns/getWeekYear.js
  function getWeekYear(date, options) {
    const _date = toDate(date, options?.in);
    const year = _date.getFullYear();
    const defaultOptions2 = getDefaultOptions();
    const firstWeekContainsDate = options?.firstWeekContainsDate ?? options?.locale?.options?.firstWeekContainsDate ?? defaultOptions2.firstWeekContainsDate ?? defaultOptions2.locale?.options?.firstWeekContainsDate ?? 1;
    const firstWeekOfNextYear = constructFrom(options?.in || date, 0);
    firstWeekOfNextYear.setFullYear(year + 1, 0, firstWeekContainsDate);
    firstWeekOfNextYear.setHours(0, 0, 0, 0);
    const startOfNextYear = startOfWeek(firstWeekOfNextYear, options);
    const firstWeekOfThisYear = constructFrom(options?.in || date, 0);
    firstWeekOfThisYear.setFullYear(year, 0, firstWeekContainsDate);
    firstWeekOfThisYear.setHours(0, 0, 0, 0);
    const startOfThisYear = startOfWeek(firstWeekOfThisYear, options);
    if (+_date >= +startOfNextYear) {
      return year + 1;
    } else if (+_date >= +startOfThisYear) {
      return year;
    } else {
      return year - 1;
    }
  }

  // ../../node_modules/date-fns/startOfWeekYear.js
  function startOfWeekYear(date, options) {
    const defaultOptions2 = getDefaultOptions();
    const firstWeekContainsDate = options?.firstWeekContainsDate ?? options?.locale?.options?.firstWeekContainsDate ?? defaultOptions2.firstWeekContainsDate ?? defaultOptions2.locale?.options?.firstWeekContainsDate ?? 1;
    const year = getWeekYear(date, options);
    const firstWeek = constructFrom(options?.in || date, 0);
    firstWeek.setFullYear(year, 0, firstWeekContainsDate);
    firstWeek.setHours(0, 0, 0, 0);
    const _date = startOfWeek(firstWeek, options);
    return _date;
  }

  // ../../node_modules/date-fns/getWeek.js
  function getWeek(date, options) {
    const _date = toDate(date, options?.in);
    const diff = +startOfWeek(_date, options) - +startOfWeekYear(_date, options);
    return Math.round(diff / millisecondsInWeek) + 1;
  }

  // ../../node_modules/date-fns/_lib/addLeadingZeros.js
  function addLeadingZeros(number2, targetLength) {
    const sign = number2 < 0 ? "-" : "";
    const output = Math.abs(number2).toString().padStart(targetLength, "0");
    return sign + output;
  }

  // ../../node_modules/date-fns/_lib/format/lightFormatters.js
  var lightFormatters = {
    // Year
    y(date, token) {
      const signedYear = date.getFullYear();
      const year = signedYear > 0 ? signedYear : 1 - signedYear;
      return addLeadingZeros(token === "yy" ? year % 100 : year, token.length);
    },
    // Month
    M(date, token) {
      const month = date.getMonth();
      return token === "M" ? String(month + 1) : addLeadingZeros(month + 1, 2);
    },
    // Day of the month
    d(date, token) {
      return addLeadingZeros(date.getDate(), token.length);
    },
    // AM or PM
    a(date, token) {
      const dayPeriodEnumValue = date.getHours() / 12 >= 1 ? "pm" : "am";
      switch (token) {
        case "a":
        case "aa":
          return dayPeriodEnumValue.toUpperCase();
        case "aaa":
          return dayPeriodEnumValue;
        case "aaaaa":
          return dayPeriodEnumValue[0];
        case "aaaa":
        default:
          return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
      }
    },
    // Hour [1-12]
    h(date, token) {
      return addLeadingZeros(date.getHours() % 12 || 12, token.length);
    },
    // Hour [0-23]
    H(date, token) {
      return addLeadingZeros(date.getHours(), token.length);
    },
    // Minute
    m(date, token) {
      return addLeadingZeros(date.getMinutes(), token.length);
    },
    // Second
    s(date, token) {
      return addLeadingZeros(date.getSeconds(), token.length);
    },
    // Fraction of second
    S(date, token) {
      const numberOfDigits = token.length;
      const milliseconds = date.getMilliseconds();
      const fractionalSeconds = Math.trunc(
        milliseconds * Math.pow(10, numberOfDigits - 3)
      );
      return addLeadingZeros(fractionalSeconds, token.length);
    }
  };

  // ../../node_modules/date-fns/_lib/format/formatters.js
  var dayPeriodEnum = {
    am: "am",
    pm: "pm",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  };
  var formatters = {
    // Era
    G: function(date, token, localize2) {
      const era = date.getFullYear() > 0 ? 1 : 0;
      switch (token) {
        // AD, BC
        case "G":
        case "GG":
        case "GGG":
          return localize2.era(era, { width: "abbreviated" });
        // A, B
        case "GGGGG":
          return localize2.era(era, { width: "narrow" });
        // Anno Domini, Before Christ
        case "GGGG":
        default:
          return localize2.era(era, { width: "wide" });
      }
    },
    // Year
    y: function(date, token, localize2) {
      if (token === "yo") {
        const signedYear = date.getFullYear();
        const year = signedYear > 0 ? signedYear : 1 - signedYear;
        return localize2.ordinalNumber(year, { unit: "year" });
      }
      return lightFormatters.y(date, token);
    },
    // Local week-numbering year
    Y: function(date, token, localize2, options) {
      const signedWeekYear = getWeekYear(date, options);
      const weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;
      if (token === "YY") {
        const twoDigitYear = weekYear % 100;
        return addLeadingZeros(twoDigitYear, 2);
      }
      if (token === "Yo") {
        return localize2.ordinalNumber(weekYear, { unit: "year" });
      }
      return addLeadingZeros(weekYear, token.length);
    },
    // ISO week-numbering year
    R: function(date, token) {
      const isoWeekYear = getISOWeekYear(date);
      return addLeadingZeros(isoWeekYear, token.length);
    },
    // Extended year. This is a single number designating the year of this calendar system.
    // The main difference between `y` and `u` localizers are B.C. years:
    // | Year | `y` | `u` |
    // |------|-----|-----|
    // | AC 1 |   1 |   1 |
    // | BC 1 |   1 |   0 |
    // | BC 2 |   2 |  -1 |
    // Also `yy` always returns the last two digits of a year,
    // while `uu` pads single digit years to 2 characters and returns other years unchanged.
    u: function(date, token) {
      const year = date.getFullYear();
      return addLeadingZeros(year, token.length);
    },
    // Quarter
    Q: function(date, token, localize2) {
      const quarter = Math.ceil((date.getMonth() + 1) / 3);
      switch (token) {
        // 1, 2, 3, 4
        case "Q":
          return String(quarter);
        // 01, 02, 03, 04
        case "QQ":
          return addLeadingZeros(quarter, 2);
        // 1st, 2nd, 3rd, 4th
        case "Qo":
          return localize2.ordinalNumber(quarter, { unit: "quarter" });
        // Q1, Q2, Q3, Q4
        case "QQQ":
          return localize2.quarter(quarter, {
            width: "abbreviated",
            context: "formatting"
          });
        // 1, 2, 3, 4 (narrow quarter; could be not numerical)
        case "QQQQQ":
          return localize2.quarter(quarter, {
            width: "narrow",
            context: "formatting"
          });
        // 1st quarter, 2nd quarter, ...
        case "QQQQ":
        default:
          return localize2.quarter(quarter, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    // Stand-alone quarter
    q: function(date, token, localize2) {
      const quarter = Math.ceil((date.getMonth() + 1) / 3);
      switch (token) {
        // 1, 2, 3, 4
        case "q":
          return String(quarter);
        // 01, 02, 03, 04
        case "qq":
          return addLeadingZeros(quarter, 2);
        // 1st, 2nd, 3rd, 4th
        case "qo":
          return localize2.ordinalNumber(quarter, { unit: "quarter" });
        // Q1, Q2, Q3, Q4
        case "qqq":
          return localize2.quarter(quarter, {
            width: "abbreviated",
            context: "standalone"
          });
        // 1, 2, 3, 4 (narrow quarter; could be not numerical)
        case "qqqqq":
          return localize2.quarter(quarter, {
            width: "narrow",
            context: "standalone"
          });
        // 1st quarter, 2nd quarter, ...
        case "qqqq":
        default:
          return localize2.quarter(quarter, {
            width: "wide",
            context: "standalone"
          });
      }
    },
    // Month
    M: function(date, token, localize2) {
      const month = date.getMonth();
      switch (token) {
        case "M":
        case "MM":
          return lightFormatters.M(date, token);
        // 1st, 2nd, ..., 12th
        case "Mo":
          return localize2.ordinalNumber(month + 1, { unit: "month" });
        // Jan, Feb, ..., Dec
        case "MMM":
          return localize2.month(month, {
            width: "abbreviated",
            context: "formatting"
          });
        // J, F, ..., D
        case "MMMMM":
          return localize2.month(month, {
            width: "narrow",
            context: "formatting"
          });
        // January, February, ..., December
        case "MMMM":
        default:
          return localize2.month(month, { width: "wide", context: "formatting" });
      }
    },
    // Stand-alone month
    L: function(date, token, localize2) {
      const month = date.getMonth();
      switch (token) {
        // 1, 2, ..., 12
        case "L":
          return String(month + 1);
        // 01, 02, ..., 12
        case "LL":
          return addLeadingZeros(month + 1, 2);
        // 1st, 2nd, ..., 12th
        case "Lo":
          return localize2.ordinalNumber(month + 1, { unit: "month" });
        // Jan, Feb, ..., Dec
        case "LLL":
          return localize2.month(month, {
            width: "abbreviated",
            context: "standalone"
          });
        // J, F, ..., D
        case "LLLLL":
          return localize2.month(month, {
            width: "narrow",
            context: "standalone"
          });
        // January, February, ..., December
        case "LLLL":
        default:
          return localize2.month(month, { width: "wide", context: "standalone" });
      }
    },
    // Local week of year
    w: function(date, token, localize2, options) {
      const week = getWeek(date, options);
      if (token === "wo") {
        return localize2.ordinalNumber(week, { unit: "week" });
      }
      return addLeadingZeros(week, token.length);
    },
    // ISO week of year
    I: function(date, token, localize2) {
      const isoWeek = getISOWeek(date);
      if (token === "Io") {
        return localize2.ordinalNumber(isoWeek, { unit: "week" });
      }
      return addLeadingZeros(isoWeek, token.length);
    },
    // Day of the month
    d: function(date, token, localize2) {
      if (token === "do") {
        return localize2.ordinalNumber(date.getDate(), { unit: "date" });
      }
      return lightFormatters.d(date, token);
    },
    // Day of year
    D: function(date, token, localize2) {
      const dayOfYear = getDayOfYear(date);
      if (token === "Do") {
        return localize2.ordinalNumber(dayOfYear, { unit: "dayOfYear" });
      }
      return addLeadingZeros(dayOfYear, token.length);
    },
    // Day of week
    E: function(date, token, localize2) {
      const dayOfWeek = date.getDay();
      switch (token) {
        // Tue
        case "E":
        case "EE":
        case "EEE":
          return localize2.day(dayOfWeek, {
            width: "abbreviated",
            context: "formatting"
          });
        // T
        case "EEEEE":
          return localize2.day(dayOfWeek, {
            width: "narrow",
            context: "formatting"
          });
        // Tu
        case "EEEEEE":
          return localize2.day(dayOfWeek, {
            width: "short",
            context: "formatting"
          });
        // Tuesday
        case "EEEE":
        default:
          return localize2.day(dayOfWeek, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    // Local day of week
    e: function(date, token, localize2, options) {
      const dayOfWeek = date.getDay();
      const localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
      switch (token) {
        // Numerical value (Nth day of week with current locale or weekStartsOn)
        case "e":
          return String(localDayOfWeek);
        // Padded numerical value
        case "ee":
          return addLeadingZeros(localDayOfWeek, 2);
        // 1st, 2nd, ..., 7th
        case "eo":
          return localize2.ordinalNumber(localDayOfWeek, { unit: "day" });
        case "eee":
          return localize2.day(dayOfWeek, {
            width: "abbreviated",
            context: "formatting"
          });
        // T
        case "eeeee":
          return localize2.day(dayOfWeek, {
            width: "narrow",
            context: "formatting"
          });
        // Tu
        case "eeeeee":
          return localize2.day(dayOfWeek, {
            width: "short",
            context: "formatting"
          });
        // Tuesday
        case "eeee":
        default:
          return localize2.day(dayOfWeek, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    // Stand-alone local day of week
    c: function(date, token, localize2, options) {
      const dayOfWeek = date.getDay();
      const localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
      switch (token) {
        // Numerical value (same as in `e`)
        case "c":
          return String(localDayOfWeek);
        // Padded numerical value
        case "cc":
          return addLeadingZeros(localDayOfWeek, token.length);
        // 1st, 2nd, ..., 7th
        case "co":
          return localize2.ordinalNumber(localDayOfWeek, { unit: "day" });
        case "ccc":
          return localize2.day(dayOfWeek, {
            width: "abbreviated",
            context: "standalone"
          });
        // T
        case "ccccc":
          return localize2.day(dayOfWeek, {
            width: "narrow",
            context: "standalone"
          });
        // Tu
        case "cccccc":
          return localize2.day(dayOfWeek, {
            width: "short",
            context: "standalone"
          });
        // Tuesday
        case "cccc":
        default:
          return localize2.day(dayOfWeek, {
            width: "wide",
            context: "standalone"
          });
      }
    },
    // ISO day of week
    i: function(date, token, localize2) {
      const dayOfWeek = date.getDay();
      const isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
      switch (token) {
        // 2
        case "i":
          return String(isoDayOfWeek);
        // 02
        case "ii":
          return addLeadingZeros(isoDayOfWeek, token.length);
        // 2nd
        case "io":
          return localize2.ordinalNumber(isoDayOfWeek, { unit: "day" });
        // Tue
        case "iii":
          return localize2.day(dayOfWeek, {
            width: "abbreviated",
            context: "formatting"
          });
        // T
        case "iiiii":
          return localize2.day(dayOfWeek, {
            width: "narrow",
            context: "formatting"
          });
        // Tu
        case "iiiiii":
          return localize2.day(dayOfWeek, {
            width: "short",
            context: "formatting"
          });
        // Tuesday
        case "iiii":
        default:
          return localize2.day(dayOfWeek, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    // AM or PM
    a: function(date, token, localize2) {
      const hours = date.getHours();
      const dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
      switch (token) {
        case "a":
        case "aa":
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "abbreviated",
            context: "formatting"
          });
        case "aaa":
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "abbreviated",
            context: "formatting"
          }).toLowerCase();
        case "aaaaa":
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "narrow",
            context: "formatting"
          });
        case "aaaa":
        default:
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    // AM, PM, midnight, noon
    b: function(date, token, localize2) {
      const hours = date.getHours();
      let dayPeriodEnumValue;
      if (hours === 12) {
        dayPeriodEnumValue = dayPeriodEnum.noon;
      } else if (hours === 0) {
        dayPeriodEnumValue = dayPeriodEnum.midnight;
      } else {
        dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
      }
      switch (token) {
        case "b":
        case "bb":
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "abbreviated",
            context: "formatting"
          });
        case "bbb":
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "abbreviated",
            context: "formatting"
          }).toLowerCase();
        case "bbbbb":
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "narrow",
            context: "formatting"
          });
        case "bbbb":
        default:
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    // in the morning, in the afternoon, in the evening, at night
    B: function(date, token, localize2) {
      const hours = date.getHours();
      let dayPeriodEnumValue;
      if (hours >= 17) {
        dayPeriodEnumValue = dayPeriodEnum.evening;
      } else if (hours >= 12) {
        dayPeriodEnumValue = dayPeriodEnum.afternoon;
      } else if (hours >= 4) {
        dayPeriodEnumValue = dayPeriodEnum.morning;
      } else {
        dayPeriodEnumValue = dayPeriodEnum.night;
      }
      switch (token) {
        case "B":
        case "BB":
        case "BBB":
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "abbreviated",
            context: "formatting"
          });
        case "BBBBB":
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "narrow",
            context: "formatting"
          });
        case "BBBB":
        default:
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    // Hour [1-12]
    h: function(date, token, localize2) {
      if (token === "ho") {
        let hours = date.getHours() % 12;
        if (hours === 0) hours = 12;
        return localize2.ordinalNumber(hours, { unit: "hour" });
      }
      return lightFormatters.h(date, token);
    },
    // Hour [0-23]
    H: function(date, token, localize2) {
      if (token === "Ho") {
        return localize2.ordinalNumber(date.getHours(), { unit: "hour" });
      }
      return lightFormatters.H(date, token);
    },
    // Hour [0-11]
    K: function(date, token, localize2) {
      const hours = date.getHours() % 12;
      if (token === "Ko") {
        return localize2.ordinalNumber(hours, { unit: "hour" });
      }
      return addLeadingZeros(hours, token.length);
    },
    // Hour [1-24]
    k: function(date, token, localize2) {
      let hours = date.getHours();
      if (hours === 0) hours = 24;
      if (token === "ko") {
        return localize2.ordinalNumber(hours, { unit: "hour" });
      }
      return addLeadingZeros(hours, token.length);
    },
    // Minute
    m: function(date, token, localize2) {
      if (token === "mo") {
        return localize2.ordinalNumber(date.getMinutes(), { unit: "minute" });
      }
      return lightFormatters.m(date, token);
    },
    // Second
    s: function(date, token, localize2) {
      if (token === "so") {
        return localize2.ordinalNumber(date.getSeconds(), { unit: "second" });
      }
      return lightFormatters.s(date, token);
    },
    // Fraction of second
    S: function(date, token) {
      return lightFormatters.S(date, token);
    },
    // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
    X: function(date, token, _localize) {
      const timezoneOffset = date.getTimezoneOffset();
      if (timezoneOffset === 0) {
        return "Z";
      }
      switch (token) {
        // Hours and optional minutes
        case "X":
          return formatTimezoneWithOptionalMinutes(timezoneOffset);
        // Hours, minutes and optional seconds without `:` delimiter
        // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
        // so this token always has the same output as `XX`
        case "XXXX":
        case "XX":
          return formatTimezone(timezoneOffset);
        // Hours, minutes and optional seconds with `:` delimiter
        // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
        // so this token always has the same output as `XXX`
        case "XXXXX":
        case "XXX":
        // Hours and minutes with `:` delimiter
        default:
          return formatTimezone(timezoneOffset, ":");
      }
    },
    // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
    x: function(date, token, _localize) {
      const timezoneOffset = date.getTimezoneOffset();
      switch (token) {
        // Hours and optional minutes
        case "x":
          return formatTimezoneWithOptionalMinutes(timezoneOffset);
        // Hours, minutes and optional seconds without `:` delimiter
        // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
        // so this token always has the same output as `xx`
        case "xxxx":
        case "xx":
          return formatTimezone(timezoneOffset);
        // Hours, minutes and optional seconds with `:` delimiter
        // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
        // so this token always has the same output as `xxx`
        case "xxxxx":
        case "xxx":
        // Hours and minutes with `:` delimiter
        default:
          return formatTimezone(timezoneOffset, ":");
      }
    },
    // Timezone (GMT)
    O: function(date, token, _localize) {
      const timezoneOffset = date.getTimezoneOffset();
      switch (token) {
        // Short
        case "O":
        case "OO":
        case "OOO":
          return "GMT" + formatTimezoneShort(timezoneOffset, ":");
        // Long
        case "OOOO":
        default:
          return "GMT" + formatTimezone(timezoneOffset, ":");
      }
    },
    // Timezone (specific non-location)
    z: function(date, token, _localize) {
      const timezoneOffset = date.getTimezoneOffset();
      switch (token) {
        // Short
        case "z":
        case "zz":
        case "zzz":
          return "GMT" + formatTimezoneShort(timezoneOffset, ":");
        // Long
        case "zzzz":
        default:
          return "GMT" + formatTimezone(timezoneOffset, ":");
      }
    },
    // Seconds timestamp
    t: function(date, token, _localize) {
      const timestamp = Math.trunc(+date / 1e3);
      return addLeadingZeros(timestamp, token.length);
    },
    // Milliseconds timestamp
    T: function(date, token, _localize) {
      return addLeadingZeros(+date, token.length);
    }
  };
  function formatTimezoneShort(offset4, delimiter = "") {
    const sign = offset4 > 0 ? "-" : "+";
    const absOffset = Math.abs(offset4);
    const hours = Math.trunc(absOffset / 60);
    const minutes = absOffset % 60;
    if (minutes === 0) {
      return sign + String(hours);
    }
    return sign + String(hours) + delimiter + addLeadingZeros(minutes, 2);
  }
  function formatTimezoneWithOptionalMinutes(offset4, delimiter) {
    if (offset4 % 60 === 0) {
      const sign = offset4 > 0 ? "-" : "+";
      return sign + addLeadingZeros(Math.abs(offset4) / 60, 2);
    }
    return formatTimezone(offset4, delimiter);
  }
  function formatTimezone(offset4, delimiter = "") {
    const sign = offset4 > 0 ? "-" : "+";
    const absOffset = Math.abs(offset4);
    const hours = addLeadingZeros(Math.trunc(absOffset / 60), 2);
    const minutes = addLeadingZeros(absOffset % 60, 2);
    return sign + hours + delimiter + minutes;
  }

  // ../../node_modules/date-fns/_lib/format/longFormatters.js
  var dateLongFormatter = (pattern, formatLong2) => {
    switch (pattern) {
      case "P":
        return formatLong2.date({ width: "short" });
      case "PP":
        return formatLong2.date({ width: "medium" });
      case "PPP":
        return formatLong2.date({ width: "long" });
      case "PPPP":
      default:
        return formatLong2.date({ width: "full" });
    }
  };
  var timeLongFormatter = (pattern, formatLong2) => {
    switch (pattern) {
      case "p":
        return formatLong2.time({ width: "short" });
      case "pp":
        return formatLong2.time({ width: "medium" });
      case "ppp":
        return formatLong2.time({ width: "long" });
      case "pppp":
      default:
        return formatLong2.time({ width: "full" });
    }
  };
  var dateTimeLongFormatter = (pattern, formatLong2) => {
    const matchResult = pattern.match(/(P+)(p+)?/) || [];
    const datePattern = matchResult[1];
    const timePattern = matchResult[2];
    if (!timePattern) {
      return dateLongFormatter(pattern, formatLong2);
    }
    let dateTimeFormat;
    switch (datePattern) {
      case "P":
        dateTimeFormat = formatLong2.dateTime({ width: "short" });
        break;
      case "PP":
        dateTimeFormat = formatLong2.dateTime({ width: "medium" });
        break;
      case "PPP":
        dateTimeFormat = formatLong2.dateTime({ width: "long" });
        break;
      case "PPPP":
      default:
        dateTimeFormat = formatLong2.dateTime({ width: "full" });
        break;
    }
    return dateTimeFormat.replace("{{date}}", dateLongFormatter(datePattern, formatLong2)).replace("{{time}}", timeLongFormatter(timePattern, formatLong2));
  };
  var longFormatters = {
    p: timeLongFormatter,
    P: dateTimeLongFormatter
  };

  // ../../node_modules/date-fns/_lib/protectedTokens.js
  var dayOfYearTokenRE = /^D+$/;
  var weekYearTokenRE = /^Y+$/;
  var throwTokens = ["D", "DD", "YY", "YYYY"];
  function isProtectedDayOfYearToken(token) {
    return dayOfYearTokenRE.test(token);
  }
  function isProtectedWeekYearToken(token) {
    return weekYearTokenRE.test(token);
  }
  function warnOrThrowProtectedError(token, format2, input) {
    const _message = message(token, format2, input);
    console.warn(_message);
    if (throwTokens.includes(token)) throw new RangeError(_message);
  }
  function message(token, format2, input) {
    const subject = token[0] === "Y" ? "years" : "days of the month";
    return `Use \`${token.toLowerCase()}\` instead of \`${token}\` (in \`${format2}\`) for formatting ${subject} to the input \`${input}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`;
  }

  // ../../node_modules/date-fns/format.js
  var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
  var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
  var escapedStringRegExp = /^'([^]*?)'?$/;
  var doubleQuoteRegExp = /''/g;
  var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
  function format(date, formatStr, options) {
    const defaultOptions2 = getDefaultOptions();
    const locale = options?.locale ?? defaultOptions2.locale ?? enUS;
    const firstWeekContainsDate = options?.firstWeekContainsDate ?? options?.locale?.options?.firstWeekContainsDate ?? defaultOptions2.firstWeekContainsDate ?? defaultOptions2.locale?.options?.firstWeekContainsDate ?? 1;
    const weekStartsOn = options?.weekStartsOn ?? options?.locale?.options?.weekStartsOn ?? defaultOptions2.weekStartsOn ?? defaultOptions2.locale?.options?.weekStartsOn ?? 0;
    const originalDate = toDate(date, options?.in);
    if (!isValid(originalDate)) {
      throw new RangeError("Invalid time value");
    }
    let parts = formatStr.match(longFormattingTokensRegExp).map((substring) => {
      const firstCharacter = substring[0];
      if (firstCharacter === "p" || firstCharacter === "P") {
        const longFormatter = longFormatters[firstCharacter];
        return longFormatter(substring, locale.formatLong);
      }
      return substring;
    }).join("").match(formattingTokensRegExp).map((substring) => {
      if (substring === "''") {
        return { isToken: false, value: "'" };
      }
      const firstCharacter = substring[0];
      if (firstCharacter === "'") {
        return { isToken: false, value: cleanEscapedString(substring) };
      }
      if (formatters[firstCharacter]) {
        return { isToken: true, value: substring };
      }
      if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
        throw new RangeError(
          "Format string contains an unescaped latin alphabet character `" + firstCharacter + "`"
        );
      }
      return { isToken: false, value: substring };
    });
    if (locale.localize.preprocessor) {
      parts = locale.localize.preprocessor(originalDate, parts);
    }
    const formatterOptions = {
      firstWeekContainsDate,
      weekStartsOn,
      locale
    };
    return parts.map((part) => {
      if (!part.isToken) return part.value;
      const token = part.value;
      if (!options?.useAdditionalWeekYearTokens && isProtectedWeekYearToken(token) || !options?.useAdditionalDayOfYearTokens && isProtectedDayOfYearToken(token)) {
        warnOrThrowProtectedError(token, formatStr, String(date));
      }
      const formatter = formatters[token[0]];
      return formatter(originalDate, token, locale.localize, formatterOptions);
    }).join("");
  }
  function cleanEscapedString(input) {
    const matched = input.match(escapedStringRegExp);
    if (!matched) {
      return input;
    }
    return matched[1].replace(doubleQuoteRegExp, "'");
  }

  // ../../node_modules/date-fns/getDaysInMonth.js
  function getDaysInMonth(date, options) {
    const _date = toDate(date, options?.in);
    const year = _date.getFullYear();
    const monthIndex = _date.getMonth();
    const lastDayOfMonth = constructFrom(_date, 0);
    lastDayOfMonth.setFullYear(year, monthIndex + 1, 0);
    lastDayOfMonth.setHours(0, 0, 0, 0);
    return lastDayOfMonth.getDate();
  }

  // ../../node_modules/date-fns/getMonth.js
  function getMonth(date, options) {
    return toDate(date, options?.in).getMonth();
  }

  // ../../node_modules/date-fns/getYear.js
  function getYear(date, options) {
    return toDate(date, options?.in).getFullYear();
  }

  // ../../node_modules/date-fns/isAfter.js
  function isAfter(date, dateToCompare) {
    return +toDate(date) > +toDate(dateToCompare);
  }

  // ../../node_modules/date-fns/isBefore.js
  function isBefore(date, dateToCompare) {
    return +toDate(date) < +toDate(dateToCompare);
  }

  // ../../node_modules/date-fns/isSameMonth.js
  function isSameMonth(laterDate, earlierDate, options) {
    const [laterDate_, earlierDate_] = normalizeDates(
      options?.in,
      laterDate,
      earlierDate
    );
    return laterDate_.getFullYear() === earlierDate_.getFullYear() && laterDate_.getMonth() === earlierDate_.getMonth();
  }

  // ../../node_modules/date-fns/isSameYear.js
  function isSameYear(laterDate, earlierDate, options) {
    const [laterDate_, earlierDate_] = normalizeDates(
      options?.in,
      laterDate,
      earlierDate
    );
    return laterDate_.getFullYear() === earlierDate_.getFullYear();
  }

  // ../../node_modules/date-fns/setMonth.js
  function setMonth(date, month, options) {
    const _date = toDate(date, options?.in);
    const year = _date.getFullYear();
    const day = _date.getDate();
    const midMonth = constructFrom(options?.in || date, 0);
    midMonth.setFullYear(year, month, 15);
    midMonth.setHours(0, 0, 0, 0);
    const daysInMonth = getDaysInMonth(midMonth);
    _date.setMonth(month, Math.min(day, daysInMonth));
    return _date;
  }

  // ../../node_modules/date-fns/setYear.js
  function setYear(date, year, options) {
    const date_ = toDate(date, options?.in);
    if (isNaN(+date_)) return constructFrom(options?.in || date, NaN);
    date_.setFullYear(year);
    return date_;
  }

  // ../../node_modules/react-day-picker/dist/esm/helpers/getBroadcastWeeksInMonth.js
  var FIVE_WEEKS = 5;
  var FOUR_WEEKS = 4;
  function getBroadcastWeeksInMonth(month, dateLib) {
    const firstDayOfMonth = dateLib.startOfMonth(month);
    const firstDayOfWeek = firstDayOfMonth.getDay() > 0 ? firstDayOfMonth.getDay() : 7;
    const broadcastStartDate = dateLib.addDays(month, -firstDayOfWeek + 1);
    const lastDateOfLastWeek = dateLib.addDays(broadcastStartDate, FIVE_WEEKS * 7 - 1);
    const numberOfWeeks = dateLib.getMonth(month) === dateLib.getMonth(lastDateOfLastWeek) ? FIVE_WEEKS : FOUR_WEEKS;
    return numberOfWeeks;
  }

  // ../../node_modules/react-day-picker/dist/esm/helpers/startOfBroadcastWeek.js
  function startOfBroadcastWeek(date, dateLib) {
    const firstOfMonth = dateLib.startOfMonth(date);
    const dayOfWeek = firstOfMonth.getDay();
    if (dayOfWeek === 1) {
      return firstOfMonth;
    } else if (dayOfWeek === 0) {
      return dateLib.addDays(firstOfMonth, -1 * 6);
    } else {
      return dateLib.addDays(firstOfMonth, -1 * (dayOfWeek - 1));
    }
  }

  // ../../node_modules/react-day-picker/dist/esm/helpers/endOfBroadcastWeek.js
  function endOfBroadcastWeek(date, dateLib) {
    const startDate = startOfBroadcastWeek(date, dateLib);
    const numberOfWeeks = getBroadcastWeeksInMonth(date, dateLib);
    const endDate = dateLib.addDays(startDate, numberOfWeeks * 7 - 1);
    return endDate;
  }

  // ../../node_modules/react-day-picker/dist/esm/locale/en-US.js
  var enUS2 = {
    ...enUS,
    labels: {
      labelDayButton: (date, modifiers, options, dateLib) => {
        let formatDate;
        if (dateLib && typeof dateLib.format === "function") {
          formatDate = dateLib.format.bind(dateLib);
        } else {
          formatDate = (d, pattern) => format(d, pattern, { locale: enUS, ...options });
        }
        let label = formatDate(date, "PPPP");
        if (modifiers.today)
          label = `Today, ${label}`;
        if (modifiers.selected)
          label = `${label}, selected`;
        return label;
      },
      labelMonthDropdown: "Choose the Month",
      labelNext: "Go to the Next Month",
      labelPrevious: "Go to the Previous Month",
      labelWeekNumber: (weekNumber) => `Week ${weekNumber}`,
      labelYearDropdown: "Choose the Year",
      labelGrid: (date, options, dateLib) => {
        let formatDate;
        if (dateLib && typeof dateLib.format === "function") {
          formatDate = dateLib.format.bind(dateLib);
        } else {
          formatDate = (d, pattern) => format(d, pattern, { locale: enUS, ...options });
        }
        return formatDate(date, "LLLL yyyy");
      },
      labelGridcell: (date, modifiers, options, dateLib) => {
        let formatDate;
        if (dateLib && typeof dateLib.format === "function") {
          formatDate = dateLib.format.bind(dateLib);
        } else {
          formatDate = (d, pattern) => format(d, pattern, { locale: enUS, ...options });
        }
        let label = formatDate(date, "PPPP");
        if (modifiers?.today) {
          label = `Today, ${label}`;
        }
        return label;
      },
      labelNav: "Navigation bar",
      labelWeekNumberHeader: "Week Number",
      labelWeekday: (date, options, dateLib) => {
        let formatDate;
        if (dateLib && typeof dateLib.format === "function") {
          formatDate = dateLib.format.bind(dateLib);
        } else {
          formatDate = (d, pattern) => format(d, pattern, { locale: enUS, ...options });
        }
        return formatDate(date, "cccc");
      }
    }
  };

  // ../../node_modules/react-day-picker/dist/esm/classes/DateLib.js
  var DateLib = class _DateLib {
    /**
     * Creates an instance of `DateLib`.
     *
     * @param options Configuration options for the date library.
     * @param overrides Custom overrides for the date library functions.
     */
    constructor(options, overrides) {
      this.Date = Date;
      this.today = () => {
        if (this.overrides?.today) {
          return this.overrides.today();
        }
        if (this.options.timeZone) {
          return TZDate.tz(this.options.timeZone);
        }
        return new this.Date();
      };
      this.newDate = (year, monthIndex, date) => {
        if (this.overrides?.newDate) {
          return this.overrides.newDate(year, monthIndex, date);
        }
        if (this.options.timeZone) {
          return new TZDate(year, monthIndex, date, this.options.timeZone);
        }
        return new Date(year, monthIndex, date);
      };
      this.addDays = (date, amount) => {
        return this.overrides?.addDays ? this.overrides.addDays(date, amount) : addDays(date, amount);
      };
      this.addMonths = (date, amount) => {
        return this.overrides?.addMonths ? this.overrides.addMonths(date, amount) : addMonths(date, amount);
      };
      this.addWeeks = (date, amount) => {
        return this.overrides?.addWeeks ? this.overrides.addWeeks(date, amount) : addWeeks(date, amount);
      };
      this.addYears = (date, amount) => {
        return this.overrides?.addYears ? this.overrides.addYears(date, amount) : addYears(date, amount);
      };
      this.differenceInCalendarDays = (dateLeft, dateRight) => {
        return this.overrides?.differenceInCalendarDays ? this.overrides.differenceInCalendarDays(dateLeft, dateRight) : differenceInCalendarDays(dateLeft, dateRight);
      };
      this.differenceInCalendarMonths = (dateLeft, dateRight) => {
        return this.overrides?.differenceInCalendarMonths ? this.overrides.differenceInCalendarMonths(dateLeft, dateRight) : differenceInCalendarMonths(dateLeft, dateRight);
      };
      this.eachMonthOfInterval = (interval) => {
        return this.overrides?.eachMonthOfInterval ? this.overrides.eachMonthOfInterval(interval) : eachMonthOfInterval(interval);
      };
      this.eachYearOfInterval = (interval) => {
        const years = this.overrides?.eachYearOfInterval ? this.overrides.eachYearOfInterval(interval) : eachYearOfInterval(interval);
        const uniqueYears = new Set(years.map((d) => this.getYear(d)));
        if (uniqueYears.size === years.length) {
          return years;
        }
        const yearsArray = [];
        uniqueYears.forEach((y2) => {
          yearsArray.push(new Date(y2, 0, 1));
        });
        return yearsArray;
      };
      this.endOfBroadcastWeek = (date) => {
        return this.overrides?.endOfBroadcastWeek ? this.overrides.endOfBroadcastWeek(date) : endOfBroadcastWeek(date, this);
      };
      this.endOfISOWeek = (date) => {
        return this.overrides?.endOfISOWeek ? this.overrides.endOfISOWeek(date) : endOfISOWeek(date);
      };
      this.endOfMonth = (date) => {
        return this.overrides?.endOfMonth ? this.overrides.endOfMonth(date) : endOfMonth(date);
      };
      this.endOfWeek = (date, options2) => {
        return this.overrides?.endOfWeek ? this.overrides.endOfWeek(date, options2) : endOfWeek(date, this.options);
      };
      this.endOfYear = (date) => {
        return this.overrides?.endOfYear ? this.overrides.endOfYear(date) : endOfYear(date);
      };
      this.format = (date, formatStr, _options) => {
        const formatted = this.overrides?.format ? this.overrides.format(date, formatStr, this.options) : format(date, formatStr, this.options);
        if (this.options.numerals && this.options.numerals !== "latn") {
          return this.replaceDigits(formatted);
        }
        return formatted;
      };
      this.getISOWeek = (date) => {
        return this.overrides?.getISOWeek ? this.overrides.getISOWeek(date) : getISOWeek(date);
      };
      this.getMonth = (date, _options) => {
        return this.overrides?.getMonth ? this.overrides.getMonth(date, this.options) : getMonth(date, this.options);
      };
      this.getYear = (date, _options) => {
        return this.overrides?.getYear ? this.overrides.getYear(date, this.options) : getYear(date, this.options);
      };
      this.getWeek = (date, _options) => {
        return this.overrides?.getWeek ? this.overrides.getWeek(date, this.options) : getWeek(date, this.options);
      };
      this.isAfter = (date, dateToCompare) => {
        return this.overrides?.isAfter ? this.overrides.isAfter(date, dateToCompare) : isAfter(date, dateToCompare);
      };
      this.isBefore = (date, dateToCompare) => {
        return this.overrides?.isBefore ? this.overrides.isBefore(date, dateToCompare) : isBefore(date, dateToCompare);
      };
      this.isDate = (value) => {
        return this.overrides?.isDate ? this.overrides.isDate(value) : isDate(value);
      };
      this.isSameDay = (dateLeft, dateRight) => {
        return this.overrides?.isSameDay ? this.overrides.isSameDay(dateLeft, dateRight) : isSameDay(dateLeft, dateRight);
      };
      this.isSameMonth = (dateLeft, dateRight) => {
        return this.overrides?.isSameMonth ? this.overrides.isSameMonth(dateLeft, dateRight) : isSameMonth(dateLeft, dateRight);
      };
      this.isSameYear = (dateLeft, dateRight) => {
        return this.overrides?.isSameYear ? this.overrides.isSameYear(dateLeft, dateRight) : isSameYear(dateLeft, dateRight);
      };
      this.max = (dates) => {
        return this.overrides?.max ? this.overrides.max(dates) : max(dates);
      };
      this.min = (dates) => {
        return this.overrides?.min ? this.overrides.min(dates) : min(dates);
      };
      this.setMonth = (date, month) => {
        return this.overrides?.setMonth ? this.overrides.setMonth(date, month) : setMonth(date, month);
      };
      this.setYear = (date, year) => {
        return this.overrides?.setYear ? this.overrides.setYear(date, year) : setYear(date, year);
      };
      this.startOfBroadcastWeek = (date, _dateLib) => {
        return this.overrides?.startOfBroadcastWeek ? this.overrides.startOfBroadcastWeek(date, this) : startOfBroadcastWeek(date, this);
      };
      this.startOfDay = (date) => {
        return this.overrides?.startOfDay ? this.overrides.startOfDay(date) : startOfDay(date);
      };
      this.startOfISOWeek = (date) => {
        return this.overrides?.startOfISOWeek ? this.overrides.startOfISOWeek(date) : startOfISOWeek(date);
      };
      this.startOfMonth = (date) => {
        return this.overrides?.startOfMonth ? this.overrides.startOfMonth(date) : startOfMonth(date);
      };
      this.startOfWeek = (date, _options) => {
        return this.overrides?.startOfWeek ? this.overrides.startOfWeek(date, this.options) : startOfWeek(date, this.options);
      };
      this.startOfYear = (date) => {
        return this.overrides?.startOfYear ? this.overrides.startOfYear(date) : startOfYear(date);
      };
      this.options = { locale: enUS2, ...options };
      this.overrides = overrides;
    }
    /**
     * Generates a mapping of Arabic digits (0-9) to the target numbering system
     * digits.
     *
     * @since 9.5.0
     * @returns A record mapping Arabic digits to the target numerals.
     */
    getDigitMap() {
      const { numerals = "latn" } = this.options;
      const formatter = new Intl.NumberFormat("en-US", {
        numberingSystem: numerals
      });
      const digitMap = {};
      for (let i3 = 0; i3 < 10; i3++) {
        digitMap[i3.toString()] = formatter.format(i3);
      }
      return digitMap;
    }
    /**
     * Replaces Arabic digits in a string with the target numbering system digits.
     *
     * @since 9.5.0
     * @param input The string containing Arabic digits.
     * @returns The string with digits replaced.
     */
    replaceDigits(input) {
      const digitMap = this.getDigitMap();
      return input.replace(/\d/g, (digit) => digitMap[digit] || digit);
    }
    /**
     * Formats a number using the configured numbering system.
     *
     * @since 9.5.0
     * @param value The number to format.
     * @returns The formatted number as a string.
     */
    formatNumber(value) {
      return this.replaceDigits(value.toString());
    }
    /**
     * Returns the preferred ordering for month and year labels for the current
     * locale.
     */
    getMonthYearOrder() {
      const code = this.options.locale?.code;
      if (!code) {
        return "month-first";
      }
      return _DateLib.yearFirstLocales.has(code) ? "year-first" : "month-first";
    }
    /**
     * Formats the month/year pair respecting locale conventions.
     *
     * @since 9.11.0
     */
    formatMonthYear(date) {
      const { locale, timeZone, numerals } = this.options;
      const localeCode = locale?.code;
      if (localeCode && _DateLib.yearFirstLocales.has(localeCode)) {
        try {
          const intl = new Intl.DateTimeFormat(localeCode, {
            month: "long",
            year: "numeric",
            timeZone,
            numberingSystem: numerals
          });
          const formatted = intl.format(date);
          return formatted;
        } catch {
        }
      }
      const pattern = this.getMonthYearOrder() === "year-first" ? "y LLLL" : "LLLL y";
      return this.format(date, pattern);
    }
  };
  DateLib.yearFirstLocales = /* @__PURE__ */ new Set([
    "eu",
    "hu",
    "ja",
    "ja-Hira",
    "ja-JP",
    "ko",
    "ko-KR",
    "lt",
    "lt-LT",
    "lv",
    "lv-LV",
    "mn",
    "mn-MN",
    "zh",
    "zh-CN",
    "zh-HK",
    "zh-TW"
  ]);
  var defaultDateLib = new DateLib();

  // ../../node_modules/react-day-picker/dist/esm/classes/CalendarDay.js
  var CalendarDay = class {
    constructor(date, displayMonth, dateLib = defaultDateLib) {
      this.date = date;
      this.displayMonth = displayMonth;
      this.outside = Boolean(displayMonth && !dateLib.isSameMonth(date, displayMonth));
      this.dateLib = dateLib;
      this.isoDate = dateLib.format(date, "yyyy-MM-dd");
      this.displayMonthId = dateLib.format(displayMonth, "yyyy-MM");
      this.dateMonthId = dateLib.format(date, "yyyy-MM");
    }
    /**
     * Checks if this day is equal to another `CalendarDay`, considering both the
     * date and the displayed month.
     *
     * @param day The `CalendarDay` to compare with.
     * @returns `true` if the days are equal, otherwise `false`.
     */
    isEqualTo(day) {
      return this.dateLib.isSameDay(day.date, this.date) && this.dateLib.isSameMonth(day.displayMonth, this.displayMonth);
    }
  };

  // ../../node_modules/react-day-picker/dist/esm/classes/CalendarMonth.js
  var CalendarMonth = class {
    constructor(month, weeks) {
      this.date = month;
      this.weeks = weeks;
    }
  };

  // ../../node_modules/react-day-picker/dist/esm/classes/CalendarWeek.js
  var CalendarWeek = class {
    constructor(weekNumber, days) {
      this.days = days;
      this.weekNumber = weekNumber;
    }
  };

  // ../../node_modules/react-day-picker/dist/esm/components/custom-components.js
  var custom_components_exports = {};
  __export(custom_components_exports, {
    Button: () => Button2,
    CaptionLabel: () => CaptionLabel,
    Chevron: () => Chevron,
    Day: () => Day,
    DayButton: () => DayButton,
    Dropdown: () => Dropdown,
    DropdownNav: () => DropdownNav,
    Footer: () => Footer,
    Month: () => Month,
    MonthCaption: () => MonthCaption,
    MonthGrid: () => MonthGrid,
    Months: () => Months,
    MonthsDropdown: () => MonthsDropdown,
    Nav: () => Nav,
    NextMonthButton: () => NextMonthButton,
    Option: () => Option,
    PreviousMonthButton: () => PreviousMonthButton,
    Root: () => Root2,
    Select: () => Select,
    Week: () => Week,
    WeekNumber: () => WeekNumber,
    WeekNumberHeader: () => WeekNumberHeader,
    Weekday: () => Weekday,
    Weekdays: () => Weekdays,
    Weeks: () => Weeks,
    YearsDropdown: () => YearsDropdown
  });

  // ../../node_modules/react-day-picker/dist/esm/components/Button.js
  var import_react33 = __toESM(require_react2(), 1);
  function Button2(props) {
    return import_react33.default.createElement("button", { ...props });
  }

  // ../../node_modules/react-day-picker/dist/esm/components/CaptionLabel.js
  var import_react34 = __toESM(require_react2(), 1);
  function CaptionLabel(props) {
    return import_react34.default.createElement("span", { ...props });
  }

  // ../../node_modules/react-day-picker/dist/esm/components/Chevron.js
  var import_react35 = __toESM(require_react2(), 1);
  function Chevron(props) {
    const { size: size4 = 24, orientation = "left", className } = props;
    return (
      // biome-ignore lint/a11y/noSvgWithoutTitle: handled by the parent component
      import_react35.default.createElement(
        "svg",
        { className, width: size4, height: size4, viewBox: "0 0 24 24" },
        orientation === "up" && import_react35.default.createElement("polygon", { points: "6.77 17 12.5 11.43 18.24 17 20 15.28 12.5 8 5 15.28" }),
        orientation === "down" && import_react35.default.createElement("polygon", { points: "6.77 8 12.5 13.57 18.24 8 20 9.72 12.5 17 5 9.72" }),
        orientation === "left" && import_react35.default.createElement("polygon", { points: "16 18.112 9.81111111 12 16 5.87733333 14.0888889 4 6 12 14.0888889 20" }),
        orientation === "right" && import_react35.default.createElement("polygon", { points: "8 18.112 14.18888889 12 8 5.87733333 9.91111111 4 18 12 9.91111111 20" })
      )
    );
  }

  // ../../node_modules/react-day-picker/dist/esm/components/Day.js
  var import_react36 = __toESM(require_react2(), 1);
  function Day(props) {
    const { day, modifiers, ...tdProps } = props;
    return import_react36.default.createElement("td", { ...tdProps });
  }

  // ../../node_modules/react-day-picker/dist/esm/components/DayButton.js
  var import_react37 = __toESM(require_react2(), 1);
  function DayButton(props) {
    const { day, modifiers, ...buttonProps } = props;
    const ref = import_react37.default.useRef(null);
    import_react37.default.useEffect(() => {
      if (modifiers.focused)
        ref.current?.focus();
    }, [modifiers.focused]);
    return import_react37.default.createElement("button", { ref, ...buttonProps });
  }

  // ../../node_modules/react-day-picker/dist/esm/components/Dropdown.js
  var import_react38 = __toESM(require_react2(), 1);

  // ../../node_modules/react-day-picker/dist/esm/UI.js
  var UI;
  (function(UI2) {
    UI2["Root"] = "root";
    UI2["Chevron"] = "chevron";
    UI2["Day"] = "day";
    UI2["DayButton"] = "day_button";
    UI2["CaptionLabel"] = "caption_label";
    UI2["Dropdowns"] = "dropdowns";
    UI2["Dropdown"] = "dropdown";
    UI2["DropdownRoot"] = "dropdown_root";
    UI2["Footer"] = "footer";
    UI2["MonthGrid"] = "month_grid";
    UI2["MonthCaption"] = "month_caption";
    UI2["MonthsDropdown"] = "months_dropdown";
    UI2["Month"] = "month";
    UI2["Months"] = "months";
    UI2["Nav"] = "nav";
    UI2["NextMonthButton"] = "button_next";
    UI2["PreviousMonthButton"] = "button_previous";
    UI2["Week"] = "week";
    UI2["Weeks"] = "weeks";
    UI2["Weekday"] = "weekday";
    UI2["Weekdays"] = "weekdays";
    UI2["WeekNumber"] = "week_number";
    UI2["WeekNumberHeader"] = "week_number_header";
    UI2["YearsDropdown"] = "years_dropdown";
  })(UI || (UI = {}));
  var DayFlag;
  (function(DayFlag2) {
    DayFlag2["disabled"] = "disabled";
    DayFlag2["hidden"] = "hidden";
    DayFlag2["outside"] = "outside";
    DayFlag2["focused"] = "focused";
    DayFlag2["today"] = "today";
  })(DayFlag || (DayFlag = {}));
  var SelectionState;
  (function(SelectionState2) {
    SelectionState2["range_end"] = "range_end";
    SelectionState2["range_middle"] = "range_middle";
    SelectionState2["range_start"] = "range_start";
    SelectionState2["selected"] = "selected";
  })(SelectionState || (SelectionState = {}));
  var Animation;
  (function(Animation3) {
    Animation3["weeks_before_enter"] = "weeks_before_enter";
    Animation3["weeks_before_exit"] = "weeks_before_exit";
    Animation3["weeks_after_enter"] = "weeks_after_enter";
    Animation3["weeks_after_exit"] = "weeks_after_exit";
    Animation3["caption_after_enter"] = "caption_after_enter";
    Animation3["caption_after_exit"] = "caption_after_exit";
    Animation3["caption_before_enter"] = "caption_before_enter";
    Animation3["caption_before_exit"] = "caption_before_exit";
  })(Animation || (Animation = {}));

  // ../../node_modules/react-day-picker/dist/esm/components/Dropdown.js
  function Dropdown(props) {
    const { options, className, components, classNames, ...selectProps } = props;
    const cssClassSelect = [classNames[UI.Dropdown], className].join(" ");
    const selectedOption = options?.find(({ value }) => value === selectProps.value);
    return import_react38.default.createElement(
      "span",
      { "data-disabled": selectProps.disabled, className: classNames[UI.DropdownRoot] },
      import_react38.default.createElement(components.Select, { className: cssClassSelect, ...selectProps }, options?.map(({ value, label, disabled }) => import_react38.default.createElement(components.Option, { key: value, value, disabled }, label))),
      import_react38.default.createElement(
        "span",
        { className: classNames[UI.CaptionLabel], "aria-hidden": true },
        selectedOption?.label,
        import_react38.default.createElement(components.Chevron, { orientation: "down", size: 18, className: classNames[UI.Chevron] })
      )
    );
  }

  // ../../node_modules/react-day-picker/dist/esm/components/DropdownNav.js
  var import_react39 = __toESM(require_react2(), 1);
  function DropdownNav(props) {
    return import_react39.default.createElement("div", { ...props });
  }

  // ../../node_modules/react-day-picker/dist/esm/components/Footer.js
  var import_react40 = __toESM(require_react2(), 1);
  function Footer(props) {
    return import_react40.default.createElement("div", { ...props });
  }

  // ../../node_modules/react-day-picker/dist/esm/components/Month.js
  var import_react41 = __toESM(require_react2(), 1);
  function Month(props) {
    const { calendarMonth, displayIndex, ...divProps } = props;
    return import_react41.default.createElement("div", { ...divProps }, props.children);
  }

  // ../../node_modules/react-day-picker/dist/esm/components/MonthCaption.js
  var import_react42 = __toESM(require_react2(), 1);
  function MonthCaption(props) {
    const { calendarMonth, displayIndex, ...divProps } = props;
    return import_react42.default.createElement("div", { ...divProps });
  }

  // ../../node_modules/react-day-picker/dist/esm/components/MonthGrid.js
  var import_react43 = __toESM(require_react2(), 1);
  function MonthGrid(props) {
    return import_react43.default.createElement("table", { ...props });
  }

  // ../../node_modules/react-day-picker/dist/esm/components/Months.js
  var import_react44 = __toESM(require_react2(), 1);
  function Months(props) {
    return import_react44.default.createElement("div", { ...props });
  }

  // ../../node_modules/react-day-picker/dist/esm/components/MonthsDropdown.js
  var import_react46 = __toESM(require_react2(), 1);

  // ../../node_modules/react-day-picker/dist/esm/useDayPicker.js
  var import_react45 = __toESM(require_react2(), 1);
  var dayPickerContext = (0, import_react45.createContext)(void 0);
  function useDayPicker() {
    const context = (0, import_react45.useContext)(dayPickerContext);
    if (context === void 0) {
      throw new Error("useDayPicker() must be used within a custom component.");
    }
    return context;
  }

  // ../../node_modules/react-day-picker/dist/esm/components/MonthsDropdown.js
  function MonthsDropdown(props) {
    const { components } = useDayPicker();
    return import_react46.default.createElement(components.Dropdown, { ...props });
  }

  // ../../node_modules/react-day-picker/dist/esm/components/Nav.js
  var import_react47 = __toESM(require_react2(), 1);
  function Nav(props) {
    const { onPreviousClick, onNextClick, previousMonth, nextMonth, ...navProps } = props;
    const { components, classNames, labels: { labelPrevious: labelPrevious2, labelNext: labelNext2 } } = useDayPicker();
    const handleNextClick = (0, import_react47.useCallback)((e2) => {
      if (nextMonth) {
        onNextClick?.(e2);
      }
    }, [nextMonth, onNextClick]);
    const handlePreviousClick = (0, import_react47.useCallback)((e2) => {
      if (previousMonth) {
        onPreviousClick?.(e2);
      }
    }, [previousMonth, onPreviousClick]);
    return import_react47.default.createElement(
      "nav",
      { ...navProps },
      import_react47.default.createElement(
        components.PreviousMonthButton,
        { type: "button", className: classNames[UI.PreviousMonthButton], tabIndex: previousMonth ? void 0 : -1, "aria-disabled": previousMonth ? void 0 : true, "aria-label": labelPrevious2(previousMonth), onClick: handlePreviousClick },
        import_react47.default.createElement(components.Chevron, { disabled: previousMonth ? void 0 : true, className: classNames[UI.Chevron], orientation: "left" })
      ),
      import_react47.default.createElement(
        components.NextMonthButton,
        { type: "button", className: classNames[UI.NextMonthButton], tabIndex: nextMonth ? void 0 : -1, "aria-disabled": nextMonth ? void 0 : true, "aria-label": labelNext2(nextMonth), onClick: handleNextClick },
        import_react47.default.createElement(components.Chevron, { disabled: nextMonth ? void 0 : true, orientation: "right", className: classNames[UI.Chevron] })
      )
    );
  }

  // ../../node_modules/react-day-picker/dist/esm/components/NextMonthButton.js
  var import_react48 = __toESM(require_react2(), 1);
  function NextMonthButton(props) {
    const { components } = useDayPicker();
    return import_react48.default.createElement(components.Button, { ...props });
  }

  // ../../node_modules/react-day-picker/dist/esm/components/Option.js
  var import_react49 = __toESM(require_react2(), 1);
  function Option(props) {
    return import_react49.default.createElement("option", { ...props });
  }

  // ../../node_modules/react-day-picker/dist/esm/components/PreviousMonthButton.js
  var import_react50 = __toESM(require_react2(), 1);
  function PreviousMonthButton(props) {
    const { components } = useDayPicker();
    return import_react50.default.createElement(components.Button, { ...props });
  }

  // ../../node_modules/react-day-picker/dist/esm/components/Root.js
  var import_react51 = __toESM(require_react2(), 1);
  function Root2(props) {
    const { rootRef, ...rest } = props;
    return import_react51.default.createElement("div", { ...rest, ref: rootRef });
  }

  // ../../node_modules/react-day-picker/dist/esm/components/Select.js
  var import_react52 = __toESM(require_react2(), 1);
  function Select(props) {
    return import_react52.default.createElement("select", { ...props });
  }

  // ../../node_modules/react-day-picker/dist/esm/components/Week.js
  var import_react53 = __toESM(require_react2(), 1);
  function Week(props) {
    const { week, ...trProps } = props;
    return import_react53.default.createElement("tr", { ...trProps });
  }

  // ../../node_modules/react-day-picker/dist/esm/components/Weekday.js
  var import_react54 = __toESM(require_react2(), 1);
  function Weekday(props) {
    return import_react54.default.createElement("th", { ...props });
  }

  // ../../node_modules/react-day-picker/dist/esm/components/Weekdays.js
  var import_react55 = __toESM(require_react2(), 1);
  function Weekdays(props) {
    return import_react55.default.createElement(
      "thead",
      { "aria-hidden": true },
      import_react55.default.createElement("tr", { ...props })
    );
  }

  // ../../node_modules/react-day-picker/dist/esm/components/WeekNumber.js
  var import_react56 = __toESM(require_react2(), 1);
  function WeekNumber(props) {
    const { week, ...thProps } = props;
    return import_react56.default.createElement("th", { ...thProps });
  }

  // ../../node_modules/react-day-picker/dist/esm/components/WeekNumberHeader.js
  var import_react57 = __toESM(require_react2(), 1);
  function WeekNumberHeader(props) {
    return import_react57.default.createElement("th", { ...props });
  }

  // ../../node_modules/react-day-picker/dist/esm/components/Weeks.js
  var import_react58 = __toESM(require_react2(), 1);
  function Weeks(props) {
    return import_react58.default.createElement("tbody", { ...props });
  }

  // ../../node_modules/react-day-picker/dist/esm/components/YearsDropdown.js
  var import_react59 = __toESM(require_react2(), 1);
  function YearsDropdown(props) {
    const { components } = useDayPicker();
    return import_react59.default.createElement(components.Dropdown, { ...props });
  }

  // ../../node_modules/react-day-picker/dist/esm/DayPicker.js
  var import_react64 = __toESM(require_react2(), 1);

  // ../../node_modules/react-day-picker/dist/esm/utils/rangeIncludesDate.js
  function rangeIncludesDate(range, date, excludeEnds = false, dateLib = defaultDateLib) {
    let { from, to: to2 } = range;
    const { differenceInCalendarDays: differenceInCalendarDays2, isSameDay: isSameDay2 } = dateLib;
    if (from && to2) {
      const isRangeInverted = differenceInCalendarDays2(to2, from) < 0;
      if (isRangeInverted) {
        [from, to2] = [to2, from];
      }
      const isInRange = differenceInCalendarDays2(date, from) >= (excludeEnds ? 1 : 0) && differenceInCalendarDays2(to2, date) >= (excludeEnds ? 1 : 0);
      return isInRange;
    }
    if (!excludeEnds && to2) {
      return isSameDay2(to2, date);
    }
    if (!excludeEnds && from) {
      return isSameDay2(from, date);
    }
    return false;
  }

  // ../../node_modules/react-day-picker/dist/esm/utils/typeguards.js
  function isDateInterval(matcher) {
    return Boolean(matcher && typeof matcher === "object" && "before" in matcher && "after" in matcher);
  }
  function isDateRange(value) {
    return Boolean(value && typeof value === "object" && "from" in value);
  }
  function isDateAfterType(value) {
    return Boolean(value && typeof value === "object" && "after" in value);
  }
  function isDateBeforeType(value) {
    return Boolean(value && typeof value === "object" && "before" in value);
  }
  function isDayOfWeekType(value) {
    return Boolean(value && typeof value === "object" && "dayOfWeek" in value);
  }
  function isDatesArray(value, dateLib) {
    return Array.isArray(value) && value.every(dateLib.isDate);
  }

  // ../../node_modules/react-day-picker/dist/esm/utils/dateMatchModifiers.js
  function dateMatchModifiers(date, matchers, dateLib = defaultDateLib) {
    const matchersArr = !Array.isArray(matchers) ? [matchers] : matchers;
    const { isSameDay: isSameDay2, differenceInCalendarDays: differenceInCalendarDays2, isAfter: isAfter2 } = dateLib;
    return matchersArr.some((matcher) => {
      if (typeof matcher === "boolean") {
        return matcher;
      }
      if (dateLib.isDate(matcher)) {
        return isSameDay2(date, matcher);
      }
      if (isDatesArray(matcher, dateLib)) {
        return matcher.some((matcherDate) => isSameDay2(date, matcherDate));
      }
      if (isDateRange(matcher)) {
        return rangeIncludesDate(matcher, date, false, dateLib);
      }
      if (isDayOfWeekType(matcher)) {
        if (!Array.isArray(matcher.dayOfWeek)) {
          return matcher.dayOfWeek === date.getDay();
        }
        return matcher.dayOfWeek.includes(date.getDay());
      }
      if (isDateInterval(matcher)) {
        const diffBefore = differenceInCalendarDays2(matcher.before, date);
        const diffAfter = differenceInCalendarDays2(matcher.after, date);
        const isDayBefore = diffBefore > 0;
        const isDayAfter = diffAfter < 0;
        const isClosedInterval = isAfter2(matcher.before, matcher.after);
        if (isClosedInterval) {
          return isDayAfter && isDayBefore;
        } else {
          return isDayBefore || isDayAfter;
        }
      }
      if (isDateAfterType(matcher)) {
        return differenceInCalendarDays2(date, matcher.after) > 0;
      }
      if (isDateBeforeType(matcher)) {
        return differenceInCalendarDays2(matcher.before, date) > 0;
      }
      if (typeof matcher === "function") {
        return matcher(date);
      }
      return false;
    });
  }

  // ../../node_modules/react-day-picker/dist/esm/helpers/createGetModifiers.js
  function createGetModifiers(days, props, navStart, navEnd, dateLib) {
    const { disabled, hidden, modifiers, showOutsideDays, broadcastCalendar, today = dateLib.today() } = props;
    const { isSameDay: isSameDay2, isSameMonth: isSameMonth2, startOfMonth: startOfMonth2, isBefore: isBefore2, endOfMonth: endOfMonth2, isAfter: isAfter2 } = dateLib;
    const computedNavStart = navStart && startOfMonth2(navStart);
    const computedNavEnd = navEnd && endOfMonth2(navEnd);
    const internalModifiersMap = {
      [DayFlag.focused]: [],
      [DayFlag.outside]: [],
      [DayFlag.disabled]: [],
      [DayFlag.hidden]: [],
      [DayFlag.today]: []
    };
    const customModifiersMap = {};
    for (const day of days) {
      const { date, displayMonth } = day;
      const isOutside = Boolean(displayMonth && !isSameMonth2(date, displayMonth));
      const isBeforeNavStart = Boolean(computedNavStart && isBefore2(date, computedNavStart));
      const isAfterNavEnd = Boolean(computedNavEnd && isAfter2(date, computedNavEnd));
      const isDisabled = Boolean(disabled && dateMatchModifiers(date, disabled, dateLib));
      const isHidden2 = Boolean(hidden && dateMatchModifiers(date, hidden, dateLib)) || isBeforeNavStart || isAfterNavEnd || // Broadcast calendar will show outside days as default
      !broadcastCalendar && !showOutsideDays && isOutside || broadcastCalendar && showOutsideDays === false && isOutside;
      const isToday = isSameDay2(date, today);
      if (isOutside)
        internalModifiersMap.outside.push(day);
      if (isDisabled)
        internalModifiersMap.disabled.push(day);
      if (isHidden2)
        internalModifiersMap.hidden.push(day);
      if (isToday)
        internalModifiersMap.today.push(day);
      if (modifiers) {
        Object.keys(modifiers).forEach((name) => {
          const modifierValue = modifiers?.[name];
          const isMatch = modifierValue ? dateMatchModifiers(date, modifierValue, dateLib) : false;
          if (!isMatch)
            return;
          if (customModifiersMap[name]) {
            customModifiersMap[name].push(day);
          } else {
            customModifiersMap[name] = [day];
          }
        });
      }
    }
    return (day) => {
      const dayFlags = {
        [DayFlag.focused]: false,
        [DayFlag.disabled]: false,
        [DayFlag.hidden]: false,
        [DayFlag.outside]: false,
        [DayFlag.today]: false
      };
      const customModifiers = {};
      for (const name in internalModifiersMap) {
        const days2 = internalModifiersMap[name];
        dayFlags[name] = days2.some((d) => d === day);
      }
      for (const name in customModifiersMap) {
        customModifiers[name] = customModifiersMap[name].some((d) => d === day);
      }
      return {
        ...dayFlags,
        // custom modifiers should override all the previous ones
        ...customModifiers
      };
    };
  }

  // ../../node_modules/react-day-picker/dist/esm/helpers/getClassNamesForModifiers.js
  function getClassNamesForModifiers(modifiers, classNames, modifiersClassNames = {}) {
    const modifierClassNames = Object.entries(modifiers).filter(([, active]) => active === true).reduce((previousValue, [key]) => {
      if (modifiersClassNames[key]) {
        previousValue.push(modifiersClassNames[key]);
      } else if (classNames[DayFlag[key]]) {
        previousValue.push(classNames[DayFlag[key]]);
      } else if (classNames[SelectionState[key]]) {
        previousValue.push(classNames[SelectionState[key]]);
      }
      return previousValue;
    }, [classNames[UI.Day]]);
    return modifierClassNames;
  }

  // ../../node_modules/react-day-picker/dist/esm/helpers/getComponents.js
  function getComponents(customComponents) {
    return {
      ...custom_components_exports,
      ...customComponents
    };
  }

  // ../../node_modules/react-day-picker/dist/esm/helpers/getDataAttributes.js
  function getDataAttributes(props) {
    const dataAttributes = {
      "data-mode": props.mode ?? void 0,
      "data-required": "required" in props ? props.required : void 0,
      "data-multiple-months": props.numberOfMonths && props.numberOfMonths > 1 || void 0,
      "data-week-numbers": props.showWeekNumber || void 0,
      "data-broadcast-calendar": props.broadcastCalendar || void 0,
      "data-nav-layout": props.navLayout || void 0
    };
    Object.entries(props).forEach(([key, val]) => {
      if (key.startsWith("data-")) {
        dataAttributes[key] = val;
      }
    });
    return dataAttributes;
  }

  // ../../node_modules/react-day-picker/dist/esm/helpers/getDefaultClassNames.js
  function getDefaultClassNames() {
    const classNames = {};
    for (const key in UI) {
      classNames[UI[key]] = `rdp-${UI[key]}`;
    }
    for (const key in DayFlag) {
      classNames[DayFlag[key]] = `rdp-${DayFlag[key]}`;
    }
    for (const key in SelectionState) {
      classNames[SelectionState[key]] = `rdp-${SelectionState[key]}`;
    }
    for (const key in Animation) {
      classNames[Animation[key]] = `rdp-${Animation[key]}`;
    }
    return classNames;
  }

  // ../../node_modules/react-day-picker/dist/esm/formatters/index.js
  var formatters_exports = {};
  __export(formatters_exports, {
    formatCaption: () => formatCaption,
    formatDay: () => formatDay,
    formatMonthCaption: () => formatMonthCaption,
    formatMonthDropdown: () => formatMonthDropdown,
    formatWeekNumber: () => formatWeekNumber,
    formatWeekNumberHeader: () => formatWeekNumberHeader,
    formatWeekdayName: () => formatWeekdayName,
    formatYearCaption: () => formatYearCaption,
    formatYearDropdown: () => formatYearDropdown
  });

  // ../../node_modules/react-day-picker/dist/esm/formatters/formatCaption.js
  function formatCaption(month, options, dateLib) {
    const lib = dateLib ?? new DateLib(options);
    return lib.formatMonthYear(month);
  }
  var formatMonthCaption = formatCaption;

  // ../../node_modules/react-day-picker/dist/esm/formatters/formatDay.js
  function formatDay(date, options, dateLib) {
    return (dateLib ?? new DateLib(options)).format(date, "d");
  }

  // ../../node_modules/react-day-picker/dist/esm/formatters/formatMonthDropdown.js
  function formatMonthDropdown(month, dateLib = defaultDateLib) {
    return dateLib.format(month, "LLLL");
  }

  // ../../node_modules/react-day-picker/dist/esm/formatters/formatWeekdayName.js
  function formatWeekdayName(weekday, options, dateLib) {
    return (dateLib ?? new DateLib(options)).format(weekday, "cccccc");
  }

  // ../../node_modules/react-day-picker/dist/esm/formatters/formatWeekNumber.js
  function formatWeekNumber(weekNumber, dateLib = defaultDateLib) {
    if (weekNumber < 10) {
      return dateLib.formatNumber(`0${weekNumber.toLocaleString()}`);
    }
    return dateLib.formatNumber(`${weekNumber.toLocaleString()}`);
  }

  // ../../node_modules/react-day-picker/dist/esm/formatters/formatWeekNumberHeader.js
  function formatWeekNumberHeader() {
    return ``;
  }

  // ../../node_modules/react-day-picker/dist/esm/formatters/formatYearDropdown.js
  function formatYearDropdown(year, dateLib = defaultDateLib) {
    return dateLib.format(year, "yyyy");
  }
  var formatYearCaption = formatYearDropdown;

  // ../../node_modules/react-day-picker/dist/esm/helpers/getFormatters.js
  function getFormatters(customFormatters) {
    if (customFormatters?.formatMonthCaption && !customFormatters.formatCaption) {
      customFormatters.formatCaption = customFormatters.formatMonthCaption;
    }
    if (customFormatters?.formatYearCaption && !customFormatters.formatYearDropdown) {
      customFormatters.formatYearDropdown = customFormatters.formatYearCaption;
    }
    return {
      ...formatters_exports,
      ...customFormatters
    };
  }

  // ../../node_modules/react-day-picker/dist/esm/labels/index.js
  var labels_exports = {};
  __export(labels_exports, {
    labelCaption: () => labelCaption,
    labelDay: () => labelDay,
    labelDayButton: () => labelDayButton,
    labelGrid: () => labelGrid,
    labelGridcell: () => labelGridcell,
    labelMonthDropdown: () => labelMonthDropdown,
    labelNav: () => labelNav,
    labelNext: () => labelNext,
    labelPrevious: () => labelPrevious,
    labelWeekNumber: () => labelWeekNumber,
    labelWeekNumberHeader: () => labelWeekNumberHeader,
    labelWeekday: () => labelWeekday,
    labelYearDropdown: () => labelYearDropdown
  });

  // ../../node_modules/react-day-picker/dist/esm/labels/labelDayButton.js
  function labelDayButton(date, modifiers, options, dateLib) {
    let label = (dateLib ?? new DateLib(options)).format(date, "PPPP");
    if (modifiers.today)
      label = `Today, ${label}`;
    if (modifiers.selected)
      label = `${label}, selected`;
    return label;
  }
  var labelDay = labelDayButton;

  // ../../node_modules/react-day-picker/dist/esm/labels/labelGrid.js
  function labelGrid(date, options, dateLib) {
    const lib = dateLib ?? new DateLib(options);
    return lib.formatMonthYear(date);
  }
  var labelCaption = labelGrid;

  // ../../node_modules/react-day-picker/dist/esm/labels/labelGridcell.js
  function labelGridcell(date, modifiers, options, dateLib) {
    let label = (dateLib ?? new DateLib(options)).format(date, "PPPP");
    if (modifiers?.today) {
      label = `Today, ${label}`;
    }
    return label;
  }

  // ../../node_modules/react-day-picker/dist/esm/labels/labelMonthDropdown.js
  function labelMonthDropdown(_options) {
    return "Choose the Month";
  }

  // ../../node_modules/react-day-picker/dist/esm/labels/labelNav.js
  function labelNav() {
    return "";
  }

  // ../../node_modules/react-day-picker/dist/esm/labels/labelNext.js
  var defaultLabel = "Go to the Next Month";
  function labelNext(_month, _options) {
    return defaultLabel;
  }

  // ../../node_modules/react-day-picker/dist/esm/labels/labelPrevious.js
  function labelPrevious(_month) {
    return "Go to the Previous Month";
  }

  // ../../node_modules/react-day-picker/dist/esm/labels/labelWeekday.js
  function labelWeekday(date, options, dateLib) {
    return (dateLib ?? new DateLib(options)).format(date, "cccc");
  }

  // ../../node_modules/react-day-picker/dist/esm/labels/labelWeekNumber.js
  function labelWeekNumber(weekNumber, _options) {
    return `Week ${weekNumber}`;
  }

  // ../../node_modules/react-day-picker/dist/esm/labels/labelWeekNumberHeader.js
  function labelWeekNumberHeader(_options) {
    return "Week Number";
  }

  // ../../node_modules/react-day-picker/dist/esm/labels/labelYearDropdown.js
  function labelYearDropdown(_options) {
    return "Choose the Year";
  }

  // ../../node_modules/react-day-picker/dist/esm/helpers/getLabels.js
  var resolveLabel = (defaultLabel2, customLabel, localeLabel) => {
    if (customLabel)
      return customLabel;
    if (localeLabel) {
      return typeof localeLabel === "function" ? localeLabel : (..._args) => localeLabel;
    }
    return defaultLabel2;
  };
  function getLabels(customLabels, options) {
    const localeLabels = options.locale?.labels ?? {};
    return {
      ...labels_exports,
      ...customLabels ?? {},
      labelDayButton: resolveLabel(labelDayButton, customLabels?.labelDayButton, localeLabels.labelDayButton),
      labelMonthDropdown: resolveLabel(labelMonthDropdown, customLabels?.labelMonthDropdown, localeLabels.labelMonthDropdown),
      labelNext: resolveLabel(labelNext, customLabels?.labelNext, localeLabels.labelNext),
      labelPrevious: resolveLabel(labelPrevious, customLabels?.labelPrevious, localeLabels.labelPrevious),
      labelWeekNumber: resolveLabel(labelWeekNumber, customLabels?.labelWeekNumber, localeLabels.labelWeekNumber),
      labelYearDropdown: resolveLabel(labelYearDropdown, customLabels?.labelYearDropdown, localeLabels.labelYearDropdown),
      labelGrid: resolveLabel(labelGrid, customLabels?.labelGrid, localeLabels.labelGrid),
      labelGridcell: resolveLabel(labelGridcell, customLabels?.labelGridcell, localeLabels.labelGridcell),
      labelNav: resolveLabel(labelNav, customLabels?.labelNav, localeLabels.labelNav),
      labelWeekNumberHeader: resolveLabel(labelWeekNumberHeader, customLabels?.labelWeekNumberHeader, localeLabels.labelWeekNumberHeader),
      labelWeekday: resolveLabel(labelWeekday, customLabels?.labelWeekday, localeLabels.labelWeekday)
    };
  }

  // ../../node_modules/react-day-picker/dist/esm/helpers/getMonthOptions.js
  function getMonthOptions(displayMonth, navStart, navEnd, formatters2, dateLib) {
    const { startOfMonth: startOfMonth2, startOfYear: startOfYear2, endOfYear: endOfYear2, eachMonthOfInterval: eachMonthOfInterval2, getMonth: getMonth2 } = dateLib;
    const months = eachMonthOfInterval2({
      start: startOfYear2(displayMonth),
      end: endOfYear2(displayMonth)
    });
    const options = months.map((month) => {
      const label = formatters2.formatMonthDropdown(month, dateLib);
      const value = getMonth2(month);
      const disabled = navStart && month < startOfMonth2(navStart) || navEnd && month > startOfMonth2(navEnd) || false;
      return { value, label, disabled };
    });
    return options;
  }

  // ../../node_modules/react-day-picker/dist/esm/helpers/getStyleForModifiers.js
  function getStyleForModifiers(dayModifiers, styles = {}, modifiersStyles = {}) {
    let style = { ...styles?.[UI.Day] };
    Object.entries(dayModifiers).filter(([, active]) => active === true).forEach(([modifier]) => {
      style = {
        ...style,
        ...modifiersStyles?.[modifier]
      };
    });
    return style;
  }

  // ../../node_modules/react-day-picker/dist/esm/helpers/getWeekdays.js
  function getWeekdays(dateLib, ISOWeek, broadcastCalendar, today) {
    const referenceToday = today ?? dateLib.today();
    const start2 = broadcastCalendar ? dateLib.startOfBroadcastWeek(referenceToday, dateLib) : ISOWeek ? dateLib.startOfISOWeek(referenceToday) : dateLib.startOfWeek(referenceToday);
    const days = [];
    for (let i3 = 0; i3 < 7; i3++) {
      const day = dateLib.addDays(start2, i3);
      days.push(day);
    }
    return days;
  }

  // ../../node_modules/react-day-picker/dist/esm/helpers/getYearOptions.js
  function getYearOptions(navStart, navEnd, formatters2, dateLib, reverse = false) {
    if (!navStart)
      return void 0;
    if (!navEnd)
      return void 0;
    const { startOfYear: startOfYear2, endOfYear: endOfYear2, eachYearOfInterval: eachYearOfInterval2, getYear: getYear2 } = dateLib;
    const firstNavYear = startOfYear2(navStart);
    const lastNavYear = endOfYear2(navEnd);
    const years = eachYearOfInterval2({ start: firstNavYear, end: lastNavYear });
    if (reverse)
      years.reverse();
    return years.map((year) => {
      const label = formatters2.formatYearDropdown(year, dateLib);
      return {
        value: getYear2(year),
        label,
        disabled: false
      };
    });
  }

  // ../../node_modules/react-day-picker/dist/esm/noonDateLib.js
  function createNoonOverrides(timeZone, options = {}) {
    const { weekStartsOn, locale } = options;
    const fallbackWeekStartsOn = weekStartsOn ?? locale?.options?.weekStartsOn ?? 0;
    const toNoonTZDate = (date) => {
      const normalizedDate = typeof date === "number" || typeof date === "string" ? new Date(date) : date;
      return new TZDate(normalizedDate.getFullYear(), normalizedDate.getMonth(), normalizedDate.getDate(), 12, 0, 0, timeZone);
    };
    const toCalendarDate = (date) => {
      const zoned = toNoonTZDate(date);
      return new Date(zoned.getFullYear(), zoned.getMonth(), zoned.getDate(), 0, 0, 0, 0);
    };
    return {
      today: () => {
        return toNoonTZDate(TZDate.tz(timeZone));
      },
      newDate: (year, monthIndex, date) => {
        return new TZDate(year, monthIndex, date, 12, 0, 0, timeZone);
      },
      startOfDay: (date) => {
        return toNoonTZDate(date);
      },
      startOfWeek: (date, options2) => {
        const base = toNoonTZDate(date);
        const weekStartsOnValue = options2?.weekStartsOn ?? fallbackWeekStartsOn;
        const diff = (base.getDay() - weekStartsOnValue + 7) % 7;
        base.setDate(base.getDate() - diff);
        return base;
      },
      startOfISOWeek: (date) => {
        const base = toNoonTZDate(date);
        const diff = (base.getDay() - 1 + 7) % 7;
        base.setDate(base.getDate() - diff);
        return base;
      },
      startOfMonth: (date) => {
        const base = toNoonTZDate(date);
        base.setDate(1);
        return base;
      },
      startOfYear: (date) => {
        const base = toNoonTZDate(date);
        base.setMonth(0, 1);
        return base;
      },
      endOfWeek: (date, options2) => {
        const base = toNoonTZDate(date);
        const weekStartsOnValue = options2?.weekStartsOn ?? fallbackWeekStartsOn;
        const endDow = (weekStartsOnValue + 6) % 7;
        const diff = (endDow - base.getDay() + 7) % 7;
        base.setDate(base.getDate() + diff);
        return base;
      },
      endOfISOWeek: (date) => {
        const base = toNoonTZDate(date);
        const diff = (7 - base.getDay()) % 7;
        base.setDate(base.getDate() + diff);
        return base;
      },
      endOfMonth: (date) => {
        const base = toNoonTZDate(date);
        base.setMonth(base.getMonth() + 1, 0);
        return base;
      },
      endOfYear: (date) => {
        const base = toNoonTZDate(date);
        base.setMonth(11, 31);
        return base;
      },
      eachMonthOfInterval: (interval) => {
        const start2 = toNoonTZDate(interval.start);
        const end = toNoonTZDate(interval.end);
        const result = [];
        const cursor = new TZDate(start2.getFullYear(), start2.getMonth(), 1, 12, 0, 0, timeZone);
        const endKey = end.getFullYear() * 12 + end.getMonth();
        while (cursor.getFullYear() * 12 + cursor.getMonth() <= endKey) {
          result.push(new TZDate(cursor, timeZone));
          cursor.setMonth(cursor.getMonth() + 1, 1);
        }
        return result;
      },
      // Normalize to noon once before arithmetic (avoid DST/midnight edge cases),
      // mutate the same TZDate, and return it.
      addDays: (date, amount) => {
        const base = toNoonTZDate(date);
        base.setDate(base.getDate() + amount);
        return base;
      },
      addWeeks: (date, amount) => {
        const base = toNoonTZDate(date);
        base.setDate(base.getDate() + amount * 7);
        return base;
      },
      addMonths: (date, amount) => {
        const base = toNoonTZDate(date);
        base.setMonth(base.getMonth() + amount);
        return base;
      },
      addYears: (date, amount) => {
        const base = toNoonTZDate(date);
        base.setFullYear(base.getFullYear() + amount);
        return base;
      },
      eachYearOfInterval: (interval) => {
        const start2 = toNoonTZDate(interval.start);
        const end = toNoonTZDate(interval.end);
        const years = [];
        const cursor = new TZDate(start2.getFullYear(), 0, 1, 12, 0, 0, timeZone);
        while (cursor.getFullYear() <= end.getFullYear()) {
          years.push(new TZDate(cursor, timeZone));
          cursor.setFullYear(cursor.getFullYear() + 1, 0, 1);
        }
        return years;
      },
      getWeek: (date, options2) => {
        const base = toCalendarDate(date);
        return getWeek(base, {
          weekStartsOn: options2?.weekStartsOn ?? fallbackWeekStartsOn,
          firstWeekContainsDate: options2?.firstWeekContainsDate ?? locale?.options?.firstWeekContainsDate ?? 1
        });
      },
      getISOWeek: (date) => {
        const base = toCalendarDate(date);
        return getISOWeek(base);
      },
      differenceInCalendarDays: (dateLeft, dateRight) => {
        const left = toCalendarDate(dateLeft);
        const right = toCalendarDate(dateRight);
        return differenceInCalendarDays(left, right);
      },
      differenceInCalendarMonths: (dateLeft, dateRight) => {
        const left = toCalendarDate(dateLeft);
        const right = toCalendarDate(dateRight);
        return differenceInCalendarMonths(left, right);
      }
    };
  }

  // ../../node_modules/react-day-picker/dist/esm/useAnimation.js
  var import_react60 = __toESM(require_react2(), 1);
  var asHtmlElement = (element) => {
    if (element instanceof HTMLElement)
      return element;
    return null;
  };
  var queryMonthEls = (element) => [
    ...element.querySelectorAll("[data-animated-month]") ?? []
  ];
  var queryMonthEl = (element) => asHtmlElement(element.querySelector("[data-animated-month]"));
  var queryCaptionEl = (element) => asHtmlElement(element.querySelector("[data-animated-caption]"));
  var queryWeeksEl = (element) => asHtmlElement(element.querySelector("[data-animated-weeks]"));
  var queryNavEl = (element) => asHtmlElement(element.querySelector("[data-animated-nav]"));
  var queryWeekdaysEl = (element) => asHtmlElement(element.querySelector("[data-animated-weekdays]"));
  function useAnimation(rootElRef, enabled, { classNames, months, focused, dateLib }) {
    const previousRootElSnapshotRef = (0, import_react60.useRef)(null);
    const previousMonthsRef = (0, import_react60.useRef)(months);
    const animatingRef = (0, import_react60.useRef)(false);
    (0, import_react60.useLayoutEffect)(() => {
      const previousMonths = previousMonthsRef.current;
      previousMonthsRef.current = months;
      if (!enabled || !rootElRef.current || // safety check because the ref can be set to anything by consumers
      !(rootElRef.current instanceof HTMLElement) || // validation required for the animation to work as expected
      months.length === 0 || previousMonths.length === 0 || months.length !== previousMonths.length) {
        return;
      }
      const isSameMonth2 = dateLib.isSameMonth(months[0].date, previousMonths[0].date);
      const isAfterPreviousMonth = dateLib.isAfter(months[0].date, previousMonths[0].date);
      const captionAnimationClass = isAfterPreviousMonth ? classNames[Animation.caption_after_enter] : classNames[Animation.caption_before_enter];
      const weeksAnimationClass = isAfterPreviousMonth ? classNames[Animation.weeks_after_enter] : classNames[Animation.weeks_before_enter];
      const previousRootElSnapshot = previousRootElSnapshotRef.current;
      const rootElSnapshot = rootElRef.current.cloneNode(true);
      if (rootElSnapshot instanceof HTMLElement) {
        const currentMonthElsSnapshot = queryMonthEls(rootElSnapshot);
        currentMonthElsSnapshot.forEach((currentMonthElSnapshot) => {
          if (!(currentMonthElSnapshot instanceof HTMLElement))
            return;
          const previousMonthElSnapshot = queryMonthEl(currentMonthElSnapshot);
          if (previousMonthElSnapshot && currentMonthElSnapshot.contains(previousMonthElSnapshot)) {
            currentMonthElSnapshot.removeChild(previousMonthElSnapshot);
          }
          const captionEl = queryCaptionEl(currentMonthElSnapshot);
          if (captionEl) {
            captionEl.classList.remove(captionAnimationClass);
          }
          const weeksEl = queryWeeksEl(currentMonthElSnapshot);
          if (weeksEl) {
            weeksEl.classList.remove(weeksAnimationClass);
          }
        });
        previousRootElSnapshotRef.current = rootElSnapshot;
      } else {
        previousRootElSnapshotRef.current = null;
      }
      if (animatingRef.current || isSameMonth2 || // skip animation if a day is focused because it can cause issues to the animation and is better for a11y
      focused) {
        return;
      }
      const previousMonthEls = previousRootElSnapshot instanceof HTMLElement ? queryMonthEls(previousRootElSnapshot) : [];
      const currentMonthEls = queryMonthEls(rootElRef.current);
      if (currentMonthEls?.every((el) => el instanceof HTMLElement) && previousMonthEls && previousMonthEls.every((el) => el instanceof HTMLElement)) {
        animatingRef.current = true;
        const cleanUpFunctions = [];
        rootElRef.current.style.isolation = "isolate";
        const navEl = queryNavEl(rootElRef.current);
        if (navEl) {
          navEl.style.zIndex = "1";
        }
        currentMonthEls.forEach((currentMonthEl, index2) => {
          const previousMonthEl = previousMonthEls[index2];
          if (!previousMonthEl) {
            return;
          }
          currentMonthEl.style.position = "relative";
          currentMonthEl.style.overflow = "hidden";
          const captionEl = queryCaptionEl(currentMonthEl);
          if (captionEl) {
            captionEl.classList.add(captionAnimationClass);
          }
          const weeksEl = queryWeeksEl(currentMonthEl);
          if (weeksEl) {
            weeksEl.classList.add(weeksAnimationClass);
          }
          const cleanUp = () => {
            animatingRef.current = false;
            if (rootElRef.current) {
              rootElRef.current.style.isolation = "";
            }
            if (navEl) {
              navEl.style.zIndex = "";
            }
            if (captionEl) {
              captionEl.classList.remove(captionAnimationClass);
            }
            if (weeksEl) {
              weeksEl.classList.remove(weeksAnimationClass);
            }
            currentMonthEl.style.position = "";
            currentMonthEl.style.overflow = "";
            if (currentMonthEl.contains(previousMonthEl)) {
              currentMonthEl.removeChild(previousMonthEl);
            }
          };
          cleanUpFunctions.push(cleanUp);
          previousMonthEl.style.pointerEvents = "none";
          previousMonthEl.style.position = "absolute";
          previousMonthEl.style.overflow = "hidden";
          previousMonthEl.setAttribute("aria-hidden", "true");
          const previousWeekdaysEl = queryWeekdaysEl(previousMonthEl);
          if (previousWeekdaysEl) {
            previousWeekdaysEl.style.opacity = "0";
          }
          const previousCaptionEl = queryCaptionEl(previousMonthEl);
          if (previousCaptionEl) {
            previousCaptionEl.classList.add(isAfterPreviousMonth ? classNames[Animation.caption_before_exit] : classNames[Animation.caption_after_exit]);
            previousCaptionEl.addEventListener("animationend", cleanUp);
          }
          const previousWeeksEl = queryWeeksEl(previousMonthEl);
          if (previousWeeksEl) {
            previousWeeksEl.classList.add(isAfterPreviousMonth ? classNames[Animation.weeks_before_exit] : classNames[Animation.weeks_after_exit]);
          }
          currentMonthEl.insertBefore(previousMonthEl, currentMonthEl.firstChild);
        });
      }
    });
  }

  // ../../node_modules/react-day-picker/dist/esm/useCalendar.js
  var import_react62 = __toESM(require_react2(), 1);

  // ../../node_modules/react-day-picker/dist/esm/helpers/getDates.js
  function getDates(displayMonths, maxDate, props, dateLib) {
    const firstMonth = displayMonths[0];
    const lastMonth = displayMonths[displayMonths.length - 1];
    const { ISOWeek, fixedWeeks, broadcastCalendar } = props ?? {};
    const { addDays: addDays2, differenceInCalendarDays: differenceInCalendarDays2, differenceInCalendarMonths: differenceInCalendarMonths2, endOfBroadcastWeek: endOfBroadcastWeek2, endOfISOWeek: endOfISOWeek2, endOfMonth: endOfMonth2, endOfWeek: endOfWeek2, isAfter: isAfter2, startOfBroadcastWeek: startOfBroadcastWeek2, startOfISOWeek: startOfISOWeek2, startOfWeek: startOfWeek2 } = dateLib;
    const startWeekFirstDate = broadcastCalendar ? startOfBroadcastWeek2(firstMonth, dateLib) : ISOWeek ? startOfISOWeek2(firstMonth) : startOfWeek2(firstMonth);
    const displayMonthsWeekEnd = broadcastCalendar ? endOfBroadcastWeek2(lastMonth) : ISOWeek ? endOfISOWeek2(endOfMonth2(lastMonth)) : endOfWeek2(endOfMonth2(lastMonth));
    const constraintWeekEnd = maxDate && (broadcastCalendar ? endOfBroadcastWeek2(maxDate) : ISOWeek ? endOfISOWeek2(maxDate) : endOfWeek2(maxDate));
    const gridEndDate = constraintWeekEnd && isAfter2(displayMonthsWeekEnd, constraintWeekEnd) ? constraintWeekEnd : displayMonthsWeekEnd;
    const nOfDays = differenceInCalendarDays2(gridEndDate, startWeekFirstDate);
    const nOfMonths = differenceInCalendarMonths2(lastMonth, firstMonth) + 1;
    const dates = [];
    for (let i3 = 0; i3 <= nOfDays; i3++) {
      const date = addDays2(startWeekFirstDate, i3);
      dates.push(date);
    }
    const nrOfDaysWithFixedWeeks = broadcastCalendar ? 35 : 42;
    const extraDates = nrOfDaysWithFixedWeeks * nOfMonths;
    if (fixedWeeks && dates.length < extraDates) {
      const daysToAdd = extraDates - dates.length;
      for (let i3 = 0; i3 < daysToAdd; i3++) {
        const date = addDays2(dates[dates.length - 1], 1);
        dates.push(date);
      }
    }
    return dates;
  }

  // ../../node_modules/react-day-picker/dist/esm/helpers/getDays.js
  function getDays(calendarMonths) {
    const initialDays = [];
    return calendarMonths.reduce((days, month) => {
      const weekDays = month.weeks.reduce((weekDays2, week) => {
        return weekDays2.concat(week.days.slice());
      }, initialDays.slice());
      return days.concat(weekDays.slice());
    }, initialDays.slice());
  }

  // ../../node_modules/react-day-picker/dist/esm/helpers/getDisplayMonths.js
  function getDisplayMonths(firstDisplayedMonth, calendarEndMonth, props, dateLib) {
    const { numberOfMonths = 1 } = props;
    const months = [];
    for (let i3 = 0; i3 < numberOfMonths; i3++) {
      const month = dateLib.addMonths(firstDisplayedMonth, i3);
      if (calendarEndMonth && month > calendarEndMonth) {
        break;
      }
      months.push(month);
    }
    return months;
  }

  // ../../node_modules/react-day-picker/dist/esm/helpers/getInitialMonth.js
  function getInitialMonth(props, navStart, navEnd, dateLib) {
    const { month, defaultMonth, today = dateLib.today(), numberOfMonths = 1 } = props;
    let initialMonth = month || defaultMonth || today;
    const { differenceInCalendarMonths: differenceInCalendarMonths2, addMonths: addMonths2, startOfMonth: startOfMonth2 } = dateLib;
    if (navEnd && differenceInCalendarMonths2(navEnd, initialMonth) < numberOfMonths - 1) {
      const offset4 = -1 * (numberOfMonths - 1);
      initialMonth = addMonths2(navEnd, offset4);
    }
    if (navStart && differenceInCalendarMonths2(initialMonth, navStart) < 0) {
      initialMonth = navStart;
    }
    return startOfMonth2(initialMonth);
  }

  // ../../node_modules/react-day-picker/dist/esm/helpers/getMonths.js
  function getMonths(displayMonths, dates, props, dateLib) {
    const { addDays: addDays2, endOfBroadcastWeek: endOfBroadcastWeek2, endOfISOWeek: endOfISOWeek2, endOfMonth: endOfMonth2, endOfWeek: endOfWeek2, getISOWeek: getISOWeek2, getWeek: getWeek2, startOfBroadcastWeek: startOfBroadcastWeek2, startOfISOWeek: startOfISOWeek2, startOfWeek: startOfWeek2 } = dateLib;
    const dayPickerMonths = displayMonths.reduce((months, month) => {
      const firstDateOfFirstWeek = props.broadcastCalendar ? startOfBroadcastWeek2(month, dateLib) : props.ISOWeek ? startOfISOWeek2(month) : startOfWeek2(month);
      const lastDateOfLastWeek = props.broadcastCalendar ? endOfBroadcastWeek2(month) : props.ISOWeek ? endOfISOWeek2(endOfMonth2(month)) : endOfWeek2(endOfMonth2(month));
      const monthDates = dates.filter((date) => {
        return date >= firstDateOfFirstWeek && date <= lastDateOfLastWeek;
      });
      const nrOfDaysWithFixedWeeks = props.broadcastCalendar ? 35 : 42;
      if (props.fixedWeeks && monthDates.length < nrOfDaysWithFixedWeeks) {
        const extraDates = dates.filter((date) => {
          const daysToAdd = nrOfDaysWithFixedWeeks - monthDates.length;
          return date > lastDateOfLastWeek && date <= addDays2(lastDateOfLastWeek, daysToAdd);
        });
        monthDates.push(...extraDates);
      }
      const weeks = monthDates.reduce((weeks2, date) => {
        const weekNumber = props.ISOWeek ? getISOWeek2(date) : getWeek2(date);
        const week = weeks2.find((week2) => week2.weekNumber === weekNumber);
        const day = new CalendarDay(date, month, dateLib);
        if (!week) {
          weeks2.push(new CalendarWeek(weekNumber, [day]));
        } else {
          week.days.push(day);
        }
        return weeks2;
      }, []);
      const dayPickerMonth = new CalendarMonth(month, weeks);
      months.push(dayPickerMonth);
      return months;
    }, []);
    if (!props.reverseMonths) {
      return dayPickerMonths;
    } else {
      return dayPickerMonths.reverse();
    }
  }

  // ../../node_modules/react-day-picker/dist/esm/helpers/getNavMonth.js
  function getNavMonths(props, dateLib) {
    let { startMonth, endMonth } = props;
    const { startOfYear: startOfYear2, startOfDay: startOfDay2, startOfMonth: startOfMonth2, endOfMonth: endOfMonth2, addYears: addYears2, endOfYear: endOfYear2, newDate, today } = dateLib;
    const { fromYear, toYear, fromMonth, toMonth } = props;
    if (!startMonth && fromMonth) {
      startMonth = fromMonth;
    }
    if (!startMonth && fromYear) {
      startMonth = dateLib.newDate(fromYear, 0, 1);
    }
    if (!endMonth && toMonth) {
      endMonth = toMonth;
    }
    if (!endMonth && toYear) {
      endMonth = newDate(toYear, 11, 31);
    }
    const hasYearDropdown = props.captionLayout === "dropdown" || props.captionLayout === "dropdown-years";
    if (startMonth) {
      startMonth = startOfMonth2(startMonth);
    } else if (fromYear) {
      startMonth = newDate(fromYear, 0, 1);
    } else if (!startMonth && hasYearDropdown) {
      startMonth = startOfYear2(addYears2(props.today ?? today(), -100));
    }
    if (endMonth) {
      endMonth = endOfMonth2(endMonth);
    } else if (toYear) {
      endMonth = newDate(toYear, 11, 31);
    } else if (!endMonth && hasYearDropdown) {
      endMonth = endOfYear2(props.today ?? today());
    }
    return [
      startMonth ? startOfDay2(startMonth) : startMonth,
      endMonth ? startOfDay2(endMonth) : endMonth
    ];
  }

  // ../../node_modules/react-day-picker/dist/esm/helpers/getNextMonth.js
  function getNextMonth(firstDisplayedMonth, calendarEndMonth, options, dateLib) {
    if (options.disableNavigation) {
      return void 0;
    }
    const { pagedNavigation, numberOfMonths = 1 } = options;
    const { startOfMonth: startOfMonth2, addMonths: addMonths2, differenceInCalendarMonths: differenceInCalendarMonths2 } = dateLib;
    const offset4 = pagedNavigation ? numberOfMonths : 1;
    const month = startOfMonth2(firstDisplayedMonth);
    if (!calendarEndMonth) {
      return addMonths2(month, offset4);
    }
    const monthsDiff = differenceInCalendarMonths2(calendarEndMonth, firstDisplayedMonth);
    if (monthsDiff < numberOfMonths) {
      return void 0;
    }
    return addMonths2(month, offset4);
  }

  // ../../node_modules/react-day-picker/dist/esm/helpers/getPreviousMonth.js
  function getPreviousMonth(firstDisplayedMonth, calendarStartMonth, options, dateLib) {
    if (options.disableNavigation) {
      return void 0;
    }
    const { pagedNavigation, numberOfMonths } = options;
    const { startOfMonth: startOfMonth2, addMonths: addMonths2, differenceInCalendarMonths: differenceInCalendarMonths2 } = dateLib;
    const offset4 = pagedNavigation ? numberOfMonths ?? 1 : 1;
    const month = startOfMonth2(firstDisplayedMonth);
    if (!calendarStartMonth) {
      return addMonths2(month, -offset4);
    }
    const monthsDiff = differenceInCalendarMonths2(month, calendarStartMonth);
    if (monthsDiff <= 0) {
      return void 0;
    }
    return addMonths2(month, -offset4);
  }

  // ../../node_modules/react-day-picker/dist/esm/helpers/getWeeks.js
  function getWeeks(months) {
    const initialWeeks = [];
    return months.reduce((weeks, month) => {
      return weeks.concat(month.weeks.slice());
    }, initialWeeks.slice());
  }

  // ../../node_modules/react-day-picker/dist/esm/helpers/useControlledValue.js
  var import_react61 = __toESM(require_react2(), 1);
  function useControlledValue(defaultValue, controlledValue) {
    const [uncontrolledValue, setValue] = (0, import_react61.useState)(defaultValue);
    const value = controlledValue === void 0 ? uncontrolledValue : controlledValue;
    return [value, setValue];
  }

  // ../../node_modules/react-day-picker/dist/esm/useCalendar.js
  function useCalendar(props, dateLib) {
    const [navStart, navEnd] = getNavMonths(props, dateLib);
    const { startOfMonth: startOfMonth2, endOfMonth: endOfMonth2 } = dateLib;
    const initialMonth = getInitialMonth(props, navStart, navEnd, dateLib);
    const [firstMonth, setFirstMonth] = useControlledValue(
      initialMonth,
      // initialMonth is always computed from props.month if provided
      props.month ? initialMonth : void 0
    );
    (0, import_react62.useEffect)(() => {
      const newInitialMonth = getInitialMonth(props, navStart, navEnd, dateLib);
      setFirstMonth(newInitialMonth);
    }, [props.timeZone]);
    const { months, weeks, days, previousMonth, nextMonth } = (0, import_react62.useMemo)(() => {
      const displayMonths = getDisplayMonths(firstMonth, navEnd, { numberOfMonths: props.numberOfMonths }, dateLib);
      const dates = getDates(displayMonths, props.endMonth ? endOfMonth2(props.endMonth) : void 0, {
        ISOWeek: props.ISOWeek,
        fixedWeeks: props.fixedWeeks,
        broadcastCalendar: props.broadcastCalendar
      }, dateLib);
      const months2 = getMonths(displayMonths, dates, {
        broadcastCalendar: props.broadcastCalendar,
        fixedWeeks: props.fixedWeeks,
        ISOWeek: props.ISOWeek,
        reverseMonths: props.reverseMonths
      }, dateLib);
      const weeks2 = getWeeks(months2);
      const days2 = getDays(months2);
      const previousMonth2 = getPreviousMonth(firstMonth, navStart, props, dateLib);
      const nextMonth2 = getNextMonth(firstMonth, navEnd, props, dateLib);
      return {
        months: months2,
        weeks: weeks2,
        days: days2,
        previousMonth: previousMonth2,
        nextMonth: nextMonth2
      };
    }, [
      dateLib,
      firstMonth.getTime(),
      navEnd?.getTime(),
      navStart?.getTime(),
      props.disableNavigation,
      props.broadcastCalendar,
      props.endMonth?.getTime(),
      props.fixedWeeks,
      props.ISOWeek,
      props.numberOfMonths,
      props.pagedNavigation,
      props.reverseMonths
    ]);
    const { disableNavigation, onMonthChange } = props;
    const isDayInCalendar = (day) => weeks.some((week) => week.days.some((d) => d.isEqualTo(day)));
    const goToMonth = (date) => {
      if (disableNavigation) {
        return;
      }
      let newMonth = startOfMonth2(date);
      if (navStart && newMonth < startOfMonth2(navStart)) {
        newMonth = startOfMonth2(navStart);
      }
      if (navEnd && newMonth > startOfMonth2(navEnd)) {
        newMonth = startOfMonth2(navEnd);
      }
      setFirstMonth(newMonth);
      onMonthChange?.(newMonth);
    };
    const goToDay = (day) => {
      if (isDayInCalendar(day)) {
        return;
      }
      goToMonth(day.date);
    };
    const calendar = {
      months,
      weeks,
      days,
      navStart,
      navEnd,
      previousMonth,
      nextMonth,
      goToMonth,
      goToDay
    };
    return calendar;
  }

  // ../../node_modules/react-day-picker/dist/esm/useFocus.js
  var import_react63 = __toESM(require_react2(), 1);

  // ../../node_modules/react-day-picker/dist/esm/helpers/calculateFocusTarget.js
  var FocusTargetPriority;
  (function(FocusTargetPriority2) {
    FocusTargetPriority2[FocusTargetPriority2["Today"] = 0] = "Today";
    FocusTargetPriority2[FocusTargetPriority2["Selected"] = 1] = "Selected";
    FocusTargetPriority2[FocusTargetPriority2["LastFocused"] = 2] = "LastFocused";
    FocusTargetPriority2[FocusTargetPriority2["FocusedModifier"] = 3] = "FocusedModifier";
  })(FocusTargetPriority || (FocusTargetPriority = {}));
  function isFocusableDay(modifiers) {
    return !modifiers[DayFlag.disabled] && !modifiers[DayFlag.hidden] && !modifiers[DayFlag.outside];
  }
  function calculateFocusTarget(days, getModifiers, isSelected, lastFocused) {
    let focusTarget;
    let foundFocusTargetPriority = -1;
    for (const day of days) {
      const modifiers = getModifiers(day);
      if (isFocusableDay(modifiers)) {
        if (modifiers[DayFlag.focused] && foundFocusTargetPriority < FocusTargetPriority.FocusedModifier) {
          focusTarget = day;
          foundFocusTargetPriority = FocusTargetPriority.FocusedModifier;
        } else if (lastFocused?.isEqualTo(day) && foundFocusTargetPriority < FocusTargetPriority.LastFocused) {
          focusTarget = day;
          foundFocusTargetPriority = FocusTargetPriority.LastFocused;
        } else if (isSelected(day.date) && foundFocusTargetPriority < FocusTargetPriority.Selected) {
          focusTarget = day;
          foundFocusTargetPriority = FocusTargetPriority.Selected;
        } else if (modifiers[DayFlag.today] && foundFocusTargetPriority < FocusTargetPriority.Today) {
          focusTarget = day;
          foundFocusTargetPriority = FocusTargetPriority.Today;
        }
      }
    }
    if (!focusTarget) {
      focusTarget = days.find((day) => isFocusableDay(getModifiers(day)));
    }
    return focusTarget;
  }

  // ../../node_modules/react-day-picker/dist/esm/helpers/getFocusableDate.js
  function getFocusableDate(moveBy, moveDir, refDate, navStart, navEnd, props, dateLib) {
    const { ISOWeek, broadcastCalendar } = props;
    const { addDays: addDays2, addMonths: addMonths2, addWeeks: addWeeks2, addYears: addYears2, endOfBroadcastWeek: endOfBroadcastWeek2, endOfISOWeek: endOfISOWeek2, endOfWeek: endOfWeek2, max: max3, min: min3, startOfBroadcastWeek: startOfBroadcastWeek2, startOfISOWeek: startOfISOWeek2, startOfWeek: startOfWeek2 } = dateLib;
    const moveFns = {
      day: addDays2,
      week: addWeeks2,
      month: addMonths2,
      year: addYears2,
      startOfWeek: (date) => broadcastCalendar ? startOfBroadcastWeek2(date, dateLib) : ISOWeek ? startOfISOWeek2(date) : startOfWeek2(date),
      endOfWeek: (date) => broadcastCalendar ? endOfBroadcastWeek2(date) : ISOWeek ? endOfISOWeek2(date) : endOfWeek2(date)
    };
    let focusableDate = moveFns[moveBy](refDate, moveDir === "after" ? 1 : -1);
    if (moveDir === "before" && navStart) {
      focusableDate = max3([navStart, focusableDate]);
    } else if (moveDir === "after" && navEnd) {
      focusableDate = min3([navEnd, focusableDate]);
    }
    return focusableDate;
  }

  // ../../node_modules/react-day-picker/dist/esm/helpers/getNextFocus.js
  function getNextFocus(moveBy, moveDir, refDay, calendarStartMonth, calendarEndMonth, props, dateLib, attempt = 0) {
    if (attempt > 365) {
      return void 0;
    }
    const focusableDate = getFocusableDate(moveBy, moveDir, refDay.date, calendarStartMonth, calendarEndMonth, props, dateLib);
    const isDisabled = Boolean(props.disabled && dateMatchModifiers(focusableDate, props.disabled, dateLib));
    const isHidden2 = Boolean(props.hidden && dateMatchModifiers(focusableDate, props.hidden, dateLib));
    const targetMonth = focusableDate;
    const focusDay = new CalendarDay(focusableDate, targetMonth, dateLib);
    if (!isDisabled && !isHidden2) {
      return focusDay;
    }
    return getNextFocus(moveBy, moveDir, focusDay, calendarStartMonth, calendarEndMonth, props, dateLib, attempt + 1);
  }

  // ../../node_modules/react-day-picker/dist/esm/useFocus.js
  function useFocus(props, calendar, getModifiers, isSelected, dateLib) {
    const { autoFocus } = props;
    const [lastFocused, setLastFocused] = (0, import_react63.useState)();
    const focusTarget = calculateFocusTarget(calendar.days, getModifiers, isSelected || (() => false), lastFocused);
    const [focusedDay, setFocused] = (0, import_react63.useState)(autoFocus ? focusTarget : void 0);
    const blur = () => {
      setLastFocused(focusedDay);
      setFocused(void 0);
    };
    const moveFocus = (moveBy, moveDir) => {
      if (!focusedDay)
        return;
      const nextFocus = getNextFocus(moveBy, moveDir, focusedDay, calendar.navStart, calendar.navEnd, props, dateLib);
      if (!nextFocus)
        return;
      if (props.disableNavigation) {
        const isNextInCalendar = calendar.days.some((day) => day.isEqualTo(nextFocus));
        if (!isNextInCalendar) {
          return;
        }
      }
      calendar.goToDay(nextFocus);
      setFocused(nextFocus);
    };
    const isFocusTarget = (day) => {
      return Boolean(focusTarget?.isEqualTo(day));
    };
    const useFocus2 = {
      isFocusTarget,
      setFocused,
      focused: focusedDay,
      blur,
      moveFocus
    };
    return useFocus2;
  }

  // ../../node_modules/react-day-picker/dist/esm/selection/useMulti.js
  function useMulti(props, dateLib) {
    const { selected: initiallySelected, required, onSelect } = props;
    const [internallySelected, setSelected] = useControlledValue(initiallySelected, onSelect ? initiallySelected : void 0);
    const selected = !onSelect ? internallySelected : initiallySelected;
    const { isSameDay: isSameDay2 } = dateLib;
    const isSelected = (date) => {
      return selected?.some((d) => isSameDay2(d, date)) ?? false;
    };
    const { min: min3, max: max3 } = props;
    const select = (triggerDate, modifiers, e2) => {
      let newDates = [...selected ?? []];
      if (isSelected(triggerDate)) {
        if (selected?.length === min3) {
          return;
        }
        if (required && selected?.length === 1) {
          return;
        }
        newDates = selected?.filter((d) => !isSameDay2(d, triggerDate));
      } else {
        if (selected?.length === max3) {
          newDates = [triggerDate];
        } else {
          newDates = [...newDates, triggerDate];
        }
      }
      if (!onSelect) {
        setSelected(newDates);
      }
      onSelect?.(newDates, triggerDate, modifiers, e2);
      return newDates;
    };
    return {
      selected,
      select,
      isSelected
    };
  }

  // ../../node_modules/react-day-picker/dist/esm/utils/addToRange.js
  function addToRange(date, initialRange, min3 = 0, max3 = 0, required = false, dateLib = defaultDateLib) {
    const { from, to: to2 } = initialRange || {};
    const { isSameDay: isSameDay2, isAfter: isAfter2, isBefore: isBefore2 } = dateLib;
    let range;
    if (!from && !to2) {
      range = { from: date, to: min3 > 0 ? void 0 : date };
    } else if (from && !to2) {
      if (isSameDay2(from, date)) {
        if (min3 === 0) {
          range = { from, to: date };
        } else if (required) {
          range = { from, to: void 0 };
        } else {
          range = void 0;
        }
      } else if (isBefore2(date, from)) {
        range = { from: date, to: from };
      } else {
        range = { from, to: date };
      }
    } else if (from && to2) {
      if (isSameDay2(from, date) && isSameDay2(to2, date)) {
        if (required) {
          range = { from, to: to2 };
        } else {
          range = void 0;
        }
      } else if (isSameDay2(from, date)) {
        range = { from, to: min3 > 0 ? void 0 : date };
      } else if (isSameDay2(to2, date)) {
        range = { from: date, to: min3 > 0 ? void 0 : date };
      } else if (isBefore2(date, from)) {
        range = { from: date, to: to2 };
      } else if (isAfter2(date, from)) {
        range = { from, to: date };
      } else if (isAfter2(date, to2)) {
        range = { from, to: date };
      } else {
        throw new Error("Invalid range");
      }
    }
    if (range?.from && range?.to) {
      const diff = dateLib.differenceInCalendarDays(range.to, range.from);
      if (max3 > 0 && diff > max3) {
        range = { from: date, to: void 0 };
      } else if (min3 > 1 && diff < min3) {
        range = { from: date, to: void 0 };
      }
    }
    return range;
  }

  // ../../node_modules/react-day-picker/dist/esm/utils/rangeContainsDayOfWeek.js
  function rangeContainsDayOfWeek(range, dayOfWeek, dateLib = defaultDateLib) {
    const dayOfWeekArr = !Array.isArray(dayOfWeek) ? [dayOfWeek] : dayOfWeek;
    let date = range.from;
    const totalDays = dateLib.differenceInCalendarDays(range.to, range.from);
    const totalDaysLimit = Math.min(totalDays, 6);
    for (let i3 = 0; i3 <= totalDaysLimit; i3++) {
      if (dayOfWeekArr.includes(date.getDay())) {
        return true;
      }
      date = dateLib.addDays(date, 1);
    }
    return false;
  }

  // ../../node_modules/react-day-picker/dist/esm/utils/rangeOverlaps.js
  function rangeOverlaps(rangeLeft, rangeRight, dateLib = defaultDateLib) {
    return rangeIncludesDate(rangeLeft, rangeRight.from, false, dateLib) || rangeIncludesDate(rangeLeft, rangeRight.to, false, dateLib) || rangeIncludesDate(rangeRight, rangeLeft.from, false, dateLib) || rangeIncludesDate(rangeRight, rangeLeft.to, false, dateLib);
  }

  // ../../node_modules/react-day-picker/dist/esm/utils/rangeContainsModifiers.js
  function rangeContainsModifiers(range, modifiers, dateLib = defaultDateLib) {
    const matchers = Array.isArray(modifiers) ? modifiers : [modifiers];
    const nonFunctionMatchers = matchers.filter((matcher) => typeof matcher !== "function");
    const nonFunctionMatchersResult = nonFunctionMatchers.some((matcher) => {
      if (typeof matcher === "boolean")
        return matcher;
      if (dateLib.isDate(matcher)) {
        return rangeIncludesDate(range, matcher, false, dateLib);
      }
      if (isDatesArray(matcher, dateLib)) {
        return matcher.some((date) => rangeIncludesDate(range, date, false, dateLib));
      }
      if (isDateRange(matcher)) {
        if (matcher.from && matcher.to) {
          return rangeOverlaps(range, { from: matcher.from, to: matcher.to }, dateLib);
        }
        return false;
      }
      if (isDayOfWeekType(matcher)) {
        return rangeContainsDayOfWeek(range, matcher.dayOfWeek, dateLib);
      }
      if (isDateInterval(matcher)) {
        const isClosedInterval = dateLib.isAfter(matcher.before, matcher.after);
        if (isClosedInterval) {
          return rangeOverlaps(range, {
            from: dateLib.addDays(matcher.after, 1),
            to: dateLib.addDays(matcher.before, -1)
          }, dateLib);
        }
        return dateMatchModifiers(range.from, matcher, dateLib) || dateMatchModifiers(range.to, matcher, dateLib);
      }
      if (isDateAfterType(matcher) || isDateBeforeType(matcher)) {
        return dateMatchModifiers(range.from, matcher, dateLib) || dateMatchModifiers(range.to, matcher, dateLib);
      }
      return false;
    });
    if (nonFunctionMatchersResult) {
      return true;
    }
    const functionMatchers = matchers.filter((matcher) => typeof matcher === "function");
    if (functionMatchers.length) {
      let date = range.from;
      const totalDays = dateLib.differenceInCalendarDays(range.to, range.from);
      for (let i3 = 0; i3 <= totalDays; i3++) {
        if (functionMatchers.some((matcher) => matcher(date))) {
          return true;
        }
        date = dateLib.addDays(date, 1);
      }
    }
    return false;
  }

  // ../../node_modules/react-day-picker/dist/esm/selection/useRange.js
  function useRange(props, dateLib) {
    const { disabled, excludeDisabled, selected: initiallySelected, required, onSelect } = props;
    const [internallySelected, setSelected] = useControlledValue(initiallySelected, onSelect ? initiallySelected : void 0);
    const selected = !onSelect ? internallySelected : initiallySelected;
    const isSelected = (date) => selected && rangeIncludesDate(selected, date, false, dateLib);
    const select = (triggerDate, modifiers, e2) => {
      const { min: min3, max: max3 } = props;
      const newRange = triggerDate ? addToRange(triggerDate, selected, min3, max3, required, dateLib) : void 0;
      if (excludeDisabled && disabled && newRange?.from && newRange.to) {
        if (rangeContainsModifiers({ from: newRange.from, to: newRange.to }, disabled, dateLib)) {
          newRange.from = triggerDate;
          newRange.to = void 0;
        }
      }
      if (!onSelect) {
        setSelected(newRange);
      }
      onSelect?.(newRange, triggerDate, modifiers, e2);
      return newRange;
    };
    return {
      selected,
      select,
      isSelected
    };
  }

  // ../../node_modules/react-day-picker/dist/esm/selection/useSingle.js
  function useSingle(props, dateLib) {
    const { selected: initiallySelected, required, onSelect } = props;
    const [internallySelected, setSelected] = useControlledValue(initiallySelected, onSelect ? initiallySelected : void 0);
    const selected = !onSelect ? internallySelected : initiallySelected;
    const { isSameDay: isSameDay2 } = dateLib;
    const isSelected = (compareDate) => {
      return selected ? isSameDay2(selected, compareDate) : false;
    };
    const select = (triggerDate, modifiers, e2) => {
      let newDate = triggerDate;
      if (!required && selected && selected && isSameDay2(triggerDate, selected)) {
        newDate = void 0;
      }
      if (!onSelect) {
        setSelected(newDate);
      }
      if (required) {
        onSelect?.(newDate, triggerDate, modifiers, e2);
      } else {
        onSelect?.(newDate, triggerDate, modifiers, e2);
      }
      return newDate;
    };
    return {
      selected,
      select,
      isSelected
    };
  }

  // ../../node_modules/react-day-picker/dist/esm/useSelection.js
  function useSelection(props, dateLib) {
    const single = useSingle(props, dateLib);
    const multi = useMulti(props, dateLib);
    const range = useRange(props, dateLib);
    switch (props.mode) {
      case "single":
        return single;
      case "multiple":
        return multi;
      case "range":
        return range;
      default:
        return void 0;
    }
  }

  // ../../node_modules/react-day-picker/dist/esm/utils/toTimeZone.js
  function toTimeZone(date, timeZone) {
    if (date instanceof TZDate && date.timeZone === timeZone) {
      return date;
    }
    return new TZDate(date, timeZone);
  }

  // ../../node_modules/react-day-picker/dist/esm/utils/convertMatchersToTimeZone.js
  function toZoneNoon(date, timeZone, noonSafe) {
    if (!noonSafe)
      return toTimeZone(date, timeZone);
    const zoned = toTimeZone(date, timeZone);
    const noonZoned = new TZDate(zoned.getFullYear(), zoned.getMonth(), zoned.getDate(), 12, 0, 0, timeZone);
    return new Date(noonZoned.getTime());
  }
  function convertMatcher(matcher, timeZone, noonSafe) {
    if (typeof matcher === "boolean" || typeof matcher === "function") {
      return matcher;
    }
    if (matcher instanceof Date) {
      return toZoneNoon(matcher, timeZone, noonSafe);
    }
    if (Array.isArray(matcher)) {
      return matcher.map((value) => value instanceof Date ? toZoneNoon(value, timeZone, noonSafe) : value);
    }
    if (isDateRange(matcher)) {
      return {
        ...matcher,
        from: matcher.from ? toTimeZone(matcher.from, timeZone) : matcher.from,
        to: matcher.to ? toTimeZone(matcher.to, timeZone) : matcher.to
      };
    }
    if (isDateInterval(matcher)) {
      return {
        before: toZoneNoon(matcher.before, timeZone, noonSafe),
        after: toZoneNoon(matcher.after, timeZone, noonSafe)
      };
    }
    if (isDateAfterType(matcher)) {
      return {
        after: toZoneNoon(matcher.after, timeZone, noonSafe)
      };
    }
    if (isDateBeforeType(matcher)) {
      return {
        before: toZoneNoon(matcher.before, timeZone, noonSafe)
      };
    }
    return matcher;
  }
  function convertMatchersToTimeZone(matchers, timeZone, noonSafe) {
    if (!matchers) {
      return matchers;
    }
    if (Array.isArray(matchers)) {
      return matchers.map((matcher) => convertMatcher(matcher, timeZone, noonSafe));
    }
    return convertMatcher(matchers, timeZone, noonSafe);
  }

  // ../../node_modules/react-day-picker/dist/esm/DayPicker.js
  function DayPicker(initialProps) {
    let props = initialProps;
    const timeZone = props.timeZone;
    if (timeZone) {
      props = {
        ...initialProps,
        timeZone
      };
      if (props.today) {
        props.today = toTimeZone(props.today, timeZone);
      }
      if (props.month) {
        props.month = toTimeZone(props.month, timeZone);
      }
      if (props.defaultMonth) {
        props.defaultMonth = toTimeZone(props.defaultMonth, timeZone);
      }
      if (props.startMonth) {
        props.startMonth = toTimeZone(props.startMonth, timeZone);
      }
      if (props.endMonth) {
        props.endMonth = toTimeZone(props.endMonth, timeZone);
      }
      if (props.mode === "single" && props.selected) {
        props.selected = toTimeZone(props.selected, timeZone);
      } else if (props.mode === "multiple" && props.selected) {
        props.selected = props.selected?.map((date) => toTimeZone(date, timeZone));
      } else if (props.mode === "range" && props.selected) {
        props.selected = {
          from: props.selected.from ? toTimeZone(props.selected.from, timeZone) : props.selected.from,
          to: props.selected.to ? toTimeZone(props.selected.to, timeZone) : props.selected.to
        };
      }
      if (props.disabled !== void 0) {
        props.disabled = convertMatchersToTimeZone(props.disabled, timeZone);
      }
      if (props.hidden !== void 0) {
        props.hidden = convertMatchersToTimeZone(props.hidden, timeZone);
      }
      if (props.modifiers) {
        const nextModifiers = {};
        Object.keys(props.modifiers).forEach((key) => {
          nextModifiers[key] = convertMatchersToTimeZone(props.modifiers?.[key], timeZone);
        });
        props.modifiers = nextModifiers;
      }
    }
    const { components, formatters: formatters2, labels, dateLib, locale, classNames } = (0, import_react64.useMemo)(() => {
      const locale2 = { ...enUS2, ...props.locale };
      const weekStartsOn = props.broadcastCalendar ? 1 : props.weekStartsOn;
      const noonOverrides = props.noonSafe && props.timeZone ? createNoonOverrides(props.timeZone, {
        weekStartsOn,
        locale: locale2
      }) : void 0;
      const overrides = props.dateLib && noonOverrides ? { ...noonOverrides, ...props.dateLib } : props.dateLib ?? noonOverrides;
      const dateLib2 = new DateLib({
        locale: locale2,
        weekStartsOn,
        firstWeekContainsDate: props.firstWeekContainsDate,
        useAdditionalWeekYearTokens: props.useAdditionalWeekYearTokens,
        useAdditionalDayOfYearTokens: props.useAdditionalDayOfYearTokens,
        timeZone: props.timeZone,
        numerals: props.numerals
      }, overrides);
      return {
        dateLib: dateLib2,
        components: getComponents(props.components),
        formatters: getFormatters(props.formatters),
        labels: getLabels(props.labels, dateLib2.options),
        locale: locale2,
        classNames: { ...getDefaultClassNames(), ...props.classNames }
      };
    }, [
      props.locale,
      props.broadcastCalendar,
      props.weekStartsOn,
      props.firstWeekContainsDate,
      props.useAdditionalWeekYearTokens,
      props.useAdditionalDayOfYearTokens,
      props.timeZone,
      props.numerals,
      props.dateLib,
      props.noonSafe,
      props.components,
      props.formatters,
      props.labels,
      props.classNames
    ]);
    if (!props.today) {
      props = { ...props, today: dateLib.today() };
    }
    const { captionLayout, mode, navLayout, numberOfMonths = 1, onDayBlur, onDayClick, onDayFocus, onDayKeyDown, onDayMouseEnter, onDayMouseLeave, onNextClick, onPrevClick, showWeekNumber, styles } = props;
    const { formatCaption: formatCaption2, formatDay: formatDay2, formatMonthDropdown: formatMonthDropdown2, formatWeekNumber: formatWeekNumber2, formatWeekNumberHeader: formatWeekNumberHeader2, formatWeekdayName: formatWeekdayName2, formatYearDropdown: formatYearDropdown2 } = formatters2;
    const calendar = useCalendar(props, dateLib);
    const { days, months, navStart, navEnd, previousMonth, nextMonth, goToMonth } = calendar;
    const getModifiers = createGetModifiers(days, props, navStart, navEnd, dateLib);
    const { isSelected, select, selected: selectedValue } = useSelection(props, dateLib) ?? {};
    const { blur, focused, isFocusTarget, moveFocus, setFocused } = useFocus(props, calendar, getModifiers, isSelected ?? (() => false), dateLib);
    const { labelDayButton: labelDayButton2, labelGridcell: labelGridcell2, labelGrid: labelGrid2, labelMonthDropdown: labelMonthDropdown2, labelNav: labelNav2, labelPrevious: labelPrevious2, labelNext: labelNext2, labelWeekday: labelWeekday2, labelWeekNumber: labelWeekNumber2, labelWeekNumberHeader: labelWeekNumberHeader2, labelYearDropdown: labelYearDropdown2 } = labels;
    const weekdays = (0, import_react64.useMemo)(() => getWeekdays(dateLib, props.ISOWeek, props.broadcastCalendar, props.today), [dateLib, props.ISOWeek, props.broadcastCalendar, props.today]);
    const isInteractive = mode !== void 0 || onDayClick !== void 0;
    const handlePreviousClick = (0, import_react64.useCallback)(() => {
      if (!previousMonth)
        return;
      goToMonth(previousMonth);
      onPrevClick?.(previousMonth);
    }, [previousMonth, goToMonth, onPrevClick]);
    const handleNextClick = (0, import_react64.useCallback)(() => {
      if (!nextMonth)
        return;
      goToMonth(nextMonth);
      onNextClick?.(nextMonth);
    }, [goToMonth, nextMonth, onNextClick]);
    const handleDayClick = (0, import_react64.useCallback)((day, m3) => (e2) => {
      e2.preventDefault();
      e2.stopPropagation();
      setFocused(day);
      if (m3.disabled) {
        return;
      }
      select?.(day.date, m3, e2);
      onDayClick?.(day.date, m3, e2);
    }, [select, onDayClick, setFocused]);
    const handleDayFocus = (0, import_react64.useCallback)((day, m3) => (e2) => {
      setFocused(day);
      onDayFocus?.(day.date, m3, e2);
    }, [onDayFocus, setFocused]);
    const handleDayBlur = (0, import_react64.useCallback)((day, m3) => (e2) => {
      blur();
      onDayBlur?.(day.date, m3, e2);
    }, [blur, onDayBlur]);
    const handleDayKeyDown = (0, import_react64.useCallback)((day, modifiers) => (e2) => {
      const keyMap = {
        ArrowLeft: [
          e2.shiftKey ? "month" : "day",
          props.dir === "rtl" ? "after" : "before"
        ],
        ArrowRight: [
          e2.shiftKey ? "month" : "day",
          props.dir === "rtl" ? "before" : "after"
        ],
        ArrowDown: [e2.shiftKey ? "year" : "week", "after"],
        ArrowUp: [e2.shiftKey ? "year" : "week", "before"],
        PageUp: [e2.shiftKey ? "year" : "month", "before"],
        PageDown: [e2.shiftKey ? "year" : "month", "after"],
        Home: ["startOfWeek", "before"],
        End: ["endOfWeek", "after"]
      };
      if (keyMap[e2.key]) {
        e2.preventDefault();
        e2.stopPropagation();
        const [moveBy, moveDir] = keyMap[e2.key];
        moveFocus(moveBy, moveDir);
      }
      onDayKeyDown?.(day.date, modifiers, e2);
    }, [moveFocus, onDayKeyDown, props.dir]);
    const handleDayMouseEnter = (0, import_react64.useCallback)((day, modifiers) => (e2) => {
      onDayMouseEnter?.(day.date, modifiers, e2);
    }, [onDayMouseEnter]);
    const handleDayMouseLeave = (0, import_react64.useCallback)((day, modifiers) => (e2) => {
      onDayMouseLeave?.(day.date, modifiers, e2);
    }, [onDayMouseLeave]);
    const handleMonthChange = (0, import_react64.useCallback)((date) => (e2) => {
      const selectedMonth = Number(e2.target.value);
      const month = dateLib.setMonth(dateLib.startOfMonth(date), selectedMonth);
      goToMonth(month);
    }, [dateLib, goToMonth]);
    const handleYearChange = (0, import_react64.useCallback)((date) => (e2) => {
      const selectedYear = Number(e2.target.value);
      const month = dateLib.setYear(dateLib.startOfMonth(date), selectedYear);
      goToMonth(month);
    }, [dateLib, goToMonth]);
    const { className, style } = (0, import_react64.useMemo)(() => ({
      className: [classNames[UI.Root], props.className].filter(Boolean).join(" "),
      style: { ...styles?.[UI.Root], ...props.style }
    }), [classNames, props.className, props.style, styles]);
    const dataAttributes = getDataAttributes(props);
    const rootElRef = (0, import_react64.useRef)(null);
    useAnimation(rootElRef, Boolean(props.animate), {
      classNames,
      months,
      focused,
      dateLib
    });
    const contextValue = {
      dayPickerProps: props,
      selected: selectedValue,
      select,
      isSelected,
      months,
      nextMonth,
      previousMonth,
      goToMonth,
      getModifiers,
      components,
      classNames,
      styles,
      labels,
      formatters: formatters2
    };
    return import_react64.default.createElement(
      dayPickerContext.Provider,
      { value: contextValue },
      import_react64.default.createElement(
        components.Root,
        { rootRef: props.animate ? rootElRef : void 0, className, style, dir: props.dir, id: props.id, lang: props.lang, nonce: props.nonce, title: props.title, role: props.role, "aria-label": props["aria-label"], "aria-labelledby": props["aria-labelledby"], ...dataAttributes },
        import_react64.default.createElement(
          components.Months,
          { className: classNames[UI.Months], style: styles?.[UI.Months] },
          !props.hideNavigation && !navLayout && import_react64.default.createElement(components.Nav, { "data-animated-nav": props.animate ? "true" : void 0, className: classNames[UI.Nav], style: styles?.[UI.Nav], "aria-label": labelNav2(), onPreviousClick: handlePreviousClick, onNextClick: handleNextClick, previousMonth, nextMonth }),
          months.map((calendarMonth, displayIndex) => {
            return import_react64.default.createElement(
              components.Month,
              {
                "data-animated-month": props.animate ? "true" : void 0,
                className: classNames[UI.Month],
                style: styles?.[UI.Month],
                // biome-ignore lint/suspicious/noArrayIndexKey: breaks animation
                key: displayIndex,
                displayIndex,
                calendarMonth
              },
              navLayout === "around" && !props.hideNavigation && displayIndex === 0 && import_react64.default.createElement(
                components.PreviousMonthButton,
                { type: "button", className: classNames[UI.PreviousMonthButton], tabIndex: previousMonth ? void 0 : -1, "aria-disabled": previousMonth ? void 0 : true, "aria-label": labelPrevious2(previousMonth), onClick: handlePreviousClick, "data-animated-button": props.animate ? "true" : void 0 },
                import_react64.default.createElement(components.Chevron, { disabled: previousMonth ? void 0 : true, className: classNames[UI.Chevron], orientation: props.dir === "rtl" ? "right" : "left" })
              ),
              import_react64.default.createElement(components.MonthCaption, { "data-animated-caption": props.animate ? "true" : void 0, className: classNames[UI.MonthCaption], style: styles?.[UI.MonthCaption], calendarMonth, displayIndex }, captionLayout?.startsWith("dropdown") ? import_react64.default.createElement(
                components.DropdownNav,
                { className: classNames[UI.Dropdowns], style: styles?.[UI.Dropdowns] },
                (() => {
                  const monthControl = captionLayout === "dropdown" || captionLayout === "dropdown-months" ? import_react64.default.createElement(components.MonthsDropdown, { key: "month", className: classNames[UI.MonthsDropdown], "aria-label": labelMonthDropdown2(), classNames, components, disabled: Boolean(props.disableNavigation), onChange: handleMonthChange(calendarMonth.date), options: getMonthOptions(calendarMonth.date, navStart, navEnd, formatters2, dateLib), style: styles?.[UI.Dropdown], value: dateLib.getMonth(calendarMonth.date) }) : import_react64.default.createElement("span", { key: "month" }, formatMonthDropdown2(calendarMonth.date, dateLib));
                  const yearControl = captionLayout === "dropdown" || captionLayout === "dropdown-years" ? import_react64.default.createElement(components.YearsDropdown, { key: "year", className: classNames[UI.YearsDropdown], "aria-label": labelYearDropdown2(dateLib.options), classNames, components, disabled: Boolean(props.disableNavigation), onChange: handleYearChange(calendarMonth.date), options: getYearOptions(navStart, navEnd, formatters2, dateLib, Boolean(props.reverseYears)), style: styles?.[UI.Dropdown], value: dateLib.getYear(calendarMonth.date) }) : import_react64.default.createElement("span", { key: "year" }, formatYearDropdown2(calendarMonth.date, dateLib));
                  const controls = dateLib.getMonthYearOrder() === "year-first" ? [yearControl, monthControl] : [monthControl, yearControl];
                  return controls;
                })(),
                import_react64.default.createElement("span", { role: "status", "aria-live": "polite", style: {
                  border: 0,
                  clip: "rect(0 0 0 0)",
                  height: "1px",
                  margin: "-1px",
                  overflow: "hidden",
                  padding: 0,
                  position: "absolute",
                  width: "1px",
                  whiteSpace: "nowrap",
                  wordWrap: "normal"
                } }, formatCaption2(calendarMonth.date, dateLib.options, dateLib))
              ) : import_react64.default.createElement(components.CaptionLabel, { className: classNames[UI.CaptionLabel], role: "status", "aria-live": "polite" }, formatCaption2(calendarMonth.date, dateLib.options, dateLib))),
              navLayout === "around" && !props.hideNavigation && displayIndex === numberOfMonths - 1 && import_react64.default.createElement(
                components.NextMonthButton,
                { type: "button", className: classNames[UI.NextMonthButton], tabIndex: nextMonth ? void 0 : -1, "aria-disabled": nextMonth ? void 0 : true, "aria-label": labelNext2(nextMonth), onClick: handleNextClick, "data-animated-button": props.animate ? "true" : void 0 },
                import_react64.default.createElement(components.Chevron, { disabled: nextMonth ? void 0 : true, className: classNames[UI.Chevron], orientation: props.dir === "rtl" ? "left" : "right" })
              ),
              displayIndex === numberOfMonths - 1 && navLayout === "after" && !props.hideNavigation && import_react64.default.createElement(components.Nav, { "data-animated-nav": props.animate ? "true" : void 0, className: classNames[UI.Nav], style: styles?.[UI.Nav], "aria-label": labelNav2(), onPreviousClick: handlePreviousClick, onNextClick: handleNextClick, previousMonth, nextMonth }),
              import_react64.default.createElement(
                components.MonthGrid,
                { role: "grid", "aria-multiselectable": mode === "multiple" || mode === "range", "aria-label": labelGrid2(calendarMonth.date, dateLib.options, dateLib) || void 0, className: classNames[UI.MonthGrid], style: styles?.[UI.MonthGrid] },
                !props.hideWeekdays && import_react64.default.createElement(
                  components.Weekdays,
                  { "data-animated-weekdays": props.animate ? "true" : void 0, className: classNames[UI.Weekdays], style: styles?.[UI.Weekdays] },
                  showWeekNumber && import_react64.default.createElement(components.WeekNumberHeader, { "aria-label": labelWeekNumberHeader2(dateLib.options), className: classNames[UI.WeekNumberHeader], style: styles?.[UI.WeekNumberHeader], scope: "col" }, formatWeekNumberHeader2()),
                  weekdays.map((weekday) => import_react64.default.createElement(components.Weekday, { "aria-label": labelWeekday2(weekday, dateLib.options, dateLib), className: classNames[UI.Weekday], key: String(weekday), style: styles?.[UI.Weekday], scope: "col" }, formatWeekdayName2(weekday, dateLib.options, dateLib)))
                ),
                import_react64.default.createElement(components.Weeks, { "data-animated-weeks": props.animate ? "true" : void 0, className: classNames[UI.Weeks], style: styles?.[UI.Weeks] }, calendarMonth.weeks.map((week) => {
                  return import_react64.default.createElement(
                    components.Week,
                    { className: classNames[UI.Week], key: week.weekNumber, style: styles?.[UI.Week], week },
                    showWeekNumber && import_react64.default.createElement(components.WeekNumber, { week, style: styles?.[UI.WeekNumber], "aria-label": labelWeekNumber2(week.weekNumber, {
                      locale
                    }), className: classNames[UI.WeekNumber], scope: "row", role: "rowheader" }, formatWeekNumber2(week.weekNumber, dateLib)),
                    week.days.map((day) => {
                      const { date } = day;
                      const modifiers = getModifiers(day);
                      modifiers[DayFlag.focused] = !modifiers.hidden && Boolean(focused?.isEqualTo(day));
                      modifiers[SelectionState.selected] = isSelected?.(date) || modifiers.selected;
                      if (isDateRange(selectedValue)) {
                        const { from, to: to2 } = selectedValue;
                        modifiers[SelectionState.range_start] = Boolean(from && to2 && dateLib.isSameDay(date, from));
                        modifiers[SelectionState.range_end] = Boolean(from && to2 && dateLib.isSameDay(date, to2));
                        modifiers[SelectionState.range_middle] = rangeIncludesDate(selectedValue, date, true, dateLib);
                      }
                      const style2 = getStyleForModifiers(modifiers, styles, props.modifiersStyles);
                      const className2 = getClassNamesForModifiers(modifiers, classNames, props.modifiersClassNames);
                      const ariaLabel = !isInteractive && !modifiers.hidden ? labelGridcell2(date, modifiers, dateLib.options, dateLib) : void 0;
                      return import_react64.default.createElement(components.Day, { key: `${day.isoDate}_${day.displayMonthId}`, day, modifiers, className: className2.join(" "), style: style2, role: "gridcell", "aria-selected": modifiers.selected || void 0, "aria-label": ariaLabel, "data-day": day.isoDate, "data-month": day.outside ? day.dateMonthId : void 0, "data-selected": modifiers.selected || void 0, "data-disabled": modifiers.disabled || void 0, "data-hidden": modifiers.hidden || void 0, "data-outside": day.outside || void 0, "data-focused": modifiers.focused || void 0, "data-today": modifiers.today || void 0 }, !modifiers.hidden && isInteractive ? import_react64.default.createElement(components.DayButton, { className: classNames[UI.DayButton], style: styles?.[UI.DayButton], type: "button", day, modifiers, disabled: !modifiers.focused && modifiers.disabled || void 0, "aria-disabled": modifiers.focused && modifiers.disabled || void 0, tabIndex: isFocusTarget(day) ? 0 : -1, "aria-label": labelDayButton2(date, modifiers, dateLib.options, dateLib), onClick: handleDayClick(day, modifiers), onBlur: handleDayBlur(day, modifiers), onFocus: handleDayFocus(day, modifiers), onKeyDown: handleDayKeyDown(day, modifiers), onMouseEnter: handleDayMouseEnter(day, modifiers), onMouseLeave: handleDayMouseLeave(day, modifiers) }, formatDay2(date, dateLib.options, dateLib)) : !modifiers.hidden && formatDay2(day.date, dateLib.options, dateLib));
                    })
                  );
                }))
              )
            );
          })
        ),
        props.footer && import_react64.default.createElement(components.Footer, { className: classNames[UI.Footer], style: styles?.[UI.Footer], role: "status", "aria-live": "polite" }, props.footer)
      )
    );
  }

  // src/components/Calendar.tsx
  var import_jsx_runtime22 = __toESM(require_jsx_runtime());
  function Calendar2({
    className,
    classNames,
    showOutsideDays = true,
    ...props
  }) {
    return /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(
      DayPicker,
      {
        showOutsideDays,
        className: cn("p-3", className),
        classNames: {
          months: "flex flex-col sm:flex-row space-y-4 sm:space-x-4 sm:space-y-0",
          month: "space-y-4",
          caption: "flex justify-center pt-1 relative items-center",
          caption_label: "text-sm font-medium",
          nav: "space-x-1 flex items-center",
          nav_button: cn(
            buttonVariants({ variant: "outline" }),
            "h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100"
          ),
          nav_button_previous: "absolute left-1",
          nav_button_next: "absolute right-1",
          table: "w-full border-collapse space-y-1",
          head_row: "flex",
          head_cell: "text-muted-foreground rounded-md w-9 font-normal text-[0.8rem]",
          row: "flex w-full mt-2",
          cell: "h-9 w-9 text-center text-sm p-0 relative [&:has([aria-selected].day-range-end)]:rounded-r-md [&:has([aria-selected].day-outside)]:bg-accent/50 [&:has([aria-selected])]:bg-accent first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md focus-within:relative focus-within:z-20",
          day: cn(
            buttonVariants({ variant: "ghost" }),
            "h-9 w-9 p-0 font-normal aria-selected:opacity-100"
          ),
          day_range_end: "day-range-end",
          day_selected: "bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground",
          day_today: "bg-accent text-accent-foreground",
          day_outside: "day-outside text-muted-foreground opacity-50 aria-selected:bg-accent/50 aria-selected:text-muted-foreground aria-selected:opacity-30",
          day_disabled: "text-muted-foreground opacity-50",
          day_range_middle: "aria-selected:bg-accent aria-selected:text-accent-foreground",
          day_hidden: "invisible",
          ...classNames
        },
        ...props
      }
    );
  }
  Calendar2.displayName = "Calendar";

  // src/components/Card.tsx
  var import_jsx_runtime23 = __toESM(require_jsx_runtime());
  function Card({ children, className, hoverable, variant = "glass" }) {
    return /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(
      motion.div,
      {
        initial: { opacity: 0, y: 20 },
        whileInView: { opacity: 1, y: 0 },
        viewport: { once: true, margin: "-50px" },
        transition: { duration: 0.5, ease: "easeOut" },
        whileHover: hoverable ? { y: -5, transition: { duration: 0.2 } } : void 0,
        className: cn(
          "rounded-[2rem] border p-6 transition-all duration-300",
          // Variant Styles
          variant === "simple" && "bg-background border-border shadow-sm",
          variant === "glass" && "bg-background/60 border-white/10 dark:border-white/5 backdrop-blur-md",
          variant === "neon" && "bg-white dark:bg-zinc-900 border-violet-500/50 shadow-[0_0_15px_rgba(139,92,246,0.15)] hover:shadow-[0_0_25px_rgba(139,92,246,0.3)] hover:border-violet-500",
          // Hover effects
          hoverable && variant !== "neon" && "hover:border-violet-500/20",
          className
        ),
        children
      }
    );
  }
  function CardHeader({ children, className }) {
    return /* @__PURE__ */ (0, import_jsx_runtime23.jsx)("div", { className: cn("mb-4", className), children });
  }
  function CardTitle({ children, className }) {
    return /* @__PURE__ */ (0, import_jsx_runtime23.jsx)("h3", { className: cn("text-lg font-semibold", className), children });
  }
  function CardDescription({ children, className }) {
    return /* @__PURE__ */ (0, import_jsx_runtime23.jsx)("p", { className: cn("text-sm text-muted-foreground", className), children });
  }
  function CardContent({ children, className }) {
    return /* @__PURE__ */ (0, import_jsx_runtime23.jsx)("div", { className: cn(className), children });
  }
  function CardFooter({ children, className }) {
    return /* @__PURE__ */ (0, import_jsx_runtime23.jsx)("div", { className: cn("mt-4 flex items-center gap-2", className), children });
  }

  // src/components/Carousel.tsx
  var import_react65 = __toESM(require_react());
  var import_jsx_runtime24 = __toESM(require_jsx_runtime());
  function Carousel({
    items,
    showControls = true,
    showIndicators = true,
    autoPlay = false,
    interval = 5e3,
    className,
    ...props
  }) {
    const containerRef = (0, import_react65.useRef)(null);
    const [currentIndex, setCurrentIndex] = (0, import_react65.useState)(0);
    const [isHovering, setIsHovering] = (0, import_react65.useState)(false);
    (0, import_react65.useEffect)(() => {
      if (!autoPlay || isHovering) return;
      const timer = setInterval(() => {
        scrollToIndex((currentIndex + 1) % items.length);
      }, interval);
      return () => clearInterval(timer);
    }, [currentIndex, autoPlay, interval, isHovering, items.length]);
    const scrollToIndex = (index2) => {
      if (containerRef.current) {
        const scrollWidth = containerRef.current.scrollWidth;
        const itemWidth = scrollWidth / items.length;
        containerRef.current.scrollTo({
          left: itemWidth * index2,
          behavior: "smooth"
        });
        setCurrentIndex(index2);
      }
    };
    const handleScroll2 = () => {
      if (containerRef.current) {
        const scrollLeft = containerRef.current.scrollLeft;
        const scrollWidth = containerRef.current.scrollWidth;
        const itemWidth = scrollWidth / items.length;
        const newIndex = Math.round(scrollLeft / itemWidth);
        if (newIndex !== currentIndex) {
          setCurrentIndex(newIndex);
        }
      }
    };
    return /* @__PURE__ */ (0, import_jsx_runtime24.jsxs)(
      "div",
      {
        className: cn("relative group w-full overflow-hidden rounded-xl", className),
        onMouseEnter: () => setIsHovering(true),
        onMouseLeave: () => setIsHovering(false),
        ...props,
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime24.jsx)(
            "div",
            {
              ref: containerRef,
              className: "flex overflow-x-auto snap-x snap-mandatory scrollbar-hide w-full",
              onScroll: handleScroll2,
              style: { scrollbarWidth: "none", msOverflowStyle: "none" },
              children: items.map((item, index2) => /* @__PURE__ */ (0, import_jsx_runtime24.jsx)(
                "div",
                {
                  className: "w-full flex-shrink-0 snap-center",
                  style: { width: "100%" },
                  children: item
                },
                index2
              ))
            }
          ),
          showControls && /* @__PURE__ */ (0, import_jsx_runtime24.jsxs)(import_jsx_runtime24.Fragment, { children: [
            /* @__PURE__ */ (0, import_jsx_runtime24.jsx)("div", { className: "absolute left-4 top-1/2 -translate-y-1/2 opacity-0 group-hover:opacity-100 transition-opacity duration-200", children: /* @__PURE__ */ (0, import_jsx_runtime24.jsx)(
              Button,
              {
                variant: "outline",
                size: "sm",
                className: "rounded-full w-8 h-8 p-0 bg-background/80 backdrop-blur-sm shadow-sm",
                onClick: () => scrollToIndex(currentIndex === 0 ? items.length - 1 : currentIndex - 1),
                children: /* @__PURE__ */ (0, import_jsx_runtime24.jsx)(ChevronLeft, { className: "w-4 h-4" })
              }
            ) }),
            /* @__PURE__ */ (0, import_jsx_runtime24.jsx)("div", { className: "absolute right-4 top-1/2 -translate-y-1/2 opacity-0 group-hover:opacity-100 transition-opacity duration-200", children: /* @__PURE__ */ (0, import_jsx_runtime24.jsx)(
              Button,
              {
                variant: "outline",
                size: "sm",
                className: "rounded-full w-8 h-8 p-0 bg-background/80 backdrop-blur-sm shadow-sm",
                onClick: () => scrollToIndex((currentIndex + 1) % items.length),
                children: /* @__PURE__ */ (0, import_jsx_runtime24.jsx)(ChevronRight, { className: "w-4 h-4" })
              }
            ) })
          ] }),
          showIndicators && /* @__PURE__ */ (0, import_jsx_runtime24.jsx)("div", { className: "absolute bottom-4 left-1/2 -translate-x-1/2 flex gap-2", children: items.map((_2, index2) => /* @__PURE__ */ (0, import_jsx_runtime24.jsx)(
            "button",
            {
              onClick: () => scrollToIndex(index2),
              className: cn(
                "w-2 h-2 rounded-full transition-all duration-300",
                index2 === currentIndex ? "bg-white w-4" : "bg-white/50 hover:bg-white/70"
              )
            },
            index2
          )) })
        ]
      }
    );
  }

  // src/components/Checkbox.tsx
  var import_react66 = __toESM(require_react());
  var import_jsx_runtime25 = __toESM(require_jsx_runtime());
  var Checkbox = import_react66.default.forwardRef(
    ({
      checked,
      defaultChecked,
      onChange,
      disabled = false,
      label,
      description,
      size: size4 = "md",
      className,
      id: id3
    }, ref) => {
      const [isChecked, setIsChecked] = import_react66.default.useState(defaultChecked || false);
      const controlledChecked = checked !== void 0 ? checked : isChecked;
      const handleChange = () => {
        if (disabled) return;
        const newValue = !controlledChecked;
        if (checked === void 0) {
          setIsChecked(newValue);
        }
        onChange?.(newValue);
      };
      const sizeClasses2 = {
        sm: "w-4 h-4",
        md: "w-5 h-5",
        lg: "w-6 h-6"
      };
      const checkSizes = {
        sm: "w-2.5 h-2.5",
        md: "w-3 h-3",
        lg: "w-3.5 h-3.5"
      };
      return /* @__PURE__ */ (0, import_jsx_runtime25.jsxs)(
        "label",
        {
          className: cn(
            "inline-flex items-start gap-3 cursor-pointer select-none group",
            disabled && "cursor-not-allowed opacity-50",
            className
          ),
          children: [
            /* @__PURE__ */ (0, import_jsx_runtime25.jsxs)("div", { className: "relative flex items-center justify-center pt-0.5", children: [
              /* @__PURE__ */ (0, import_jsx_runtime25.jsx)(
                "input",
                {
                  ref,
                  type: "checkbox",
                  id: id3,
                  checked: controlledChecked,
                  onChange: handleChange,
                  disabled,
                  className: "sr-only"
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime25.jsx)(
                "div",
                {
                  className: cn(
                    sizeClasses2[size4],
                    "rounded-md border-2 transition-all duration-200 ease-out flex items-center justify-center",
                    controlledChecked ? "bg-[#007AFF] border-[#007AFF]" : "bg-background border-border/60 group-hover:border-[#007AFF]/50",
                    "dark:bg-zinc-900 dark:border-zinc-700",
                    controlledChecked && "dark:bg-[#0A84FF] dark:border-[#0A84FF]"
                  ),
                  children: /* @__PURE__ */ (0, import_jsx_runtime25.jsx)(
                    "svg",
                    {
                      className: cn(
                        checkSizes[size4],
                        "text-white transition-all duration-200",
                        controlledChecked ? "opacity-100 scale-100" : "opacity-0 scale-50"
                      ),
                      fill: "none",
                      viewBox: "0 0 24 24",
                      stroke: "currentColor",
                      strokeWidth: 3,
                      children: /* @__PURE__ */ (0, import_jsx_runtime25.jsx)(
                        "path",
                        {
                          strokeLinecap: "round",
                          strokeLinejoin: "round",
                          d: "M5 13l4 4L19 7"
                        }
                      )
                    }
                  )
                }
              )
            ] }),
            (label || description) && /* @__PURE__ */ (0, import_jsx_runtime25.jsxs)("div", { className: "flex flex-col", children: [
              label && /* @__PURE__ */ (0, import_jsx_runtime25.jsx)("span", { className: "text-sm font-medium text-foreground", children: label }),
              description && /* @__PURE__ */ (0, import_jsx_runtime25.jsx)("span", { className: "text-xs text-muted-foreground mt-0.5", children: description })
            ] })
          ]
        }
      );
    }
  );
  Checkbox.displayName = "Checkbox";

  // src/components/CircularProgress.tsx
  var import_jsx_runtime26 = __toESM(require_jsx_runtime());
  function CircularProgress({
    value,
    max: max3 = 100,
    size: size4 = 60,
    strokeWidth = 6,
    circleColor = "stroke-gray-200 dark:stroke-gray-800",
    progressColor = "stroke-blue-600 dark:stroke-blue-500",
    className,
    showValue = true
  }) {
    const radius = (size4 - strokeWidth) / 2;
    const circumference = radius * 2 * Math.PI;
    const offset4 = circumference - value / max3 * circumference;
    return /* @__PURE__ */ (0, import_jsx_runtime26.jsxs)(
      "div",
      {
        className: cn("relative flex items-center justify-center", className),
        style: { width: size4, height: size4 },
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime26.jsxs)(
            "svg",
            {
              width: size4,
              height: size4,
              viewBox: `0 0 ${size4} ${size4}`,
              className: "transform -rotate-90",
              children: [
                /* @__PURE__ */ (0, import_jsx_runtime26.jsx)(
                  "circle",
                  {
                    cx: size4 / 2,
                    cy: size4 / 2,
                    r: radius,
                    fill: "none",
                    strokeWidth,
                    className: cn("transition-colors duration-300", circleColor)
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime26.jsx)(
                  "circle",
                  {
                    cx: size4 / 2,
                    cy: size4 / 2,
                    r: radius,
                    fill: "none",
                    strokeWidth,
                    strokeDasharray: circumference,
                    strokeDashoffset: offset4,
                    strokeLinecap: "round",
                    className: cn("transition-all duration-500 ease-out", progressColor)
                  }
                )
              ]
            }
          ),
          showValue && /* @__PURE__ */ (0, import_jsx_runtime26.jsxs)("span", { className: "absolute text-xs font-medium text-foreground", children: [
            Math.round(value / max3 * 100),
            "%"
          ] })
        ]
      }
    );
  }

  // src/components/Combobox.tsx
  var import_react69 = __toESM(require_react());

  // ../../node_modules/cmdk/dist/chunk-NZJY6EH4.mjs
  var U = 1;
  var Y = 0.9;
  var H = 0.8;
  var J = 0.17;
  var p = 0.1;
  var u = 0.999;
  var $ = 0.9999;
  var k = 0.99;
  var m = /[\\\/_+.#"@\[\(\{&]/;
  var B = /[\\\/_+.#"@\[\(\{&]/g;
  var K = /[\s-]/;
  var X2 = /[\s-]/g;
  function G(_2, C2, h, P2, A3, f2, O) {
    if (f2 === C2.length) return A3 === _2.length ? U : k;
    var T2 = `${A3},${f2}`;
    if (O[T2] !== void 0) return O[T2];
    for (var L2 = P2.charAt(f2), c = h.indexOf(L2, A3), S2 = 0, E2, N2, R, M3; c >= 0; ) E2 = G(_2, C2, h, P2, c + 1, f2 + 1, O), E2 > S2 && (c === A3 ? E2 *= U : m.test(_2.charAt(c - 1)) ? (E2 *= H, R = _2.slice(A3, c - 1).match(B), R && A3 > 0 && (E2 *= Math.pow(u, R.length))) : K.test(_2.charAt(c - 1)) ? (E2 *= Y, M3 = _2.slice(A3, c - 1).match(X2), M3 && A3 > 0 && (E2 *= Math.pow(u, M3.length))) : (E2 *= J, A3 > 0 && (E2 *= Math.pow(u, c - A3))), _2.charAt(c) !== C2.charAt(f2) && (E2 *= $)), (E2 < p && h.charAt(c - 1) === P2.charAt(f2 + 1) || P2.charAt(f2 + 1) === P2.charAt(f2) && h.charAt(c - 1) !== P2.charAt(f2)) && (N2 = G(_2, C2, h, P2, c + 1, f2 + 2, O), N2 * p > E2 && (E2 = N2 * p)), E2 > S2 && (S2 = E2), c = h.indexOf(L2, c + 1);
    return O[T2] = S2, S2;
  }
  function D(_2) {
    return _2.toLowerCase().replace(X2, " ");
  }
  function W(_2, C2, h) {
    return _2 = h && h.length > 0 ? `${_2 + " " + h.join(" ")}` : _2, G(_2, C2, D(_2), D(C2), 0, 0, {});
  }

  // ../../node_modules/@radix-ui/react-dialog/dist/index.mjs
  var React60 = __toESM(require_react2(), 1);

  // ../../node_modules/@radix-ui/primitive/dist/index.mjs
  var canUseDOM = !!(typeof window !== "undefined" && window.document && window.document.createElement);
  function composeEventHandlers(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
    return function handleEvent(event) {
      originalEventHandler?.(event);
      if (checkForDefaultPrevented === false || !event.defaultPrevented) {
        return ourEventHandler?.(event);
      }
    };
  }

  // ../../node_modules/@radix-ui/react-context/dist/index.mjs
  var React42 = __toESM(require_react2(), 1);
  var import_jsx_runtime27 = __toESM(require_jsx_runtime2(), 1);
  function createContext22(rootComponentName, defaultContext) {
    const Context = React42.createContext(defaultContext);
    const Provider2 = (props) => {
      const { children, ...context } = props;
      const value = React42.useMemo(() => context, Object.values(context));
      return /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(Context.Provider, { value, children });
    };
    Provider2.displayName = rootComponentName + "Provider";
    function useContext25(consumerName) {
      const context = React42.useContext(Context);
      if (context) return context;
      if (defaultContext !== void 0) return defaultContext;
      throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    return [Provider2, useContext25];
  }
  function createContextScope2(scopeName, createContextScopeDeps = []) {
    let defaultContexts = [];
    function createContext32(rootComponentName, defaultContext) {
      const BaseContext = React42.createContext(defaultContext);
      const index2 = defaultContexts.length;
      defaultContexts = [...defaultContexts, defaultContext];
      const Provider2 = (props) => {
        const { scope, children, ...context } = props;
        const Context = scope?.[scopeName]?.[index2] || BaseContext;
        const value = React42.useMemo(() => context, Object.values(context));
        return /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(Context.Provider, { value, children });
      };
      Provider2.displayName = rootComponentName + "Provider";
      function useContext25(consumerName, scope) {
        const Context = scope?.[scopeName]?.[index2] || BaseContext;
        const context = React42.useContext(Context);
        if (context) return context;
        if (defaultContext !== void 0) return defaultContext;
        throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
      }
      return [Provider2, useContext25];
    }
    const createScope = () => {
      const scopeContexts = defaultContexts.map((defaultContext) => {
        return React42.createContext(defaultContext);
      });
      return function useScope(scope) {
        const contexts = scope?.[scopeName] || scopeContexts;
        return React42.useMemo(
          () => ({ [`__scope${scopeName}`]: { ...scope, [scopeName]: contexts } }),
          [scope, contexts]
        );
      };
    };
    createScope.scopeName = scopeName;
    return [createContext32, composeContextScopes2(createScope, ...createContextScopeDeps)];
  }
  function composeContextScopes2(...scopes) {
    const baseScope = scopes[0];
    if (scopes.length === 1) return baseScope;
    const createScope = () => {
      const scopeHooks = scopes.map((createScope2) => ({
        useScope: createScope2(),
        scopeName: createScope2.scopeName
      }));
      return function useComposedScopes(overrideScopes) {
        const nextScopes = scopeHooks.reduce((nextScopes2, { useScope, scopeName }) => {
          const scopeProps = useScope(overrideScopes);
          const currentScope = scopeProps[`__scope${scopeName}`];
          return { ...nextScopes2, ...currentScope };
        }, {});
        return React42.useMemo(() => ({ [`__scope${baseScope.scopeName}`]: nextScopes }), [nextScopes]);
      };
    };
    createScope.scopeName = baseScope.scopeName;
    return createScope;
  }

  // ../../node_modules/@radix-ui/react-id/dist/index.mjs
  var React43 = __toESM(require_react2(), 1);
  var useReactId = React43[" useId ".trim().toString()] || (() => void 0);
  var count = 0;
  function useId5(deterministicId) {
    const [id3, setId] = React43.useState(useReactId());
    useLayoutEffect22(() => {
      if (!deterministicId) setId((reactId) => reactId ?? String(count++));
    }, [deterministicId]);
    return deterministicId || (id3 ? `radix-${id3}` : "");
  }

  // ../../node_modules/@radix-ui/react-use-controllable-state/dist/index.mjs
  var React44 = __toESM(require_react2(), 1);
  var React210 = __toESM(require_react2(), 1);
  var useInsertionEffect5 = React44[" useInsertionEffect ".trim().toString()] || useLayoutEffect22;
  function useControllableState({
    prop,
    defaultProp,
    onChange = () => {
    },
    caller
  }) {
    const [uncontrolledProp, setUncontrolledProp, onChangeRef] = useUncontrolledState({
      defaultProp,
      onChange
    });
    const isControlled = prop !== void 0;
    const value = isControlled ? prop : uncontrolledProp;
    if (true) {
      const isControlledRef = React44.useRef(prop !== void 0);
      React44.useEffect(() => {
        const wasControlled = isControlledRef.current;
        if (wasControlled !== isControlled) {
          const from = wasControlled ? "controlled" : "uncontrolled";
          const to2 = isControlled ? "controlled" : "uncontrolled";
          console.warn(
            `${caller} is changing from ${from} to ${to2}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`
          );
        }
        isControlledRef.current = isControlled;
      }, [isControlled, caller]);
    }
    const setValue = React44.useCallback(
      (nextValue) => {
        if (isControlled) {
          const value2 = isFunction(nextValue) ? nextValue(prop) : nextValue;
          if (value2 !== prop) {
            onChangeRef.current?.(value2);
          }
        } else {
          setUncontrolledProp(nextValue);
        }
      },
      [isControlled, prop, setUncontrolledProp, onChangeRef]
    );
    return [value, setValue];
  }
  function useUncontrolledState({
    defaultProp,
    onChange
  }) {
    const [value, setValue] = React44.useState(defaultProp);
    const prevValueRef = React44.useRef(value);
    const onChangeRef = React44.useRef(onChange);
    useInsertionEffect5(() => {
      onChangeRef.current = onChange;
    }, [onChange]);
    React44.useEffect(() => {
      if (prevValueRef.current !== value) {
        onChangeRef.current?.(value);
        prevValueRef.current = value;
      }
    }, [value, prevValueRef]);
    return [value, setValue, onChangeRef];
  }
  function isFunction(value) {
    return typeof value === "function";
  }

  // ../../node_modules/@radix-ui/react-dismissable-layer/dist/index.mjs
  var React48 = __toESM(require_react2(), 1);

  // ../../node_modules/@radix-ui/react-primitive/dist/index.mjs
  var React46 = __toESM(require_react2(), 1);
  var ReactDOM2 = __toESM(require_react_dom(), 1);

  // ../../node_modules/@radix-ui/react-slot/dist/index.mjs
  var React45 = __toESM(require_react2(), 1);
  var import_jsx_runtime28 = __toESM(require_jsx_runtime2(), 1);
  // @__NO_SIDE_EFFECTS__
  function createSlot2(ownerName) {
    const SlotClone = /* @__PURE__ */ createSlotClone2(ownerName);
    const Slot2 = React45.forwardRef((props, forwardedRef) => {
      const { children, ...slotProps } = props;
      const childrenArray = React45.Children.toArray(children);
      const slottable = childrenArray.find(isSlottable2);
      if (slottable) {
        const newElement = slottable.props.children;
        const newChildren = childrenArray.map((child) => {
          if (child === slottable) {
            if (React45.Children.count(newElement) > 1) return React45.Children.only(null);
            return React45.isValidElement(newElement) ? newElement.props.children : null;
          } else {
            return child;
          }
        });
        return /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children: React45.isValidElement(newElement) ? React45.cloneElement(newElement, void 0, newChildren) : null });
      }
      return /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children });
    });
    Slot2.displayName = `${ownerName}.Slot`;
    return Slot2;
  }
  // @__NO_SIDE_EFFECTS__
  function createSlotClone2(ownerName) {
    const SlotClone = React45.forwardRef((props, forwardedRef) => {
      const { children, ...slotProps } = props;
      if (React45.isValidElement(children)) {
        const childrenRef = getElementRef2(children);
        const props2 = mergeProps2(slotProps, children.props);
        if (children.type !== React45.Fragment) {
          props2.ref = forwardedRef ? composeRefs2(forwardedRef, childrenRef) : childrenRef;
        }
        return React45.cloneElement(children, props2);
      }
      return React45.Children.count(children) > 1 ? React45.Children.only(null) : null;
    });
    SlotClone.displayName = `${ownerName}.SlotClone`;
    return SlotClone;
  }
  var SLOTTABLE_IDENTIFIER2 = /* @__PURE__ */ Symbol("radix.slottable");
  // @__NO_SIDE_EFFECTS__
  function createSlottable(ownerName) {
    const Slottable2 = ({ children }) => {
      return /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(import_jsx_runtime28.Fragment, { children });
    };
    Slottable2.displayName = `${ownerName}.Slottable`;
    Slottable2.__radixId = SLOTTABLE_IDENTIFIER2;
    return Slottable2;
  }
  function isSlottable2(child) {
    return React45.isValidElement(child) && typeof child.type === "function" && "__radixId" in child.type && child.type.__radixId === SLOTTABLE_IDENTIFIER2;
  }
  function mergeProps2(slotProps, childProps) {
    const overrideProps = { ...childProps };
    for (const propName in childProps) {
      const slotPropValue = slotProps[propName];
      const childPropValue = childProps[propName];
      const isHandler = /^on[A-Z]/.test(propName);
      if (isHandler) {
        if (slotPropValue && childPropValue) {
          overrideProps[propName] = (...args) => {
            const result = childPropValue(...args);
            slotPropValue(...args);
            return result;
          };
        } else if (slotPropValue) {
          overrideProps[propName] = slotPropValue;
        }
      } else if (propName === "style") {
        overrideProps[propName] = { ...slotPropValue, ...childPropValue };
      } else if (propName === "className") {
        overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
      }
    }
    return { ...slotProps, ...overrideProps };
  }
  function getElementRef2(element) {
    let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get;
    let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
    if (mayWarn) {
      return element.ref;
    }
    getter = Object.getOwnPropertyDescriptor(element, "ref")?.get;
    mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
    if (mayWarn) {
      return element.props.ref;
    }
    return element.props.ref || element.ref;
  }

  // ../../node_modules/@radix-ui/react-primitive/dist/index.mjs
  var import_jsx_runtime29 = __toESM(require_jsx_runtime2(), 1);
  var NODES2 = [
    "a",
    "button",
    "div",
    "form",
    "h2",
    "h3",
    "img",
    "input",
    "label",
    "li",
    "nav",
    "ol",
    "p",
    "select",
    "span",
    "svg",
    "ul"
  ];
  var Primitive2 = NODES2.reduce((primitive, node) => {
    const Slot2 = createSlot2(`Primitive.${node}`);
    const Node2 = React46.forwardRef((props, forwardedRef) => {
      const { asChild, ...primitiveProps } = props;
      const Comp = asChild ? Slot2 : node;
      if (typeof window !== "undefined") {
        window[/* @__PURE__ */ Symbol.for("radix-ui")] = true;
      }
      return /* @__PURE__ */ (0, import_jsx_runtime29.jsx)(Comp, { ...primitiveProps, ref: forwardedRef });
    });
    Node2.displayName = `Primitive.${node}`;
    return { ...primitive, [node]: Node2 };
  }, {});
  function dispatchDiscreteCustomEvent(target, event) {
    if (target) ReactDOM2.flushSync(() => target.dispatchEvent(event));
  }

  // ../../node_modules/@radix-ui/react-use-escape-keydown/dist/index.mjs
  var React47 = __toESM(require_react2(), 1);
  function useEscapeKeydown(onEscapeKeyDownProp, ownerDocument = globalThis?.document) {
    const onEscapeKeyDown = useCallbackRef(onEscapeKeyDownProp);
    React47.useEffect(() => {
      const handleKeyDown = (event) => {
        if (event.key === "Escape") {
          onEscapeKeyDown(event);
        }
      };
      ownerDocument.addEventListener("keydown", handleKeyDown, { capture: true });
      return () => ownerDocument.removeEventListener("keydown", handleKeyDown, { capture: true });
    }, [onEscapeKeyDown, ownerDocument]);
  }

  // ../../node_modules/@radix-ui/react-dismissable-layer/dist/index.mjs
  var import_jsx_runtime30 = __toESM(require_jsx_runtime2(), 1);
  var DISMISSABLE_LAYER_NAME = "DismissableLayer";
  var CONTEXT_UPDATE = "dismissableLayer.update";
  var POINTER_DOWN_OUTSIDE = "dismissableLayer.pointerDownOutside";
  var FOCUS_OUTSIDE = "dismissableLayer.focusOutside";
  var originalBodyPointerEvents;
  var DismissableLayerContext = React48.createContext({
    layers: /* @__PURE__ */ new Set(),
    layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
    branches: /* @__PURE__ */ new Set()
  });
  var DismissableLayer = React48.forwardRef(
    (props, forwardedRef) => {
      const {
        disableOutsidePointerEvents = false,
        onEscapeKeyDown,
        onPointerDownOutside,
        onFocusOutside,
        onInteractOutside,
        onDismiss,
        ...layerProps
      } = props;
      const context = React48.useContext(DismissableLayerContext);
      const [node, setNode] = React48.useState(null);
      const ownerDocument = node?.ownerDocument ?? globalThis?.document;
      const [, force] = React48.useState({});
      const composedRefs = useComposedRefs2(forwardedRef, (node2) => setNode(node2));
      const layers = Array.from(context.layers);
      const [highestLayerWithOutsidePointerEventsDisabled] = [...context.layersWithOutsidePointerEventsDisabled].slice(-1);
      const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled);
      const index2 = node ? layers.indexOf(node) : -1;
      const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;
      const isPointerEventsEnabled = index2 >= highestLayerWithOutsidePointerEventsDisabledIndex;
      const pointerDownOutside = usePointerDownOutside((event) => {
        const target = event.target;
        const isPointerDownOnBranch = [...context.branches].some((branch) => branch.contains(target));
        if (!isPointerEventsEnabled || isPointerDownOnBranch) return;
        onPointerDownOutside?.(event);
        onInteractOutside?.(event);
        if (!event.defaultPrevented) onDismiss?.();
      }, ownerDocument);
      const focusOutside = useFocusOutside((event) => {
        const target = event.target;
        const isFocusInBranch = [...context.branches].some((branch) => branch.contains(target));
        if (isFocusInBranch) return;
        onFocusOutside?.(event);
        onInteractOutside?.(event);
        if (!event.defaultPrevented) onDismiss?.();
      }, ownerDocument);
      useEscapeKeydown((event) => {
        const isHighestLayer = index2 === context.layers.size - 1;
        if (!isHighestLayer) return;
        onEscapeKeyDown?.(event);
        if (!event.defaultPrevented && onDismiss) {
          event.preventDefault();
          onDismiss();
        }
      }, ownerDocument);
      React48.useEffect(() => {
        if (!node) return;
        if (disableOutsidePointerEvents) {
          if (context.layersWithOutsidePointerEventsDisabled.size === 0) {
            originalBodyPointerEvents = ownerDocument.body.style.pointerEvents;
            ownerDocument.body.style.pointerEvents = "none";
          }
          context.layersWithOutsidePointerEventsDisabled.add(node);
        }
        context.layers.add(node);
        dispatchUpdate();
        return () => {
          if (disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1) {
            ownerDocument.body.style.pointerEvents = originalBodyPointerEvents;
          }
        };
      }, [node, ownerDocument, disableOutsidePointerEvents, context]);
      React48.useEffect(() => {
        return () => {
          if (!node) return;
          context.layers.delete(node);
          context.layersWithOutsidePointerEventsDisabled.delete(node);
          dispatchUpdate();
        };
      }, [node, context]);
      React48.useEffect(() => {
        const handleUpdate = () => force({});
        document.addEventListener(CONTEXT_UPDATE, handleUpdate);
        return () => document.removeEventListener(CONTEXT_UPDATE, handleUpdate);
      }, []);
      return /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(
        Primitive2.div,
        {
          ...layerProps,
          ref: composedRefs,
          style: {
            pointerEvents: isBodyPointerEventsDisabled ? isPointerEventsEnabled ? "auto" : "none" : void 0,
            ...props.style
          },
          onFocusCapture: composeEventHandlers(props.onFocusCapture, focusOutside.onFocusCapture),
          onBlurCapture: composeEventHandlers(props.onBlurCapture, focusOutside.onBlurCapture),
          onPointerDownCapture: composeEventHandlers(
            props.onPointerDownCapture,
            pointerDownOutside.onPointerDownCapture
          )
        }
      );
    }
  );
  DismissableLayer.displayName = DISMISSABLE_LAYER_NAME;
  var BRANCH_NAME = "DismissableLayerBranch";
  var DismissableLayerBranch = React48.forwardRef((props, forwardedRef) => {
    const context = React48.useContext(DismissableLayerContext);
    const ref = React48.useRef(null);
    const composedRefs = useComposedRefs2(forwardedRef, ref);
    React48.useEffect(() => {
      const node = ref.current;
      if (node) {
        context.branches.add(node);
        return () => {
          context.branches.delete(node);
        };
      }
    }, [context.branches]);
    return /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(Primitive2.div, { ...props, ref: composedRefs });
  });
  DismissableLayerBranch.displayName = BRANCH_NAME;
  function usePointerDownOutside(onPointerDownOutside, ownerDocument = globalThis?.document) {
    const handlePointerDownOutside = useCallbackRef(onPointerDownOutside);
    const isPointerInsideReactTreeRef = React48.useRef(false);
    const handleClickRef = React48.useRef(() => {
    });
    React48.useEffect(() => {
      const handlePointerDown = (event) => {
        if (event.target && !isPointerInsideReactTreeRef.current) {
          let handleAndDispatchPointerDownOutsideEvent2 = function() {
            handleAndDispatchCustomEvent(
              POINTER_DOWN_OUTSIDE,
              handlePointerDownOutside,
              eventDetail,
              { discrete: true }
            );
          };
          var handleAndDispatchPointerDownOutsideEvent = handleAndDispatchPointerDownOutsideEvent2;
          const eventDetail = { originalEvent: event };
          if (event.pointerType === "touch") {
            ownerDocument.removeEventListener("click", handleClickRef.current);
            handleClickRef.current = handleAndDispatchPointerDownOutsideEvent2;
            ownerDocument.addEventListener("click", handleClickRef.current, { once: true });
          } else {
            handleAndDispatchPointerDownOutsideEvent2();
          }
        } else {
          ownerDocument.removeEventListener("click", handleClickRef.current);
        }
        isPointerInsideReactTreeRef.current = false;
      };
      const timerId = window.setTimeout(() => {
        ownerDocument.addEventListener("pointerdown", handlePointerDown);
      }, 0);
      return () => {
        window.clearTimeout(timerId);
        ownerDocument.removeEventListener("pointerdown", handlePointerDown);
        ownerDocument.removeEventListener("click", handleClickRef.current);
      };
    }, [ownerDocument, handlePointerDownOutside]);
    return {
      // ensures we check React component tree (not just DOM tree)
      onPointerDownCapture: () => isPointerInsideReactTreeRef.current = true
    };
  }
  function useFocusOutside(onFocusOutside, ownerDocument = globalThis?.document) {
    const handleFocusOutside = useCallbackRef(onFocusOutside);
    const isFocusInsideReactTreeRef = React48.useRef(false);
    React48.useEffect(() => {
      const handleFocus = (event) => {
        if (event.target && !isFocusInsideReactTreeRef.current) {
          const eventDetail = { originalEvent: event };
          handleAndDispatchCustomEvent(FOCUS_OUTSIDE, handleFocusOutside, eventDetail, {
            discrete: false
          });
        }
      };
      ownerDocument.addEventListener("focusin", handleFocus);
      return () => ownerDocument.removeEventListener("focusin", handleFocus);
    }, [ownerDocument, handleFocusOutside]);
    return {
      onFocusCapture: () => isFocusInsideReactTreeRef.current = true,
      onBlurCapture: () => isFocusInsideReactTreeRef.current = false
    };
  }
  function dispatchUpdate() {
    const event = new CustomEvent(CONTEXT_UPDATE);
    document.dispatchEvent(event);
  }
  function handleAndDispatchCustomEvent(name, handler, detail, { discrete }) {
    const target = detail.originalEvent.target;
    const event = new CustomEvent(name, { bubbles: false, cancelable: true, detail });
    if (handler) target.addEventListener(name, handler, { once: true });
    if (discrete) {
      dispatchDiscreteCustomEvent(target, event);
    } else {
      target.dispatchEvent(event);
    }
  }

  // ../../node_modules/@radix-ui/react-focus-scope/dist/index.mjs
  var React49 = __toESM(require_react2(), 1);
  var import_jsx_runtime31 = __toESM(require_jsx_runtime2(), 1);
  var AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount";
  var AUTOFOCUS_ON_UNMOUNT = "focusScope.autoFocusOnUnmount";
  var EVENT_OPTIONS = { bubbles: false, cancelable: true };
  var FOCUS_SCOPE_NAME = "FocusScope";
  var FocusScope = React49.forwardRef((props, forwardedRef) => {
    const {
      loop: loop2 = false,
      trapped = false,
      onMountAutoFocus: onMountAutoFocusProp,
      onUnmountAutoFocus: onUnmountAutoFocusProp,
      ...scopeProps
    } = props;
    const [container, setContainer] = React49.useState(null);
    const onMountAutoFocus = useCallbackRef(onMountAutoFocusProp);
    const onUnmountAutoFocus = useCallbackRef(onUnmountAutoFocusProp);
    const lastFocusedElementRef = React49.useRef(null);
    const composedRefs = useComposedRefs2(forwardedRef, (node) => setContainer(node));
    const focusScope = React49.useRef({
      paused: false,
      pause() {
        this.paused = true;
      },
      resume() {
        this.paused = false;
      }
    }).current;
    React49.useEffect(() => {
      if (trapped) {
        let handleFocusIn2 = function(event) {
          if (focusScope.paused || !container) return;
          const target = event.target;
          if (container.contains(target)) {
            lastFocusedElementRef.current = target;
          } else {
            focus(lastFocusedElementRef.current, { select: true });
          }
        }, handleFocusOut2 = function(event) {
          if (focusScope.paused || !container) return;
          const relatedTarget = event.relatedTarget;
          if (relatedTarget === null) return;
          if (!container.contains(relatedTarget)) {
            focus(lastFocusedElementRef.current, { select: true });
          }
        }, handleMutations2 = function(mutations) {
          const focusedElement = document.activeElement;
          if (focusedElement !== document.body) return;
          for (const mutation of mutations) {
            if (mutation.removedNodes.length > 0) focus(container);
          }
        };
        var handleFocusIn = handleFocusIn2, handleFocusOut = handleFocusOut2, handleMutations = handleMutations2;
        document.addEventListener("focusin", handleFocusIn2);
        document.addEventListener("focusout", handleFocusOut2);
        const mutationObserver = new MutationObserver(handleMutations2);
        if (container) mutationObserver.observe(container, { childList: true, subtree: true });
        return () => {
          document.removeEventListener("focusin", handleFocusIn2);
          document.removeEventListener("focusout", handleFocusOut2);
          mutationObserver.disconnect();
        };
      }
    }, [trapped, container, focusScope.paused]);
    React49.useEffect(() => {
      if (container) {
        focusScopesStack.add(focusScope);
        const previouslyFocusedElement = document.activeElement;
        const hasFocusedCandidate = container.contains(previouslyFocusedElement);
        if (!hasFocusedCandidate) {
          const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS);
          container.addEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
          container.dispatchEvent(mountEvent);
          if (!mountEvent.defaultPrevented) {
            focusFirst(removeLinks(getTabbableCandidates(container)), { select: true });
            if (document.activeElement === previouslyFocusedElement) {
              focus(container);
            }
          }
        }
        return () => {
          container.removeEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
          setTimeout(() => {
            const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS);
            container.addEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
            container.dispatchEvent(unmountEvent);
            if (!unmountEvent.defaultPrevented) {
              focus(previouslyFocusedElement ?? document.body, { select: true });
            }
            container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
            focusScopesStack.remove(focusScope);
          }, 0);
        };
      }
    }, [container, onMountAutoFocus, onUnmountAutoFocus, focusScope]);
    const handleKeyDown = React49.useCallback(
      (event) => {
        if (!loop2 && !trapped) return;
        if (focusScope.paused) return;
        const isTabKey = event.key === "Tab" && !event.altKey && !event.ctrlKey && !event.metaKey;
        const focusedElement = document.activeElement;
        if (isTabKey && focusedElement) {
          const container2 = event.currentTarget;
          const [first, last] = getTabbableEdges(container2);
          const hasTabbableElementsInside = first && last;
          if (!hasTabbableElementsInside) {
            if (focusedElement === container2) event.preventDefault();
          } else {
            if (!event.shiftKey && focusedElement === last) {
              event.preventDefault();
              if (loop2) focus(first, { select: true });
            } else if (event.shiftKey && focusedElement === first) {
              event.preventDefault();
              if (loop2) focus(last, { select: true });
            }
          }
        }
      },
      [loop2, trapped, focusScope.paused]
    );
    return /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(Primitive2.div, { tabIndex: -1, ...scopeProps, ref: composedRefs, onKeyDown: handleKeyDown });
  });
  FocusScope.displayName = FOCUS_SCOPE_NAME;
  function focusFirst(candidates, { select = false } = {}) {
    const previouslyFocusedElement = document.activeElement;
    for (const candidate of candidates) {
      focus(candidate, { select });
      if (document.activeElement !== previouslyFocusedElement) return;
    }
  }
  function getTabbableEdges(container) {
    const candidates = getTabbableCandidates(container);
    const first = findVisible(candidates, container);
    const last = findVisible(candidates.reverse(), container);
    return [first, last];
  }
  function getTabbableCandidates(container) {
    const nodes = [];
    const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
      acceptNode: (node) => {
        const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
        if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;
        return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
      }
    });
    while (walker.nextNode()) nodes.push(walker.currentNode);
    return nodes;
  }
  function findVisible(elements, container) {
    for (const element of elements) {
      if (!isHidden(element, { upTo: container })) return element;
    }
  }
  function isHidden(node, { upTo }) {
    if (getComputedStyle(node).visibility === "hidden") return true;
    while (node) {
      if (upTo !== void 0 && node === upTo) return false;
      if (getComputedStyle(node).display === "none") return true;
      node = node.parentElement;
    }
    return false;
  }
  function isSelectableInput(element) {
    return element instanceof HTMLInputElement && "select" in element;
  }
  function focus(element, { select = false } = {}) {
    if (element && element.focus) {
      const previouslyFocusedElement = document.activeElement;
      element.focus({ preventScroll: true });
      if (element !== previouslyFocusedElement && isSelectableInput(element) && select)
        element.select();
    }
  }
  var focusScopesStack = createFocusScopesStack();
  function createFocusScopesStack() {
    let stack = [];
    return {
      add(focusScope) {
        const activeFocusScope = stack[0];
        if (focusScope !== activeFocusScope) {
          activeFocusScope?.pause();
        }
        stack = arrayRemove(stack, focusScope);
        stack.unshift(focusScope);
      },
      remove(focusScope) {
        stack = arrayRemove(stack, focusScope);
        stack[0]?.resume();
      }
    };
  }
  function arrayRemove(array, item) {
    const updatedArray = [...array];
    const index2 = updatedArray.indexOf(item);
    if (index2 !== -1) {
      updatedArray.splice(index2, 1);
    }
    return updatedArray;
  }
  function removeLinks(items) {
    return items.filter((item) => item.tagName !== "A");
  }

  // ../../node_modules/@radix-ui/react-portal/dist/index.mjs
  var React50 = __toESM(require_react2(), 1);
  var import_react_dom = __toESM(require_react_dom(), 1);
  var import_jsx_runtime32 = __toESM(require_jsx_runtime2(), 1);
  var PORTAL_NAME = "Portal";
  var Portal = React50.forwardRef((props, forwardedRef) => {
    const { container: containerProp, ...portalProps } = props;
    const [mounted, setMounted] = React50.useState(false);
    useLayoutEffect22(() => setMounted(true), []);
    const container = containerProp || mounted && globalThis?.document?.body;
    return container ? import_react_dom.default.createPortal(/* @__PURE__ */ (0, import_jsx_runtime32.jsx)(Primitive2.div, { ...portalProps, ref: forwardedRef }), container) : null;
  });
  Portal.displayName = PORTAL_NAME;

  // ../../node_modules/@radix-ui/react-presence/dist/index.mjs
  var React211 = __toESM(require_react2(), 1);
  var React51 = __toESM(require_react2(), 1);
  function useStateMachine(initialState, machine) {
    return React51.useReducer((state, event) => {
      const nextState = machine[state][event];
      return nextState ?? state;
    }, initialState);
  }
  var Presence = (props) => {
    const { present, children } = props;
    const presence = usePresence2(present);
    const child = typeof children === "function" ? children({ present: presence.isPresent }) : React211.Children.only(children);
    const ref = useComposedRefs2(presence.ref, getElementRef3(child));
    const forceMount = typeof children === "function";
    return forceMount || presence.isPresent ? React211.cloneElement(child, { ref }) : null;
  };
  Presence.displayName = "Presence";
  function usePresence2(present) {
    const [node, setNode] = React211.useState();
    const stylesRef = React211.useRef(null);
    const prevPresentRef = React211.useRef(present);
    const prevAnimationNameRef = React211.useRef("none");
    const initialState = present ? "mounted" : "unmounted";
    const [state, send] = useStateMachine(initialState, {
      mounted: {
        UNMOUNT: "unmounted",
        ANIMATION_OUT: "unmountSuspended"
      },
      unmountSuspended: {
        MOUNT: "mounted",
        ANIMATION_END: "unmounted"
      },
      unmounted: {
        MOUNT: "mounted"
      }
    });
    React211.useEffect(() => {
      const currentAnimationName = getAnimationName(stylesRef.current);
      prevAnimationNameRef.current = state === "mounted" ? currentAnimationName : "none";
    }, [state]);
    useLayoutEffect22(() => {
      const styles = stylesRef.current;
      const wasPresent = prevPresentRef.current;
      const hasPresentChanged = wasPresent !== present;
      if (hasPresentChanged) {
        const prevAnimationName = prevAnimationNameRef.current;
        const currentAnimationName = getAnimationName(styles);
        if (present) {
          send("MOUNT");
        } else if (currentAnimationName === "none" || styles?.display === "none") {
          send("UNMOUNT");
        } else {
          const isAnimating2 = prevAnimationName !== currentAnimationName;
          if (wasPresent && isAnimating2) {
            send("ANIMATION_OUT");
          } else {
            send("UNMOUNT");
          }
        }
        prevPresentRef.current = present;
      }
    }, [present, send]);
    useLayoutEffect22(() => {
      if (node) {
        let timeoutId;
        const ownerWindow = node.ownerDocument.defaultView ?? window;
        const handleAnimationEnd = (event) => {
          const currentAnimationName = getAnimationName(stylesRef.current);
          const isCurrentAnimation = currentAnimationName.includes(CSS.escape(event.animationName));
          if (event.target === node && isCurrentAnimation) {
            send("ANIMATION_END");
            if (!prevPresentRef.current) {
              const currentFillMode = node.style.animationFillMode;
              node.style.animationFillMode = "forwards";
              timeoutId = ownerWindow.setTimeout(() => {
                if (node.style.animationFillMode === "forwards") {
                  node.style.animationFillMode = currentFillMode;
                }
              });
            }
          }
        };
        const handleAnimationStart = (event) => {
          if (event.target === node) {
            prevAnimationNameRef.current = getAnimationName(stylesRef.current);
          }
        };
        node.addEventListener("animationstart", handleAnimationStart);
        node.addEventListener("animationcancel", handleAnimationEnd);
        node.addEventListener("animationend", handleAnimationEnd);
        return () => {
          ownerWindow.clearTimeout(timeoutId);
          node.removeEventListener("animationstart", handleAnimationStart);
          node.removeEventListener("animationcancel", handleAnimationEnd);
          node.removeEventListener("animationend", handleAnimationEnd);
        };
      } else {
        send("ANIMATION_END");
      }
    }, [node, send]);
    return {
      isPresent: ["mounted", "unmountSuspended"].includes(state),
      ref: React211.useCallback((node2) => {
        stylesRef.current = node2 ? getComputedStyle(node2) : null;
        setNode(node2);
      }, [])
    };
  }
  function getAnimationName(styles) {
    return styles?.animationName || "none";
  }
  function getElementRef3(element) {
    let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get;
    let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
    if (mayWarn) {
      return element.ref;
    }
    getter = Object.getOwnPropertyDescriptor(element, "ref")?.get;
    mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
    if (mayWarn) {
      return element.props.ref;
    }
    return element.props.ref || element.ref;
  }

  // ../../node_modules/@radix-ui/react-focus-guards/dist/index.mjs
  var React52 = __toESM(require_react2(), 1);
  var count2 = 0;
  function useFocusGuards() {
    React52.useEffect(() => {
      const edgeGuards = document.querySelectorAll("[data-radix-focus-guard]");
      document.body.insertAdjacentElement("afterbegin", edgeGuards[0] ?? createFocusGuard());
      document.body.insertAdjacentElement("beforeend", edgeGuards[1] ?? createFocusGuard());
      count2++;
      return () => {
        if (count2 === 1) {
          document.querySelectorAll("[data-radix-focus-guard]").forEach((node) => node.remove());
        }
        count2--;
      };
    }, []);
  }
  function createFocusGuard() {
    const element = document.createElement("span");
    element.setAttribute("data-radix-focus-guard", "");
    element.tabIndex = 0;
    element.style.outline = "none";
    element.style.opacity = "0";
    element.style.position = "fixed";
    element.style.pointerEvents = "none";
    return element;
  }

  // ../../node_modules/tslib/tslib.es6.mjs
  var __assign = function() {
    __assign = Object.assign || function __assign2(t3) {
      for (var s, i3 = 1, n2 = arguments.length; i3 < n2; i3++) {
        s = arguments[i3];
        for (var p3 in s) if (Object.prototype.hasOwnProperty.call(s, p3)) t3[p3] = s[p3];
      }
      return t3;
    };
    return __assign.apply(this, arguments);
  };
  function __rest(s, e2) {
    var t3 = {};
    for (var p3 in s) if (Object.prototype.hasOwnProperty.call(s, p3) && e2.indexOf(p3) < 0)
      t3[p3] = s[p3];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i3 = 0, p3 = Object.getOwnPropertySymbols(s); i3 < p3.length; i3++) {
        if (e2.indexOf(p3[i3]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p3[i3]))
          t3[p3[i3]] = s[p3[i3]];
      }
    return t3;
  }
  function __spreadArray(to2, from, pack) {
    if (pack || arguments.length === 2) for (var i3 = 0, l2 = from.length, ar; i3 < l2; i3++) {
      if (ar || !(i3 in from)) {
        if (!ar) ar = Array.prototype.slice.call(from, 0, i3);
        ar[i3] = from[i3];
      }
    }
    return to2.concat(ar || Array.prototype.slice.call(from));
  }

  // ../../node_modules/react-remove-scroll/dist/es2015/Combination.js
  var React59 = __toESM(require_react2());

  // ../../node_modules/react-remove-scroll/dist/es2015/UI.js
  var React55 = __toESM(require_react2());

  // ../../node_modules/react-remove-scroll-bar/dist/es2015/constants.js
  var zeroRightClassName = "right-scroll-bar-position";
  var fullWidthClassName = "width-before-scroll-bar";
  var noScrollbarsClassName = "with-scroll-bars-hidden";
  var removedBarSizeVariable = "--removed-body-scroll-bar-size";

  // ../../node_modules/use-callback-ref/dist/es2015/assignRef.js
  function assignRef(ref, value) {
    if (typeof ref === "function") {
      ref(value);
    } else if (ref) {
      ref.current = value;
    }
    return ref;
  }

  // ../../node_modules/use-callback-ref/dist/es2015/useRef.js
  var import_react67 = __toESM(require_react2());
  function useCallbackRef2(initialValue, callback) {
    var ref = (0, import_react67.useState)(function() {
      return {
        // value
        value: initialValue,
        // last callback
        callback,
        // "memoized" public interface
        facade: {
          get current() {
            return ref.value;
          },
          set current(value) {
            var last = ref.value;
            if (last !== value) {
              ref.value = value;
              ref.callback(value, last);
            }
          }
        }
      };
    })[0];
    ref.callback = callback;
    return ref.facade;
  }

  // ../../node_modules/use-callback-ref/dist/es2015/useMergeRef.js
  var React53 = __toESM(require_react2());
  var useIsomorphicLayoutEffect2 = typeof window !== "undefined" ? React53.useLayoutEffect : React53.useEffect;
  var currentValues = /* @__PURE__ */ new WeakMap();
  function useMergeRefs(refs, defaultValue) {
    var callbackRef = useCallbackRef2(defaultValue || null, function(newValue) {
      return refs.forEach(function(ref) {
        return assignRef(ref, newValue);
      });
    });
    useIsomorphicLayoutEffect2(function() {
      var oldValue = currentValues.get(callbackRef);
      if (oldValue) {
        var prevRefs_1 = new Set(oldValue);
        var nextRefs_1 = new Set(refs);
        var current_1 = callbackRef.current;
        prevRefs_1.forEach(function(ref) {
          if (!nextRefs_1.has(ref)) {
            assignRef(ref, null);
          }
        });
        nextRefs_1.forEach(function(ref) {
          if (!prevRefs_1.has(ref)) {
            assignRef(ref, current_1);
          }
        });
      }
      currentValues.set(callbackRef, refs);
    }, [refs]);
    return callbackRef;
  }

  // ../../node_modules/use-sidecar/dist/es2015/medium.js
  function ItoI(a) {
    return a;
  }
  function innerCreateMedium(defaults2, middleware) {
    if (middleware === void 0) {
      middleware = ItoI;
    }
    var buffer = [];
    var assigned = false;
    var medium = {
      read: function() {
        if (assigned) {
          throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
        }
        if (buffer.length) {
          return buffer[buffer.length - 1];
        }
        return defaults2;
      },
      useMedium: function(data) {
        var item = middleware(data, assigned);
        buffer.push(item);
        return function() {
          buffer = buffer.filter(function(x2) {
            return x2 !== item;
          });
        };
      },
      assignSyncMedium: function(cb) {
        assigned = true;
        while (buffer.length) {
          var cbs = buffer;
          buffer = [];
          cbs.forEach(cb);
        }
        buffer = {
          push: function(x2) {
            return cb(x2);
          },
          filter: function() {
            return buffer;
          }
        };
      },
      assignMedium: function(cb) {
        assigned = true;
        var pendingQueue = [];
        if (buffer.length) {
          var cbs = buffer;
          buffer = [];
          cbs.forEach(cb);
          pendingQueue = buffer;
        }
        var executeQueue = function() {
          var cbs2 = pendingQueue;
          pendingQueue = [];
          cbs2.forEach(cb);
        };
        var cycle = function() {
          return Promise.resolve().then(executeQueue);
        };
        cycle();
        buffer = {
          push: function(x2) {
            pendingQueue.push(x2);
            cycle();
          },
          filter: function(filter2) {
            pendingQueue = pendingQueue.filter(filter2);
            return buffer;
          }
        };
      }
    };
    return medium;
  }
  function createSidecarMedium(options) {
    if (options === void 0) {
      options = {};
    }
    var medium = innerCreateMedium(null);
    medium.options = __assign({ async: true, ssr: false }, options);
    return medium;
  }

  // ../../node_modules/use-sidecar/dist/es2015/exports.js
  var React54 = __toESM(require_react2());
  var SideCar = function(_a) {
    var sideCar = _a.sideCar, rest = __rest(_a, ["sideCar"]);
    if (!sideCar) {
      throw new Error("Sidecar: please provide `sideCar` property to import the right car");
    }
    var Target = sideCar.read();
    if (!Target) {
      throw new Error("Sidecar medium not found");
    }
    return React54.createElement(Target, __assign({}, rest));
  };
  SideCar.isSideCarExport = true;
  function exportSidecar(medium, exported) {
    medium.useMedium(exported);
    return SideCar;
  }

  // ../../node_modules/react-remove-scroll/dist/es2015/medium.js
  var effectCar = createSidecarMedium();

  // ../../node_modules/react-remove-scroll/dist/es2015/UI.js
  var nothing = function() {
    return;
  };
  var RemoveScroll = React55.forwardRef(function(props, parentRef) {
    var ref = React55.useRef(null);
    var _a = React55.useState({
      onScrollCapture: nothing,
      onWheelCapture: nothing,
      onTouchMoveCapture: nothing
    }), callbacks = _a[0], setCallbacks = _a[1];
    var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noRelative = props.noRelative, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b = props.as, Container = _b === void 0 ? "div" : _b, gapMode = props.gapMode, rest = __rest(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noRelative", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]);
    var SideCar2 = sideCar;
    var containerRef = useMergeRefs([ref, parentRef]);
    var containerProps = __assign(__assign({}, rest), callbacks);
    return React55.createElement(
      React55.Fragment,
      null,
      enabled && React55.createElement(SideCar2, { sideCar: effectCar, removeScrollBar, shards, noRelative, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref, gapMode }),
      forwardProps ? React55.cloneElement(React55.Children.only(children), __assign(__assign({}, containerProps), { ref: containerRef })) : React55.createElement(Container, __assign({}, containerProps, { className, ref: containerRef }), children)
    );
  });
  RemoveScroll.defaultProps = {
    enabled: true,
    removeScrollBar: true,
    inert: false
  };
  RemoveScroll.classNames = {
    fullWidth: fullWidthClassName,
    zeroRight: zeroRightClassName
  };

  // ../../node_modules/react-remove-scroll/dist/es2015/SideEffect.js
  var React58 = __toESM(require_react2());

  // ../../node_modules/react-remove-scroll-bar/dist/es2015/component.js
  var React57 = __toESM(require_react2());

  // ../../node_modules/react-style-singleton/dist/es2015/hook.js
  var React56 = __toESM(require_react2());

  // ../../node_modules/get-nonce/dist/es2015/index.js
  var currentNonce;
  var getNonce = function() {
    if (currentNonce) {
      return currentNonce;
    }
    if (typeof __webpack_nonce__ !== "undefined") {
      return __webpack_nonce__;
    }
    return void 0;
  };

  // ../../node_modules/react-style-singleton/dist/es2015/singleton.js
  function makeStyleTag() {
    if (!document)
      return null;
    var tag = document.createElement("style");
    tag.type = "text/css";
    var nonce = getNonce();
    if (nonce) {
      tag.setAttribute("nonce", nonce);
    }
    return tag;
  }
  function injectStyles(tag, css) {
    if (tag.styleSheet) {
      tag.styleSheet.cssText = css;
    } else {
      tag.appendChild(document.createTextNode(css));
    }
  }
  function insertStyleTag(tag) {
    var head = document.head || document.getElementsByTagName("head")[0];
    head.appendChild(tag);
  }
  var stylesheetSingleton = function() {
    var counter = 0;
    var stylesheet = null;
    return {
      add: function(style) {
        if (counter == 0) {
          if (stylesheet = makeStyleTag()) {
            injectStyles(stylesheet, style);
            insertStyleTag(stylesheet);
          }
        }
        counter++;
      },
      remove: function() {
        counter--;
        if (!counter && stylesheet) {
          stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
          stylesheet = null;
        }
      }
    };
  };

  // ../../node_modules/react-style-singleton/dist/es2015/hook.js
  var styleHookSingleton = function() {
    var sheet = stylesheetSingleton();
    return function(styles, isDynamic) {
      React56.useEffect(function() {
        sheet.add(styles);
        return function() {
          sheet.remove();
        };
      }, [styles && isDynamic]);
    };
  };

  // ../../node_modules/react-style-singleton/dist/es2015/component.js
  var styleSingleton = function() {
    var useStyle2 = styleHookSingleton();
    var Sheet2 = function(_a) {
      var styles = _a.styles, dynamic = _a.dynamic;
      useStyle2(styles, dynamic);
      return null;
    };
    return Sheet2;
  };

  // ../../node_modules/react-remove-scroll-bar/dist/es2015/utils.js
  var zeroGap = {
    left: 0,
    top: 0,
    right: 0,
    gap: 0
  };
  var parse = function(x2) {
    return parseInt(x2 || "", 10) || 0;
  };
  var getOffset = function(gapMode) {
    var cs = window.getComputedStyle(document.body);
    var left = cs[gapMode === "padding" ? "paddingLeft" : "marginLeft"];
    var top = cs[gapMode === "padding" ? "paddingTop" : "marginTop"];
    var right = cs[gapMode === "padding" ? "paddingRight" : "marginRight"];
    return [parse(left), parse(top), parse(right)];
  };
  var getGapWidth = function(gapMode) {
    if (gapMode === void 0) {
      gapMode = "margin";
    }
    if (typeof window === "undefined") {
      return zeroGap;
    }
    var offsets = getOffset(gapMode);
    var documentWidth = document.documentElement.clientWidth;
    var windowWidth = window.innerWidth;
    return {
      left: offsets[0],
      top: offsets[1],
      right: offsets[2],
      gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
    };
  };

  // ../../node_modules/react-remove-scroll-bar/dist/es2015/component.js
  var Style = styleSingleton();
  var lockAttribute = "data-scroll-locked";
  var getStyles = function(_a, allowRelative, gapMode, important) {
    var left = _a.left, top = _a.top, right = _a.right, gap = _a.gap;
    if (gapMode === void 0) {
      gapMode = "margin";
    }
    return "\n  .".concat(noScrollbarsClassName, " {\n   overflow: hidden ").concat(important, ";\n   padding-right: ").concat(gap, "px ").concat(important, ";\n  }\n  body[").concat(lockAttribute, "] {\n    overflow: hidden ").concat(important, ";\n    overscroll-behavior: contain;\n    ").concat([
      allowRelative && "position: relative ".concat(important, ";"),
      gapMode === "margin" && "\n    padding-left: ".concat(left, "px;\n    padding-top: ").concat(top, "px;\n    padding-right: ").concat(right, "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ").concat(gap, "px ").concat(important, ";\n    "),
      gapMode === "padding" && "padding-right: ".concat(gap, "px ").concat(important, ";")
    ].filter(Boolean).join(""), "\n  }\n  \n  .").concat(zeroRightClassName, " {\n    right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " {\n    margin-right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(zeroRightClassName, " .").concat(zeroRightClassName, " {\n    right: 0 ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " .").concat(fullWidthClassName, " {\n    margin-right: 0 ").concat(important, ";\n  }\n  \n  body[").concat(lockAttribute, "] {\n    ").concat(removedBarSizeVariable, ": ").concat(gap, "px;\n  }\n");
  };
  var getCurrentUseCounter = function() {
    var counter = parseInt(document.body.getAttribute(lockAttribute) || "0", 10);
    return isFinite(counter) ? counter : 0;
  };
  var useLockAttribute = function() {
    React57.useEffect(function() {
      document.body.setAttribute(lockAttribute, (getCurrentUseCounter() + 1).toString());
      return function() {
        var newCounter = getCurrentUseCounter() - 1;
        if (newCounter <= 0) {
          document.body.removeAttribute(lockAttribute);
        } else {
          document.body.setAttribute(lockAttribute, newCounter.toString());
        }
      };
    }, []);
  };
  var RemoveScrollBar = function(_a) {
    var noRelative = _a.noRelative, noImportant = _a.noImportant, _b = _a.gapMode, gapMode = _b === void 0 ? "margin" : _b;
    useLockAttribute();
    var gap = React57.useMemo(function() {
      return getGapWidth(gapMode);
    }, [gapMode]);
    return React57.createElement(Style, { styles: getStyles(gap, !noRelative, gapMode, !noImportant ? "!important" : "") });
  };

  // ../../node_modules/react-remove-scroll/dist/es2015/aggresiveCapture.js
  var passiveSupported = false;
  if (typeof window !== "undefined") {
    try {
      options = Object.defineProperty({}, "passive", {
        get: function() {
          passiveSupported = true;
          return true;
        }
      });
      window.addEventListener("test", options, options);
      window.removeEventListener("test", options, options);
    } catch (err) {
      passiveSupported = false;
    }
  }
  var options;
  var nonPassive = passiveSupported ? { passive: false } : false;

  // ../../node_modules/react-remove-scroll/dist/es2015/handleScroll.js
  var alwaysContainsScroll = function(node) {
    return node.tagName === "TEXTAREA";
  };
  var elementCanBeScrolled = function(node, overflow) {
    if (!(node instanceof Element)) {
      return false;
    }
    var styles = window.getComputedStyle(node);
    return (
      // not-not-scrollable
      styles[overflow] !== "hidden" && // contains scroll inside self
      !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node) && styles[overflow] === "visible")
    );
  };
  var elementCouldBeVScrolled = function(node) {
    return elementCanBeScrolled(node, "overflowY");
  };
  var elementCouldBeHScrolled = function(node) {
    return elementCanBeScrolled(node, "overflowX");
  };
  var locationCouldBeScrolled = function(axis, node) {
    var ownerDocument = node.ownerDocument;
    var current = node;
    do {
      if (typeof ShadowRoot !== "undefined" && current instanceof ShadowRoot) {
        current = current.host;
      }
      var isScrollable = elementCouldBeScrolled(axis, current);
      if (isScrollable) {
        var _a = getScrollVariables(axis, current), scrollHeight = _a[1], clientHeight = _a[2];
        if (scrollHeight > clientHeight) {
          return true;
        }
      }
      current = current.parentNode;
    } while (current && current !== ownerDocument.body);
    return false;
  };
  var getVScrollVariables = function(_a) {
    var scrollTop = _a.scrollTop, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight;
    return [
      scrollTop,
      scrollHeight,
      clientHeight
    ];
  };
  var getHScrollVariables = function(_a) {
    var scrollLeft = _a.scrollLeft, scrollWidth = _a.scrollWidth, clientWidth = _a.clientWidth;
    return [
      scrollLeft,
      scrollWidth,
      clientWidth
    ];
  };
  var elementCouldBeScrolled = function(axis, node) {
    return axis === "v" ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);
  };
  var getScrollVariables = function(axis, node) {
    return axis === "v" ? getVScrollVariables(node) : getHScrollVariables(node);
  };
  var getDirectionFactor = function(axis, direction) {
    return axis === "h" && direction === "rtl" ? -1 : 1;
  };
  var handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {
    var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);
    var delta = directionFactor * sourceDelta;
    var target = event.target;
    var targetInLock = endTarget.contains(target);
    var shouldCancelScroll = false;
    var isDeltaPositive = delta > 0;
    var availableScroll = 0;
    var availableScrollTop = 0;
    do {
      if (!target) {
        break;
      }
      var _a = getScrollVariables(axis, target), position = _a[0], scroll_1 = _a[1], capacity = _a[2];
      var elementScroll = scroll_1 - capacity - directionFactor * position;
      if (position || elementScroll) {
        if (elementCouldBeScrolled(axis, target)) {
          availableScroll += elementScroll;
          availableScrollTop += position;
        }
      }
      var parent_1 = target.parentNode;
      target = parent_1 && parent_1.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? parent_1.host : parent_1;
    } while (
      // portaled content
      !targetInLock && target !== document.body || // self content
      targetInLock && (endTarget.contains(target) || endTarget === target)
    );
    if (isDeltaPositive && (noOverscroll && Math.abs(availableScroll) < 1 || !noOverscroll && delta > availableScroll)) {
      shouldCancelScroll = true;
    } else if (!isDeltaPositive && (noOverscroll && Math.abs(availableScrollTop) < 1 || !noOverscroll && -delta > availableScrollTop)) {
      shouldCancelScroll = true;
    }
    return shouldCancelScroll;
  };

  // ../../node_modules/react-remove-scroll/dist/es2015/SideEffect.js
  var getTouchXY = function(event) {
    return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
  };
  var getDeltaXY = function(event) {
    return [event.deltaX, event.deltaY];
  };
  var extractRef = function(ref) {
    return ref && "current" in ref ? ref.current : ref;
  };
  var deltaCompare = function(x2, y2) {
    return x2[0] === y2[0] && x2[1] === y2[1];
  };
  var generateStyle = function(id3) {
    return "\n  .block-interactivity-".concat(id3, " {pointer-events: none;}\n  .allow-interactivity-").concat(id3, " {pointer-events: all;}\n");
  };
  var idCounter = 0;
  var lockStack = [];
  function RemoveScrollSideCar(props) {
    var shouldPreventQueue = React58.useRef([]);
    var touchStartRef = React58.useRef([0, 0]);
    var activeAxis = React58.useRef();
    var id3 = React58.useState(idCounter++)[0];
    var Style2 = React58.useState(styleSingleton)[0];
    var lastProps = React58.useRef(props);
    React58.useEffect(function() {
      lastProps.current = props;
    }, [props]);
    React58.useEffect(function() {
      if (props.inert) {
        document.body.classList.add("block-interactivity-".concat(id3));
        var allow_1 = __spreadArray([props.lockRef.current], (props.shards || []).map(extractRef), true).filter(Boolean);
        allow_1.forEach(function(el) {
          return el.classList.add("allow-interactivity-".concat(id3));
        });
        return function() {
          document.body.classList.remove("block-interactivity-".concat(id3));
          allow_1.forEach(function(el) {
            return el.classList.remove("allow-interactivity-".concat(id3));
          });
        };
      }
      return;
    }, [props.inert, props.lockRef.current, props.shards]);
    var shouldCancelEvent = React58.useCallback(function(event, parent) {
      if ("touches" in event && event.touches.length === 2 || event.type === "wheel" && event.ctrlKey) {
        return !lastProps.current.allowPinchZoom;
      }
      var touch = getTouchXY(event);
      var touchStart = touchStartRef.current;
      var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
      var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
      var currentAxis;
      var target = event.target;
      var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
      if ("touches" in event && moveDirection === "h" && target.type === "range") {
        return false;
      }
      var selection = window.getSelection();
      var anchorNode = selection && selection.anchorNode;
      var isTouchingSelection = anchorNode ? anchorNode === target || anchorNode.contains(target) : false;
      if (isTouchingSelection) {
        return false;
      }
      var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
      if (!canBeScrolledInMainDirection) {
        return true;
      }
      if (canBeScrolledInMainDirection) {
        currentAxis = moveDirection;
      } else {
        currentAxis = moveDirection === "v" ? "h" : "v";
        canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
      }
      if (!canBeScrolledInMainDirection) {
        return false;
      }
      if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
        activeAxis.current = currentAxis;
      }
      if (!currentAxis) {
        return true;
      }
      var cancelingAxis = activeAxis.current || currentAxis;
      return handleScroll(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY, true);
    }, []);
    var shouldPrevent = React58.useCallback(function(_event) {
      var event = _event;
      if (!lockStack.length || lockStack[lockStack.length - 1] !== Style2) {
        return;
      }
      var delta = "deltaY" in event ? getDeltaXY(event) : getTouchXY(event);
      var sourceEvent = shouldPreventQueue.current.filter(function(e2) {
        return e2.name === event.type && (e2.target === event.target || event.target === e2.shadowParent) && deltaCompare(e2.delta, delta);
      })[0];
      if (sourceEvent && sourceEvent.should) {
        if (event.cancelable) {
          event.preventDefault();
        }
        return;
      }
      if (!sourceEvent) {
        var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function(node) {
          return node.contains(event.target);
        });
        var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
        if (shouldStop) {
          if (event.cancelable) {
            event.preventDefault();
          }
        }
      }
    }, []);
    var shouldCancel = React58.useCallback(function(name, delta, target, should) {
      var event = { name, delta, target, should, shadowParent: getOutermostShadowParent(target) };
      shouldPreventQueue.current.push(event);
      setTimeout(function() {
        shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e2) {
          return e2 !== event;
        });
      }, 1);
    }, []);
    var scrollTouchStart = React58.useCallback(function(event) {
      touchStartRef.current = getTouchXY(event);
      activeAxis.current = void 0;
    }, []);
    var scrollWheel = React58.useCallback(function(event) {
      shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
    }, []);
    var scrollTouchMove = React58.useCallback(function(event) {
      shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
    }, []);
    React58.useEffect(function() {
      lockStack.push(Style2);
      props.setCallbacks({
        onScrollCapture: scrollWheel,
        onWheelCapture: scrollWheel,
        onTouchMoveCapture: scrollTouchMove
      });
      document.addEventListener("wheel", shouldPrevent, nonPassive);
      document.addEventListener("touchmove", shouldPrevent, nonPassive);
      document.addEventListener("touchstart", scrollTouchStart, nonPassive);
      return function() {
        lockStack = lockStack.filter(function(inst) {
          return inst !== Style2;
        });
        document.removeEventListener("wheel", shouldPrevent, nonPassive);
        document.removeEventListener("touchmove", shouldPrevent, nonPassive);
        document.removeEventListener("touchstart", scrollTouchStart, nonPassive);
      };
    }, []);
    var removeScrollBar = props.removeScrollBar, inert = props.inert;
    return React58.createElement(
      React58.Fragment,
      null,
      inert ? React58.createElement(Style2, { styles: generateStyle(id3) }) : null,
      removeScrollBar ? React58.createElement(RemoveScrollBar, { noRelative: props.noRelative, gapMode: props.gapMode }) : null
    );
  }
  function getOutermostShadowParent(node) {
    var shadowParent = null;
    while (node !== null) {
      if (node instanceof ShadowRoot) {
        shadowParent = node.host;
        node = node.host;
      }
      node = node.parentNode;
    }
    return shadowParent;
  }

  // ../../node_modules/react-remove-scroll/dist/es2015/sidecar.js
  var sidecar_default = exportSidecar(effectCar, RemoveScrollSideCar);

  // ../../node_modules/react-remove-scroll/dist/es2015/Combination.js
  var ReactRemoveScroll = React59.forwardRef(function(props, ref) {
    return React59.createElement(RemoveScroll, __assign({}, props, { ref, sideCar: sidecar_default }));
  });
  ReactRemoveScroll.classNames = RemoveScroll.classNames;
  var Combination_default = ReactRemoveScroll;

  // ../../node_modules/aria-hidden/dist/es2015/index.js
  var getDefaultParent = function(originalTarget) {
    if (typeof document === "undefined") {
      return null;
    }
    var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
    return sampleTarget.ownerDocument.body;
  };
  var counterMap = /* @__PURE__ */ new WeakMap();
  var uncontrolledNodes = /* @__PURE__ */ new WeakMap();
  var markerMap = {};
  var lockCount = 0;
  var unwrapHost = function(node) {
    return node && (node.host || unwrapHost(node.parentNode));
  };
  var correctTargets = function(parent, targets) {
    return targets.map(function(target) {
      if (parent.contains(target)) {
        return target;
      }
      var correctedTarget = unwrapHost(target);
      if (correctedTarget && parent.contains(correctedTarget)) {
        return correctedTarget;
      }
      console.error("aria-hidden", target, "in not contained inside", parent, ". Doing nothing");
      return null;
    }).filter(function(x2) {
      return Boolean(x2);
    });
  };
  var applyAttributeToOthers = function(originalTarget, parentNode, markerName, controlAttribute) {
    var targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
    if (!markerMap[markerName]) {
      markerMap[markerName] = /* @__PURE__ */ new WeakMap();
    }
    var markerCounter = markerMap[markerName];
    var hiddenNodes = [];
    var elementsToKeep = /* @__PURE__ */ new Set();
    var elementsToStop = new Set(targets);
    var keep = function(el) {
      if (!el || elementsToKeep.has(el)) {
        return;
      }
      elementsToKeep.add(el);
      keep(el.parentNode);
    };
    targets.forEach(keep);
    var deep = function(parent) {
      if (!parent || elementsToStop.has(parent)) {
        return;
      }
      Array.prototype.forEach.call(parent.children, function(node) {
        if (elementsToKeep.has(node)) {
          deep(node);
        } else {
          try {
            var attr = node.getAttribute(controlAttribute);
            var alreadyHidden = attr !== null && attr !== "false";
            var counterValue = (counterMap.get(node) || 0) + 1;
            var markerValue = (markerCounter.get(node) || 0) + 1;
            counterMap.set(node, counterValue);
            markerCounter.set(node, markerValue);
            hiddenNodes.push(node);
            if (counterValue === 1 && alreadyHidden) {
              uncontrolledNodes.set(node, true);
            }
            if (markerValue === 1) {
              node.setAttribute(markerName, "true");
            }
            if (!alreadyHidden) {
              node.setAttribute(controlAttribute, "true");
            }
          } catch (e2) {
            console.error("aria-hidden: cannot operate on ", node, e2);
          }
        }
      });
    };
    deep(parentNode);
    elementsToKeep.clear();
    lockCount++;
    return function() {
      hiddenNodes.forEach(function(node) {
        var counterValue = counterMap.get(node) - 1;
        var markerValue = markerCounter.get(node) - 1;
        counterMap.set(node, counterValue);
        markerCounter.set(node, markerValue);
        if (!counterValue) {
          if (!uncontrolledNodes.has(node)) {
            node.removeAttribute(controlAttribute);
          }
          uncontrolledNodes.delete(node);
        }
        if (!markerValue) {
          node.removeAttribute(markerName);
        }
      });
      lockCount--;
      if (!lockCount) {
        counterMap = /* @__PURE__ */ new WeakMap();
        counterMap = /* @__PURE__ */ new WeakMap();
        uncontrolledNodes = /* @__PURE__ */ new WeakMap();
        markerMap = {};
      }
    };
  };
  var hideOthers = function(originalTarget, parentNode, markerName) {
    if (markerName === void 0) {
      markerName = "data-aria-hidden";
    }
    var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
    var activeParentNode = parentNode || getDefaultParent(originalTarget);
    if (!activeParentNode) {
      return function() {
        return null;
      };
    }
    targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll("[aria-live], script")));
    return applyAttributeToOthers(targets, activeParentNode, markerName, "aria-hidden");
  };

  // ../../node_modules/@radix-ui/react-dialog/dist/index.mjs
  var import_jsx_runtime33 = __toESM(require_jsx_runtime2(), 1);
  var DIALOG_NAME = "Dialog";
  var [createDialogContext, createDialogScope] = createContextScope2(DIALOG_NAME);
  var [DialogProvider, useDialogContext] = createDialogContext(DIALOG_NAME);
  var Dialog = (props) => {
    const {
      __scopeDialog,
      children,
      open: openProp,
      defaultOpen,
      onOpenChange,
      modal = true
    } = props;
    const triggerRef = React60.useRef(null);
    const contentRef = React60.useRef(null);
    const [open, setOpen] = useControllableState({
      prop: openProp,
      defaultProp: defaultOpen ?? false,
      onChange: onOpenChange,
      caller: DIALOG_NAME
    });
    return /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(
      DialogProvider,
      {
        scope: __scopeDialog,
        triggerRef,
        contentRef,
        contentId: useId5(),
        titleId: useId5(),
        descriptionId: useId5(),
        open,
        onOpenChange: setOpen,
        onOpenToggle: React60.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
        modal,
        children
      }
    );
  };
  Dialog.displayName = DIALOG_NAME;
  var TRIGGER_NAME = "DialogTrigger";
  var DialogTrigger = React60.forwardRef(
    (props, forwardedRef) => {
      const { __scopeDialog, ...triggerProps } = props;
      const context = useDialogContext(TRIGGER_NAME, __scopeDialog);
      const composedTriggerRef = useComposedRefs2(forwardedRef, context.triggerRef);
      return /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(
        Primitive2.button,
        {
          type: "button",
          "aria-haspopup": "dialog",
          "aria-expanded": context.open,
          "aria-controls": context.contentId,
          "data-state": getState(context.open),
          ...triggerProps,
          ref: composedTriggerRef,
          onClick: composeEventHandlers(props.onClick, context.onOpenToggle)
        }
      );
    }
  );
  DialogTrigger.displayName = TRIGGER_NAME;
  var PORTAL_NAME2 = "DialogPortal";
  var [PortalProvider, usePortalContext] = createDialogContext(PORTAL_NAME2, {
    forceMount: void 0
  });
  var DialogPortal = (props) => {
    const { __scopeDialog, forceMount, children, container } = props;
    const context = useDialogContext(PORTAL_NAME2, __scopeDialog);
    return /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(PortalProvider, { scope: __scopeDialog, forceMount, children: React60.Children.map(children, (child) => /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(Portal, { asChild: true, container, children: child }) })) });
  };
  DialogPortal.displayName = PORTAL_NAME2;
  var OVERLAY_NAME = "DialogOverlay";
  var DialogOverlay = React60.forwardRef(
    (props, forwardedRef) => {
      const portalContext = usePortalContext(OVERLAY_NAME, props.__scopeDialog);
      const { forceMount = portalContext.forceMount, ...overlayProps } = props;
      const context = useDialogContext(OVERLAY_NAME, props.__scopeDialog);
      return context.modal ? /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(DialogOverlayImpl, { ...overlayProps, ref: forwardedRef }) }) : null;
    }
  );
  DialogOverlay.displayName = OVERLAY_NAME;
  var Slot = createSlot2("DialogOverlay.RemoveScroll");
  var DialogOverlayImpl = React60.forwardRef(
    (props, forwardedRef) => {
      const { __scopeDialog, ...overlayProps } = props;
      const context = useDialogContext(OVERLAY_NAME, __scopeDialog);
      return (
        // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
        // ie. when `Overlay` and `Content` are siblings
        /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(Combination_default, { as: Slot, allowPinchZoom: true, shards: [context.contentRef], children: /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(
          Primitive2.div,
          {
            "data-state": getState(context.open),
            ...overlayProps,
            ref: forwardedRef,
            style: { pointerEvents: "auto", ...overlayProps.style }
          }
        ) })
      );
    }
  );
  var CONTENT_NAME = "DialogContent";
  var DialogContent = React60.forwardRef(
    (props, forwardedRef) => {
      const portalContext = usePortalContext(CONTENT_NAME, props.__scopeDialog);
      const { forceMount = portalContext.forceMount, ...contentProps } = props;
      const context = useDialogContext(CONTENT_NAME, props.__scopeDialog);
      return /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(Presence, { present: forceMount || context.open, children: context.modal ? /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(DialogContentModal, { ...contentProps, ref: forwardedRef }) : /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(DialogContentNonModal, { ...contentProps, ref: forwardedRef }) });
    }
  );
  DialogContent.displayName = CONTENT_NAME;
  var DialogContentModal = React60.forwardRef(
    (props, forwardedRef) => {
      const context = useDialogContext(CONTENT_NAME, props.__scopeDialog);
      const contentRef = React60.useRef(null);
      const composedRefs = useComposedRefs2(forwardedRef, context.contentRef, contentRef);
      React60.useEffect(() => {
        const content = contentRef.current;
        if (content) return hideOthers(content);
      }, []);
      return /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(
        DialogContentImpl,
        {
          ...props,
          ref: composedRefs,
          trapFocus: context.open,
          disableOutsidePointerEvents: true,
          onCloseAutoFocus: composeEventHandlers(props.onCloseAutoFocus, (event) => {
            event.preventDefault();
            context.triggerRef.current?.focus();
          }),
          onPointerDownOutside: composeEventHandlers(props.onPointerDownOutside, (event) => {
            const originalEvent = event.detail.originalEvent;
            const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
            const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
            if (isRightClick) event.preventDefault();
          }),
          onFocusOutside: composeEventHandlers(
            props.onFocusOutside,
            (event) => event.preventDefault()
          )
        }
      );
    }
  );
  var DialogContentNonModal = React60.forwardRef(
    (props, forwardedRef) => {
      const context = useDialogContext(CONTENT_NAME, props.__scopeDialog);
      const hasInteractedOutsideRef = React60.useRef(false);
      const hasPointerDownOutsideRef = React60.useRef(false);
      return /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(
        DialogContentImpl,
        {
          ...props,
          ref: forwardedRef,
          trapFocus: false,
          disableOutsidePointerEvents: false,
          onCloseAutoFocus: (event) => {
            props.onCloseAutoFocus?.(event);
            if (!event.defaultPrevented) {
              if (!hasInteractedOutsideRef.current) context.triggerRef.current?.focus();
              event.preventDefault();
            }
            hasInteractedOutsideRef.current = false;
            hasPointerDownOutsideRef.current = false;
          },
          onInteractOutside: (event) => {
            props.onInteractOutside?.(event);
            if (!event.defaultPrevented) {
              hasInteractedOutsideRef.current = true;
              if (event.detail.originalEvent.type === "pointerdown") {
                hasPointerDownOutsideRef.current = true;
              }
            }
            const target = event.target;
            const targetIsTrigger = context.triggerRef.current?.contains(target);
            if (targetIsTrigger) event.preventDefault();
            if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.current) {
              event.preventDefault();
            }
          }
        }
      );
    }
  );
  var DialogContentImpl = React60.forwardRef(
    (props, forwardedRef) => {
      const { __scopeDialog, trapFocus, onOpenAutoFocus, onCloseAutoFocus, ...contentProps } = props;
      const context = useDialogContext(CONTENT_NAME, __scopeDialog);
      const contentRef = React60.useRef(null);
      const composedRefs = useComposedRefs2(forwardedRef, contentRef);
      useFocusGuards();
      return /* @__PURE__ */ (0, import_jsx_runtime33.jsxs)(import_jsx_runtime33.Fragment, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(
          FocusScope,
          {
            asChild: true,
            loop: true,
            trapped: trapFocus,
            onMountAutoFocus: onOpenAutoFocus,
            onUnmountAutoFocus: onCloseAutoFocus,
            children: /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(
              DismissableLayer,
              {
                role: "dialog",
                id: context.contentId,
                "aria-describedby": context.descriptionId,
                "aria-labelledby": context.titleId,
                "data-state": getState(context.open),
                ...contentProps,
                ref: composedRefs,
                onDismiss: () => context.onOpenChange(false)
              }
            )
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime33.jsxs)(import_jsx_runtime33.Fragment, { children: [
          /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(TitleWarning, { titleId: context.titleId }),
          /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(DescriptionWarning, { contentRef, descriptionId: context.descriptionId })
        ] })
      ] });
    }
  );
  var TITLE_NAME = "DialogTitle";
  var DialogTitle = React60.forwardRef(
    (props, forwardedRef) => {
      const { __scopeDialog, ...titleProps } = props;
      const context = useDialogContext(TITLE_NAME, __scopeDialog);
      return /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(Primitive2.h2, { id: context.titleId, ...titleProps, ref: forwardedRef });
    }
  );
  DialogTitle.displayName = TITLE_NAME;
  var DESCRIPTION_NAME = "DialogDescription";
  var DialogDescription = React60.forwardRef(
    (props, forwardedRef) => {
      const { __scopeDialog, ...descriptionProps } = props;
      const context = useDialogContext(DESCRIPTION_NAME, __scopeDialog);
      return /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(Primitive2.p, { id: context.descriptionId, ...descriptionProps, ref: forwardedRef });
    }
  );
  DialogDescription.displayName = DESCRIPTION_NAME;
  var CLOSE_NAME = "DialogClose";
  var DialogClose = React60.forwardRef(
    (props, forwardedRef) => {
      const { __scopeDialog, ...closeProps } = props;
      const context = useDialogContext(CLOSE_NAME, __scopeDialog);
      return /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(
        Primitive2.button,
        {
          type: "button",
          ...closeProps,
          ref: forwardedRef,
          onClick: composeEventHandlers(props.onClick, () => context.onOpenChange(false))
        }
      );
    }
  );
  DialogClose.displayName = CLOSE_NAME;
  function getState(open) {
    return open ? "open" : "closed";
  }
  var TITLE_WARNING_NAME = "DialogTitleWarning";
  var [WarningProvider, useWarningContext] = createContext22(TITLE_WARNING_NAME, {
    contentName: CONTENT_NAME,
    titleName: TITLE_NAME,
    docsSlug: "dialog"
  });
  var TitleWarning = ({ titleId }) => {
    const titleWarningContext = useWarningContext(TITLE_WARNING_NAME);
    const MESSAGE = `\`${titleWarningContext.contentName}\` requires a \`${titleWarningContext.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${titleWarningContext.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${titleWarningContext.docsSlug}`;
    React60.useEffect(() => {
      if (titleId) {
        const hasTitle = document.getElementById(titleId);
        if (!hasTitle) console.error(MESSAGE);
      }
    }, [MESSAGE, titleId]);
    return null;
  };
  var DESCRIPTION_WARNING_NAME = "DialogDescriptionWarning";
  var DescriptionWarning = ({ contentRef, descriptionId }) => {
    const descriptionWarningContext = useWarningContext(DESCRIPTION_WARNING_NAME);
    const MESSAGE = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${descriptionWarningContext.contentName}}.`;
    React60.useEffect(() => {
      const describedById = contentRef.current?.getAttribute("aria-describedby");
      if (descriptionId && describedById) {
        const hasDescription = document.getElementById(descriptionId);
        if (!hasDescription) console.warn(MESSAGE);
      }
    }, [MESSAGE, contentRef, descriptionId]);
    return null;
  };
  var Root3 = Dialog;
  var Trigger = DialogTrigger;
  var Portal2 = DialogPortal;
  var Overlay = DialogOverlay;
  var Content = DialogContent;
  var Title = DialogTitle;
  var Description = DialogDescription;
  var Close = DialogClose;

  // ../../node_modules/cmdk/dist/index.mjs
  var t = __toESM(require_react2(), 1);
  var N = '[cmdk-group=""]';
  var Y2 = '[cmdk-group-items=""]';
  var be = '[cmdk-group-heading=""]';
  var le = '[cmdk-item=""]';
  var ce = `${le}:not([aria-disabled="true"])`;
  var Z = "cmdk-item-select";
  var T = "data-value";
  var Re = (r4, o, n2) => W(r4, o, n2);
  var ue = t.createContext(void 0);
  var K2 = () => t.useContext(ue);
  var de = t.createContext(void 0);
  var ee = () => t.useContext(de);
  var fe = t.createContext(void 0);
  var me = t.forwardRef((r4, o) => {
    let n2 = L(() => {
      var e2, a;
      return { search: "", value: (a = (e2 = r4.value) != null ? e2 : r4.defaultValue) != null ? a : "", selectedItemId: void 0, filtered: { count: 0, items: /* @__PURE__ */ new Map(), groups: /* @__PURE__ */ new Set() } };
    }), u2 = L(() => /* @__PURE__ */ new Set()), c = L(() => /* @__PURE__ */ new Map()), d = L(() => /* @__PURE__ */ new Map()), f2 = L(() => /* @__PURE__ */ new Set()), p3 = pe(r4), { label: b2, children: m3, value: R, onValueChange: x2, filter: C2, shouldFilter: S2, loop: A3, disablePointerSelection: ge2 = false, vimBindings: j2 = true, ...O } = r4, $5 = useId5(), q3 = useId5(), _2 = useId5(), I2 = t.useRef(null), v2 = ke();
    k2(() => {
      if (R !== void 0) {
        let e2 = R.trim();
        n2.current.value = e2, E2.emit();
      }
    }, [R]), k2(() => {
      v2(6, ne);
    }, []);
    let E2 = t.useMemo(() => ({ subscribe: (e2) => (f2.current.add(e2), () => f2.current.delete(e2)), snapshot: () => n2.current, setState: (e2, a, s) => {
      var i3, l2, g2, y2;
      if (!Object.is(n2.current[e2], a)) {
        if (n2.current[e2] = a, e2 === "search") J3(), z3(), v2(1, W3);
        else if (e2 === "value") {
          if (document.activeElement.hasAttribute("cmdk-input") || document.activeElement.hasAttribute("cmdk-root")) {
            let h = document.getElementById(_2);
            h ? h.focus() : (i3 = document.getElementById($5)) == null || i3.focus();
          }
          if (v2(7, () => {
            var h;
            n2.current.selectedItemId = (h = M3()) == null ? void 0 : h.id, E2.emit();
          }), s || v2(5, ne), ((l2 = p3.current) == null ? void 0 : l2.value) !== void 0) {
            let h = a != null ? a : "";
            (y2 = (g2 = p3.current).onValueChange) == null || y2.call(g2, h);
            return;
          }
        }
        E2.emit();
      }
    }, emit: () => {
      f2.current.forEach((e2) => e2());
    } }), []), U5 = t.useMemo(() => ({ value: (e2, a, s) => {
      var i3;
      a !== ((i3 = d.current.get(e2)) == null ? void 0 : i3.value) && (d.current.set(e2, { value: a, keywords: s }), n2.current.filtered.items.set(e2, te2(a, s)), v2(2, () => {
        z3(), E2.emit();
      }));
    }, item: (e2, a) => (u2.current.add(e2), a && (c.current.has(a) ? c.current.get(a).add(e2) : c.current.set(a, /* @__PURE__ */ new Set([e2]))), v2(3, () => {
      J3(), z3(), n2.current.value || W3(), E2.emit();
    }), () => {
      d.current.delete(e2), u2.current.delete(e2), n2.current.filtered.items.delete(e2);
      let s = M3();
      v2(4, () => {
        J3(), (s == null ? void 0 : s.getAttribute("id")) === e2 && W3(), E2.emit();
      });
    }), group: (e2) => (c.current.has(e2) || c.current.set(e2, /* @__PURE__ */ new Set()), () => {
      d.current.delete(e2), c.current.delete(e2);
    }), filter: () => p3.current.shouldFilter, label: b2 || r4["aria-label"], getDisablePointerSelection: () => p3.current.disablePointerSelection, listId: $5, inputId: _2, labelId: q3, listInnerRef: I2 }), []);
    function te2(e2, a) {
      var i3, l2;
      let s = (l2 = (i3 = p3.current) == null ? void 0 : i3.filter) != null ? l2 : Re;
      return e2 ? s(e2, n2.current.search, a) : 0;
    }
    function z3() {
      if (!n2.current.search || p3.current.shouldFilter === false) return;
      let e2 = n2.current.filtered.items, a = [];
      n2.current.filtered.groups.forEach((i3) => {
        let l2 = c.current.get(i3), g2 = 0;
        l2.forEach((y2) => {
          let h = e2.get(y2);
          g2 = Math.max(h, g2);
        }), a.push([i3, g2]);
      });
      let s = I2.current;
      V3().sort((i3, l2) => {
        var h, F3;
        let g2 = i3.getAttribute("id"), y2 = l2.getAttribute("id");
        return ((h = e2.get(y2)) != null ? h : 0) - ((F3 = e2.get(g2)) != null ? F3 : 0);
      }).forEach((i3) => {
        let l2 = i3.closest(Y2);
        l2 ? l2.appendChild(i3.parentElement === l2 ? i3 : i3.closest(`${Y2} > *`)) : s.appendChild(i3.parentElement === s ? i3 : i3.closest(`${Y2} > *`));
      }), a.sort((i3, l2) => l2[1] - i3[1]).forEach((i3) => {
        var g2;
        let l2 = (g2 = I2.current) == null ? void 0 : g2.querySelector(`${N}[${T}="${encodeURIComponent(i3[0])}"]`);
        l2 == null || l2.parentElement.appendChild(l2);
      });
    }
    function W3() {
      let e2 = V3().find((s) => s.getAttribute("aria-disabled") !== "true"), a = e2 == null ? void 0 : e2.getAttribute(T);
      E2.setState("value", a || void 0);
    }
    function J3() {
      var a, s, i3, l2;
      if (!n2.current.search || p3.current.shouldFilter === false) {
        n2.current.filtered.count = u2.current.size;
        return;
      }
      n2.current.filtered.groups = /* @__PURE__ */ new Set();
      let e2 = 0;
      for (let g2 of u2.current) {
        let y2 = (s = (a = d.current.get(g2)) == null ? void 0 : a.value) != null ? s : "", h = (l2 = (i3 = d.current.get(g2)) == null ? void 0 : i3.keywords) != null ? l2 : [], F3 = te2(y2, h);
        n2.current.filtered.items.set(g2, F3), F3 > 0 && e2++;
      }
      for (let [g2, y2] of c.current) for (let h of y2) if (n2.current.filtered.items.get(h) > 0) {
        n2.current.filtered.groups.add(g2);
        break;
      }
      n2.current.filtered.count = e2;
    }
    function ne() {
      var a, s, i3;
      let e2 = M3();
      e2 && (((a = e2.parentElement) == null ? void 0 : a.firstChild) === e2 && ((i3 = (s = e2.closest(N)) == null ? void 0 : s.querySelector(be)) == null || i3.scrollIntoView({ block: "nearest" })), e2.scrollIntoView({ block: "nearest" }));
    }
    function M3() {
      var e2;
      return (e2 = I2.current) == null ? void 0 : e2.querySelector(`${le}[aria-selected="true"]`);
    }
    function V3() {
      var e2;
      return Array.from(((e2 = I2.current) == null ? void 0 : e2.querySelectorAll(ce)) || []);
    }
    function X5(e2) {
      let s = V3()[e2];
      s && E2.setState("value", s.getAttribute(T));
    }
    function Q3(e2) {
      var g2;
      let a = M3(), s = V3(), i3 = s.findIndex((y2) => y2 === a), l2 = s[i3 + e2];
      (g2 = p3.current) != null && g2.loop && (l2 = i3 + e2 < 0 ? s[s.length - 1] : i3 + e2 === s.length ? s[0] : s[i3 + e2]), l2 && E2.setState("value", l2.getAttribute(T));
    }
    function re2(e2) {
      let a = M3(), s = a == null ? void 0 : a.closest(N), i3;
      for (; s && !i3; ) s = e2 > 0 ? we(s, N) : De(s, N), i3 = s == null ? void 0 : s.querySelector(ce);
      i3 ? E2.setState("value", i3.getAttribute(T)) : Q3(e2);
    }
    let oe = () => X5(V3().length - 1), ie2 = (e2) => {
      e2.preventDefault(), e2.metaKey ? oe() : e2.altKey ? re2(1) : Q3(1);
    }, se = (e2) => {
      e2.preventDefault(), e2.metaKey ? X5(0) : e2.altKey ? re2(-1) : Q3(-1);
    };
    return t.createElement(Primitive2.div, { ref: o, tabIndex: -1, ...O, "cmdk-root": "", onKeyDown: (e2) => {
      var s;
      (s = O.onKeyDown) == null || s.call(O, e2);
      let a = e2.nativeEvent.isComposing || e2.keyCode === 229;
      if (!(e2.defaultPrevented || a)) switch (e2.key) {
        case "n":
        case "j": {
          j2 && e2.ctrlKey && ie2(e2);
          break;
        }
        case "ArrowDown": {
          ie2(e2);
          break;
        }
        case "p":
        case "k": {
          j2 && e2.ctrlKey && se(e2);
          break;
        }
        case "ArrowUp": {
          se(e2);
          break;
        }
        case "Home": {
          e2.preventDefault(), X5(0);
          break;
        }
        case "End": {
          e2.preventDefault(), oe();
          break;
        }
        case "Enter": {
          e2.preventDefault();
          let i3 = M3();
          if (i3) {
            let l2 = new Event(Z);
            i3.dispatchEvent(l2);
          }
        }
      }
    } }, t.createElement("label", { "cmdk-label": "", htmlFor: U5.inputId, id: U5.labelId, style: Te }, b2), B2(r4, (e2) => t.createElement(de.Provider, { value: E2 }, t.createElement(ue.Provider, { value: U5 }, e2))));
  });
  var he = t.forwardRef((r4, o) => {
    var _2, I2;
    let n2 = useId5(), u2 = t.useRef(null), c = t.useContext(fe), d = K2(), f2 = pe(r4), p3 = (I2 = (_2 = f2.current) == null ? void 0 : _2.forceMount) != null ? I2 : c == null ? void 0 : c.forceMount;
    k2(() => {
      if (!p3) return d.item(n2, c == null ? void 0 : c.id);
    }, [p3]);
    let b2 = ve(n2, u2, [r4.value, r4.children, u2], r4.keywords), m3 = ee(), R = P((v2) => v2.value && v2.value === b2.current), x2 = P((v2) => p3 || d.filter() === false ? true : v2.search ? v2.filtered.items.get(n2) > 0 : true);
    t.useEffect(() => {
      let v2 = u2.current;
      if (!(!v2 || r4.disabled)) return v2.addEventListener(Z, C2), () => v2.removeEventListener(Z, C2);
    }, [x2, r4.onSelect, r4.disabled]);
    function C2() {
      var v2, E2;
      S2(), (E2 = (v2 = f2.current).onSelect) == null || E2.call(v2, b2.current);
    }
    function S2() {
      m3.setState("value", b2.current, true);
    }
    if (!x2) return null;
    let { disabled: A3, value: ge2, onSelect: j2, forceMount: O, keywords: $5, ...q3 } = r4;
    return t.createElement(Primitive2.div, { ref: composeRefs2(u2, o), ...q3, id: n2, "cmdk-item": "", role: "option", "aria-disabled": !!A3, "aria-selected": !!R, "data-disabled": !!A3, "data-selected": !!R, onPointerMove: A3 || d.getDisablePointerSelection() ? void 0 : S2, onClick: A3 ? void 0 : C2 }, r4.children);
  });
  var Ee = t.forwardRef((r4, o) => {
    let { heading: n2, children: u2, forceMount: c, ...d } = r4, f2 = useId5(), p3 = t.useRef(null), b2 = t.useRef(null), m3 = useId5(), R = K2(), x2 = P((S2) => c || R.filter() === false ? true : S2.search ? S2.filtered.groups.has(f2) : true);
    k2(() => R.group(f2), []), ve(f2, p3, [r4.value, r4.heading, b2]);
    let C2 = t.useMemo(() => ({ id: f2, forceMount: c }), [c]);
    return t.createElement(Primitive2.div, { ref: composeRefs2(p3, o), ...d, "cmdk-group": "", role: "presentation", hidden: x2 ? void 0 : true }, n2 && t.createElement("div", { ref: b2, "cmdk-group-heading": "", "aria-hidden": true, id: m3 }, n2), B2(r4, (S2) => t.createElement("div", { "cmdk-group-items": "", role: "group", "aria-labelledby": n2 ? m3 : void 0 }, t.createElement(fe.Provider, { value: C2 }, S2))));
  });
  var ye = t.forwardRef((r4, o) => {
    let { alwaysRender: n2, ...u2 } = r4, c = t.useRef(null), d = P((f2) => !f2.search);
    return !n2 && !d ? null : t.createElement(Primitive2.div, { ref: composeRefs2(c, o), ...u2, "cmdk-separator": "", role: "separator" });
  });
  var Se = t.forwardRef((r4, o) => {
    let { onValueChange: n2, ...u2 } = r4, c = r4.value != null, d = ee(), f2 = P((m3) => m3.search), p3 = P((m3) => m3.selectedItemId), b2 = K2();
    return t.useEffect(() => {
      r4.value != null && d.setState("search", r4.value);
    }, [r4.value]), t.createElement(Primitive2.input, { ref: o, ...u2, "cmdk-input": "", autoComplete: "off", autoCorrect: "off", spellCheck: false, "aria-autocomplete": "list", role: "combobox", "aria-expanded": true, "aria-controls": b2.listId, "aria-labelledby": b2.labelId, "aria-activedescendant": p3, id: b2.inputId, type: "text", value: c ? r4.value : f2, onChange: (m3) => {
      c || d.setState("search", m3.target.value), n2 == null || n2(m3.target.value);
    } });
  });
  var Ce = t.forwardRef((r4, o) => {
    let { children: n2, label: u2 = "Suggestions", ...c } = r4, d = t.useRef(null), f2 = t.useRef(null), p3 = P((m3) => m3.selectedItemId), b2 = K2();
    return t.useEffect(() => {
      if (f2.current && d.current) {
        let m3 = f2.current, R = d.current, x2, C2 = new ResizeObserver(() => {
          x2 = requestAnimationFrame(() => {
            let S2 = m3.offsetHeight;
            R.style.setProperty("--cmdk-list-height", S2.toFixed(1) + "px");
          });
        });
        return C2.observe(m3), () => {
          cancelAnimationFrame(x2), C2.unobserve(m3);
        };
      }
    }, []), t.createElement(Primitive2.div, { ref: composeRefs2(d, o), ...c, "cmdk-list": "", role: "listbox", tabIndex: -1, "aria-activedescendant": p3, "aria-label": u2, id: b2.listId }, B2(r4, (m3) => t.createElement("div", { ref: composeRefs2(f2, b2.listInnerRef), "cmdk-list-sizer": "" }, m3)));
  });
  var xe = t.forwardRef((r4, o) => {
    let { open: n2, onOpenChange: u2, overlayClassName: c, contentClassName: d, container: f2, ...p3 } = r4;
    return t.createElement(Root3, { open: n2, onOpenChange: u2 }, t.createElement(Portal2, { container: f2 }, t.createElement(Overlay, { "cmdk-overlay": "", className: c }), t.createElement(Content, { "aria-label": r4.label, "cmdk-dialog": "", className: d }, t.createElement(me, { ref: o, ...p3 }))));
  });
  var Ie = t.forwardRef((r4, o) => P((u2) => u2.filtered.count === 0) ? t.createElement(Primitive2.div, { ref: o, ...r4, "cmdk-empty": "", role: "presentation" }) : null);
  var Pe = t.forwardRef((r4, o) => {
    let { progress: n2, children: u2, label: c = "Loading...", ...d } = r4;
    return t.createElement(Primitive2.div, { ref: o, ...d, "cmdk-loading": "", role: "progressbar", "aria-valuenow": n2, "aria-valuemin": 0, "aria-valuemax": 100, "aria-label": c }, B2(r4, (f2) => t.createElement("div", { "aria-hidden": true }, f2)));
  });
  var _e = Object.assign(me, { List: Ce, Item: he, Input: Se, Group: Ee, Separator: ye, Dialog: xe, Empty: Ie, Loading: Pe });
  function we(r4, o) {
    let n2 = r4.nextElementSibling;
    for (; n2; ) {
      if (n2.matches(o)) return n2;
      n2 = n2.nextElementSibling;
    }
  }
  function De(r4, o) {
    let n2 = r4.previousElementSibling;
    for (; n2; ) {
      if (n2.matches(o)) return n2;
      n2 = n2.previousElementSibling;
    }
  }
  function pe(r4) {
    let o = t.useRef(r4);
    return k2(() => {
      o.current = r4;
    }), o;
  }
  var k2 = typeof window == "undefined" ? t.useEffect : t.useLayoutEffect;
  function L(r4) {
    let o = t.useRef();
    return o.current === void 0 && (o.current = r4()), o;
  }
  function P(r4) {
    let o = ee(), n2 = () => r4(o.snapshot());
    return t.useSyncExternalStore(o.subscribe, n2, n2);
  }
  function ve(r4, o, n2, u2 = []) {
    let c = t.useRef(), d = K2();
    return k2(() => {
      var b2;
      let f2 = (() => {
        var m3;
        for (let R of n2) {
          if (typeof R == "string") return R.trim();
          if (typeof R == "object" && "current" in R) return R.current ? (m3 = R.current.textContent) == null ? void 0 : m3.trim() : c.current;
        }
      })(), p3 = u2.map((m3) => m3.trim());
      d.value(r4, f2, p3), (b2 = o.current) == null || b2.setAttribute(T, f2), c.current = f2;
    }), c;
  }
  var ke = () => {
    let [r4, o] = t.useState(), n2 = L(() => /* @__PURE__ */ new Map());
    return k2(() => {
      n2.current.forEach((u2) => u2()), n2.current = /* @__PURE__ */ new Map();
    }, [r4]), (u2, c) => {
      n2.current.set(u2, c), o({});
    };
  };
  function Me(r4) {
    let o = r4.type;
    return typeof o == "function" ? o(r4.props) : "render" in o ? o.render(r4.props) : r4;
  }
  function B2({ asChild: r4, children: o }, n2) {
    return r4 && t.isValidElement(o) ? t.cloneElement(Me(o), { ref: o.ref }, n2(o.props.children)) : n2(o);
  }
  var Te = { position: "absolute", width: "1px", height: "1px", padding: "0", margin: "-1px", overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", borderWidth: "0" };

  // src/components/Popover.tsx
  var import_react68 = __toESM(require_react());
  var import_jsx_runtime34 = __toESM(require_jsx_runtime());
  var Popover = ({
    trigger,
    children,
    side = "bottom",
    align = "center",
    className,
    triggerClassName
  }) => {
    const [isOpen, setIsOpen] = import_react68.default.useState(false);
    const popoverRef = import_react68.default.useRef(null);
    const triggerRef = import_react68.default.useRef(null);
    import_react68.default.useEffect(() => {
      const handleClickOutside = (event) => {
        if (popoverRef.current && !popoverRef.current.contains(event.target) && triggerRef.current && !triggerRef.current.contains(event.target)) {
          setIsOpen(false);
        }
      };
      const handleEscape = (event) => {
        if (event.key === "Escape") {
          setIsOpen(false);
        }
      };
      document.addEventListener("mousedown", handleClickOutside);
      document.addEventListener("keydown", handleEscape);
      return () => {
        document.removeEventListener("mousedown", handleClickOutside);
        document.removeEventListener("keydown", handleEscape);
      };
    }, []);
    const sideClasses = {
      top: "bottom-full mb-2",
      bottom: "top-full mt-2",
      left: "right-full mr-2",
      right: "left-full ml-2"
    };
    const alignClasses = {
      start: side === "top" || side === "bottom" ? "left-0" : "top-0",
      center: side === "top" || side === "bottom" ? "left-1/2 -translate-x-1/2" : "top-1/2 -translate-y-1/2",
      end: side === "top" || side === "bottom" ? "right-0" : "bottom-0"
    };
    return /* @__PURE__ */ (0, import_jsx_runtime34.jsxs)("div", { className: "relative inline-block", children: [
      /* @__PURE__ */ (0, import_jsx_runtime34.jsx)(
        "button",
        {
          ref: triggerRef,
          type: "button",
          onClick: () => setIsOpen(!isOpen),
          className: cn("outline-none", triggerClassName),
          children: trigger
        }
      ),
      isOpen && /* @__PURE__ */ (0, import_jsx_runtime34.jsx)(
        "div",
        {
          ref: popoverRef,
          className: cn(
            "absolute z-50 min-w-[200px]",
            "rounded-xl border border-border/50 bg-background/95 backdrop-blur-xl",
            "shadow-lg shadow-black/10 dark:shadow-black/30",
            "p-4 animate-in fade-in-0 zoom-in-95 duration-200",
            "dark:bg-zinc-900/95 dark:border-zinc-800",
            sideClasses[side],
            alignClasses[align],
            className
          ),
          children
        }
      )
    ] });
  };

  // src/components/Combobox.tsx
  var import_jsx_runtime35 = __toESM(require_jsx_runtime());
  function Combobox({
    options,
    value,
    onChange,
    placeholder = "Select item...",
    className
  }) {
    const [open, setOpen] = (0, import_react69.useState)(false);
    return /* @__PURE__ */ (0, import_jsx_runtime35.jsx)(
      Popover,
      {
        side: "bottom",
        align: "start",
        className: "p-0",
        trigger: /* @__PURE__ */ (0, import_jsx_runtime35.jsxs)(
          "div",
          {
            "aria-expanded": open,
            className: cn(
              "flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 cursor-pointer hover:bg-accent hover:text-accent-foreground",
              className
            ),
            role: "combobox",
            children: [
              value ? options.find((option) => option.value === value)?.label : placeholder,
              /* @__PURE__ */ (0, import_jsx_runtime35.jsx)(ChevronsUpDown, { className: "ml-2 h-4 w-4 shrink-0 opacity-50" })
            ]
          }
        ),
        children: /* @__PURE__ */ (0, import_jsx_runtime35.jsx)("div", { className: "p-0 w-[200px] border border-border bg-popover text-popover-foreground shadow-md rounded-md", children: /* @__PURE__ */ (0, import_jsx_runtime35.jsxs)(_e, { className: "w-full", children: [
          /* @__PURE__ */ (0, import_jsx_runtime35.jsx)("div", { className: "flex items-center border-b px-3", "cmdk-input-wrapper": "", children: /* @__PURE__ */ (0, import_jsx_runtime35.jsx)(
            "input",
            {
              className: "flex h-10 w-full rounded-md bg-transparent py-3 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50",
              placeholder: "Search...",
              onChange: (e2) => {
              }
            }
          ) }),
          /* @__PURE__ */ (0, import_jsx_runtime35.jsxs)("div", { className: "max-h-[300px] overflow-y-auto overflow-x-hidden p-1", children: [
            options.map((option) => /* @__PURE__ */ (0, import_jsx_runtime35.jsxs)(
              "div",
              {
                className: cn(
                  "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none aria-selected:bg-accent aria-selected:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 hover:bg-accent hover:text-accent-foreground",
                  value === option.value ? "bg-accent text-accent-foreground" : ""
                ),
                onClick: () => {
                  onChange?.(option.value);
                  setOpen(false);
                },
                children: [
                  /* @__PURE__ */ (0, import_jsx_runtime35.jsx)(
                    Check,
                    {
                      className: cn(
                        "mr-2 h-4 w-4",
                        value === option.value ? "opacity-100" : "opacity-0"
                      )
                    }
                  ),
                  option.label
                ]
              },
              option.value
            )),
            options.length === 0 && /* @__PURE__ */ (0, import_jsx_runtime35.jsx)("div", { className: "py-6 text-center text-sm", children: "No items found." })
          ] })
        ] }) })
      }
    );
  }

  // src/components/CommandMenu.tsx
  var import_react70 = __toESM(require_react());
  var import_jsx_runtime36 = __toESM(require_jsx_runtime());
  function CommandMenu({
    open,
    onOpenChange,
    items = [],
    placeholder = "Type a command or search..."
  }) {
    const [query, setQuery] = (0, import_react70.useState)("");
    (0, import_react70.useEffect)(() => {
      const down = (e2) => {
        if (e2.key === "k" && (e2.metaKey || e2.ctrlKey)) {
          e2.preventDefault();
          onOpenChange(!open);
        }
      };
      document.addEventListener("keydown", down);
      return () => document.removeEventListener("keydown", down);
    }, [onOpenChange, open]);
    const filteredItems = (0, import_react70.useMemo)(() => {
      if (!query) return [];
      return items.filter(
        (item) => item.name.toLowerCase().includes(query.toLowerCase())
      );
    }, [query, items]);
    const runCommand = (0, import_react70.useCallback)((command) => {
      onOpenChange(false);
      command();
    }, [onOpenChange]);
    if (!open) return null;
    return /* @__PURE__ */ (0, import_jsx_runtime36.jsxs)("div", { className: "fixed inset-0 z-50 flex items-start justify-center pt-[15vh]", children: [
      /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(
        "div",
        {
          className: "fixed inset-0 bg-black/40 backdrop-blur-sm transition-opacity",
          onClick: () => onOpenChange(false)
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime36.jsxs)("div", { className: cn(
        "relative w-full max-w-lg overflow-hidden transition-all duration-300",
        "rounded-[2rem]",
        "backdrop-blur-xl",
        "animate-in fade-in-0 zoom-in-95 slide-in-from-top-2",
        // Standard Dark Mode Classes
        "bg-white/80 dark:bg-zinc-900/80",
        "border border-white/20 dark:border-white/10",
        "shadow-2xl dark:shadow-[0_8px_32px_rgba(0,0,0,0.5)]"
      ), children: [
        /* @__PURE__ */ (0, import_jsx_runtime36.jsxs)("div", { className: cn(
          "flex items-center border-b px-4 pt-1",
          "border-black/5 dark:border-white/5"
        ), children: [
          /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(
            "svg",
            {
              className: "mr-2 h-4 w-4 shrink-0 opacity-50 text-black dark:text-white",
              fill: "none",
              viewBox: "0 0 24 24",
              stroke: "currentColor",
              strokeWidth: 2,
              children: /* @__PURE__ */ (0, import_jsx_runtime36.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" })
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(
            "input",
            {
              className: cn(
                "h-11 flex-1 rounded-md bg-transparent py-3 text-sm outline-none disabled:cursor-not-allowed disabled:opacity-50",
                "text-black dark:text-white placeholder:text-zinc-500"
              ),
              placeholder,
              value: query,
              onChange: (e2) => setQuery(e2.target.value),
              autoFocus: true
            }
          )
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime36.jsx)("div", { className: "max-h-[300px] overflow-y-auto p-2", children: query === "" ? /* @__PURE__ */ (0, import_jsx_runtime36.jsx)("div", { className: "py-6 text-center text-sm text-zinc-500 dark:text-zinc-400", children: "Type to search..." }) : filteredItems.length === 0 ? /* @__PURE__ */ (0, import_jsx_runtime36.jsx)("div", { className: "py-6 text-center text-sm text-zinc-500 dark:text-zinc-400", children: "No results found." }) : /* @__PURE__ */ (0, import_jsx_runtime36.jsx)("div", { className: "space-y-1", children: filteredItems.map((item, index2) => /* @__PURE__ */ (0, import_jsx_runtime36.jsxs)(
          "button",
          {
            onClick: () => runCommand(() => {
              item.onSelect?.();
              if (item.href) window.location.href = item.href;
            }),
            className: cn(
              "flex w-full items-center rounded-md px-2 py-2 text-sm transition-colors",
              "text-zinc-600 dark:text-zinc-300",
              "hover:bg-black/5 dark:hover:bg-white/5",
              "hover:text-black dark:hover:text-white"
            ),
            children: [
              /* @__PURE__ */ (0, import_jsx_runtime36.jsx)("div", { className: cn(
                "flex h-6 w-6 shrink-0 items-center justify-center rounded-full mr-2",
                "bg-black/5 dark:bg-white/10 text-black/50 dark:text-white/50"
              ), children: item.icon || "#" }),
              /* @__PURE__ */ (0, import_jsx_runtime36.jsx)("span", { children: item.name }),
              /* @__PURE__ */ (0, import_jsx_runtime36.jsx)("span", { className: "ml-auto text-xs text-zinc-400 dark:text-zinc-500", children: item.category })
            ]
          },
          index2
        )) }) }),
        /* @__PURE__ */ (0, import_jsx_runtime36.jsxs)("div", { className: cn(
          "border-t px-4 py-2 text-[10px] text-zinc-500 dark:text-zinc-400 flex items-center justify-end gap-2",
          "border-black/5 dark:border-white/5 bg-black/5 dark:bg-white/5"
        ), children: [
          /* @__PURE__ */ (0, import_jsx_runtime36.jsx)("span", { children: "Select" }),
          " ",
          /* @__PURE__ */ (0, import_jsx_runtime36.jsx)("kbd", { className: "bg-transparent px-1.5 rounded border border-current opacity-50", children: "\u21B5" }),
          /* @__PURE__ */ (0, import_jsx_runtime36.jsx)("span", { children: "Close" }),
          " ",
          /* @__PURE__ */ (0, import_jsx_runtime36.jsx)("kbd", { className: "bg-transparent px-1.5 rounded border border-current opacity-50", children: "Esc" })
        ] })
      ] })
    ] });
  }

  // src/components/Confetti.tsx
  var import_react71 = __toESM(require_react());
  var import_jsx_runtime37 = __toESM(require_jsx_runtime());
  var Confetti = ({
    active = false,
    duration = 3e3,
    particleCount = 50,
    className
  }) => {
    const [particles, setParticles] = import_react71.default.useState([]);
    import_react71.default.useEffect(() => {
      if (active) {
        const colors3 = ["#FF6B6B", "#4ECDC4", "#45B7D1", "#96E6A1", "#DDA0DD", "#FFD93D", "#6BCB77"];
        const newParticles = Array.from({ length: particleCount }, (_2, i3) => ({
          id: i3,
          x: Math.random() * 100,
          color: colors3[Math.floor(Math.random() * colors3.length)],
          delay: Math.random() * 500,
          rotation: Math.random() * 360
        }));
        setParticles(newParticles);
        const timeout = setTimeout(() => {
          setParticles([]);
        }, duration);
        return () => clearTimeout(timeout);
      } else {
        setParticles([]);
      }
    }, [active, duration, particleCount]);
    if (particles.length === 0) return null;
    return /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(
      "div",
      {
        className: cn(
          "fixed inset-0 pointer-events-none overflow-hidden z-50",
          className
        ),
        children: particles.map((particle) => /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(
          "div",
          {
            className: "absolute w-3 h-3 animate-confetti",
            style: {
              left: `${particle.x}%`,
              backgroundColor: particle.color,
              animationDelay: `${particle.delay}ms`,
              transform: `rotate(${particle.rotation}deg)`,
              borderRadius: Math.random() > 0.5 ? "50%" : "0"
            }
          },
          particle.id
        ))
      }
    );
  };
  var useConfetti = () => {
    const [active, setActive] = import_react71.default.useState(false);
    const fire = import_react71.default.useCallback(() => {
      setActive(true);
      setTimeout(() => setActive(false), 100);
    }, []);
    return { active, fire };
  };
  var confettiStyles = `
@keyframes confetti {
  0% {
    transform: translateY(-10vh) rotate(0deg);
    opacity: 1;
  }
  100% {
    transform: translateY(100vh) rotate(720deg);
    opacity: 0;
  }
}

.animate-confetti {
  animation: confetti 3s ease-out forwards;
}
`;
  if (typeof document !== "undefined") {
    const styleId = "auralix-confetti-styles";
    if (!document.getElementById(styleId)) {
      const style = document.createElement("style");
      style.id = styleId;
      style.textContent = confettiStyles;
      document.head.appendChild(style);
    }
  }

  // src/components/CopyCommand.tsx
  var React65 = __toESM(require_react());
  var import_jsx_runtime38 = __toESM(require_jsx_runtime());
  function CopyCommand({ command, className, variant = "boxed" }) {
    const [hasCopied, setHasCopied] = React65.useState(false);
    const copyToClipboard = React65.useCallback(() => {
      navigator.clipboard.writeText(command);
      setHasCopied(true);
      setTimeout(() => setHasCopied(false), 2e3);
    }, [command]);
    return /* @__PURE__ */ (0, import_jsx_runtime38.jsxs)(
      "div",
      {
        className: cn(
          "relative flex items-center justify-between",
          // Boxed (Default)
          variant === "boxed" && "rounded-lg border bg-muted/50 p-4 font-mono text-sm backdrop-blur-sm",
          // Simple (Just text and button)
          variant === "simple" && "rounded-md bg-transparent p-0 font-mono text-sm gap-2",
          // Minimal (Pill)
          variant === "minimal" && "rounded-full border bg-background px-4 py-2 font-mono text-xs shadow-sm w-fit gap-4",
          className
        ),
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime38.jsx)("code", { className: cn(
            "flex-1 break-all",
            variant === "minimal" && "text-muted-foreground"
          ), children: command }),
          /* @__PURE__ */ (0, import_jsx_runtime38.jsxs)(
            Button,
            {
              variant: "ghost",
              size: "sm",
              className: cn(
                "h-8 w-8 px-0",
                variant === "minimal" && "h-6 w-6 -mr-2"
              ),
              onClick: copyToClipboard,
              children: [
                hasCopied ? /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(Check, { className: "h-4 w-4 text-green-500" }) : /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(Copy, { className: "h-4 w-4 text-muted-foreground" }),
                /* @__PURE__ */ (0, import_jsx_runtime38.jsx)("span", { className: "sr-only", children: "Copy command" })
              ]
            }
          )
        ]
      }
    );
  }

  // src/components/DatePicker.tsx
  var import_jsx_runtime39 = __toESM(require_jsx_runtime());
  function DatePicker({
    date,
    setDate,
    className
  }) {
    return /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(
      Popover,
      {
        trigger: /* @__PURE__ */ (0, import_jsx_runtime39.jsxs)(
          "div",
          {
            className: cn(
              "flex h-10 w-full items-center justify-start rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 hover:bg-accent hover:text-accent-foreground cursor-pointer",
              !date && "text-muted-foreground",
              className
            ),
            children: [
              /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(Calendar, { className: "mr-2 h-4 w-4" }),
              date ? format(date, "PPP") : /* @__PURE__ */ (0, import_jsx_runtime39.jsx)("span", { children: "Pick a date" })
            ]
          }
        ),
        children: /* @__PURE__ */ (0, import_jsx_runtime39.jsx)("div", { className: "w-auto p-0 bg-background/95 backdrop-blur-xl border border-border/50 rounded-xl shadow-xl", children: /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(
          Calendar2,
          {
            mode: "single",
            selected: date,
            onSelect: setDate,
            initialFocus: true
          }
        ) })
      }
    );
  }

  // src/components/Dialog.tsx
  var React66 = __toESM(require_react());
  var import_jsx_runtime40 = __toESM(require_jsx_runtime());
  function Dialog2({
    isOpen,
    onClose,
    title,
    description,
    children,
    footer,
    className,
    variant = "standard"
  }) {
    React66.useEffect(() => {
      const handleKeyDown = (e2) => {
        if (e2.key === "Escape") onClose();
      };
      if (isOpen) {
        document.addEventListener("keydown", handleKeyDown);
        document.body.style.overflow = "hidden";
      }
      return () => {
        document.removeEventListener("keydown", handleKeyDown);
        document.body.style.overflow = "unset";
      };
    }, [isOpen, onClose]);
    if (!isOpen) return null;
    return /* @__PURE__ */ (0, import_jsx_runtime40.jsxs)("div", { className: cn(
      "fixed inset-0 z-50 flex p-4",
      variant === "sheet" ? "justify-end pr-0 py-0" : "items-center justify-center"
    ), children: [
      /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(
        "div",
        {
          className: "absolute inset-0 bg-black/40 backdrop-blur-sm transition-all duration-300",
          onClick: onClose
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(
        "div",
        {
          className: cn(
            "relative z-10 w-full transform overflow-hidden transition-all duration-300 shadow-2xl",
            // Base styles
            "bg-white/80 dark:bg-zinc-900/80 backdrop-blur-2xl supported-[backdrop-filter]:bg-white/40",
            "ring-1 ring-black/5 dark:ring-white/10",
            // Variant: Standard
            variant === "standard" && "max-w-sm rounded-[2rem] animate-in fade-in zoom-in-95 p-6",
            // Variant: Sheet
            variant === "sheet" && "h-full max-w-md rounded-l-[2rem] animate-in slide-in-from-right duration-500 p-8 border-l border-border",
            // Variant: Fullscreen
            variant === "fullscreen" && "inset-0 max-w-none h-full rounded-none animate-in zoom-in-90 duration-300 p-12 flex flex-col items-center justify-center",
            className
          ),
          children: /* @__PURE__ */ (0, import_jsx_runtime40.jsxs)("div", { className: cn("flex flex-col gap-4", variant === "fullscreen" && "max-w-2xl w-full"), children: [
            variant === "sheet" && /* @__PURE__ */ (0, import_jsx_runtime40.jsx)("button", { onClick: onClose, className: "absolute top-4 right-4 p-2 rounded-full hover:bg-black/5 dark:hover:bg-white/5 transition-colors", children: /* @__PURE__ */ (0, import_jsx_runtime40.jsx)("svg", { className: "w-5 h-5 text-muted-foreground", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: /* @__PURE__ */ (0, import_jsx_runtime40.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M6 18L18 6M6 6l12 12" }) }) }),
            (title || description) && /* @__PURE__ */ (0, import_jsx_runtime40.jsxs)("div", { className: "space-y-2", children: [
              title && /* @__PURE__ */ (0, import_jsx_runtime40.jsx)("h2", { className: cn(
                "font-semibold leading-none tracking-tight",
                variant === "fullscreen" ? "text-4xl mb-4 text-center" : "text-lg"
              ), children: title }),
              description && /* @__PURE__ */ (0, import_jsx_runtime40.jsx)("p", { className: cn(
                "text-muted-foreground leading-relaxed",
                variant === "fullscreen" ? "text-xl text-center max-w-lg mx-auto" : "text-sm"
              ), children: description })
            ] }),
            children,
            footer && /* @__PURE__ */ (0, import_jsx_runtime40.jsx)("div", { className: cn(
              "flex gap-3 pt-2",
              variant === "fullscreen" ? "justify-center mt-8" : ""
            ), children: footer })
          ] })
        }
      )
    ] });
  }
  function DialogButton({
    className,
    variant = "primary",
    ...props
  }) {
    return /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(
      "button",
      {
        className: cn(
          "flex-1 inline-flex items-center justify-center rounded-full px-4 py-2.5 text-sm font-semibold transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
          variant === "primary" ? "bg-blue-600 text-white hover:bg-blue-700 shadow-sm" : "bg-blue-100/50 text-blue-900 hover:bg-blue-200/50 dark:bg-white/10 dark:text-white dark:hover:bg-white/20",
          className
        ),
        ...props
      }
    );
  }

  // src/components/Divider.tsx
  var import_jsx_runtime41 = __toESM(require_jsx_runtime());
  var Divider = ({
    orientation = "horizontal",
    variant = "solid",
    label,
    className
  }) => {
    const variantClasses = {
      solid: "border-solid",
      dashed: "border-dashed",
      dotted: "border-dotted"
    };
    if (orientation === "vertical") {
      return /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(
        "div",
        {
          className: cn(
            "inline-block h-full min-h-[20px] w-px bg-border/50",
            "dark:bg-zinc-800",
            className
          ),
          role: "separator",
          "aria-orientation": "vertical"
        }
      );
    }
    if (label) {
      return /* @__PURE__ */ (0, import_jsx_runtime41.jsxs)(
        "div",
        {
          className: cn("flex items-center gap-4 w-full", className),
          role: "separator",
          "aria-orientation": "horizontal",
          children: [
            /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(
              "div",
              {
                className: cn(
                  "flex-1 h-px border-t border-border/50",
                  variantClasses[variant],
                  "dark:border-zinc-800"
                )
              }
            ),
            /* @__PURE__ */ (0, import_jsx_runtime41.jsx)("span", { className: "text-xs text-muted-foreground font-medium uppercase tracking-wider", children: label }),
            /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(
              "div",
              {
                className: cn(
                  "flex-1 h-px border-t border-border/50",
                  variantClasses[variant],
                  "dark:border-zinc-800"
                )
              }
            )
          ]
        }
      );
    }
    return /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(
      "div",
      {
        className: cn(
          "w-full h-px border-t border-border/50",
          variantClasses[variant],
          "dark:border-zinc-800",
          className
        ),
        role: "separator",
        "aria-orientation": "horizontal"
      }
    );
  };

  // src/components/Dock.tsx
  var import_react72 = __toESM(require_react());
  var import_jsx_runtime42 = __toESM(require_jsx_runtime());
  var DEFAULT_MAGNIFICATION = 60;
  var DEFAULT_DISTANCE = 140;
  var DockContext = import_react72.default.createContext(null);
  function Dock({
    className,
    direction: _direction = "bottom",
    children,
    magnification = DEFAULT_MAGNIFICATION,
    distance: distance2 = DEFAULT_DISTANCE,
    variant = "mac"
  }) {
    const dockRef = (0, import_react72.useRef)(null);
    return /* @__PURE__ */ (0, import_jsx_runtime42.jsx)(DockContext.Provider, { value: { magnification, distance: distance2, variant }, children: /* @__PURE__ */ (0, import_jsx_runtime42.jsx)(
      "div",
      {
        ref: dockRef,
        className: cn(
          "mx-auto flex w-max gap-2 transition-all duration-300",
          // Variant: Mac (Default) - Floating, Glassy, Animated
          variant === "mac" && "supports-backdrop-blur:bg-white/10 supports-backdrop-blur:dark:bg-black/10 mt-8 h-[58px] rounded-2xl border p-2 backdrop-blur-md",
          // Variant: Windows - Bottom fixed bar, dark/flat
          variant === "windows" && "fixed bottom-4 left-1/2 -translate-x-1/2 h-14 bg-background/90 dark:bg-zinc-900/90 backdrop-blur-xl border border-border rounded-lg px-2 items-center gap-1 shadow-2xl",
          // Variant: Material - Pill floating
          variant === "material" && "mt-8 h-16 rounded-full bg-background dark:bg-slate-900 text-foreground shadow-xl px-6 items-center gap-4 border border-border",
          className
        ),
        children
      }
    ) });
  }
  function DockIcon({
    size: size4 = 40,
    magnification: propMagnification,
    distance: propDistance,
    className,
    children,
    ...props
  }) {
    const ref = (0, import_react72.useRef)(null);
    const [scale2, setScale] = (0, import_react72.useState)(1);
    const context = import_react72.default.useContext(DockContext);
    const magnification = propMagnification ?? context?.magnification ?? DEFAULT_MAGNIFICATION;
    const distance2 = propDistance ?? context?.distance ?? DEFAULT_DISTANCE;
    const variant = context?.variant ?? "mac";
    import_react72.default.useEffect(() => {
      if (variant !== "mac") {
        setScale(1);
        return;
      }
      const handleMouseMove = (e2) => {
        if (!ref.current) return;
        const rect = ref.current.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const dist = Math.abs(e2.clientX - centerX);
        if (dist < distance2) {
          const val = 1 + (magnification / size4 - 1) * Math.cos(dist / distance2 * Math.PI / 2);
          setScale(val);
        } else {
          setScale(1);
        }
      };
      window.addEventListener("mousemove", handleMouseMove);
      return () => {
        window.removeEventListener("mousemove", handleMouseMove);
      };
    }, [distance2, magnification, size4, variant]);
    return /* @__PURE__ */ (0, import_jsx_runtime42.jsx)(
      "div",
      {
        ref,
        style: {
          width: variant === "mac" ? size4 * scale2 : size4,
          height: variant === "mac" ? size4 * scale2 : size4,
          transition: variant === "mac" ? "width 0.1s ease-out, height 0.1s ease-out" : "all 0.2s"
        },
        className: cn(
          "flex aspect-square cursor-pointer items-center justify-center transition-all",
          // Base styling
          variant === "mac" && "rounded-full bg-black/5 dark:bg-white/10 shadow-sm hover:bg-black/10 dark:hover:bg-white/20",
          // Windows: Boxy hover
          variant === "windows" && "rounded-md hover:bg-accent active:scale-95 h-10 w-10",
          // Material: Ripple-like (simulated with hover)
          variant === "material" && "rounded-full hover:bg-accent active:scale-90 h-12 w-12",
          className
        ),
        ...props,
        children
      }
    );
  }

  // src/components/DotPattern.tsx
  var import_react73 = __toESM(require_react());
  var import_jsx_runtime43 = __toESM(require_jsx_runtime());
  var DotPattern = ({
    size: size4 = 24,
    radius = 1,
    className,
    fade = true
  }) => {
    const id3 = import_react73.default.useId();
    return /* @__PURE__ */ (0, import_jsx_runtime43.jsxs)(
      "svg",
      {
        className: cn(
          "absolute inset-0 h-full w-full pointer-events-none",
          fade && "[mask-image:radial-gradient(ellipse_at_center,white,transparent_80%)]",
          className
        ),
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime43.jsx)("defs", { children: /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(
            "pattern",
            {
              id: id3,
              width: size4,
              height: size4,
              patternUnits: "userSpaceOnUse",
              children: /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(
                "circle",
                {
                  cx: size4 / 2,
                  cy: size4 / 2,
                  r: radius,
                  className: "fill-border/50 dark:fill-zinc-700"
                }
              )
            }
          ) }),
          /* @__PURE__ */ (0, import_jsx_runtime43.jsx)("rect", { width: "100%", height: "100%", fill: `url(#${id3})` })
        ]
      }
    );
  };
  var AnimatedDotPattern = ({
    size: size4 = 30,
    radius = 1.5,
    className
  }) => {
    const [mousePosition, setMousePosition] = import_react73.default.useState({ x: 0, y: 0 });
    const containerRef = import_react73.default.useRef(null);
    import_react73.default.useEffect(() => {
      const handleMouseMove = (e2) => {
        if (!containerRef.current) return;
        const rect = containerRef.current.getBoundingClientRect();
        setMousePosition({
          x: e2.clientX - rect.left,
          y: e2.clientY - rect.top
        });
      };
      const container = containerRef.current;
      if (container) {
        container.addEventListener("mousemove", handleMouseMove);
      }
      return () => {
        if (container) {
          container.removeEventListener("mousemove", handleMouseMove);
        }
      };
    }, []);
    const cols = Math.ceil(1920 / size4);
    const rows = Math.ceil(1080 / size4);
    return /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(
      "div",
      {
        ref: containerRef,
        className: cn("absolute inset-0 overflow-hidden pointer-events-none", className),
        children: /* @__PURE__ */ (0, import_jsx_runtime43.jsx)("svg", { className: "w-full h-full", children: Array.from({ length: rows }).map(
          (_2, row) => Array.from({ length: cols }).map((_3, col) => {
            const x2 = col * size4 + size4 / 2;
            const y2 = row * size4 + size4 / 2;
            const distance2 = Math.sqrt(
              Math.pow(x2 - mousePosition.x, 2) + Math.pow(y2 - mousePosition.y, 2)
            );
            const maxDistance = 150;
            const scale2 = Math.max(0, 1 - distance2 / maxDistance);
            const dotRadius = radius + scale2 * 2;
            const opacity = 0.2 + scale2 * 0.6;
            return /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(
              "circle",
              {
                cx: x2,
                cy: y2,
                r: dotRadius,
                className: "fill-[#007AFF] dark:fill-[#0A84FF] transition-all duration-100",
                style: { opacity }
              },
              `${row}-${col}`
            );
          })
        ) })
      }
    );
  };

  // src/components/Dropdown.tsx
  var import_react74 = __toESM(require_react());
  var import_jsx_runtime44 = __toESM(require_jsx_runtime());
  var Dropdown2 = ({
    trigger,
    children,
    align = "start",
    className
  }) => {
    const [isOpen, setIsOpen] = import_react74.default.useState(false);
    const dropdownRef = import_react74.default.useRef(null);
    import_react74.default.useEffect(() => {
      const handleClickOutside = (event) => {
        if (dropdownRef.current && !dropdownRef.current.contains(event.target)) {
          setIsOpen(false);
        }
      };
      const handleEscape = (event) => {
        if (event.key === "Escape") {
          setIsOpen(false);
        }
      };
      document.addEventListener("mousedown", handleClickOutside);
      document.addEventListener("keydown", handleEscape);
      return () => {
        document.removeEventListener("mousedown", handleClickOutside);
        document.removeEventListener("keydown", handleEscape);
      };
    }, []);
    const alignClasses = {
      start: "left-0",
      center: "left-1/2 -translate-x-1/2",
      end: "right-0"
    };
    return /* @__PURE__ */ (0, import_jsx_runtime44.jsxs)("div", { ref: dropdownRef, className: "relative inline-block", children: [
      /* @__PURE__ */ (0, import_jsx_runtime44.jsx)("div", { onClick: () => setIsOpen(!isOpen), className: "cursor-pointer", children: trigger }),
      isOpen && /* @__PURE__ */ (0, import_jsx_runtime44.jsx)(
        "div",
        {
          className: cn(
            "absolute z-50 mt-2 min-w-[180px]",
            "rounded-xl border border-border/50 bg-background/95 backdrop-blur-xl",
            "shadow-lg shadow-black/10 dark:shadow-black/30",
            "py-1 animate-in fade-in-0 zoom-in-95 duration-150",
            "dark:bg-zinc-900/95 dark:border-zinc-800",
            alignClasses[align],
            className
          ),
          children
        }
      )
    ] });
  };
  var DropdownItem = ({
    children,
    icon,
    shortcut,
    disabled = false,
    destructive = false,
    onClick,
    className
  }) => {
    return /* @__PURE__ */ (0, import_jsx_runtime44.jsxs)(
      "button",
      {
        onClick,
        disabled,
        className: cn(
          "w-full flex items-center gap-2 px-3 py-2 text-sm text-left",
          "transition-colors duration-100",
          "hover:bg-muted/50 dark:hover:bg-zinc-800/50",
          disabled && "opacity-50 cursor-not-allowed",
          destructive && "text-red-500 hover:bg-red-500/10",
          className
        ),
        children: [
          icon && /* @__PURE__ */ (0, import_jsx_runtime44.jsx)("span", { className: "w-4 h-4 text-muted-foreground", children: icon }),
          /* @__PURE__ */ (0, import_jsx_runtime44.jsx)("span", { className: "flex-1", children }),
          shortcut && /* @__PURE__ */ (0, import_jsx_runtime44.jsx)("span", { className: "text-xs text-muted-foreground/60", children: shortcut })
        ]
      }
    );
  };
  var DropdownSeparator = () => /* @__PURE__ */ (0, import_jsx_runtime44.jsx)("div", { className: "h-px my-1 bg-border/50 dark:bg-zinc-800" });
  var DropdownLabel = ({ children }) => /* @__PURE__ */ (0, import_jsx_runtime44.jsx)("div", { className: "px-3 py-1.5 text-xs font-medium text-muted-foreground uppercase tracking-wider", children });

  // src/components/EmptyState.tsx
  var import_jsx_runtime45 = __toESM(require_jsx_runtime());
  var EmptyState = ({
    icon,
    title,
    description,
    action,
    className
  }) => {
    return /* @__PURE__ */ (0, import_jsx_runtime45.jsxs)(
      "div",
      {
        className: cn(
          "flex flex-col items-center justify-center py-12 px-6 text-center",
          className
        ),
        children: [
          icon && /* @__PURE__ */ (0, import_jsx_runtime45.jsx)("div", { className: "w-16 h-16 rounded-full bg-muted/50 flex items-center justify-center mb-4 dark:bg-zinc-800", children: /* @__PURE__ */ (0, import_jsx_runtime45.jsx)("div", { className: "w-8 h-8 text-muted-foreground", children: icon }) }),
          /* @__PURE__ */ (0, import_jsx_runtime45.jsx)("h3", { className: "text-lg font-semibold text-foreground mb-1", children: title }),
          description && /* @__PURE__ */ (0, import_jsx_runtime45.jsx)("p", { className: "text-sm text-muted-foreground max-w-sm mb-4", children: description }),
          action && /* @__PURE__ */ (0, import_jsx_runtime45.jsx)("div", { children: action })
        ]
      }
    );
  };
  var NoData = ({
    title = "No data found",
    description = "There's nothing to show here yet.",
    action
  }) => /* @__PURE__ */ (0, import_jsx_runtime45.jsx)(
    EmptyState,
    {
      icon: /* @__PURE__ */ (0, import_jsx_runtime45.jsx)("svg", { fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", strokeWidth: 1.5, children: /* @__PURE__ */ (0, import_jsx_runtime45.jsx)(
        "path",
        {
          strokeLinecap: "round",
          strokeLinejoin: "round",
          d: "M20 13V6a2 2 0 00-2-2H6a2 2 0 00-2 2v7m16 0v5a2 2 0 01-2 2H6a2 2 0 01-2-2v-5m16 0h-2.586a1 1 0 00-.707.293l-2.414 2.414a1 1 0 01-.707.293h-3.172a1 1 0 01-.707-.293l-2.414-2.414A1 1 0 006.586 13H4"
        }
      ) }),
      title,
      description,
      action
    }
  );
  var NoSearchResults = ({
    title = "No results found",
    description = "Try adjusting your search terms.",
    action
  }) => /* @__PURE__ */ (0, import_jsx_runtime45.jsx)(
    EmptyState,
    {
      icon: /* @__PURE__ */ (0, import_jsx_runtime45.jsx)("svg", { fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", strokeWidth: 1.5, children: /* @__PURE__ */ (0, import_jsx_runtime45.jsx)(
        "path",
        {
          strokeLinecap: "round",
          strokeLinejoin: "round",
          d: "M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"
        }
      ) }),
      title,
      description,
      action
    }
  );
  var ErrorState = ({
    title = "Something went wrong",
    description = "We couldn't load this content. Please try again.",
    action
  }) => /* @__PURE__ */ (0, import_jsx_runtime45.jsx)(
    EmptyState,
    {
      icon: /* @__PURE__ */ (0, import_jsx_runtime45.jsx)("svg", { fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", strokeWidth: 1.5, children: /* @__PURE__ */ (0, import_jsx_runtime45.jsx)(
        "path",
        {
          strokeLinecap: "round",
          strokeLinejoin: "round",
          d: "M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"
        }
      ) }),
      title,
      description,
      action
    }
  );

  // src/components/ExpandableCard.tsx
  var import_react75 = __toESM(require_react());
  var import_jsx_runtime46 = __toESM(require_jsx_runtime());
  var ExpandableCard = ({
    title,
    description,
    children,
    className,
    defaultExpanded = false
  }) => {
    const [isExpanded, setIsExpanded] = import_react75.default.useState(defaultExpanded);
    const [ref, { height }] = useElementSize();
    return /* @__PURE__ */ (0, import_jsx_runtime46.jsxs)(
      "div",
      {
        className: cn(
          "rounded-2xl border border-border/50 bg-background/80 backdrop-blur-sm overflow-hidden",
          "transition-all duration-300 ease-out",
          "hover:shadow-lg hover:shadow-black/5",
          "dark:bg-zinc-900/80 dark:border-zinc-800",
          isExpanded && "shadow-xl shadow-black/10",
          className
        ),
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime46.jsxs)(
            "button",
            {
              onClick: () => setIsExpanded(!isExpanded),
              className: "w-full p-5 flex items-center justify-between text-left group",
              children: [
                /* @__PURE__ */ (0, import_jsx_runtime46.jsxs)("div", { children: [
                  /* @__PURE__ */ (0, import_jsx_runtime46.jsx)("h3", { className: "font-semibold text-foreground", children: title }),
                  description && /* @__PURE__ */ (0, import_jsx_runtime46.jsx)("p", { className: "text-sm text-muted-foreground mt-0.5", children: description })
                ] }),
                /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(
                  "div",
                  {
                    className: cn(
                      "w-8 h-8 rounded-full bg-muted/50 flex items-center justify-center",
                      "transition-all duration-300",
                      "group-hover:bg-[#007AFF]/10 group-hover:text-[#007AFF]",
                      "dark:bg-zinc-800"
                    ),
                    children: /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(
                      "svg",
                      {
                        className: cn(
                          "w-4 h-4 transition-transform duration-300",
                          isExpanded && "rotate-180"
                        ),
                        fill: "none",
                        viewBox: "0 0 24 24",
                        stroke: "currentColor",
                        strokeWidth: 2,
                        children: /* @__PURE__ */ (0, import_jsx_runtime46.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M19 9l-7 7-7-7" })
                      }
                    )
                  }
                )
              ]
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(
            "div",
            {
              className: "overflow-hidden transition-all duration-300 ease-out",
              style: { height: isExpanded ? height : 0 },
              children: /* @__PURE__ */ (0, import_jsx_runtime46.jsx)("div", { ref, className: "p-5 pt-0 border-t border-border/50 dark:border-zinc-800", children })
            }
          )
        ]
      }
    );
  };
  function useElementSize() {
    const ref = import_react75.default.useRef(null);
    const [size4, setSize] = import_react75.default.useState({ width: 0, height: 0 });
    import_react75.default.useEffect(() => {
      if (!ref.current) return;
      const observer2 = new ResizeObserver((entries) => {
        const entry = entries[0];
        if (entry) {
          setSize({
            width: entry.contentRect.width,
            height: entry.contentRect.height
          });
        }
      });
      observer2.observe(ref.current);
      return () => observer2.disconnect();
    }, []);
    return [ref, size4];
  }

  // src/components/FileTree.tsx
  var import_react76 = __toESM(require_react());
  var import_jsx_runtime47 = __toESM(require_jsx_runtime());
  var FileTree = ({
    data,
    className,
    onSelect
  }) => {
    return /* @__PURE__ */ (0, import_jsx_runtime47.jsx)("div", { className: cn("font-mono text-sm", className), children: data.map((node, index2) => /* @__PURE__ */ (0, import_jsx_runtime47.jsx)(FileTreeItem, { node, depth: 0, onSelect }, index2)) });
  };
  var FileTreeItem = ({ node, depth, onSelect }) => {
    const [isExpanded, setIsExpanded] = import_react76.default.useState(true);
    const hasChildren = node.type === "folder" && node.children && node.children.length > 0;
    const handleClick = () => {
      if (node.type === "folder") {
        setIsExpanded(!isExpanded);
      }
      onSelect?.(node);
    };
    const getDefaultIcon = () => {
      if (node.type === "folder") {
        return isExpanded ? /* @__PURE__ */ (0, import_jsx_runtime47.jsx)("svg", { className: "w-4 h-4 text-[#007AFF] dark:text-[#0A84FF]", fill: "currentColor", viewBox: "0 0 20 20", children: /* @__PURE__ */ (0, import_jsx_runtime47.jsx)("path", { d: "M2 6a2 2 0 012-2h5l2 2h5a2 2 0 012 2v6a2 2 0 01-2 2H4a2 2 0 01-2-2V6z" }) }) : /* @__PURE__ */ (0, import_jsx_runtime47.jsx)("svg", { className: "w-4 h-4 text-[#007AFF] dark:text-[#0A84FF]", fill: "currentColor", viewBox: "0 0 20 20", children: /* @__PURE__ */ (0, import_jsx_runtime47.jsx)("path", { fillRule: "evenodd", d: "M2 6a2 2 0 012-2h5l2 2h5a2 2 0 012 2v6a2 2 0 01-2 2H4a2 2 0 01-2-2V6z", clipRule: "evenodd" }) });
      }
      const ext = node.name.split(".").pop()?.toLowerCase();
      const iconColor = getFileColor(ext);
      return /* @__PURE__ */ (0, import_jsx_runtime47.jsx)("svg", { className: cn("w-4 h-4", iconColor), fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", strokeWidth: 2, children: /* @__PURE__ */ (0, import_jsx_runtime47.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" }) });
    };
    return /* @__PURE__ */ (0, import_jsx_runtime47.jsxs)("div", { children: [
      /* @__PURE__ */ (0, import_jsx_runtime47.jsxs)(
        "div",
        {
          className: cn(
            "flex items-center gap-1.5 py-1 px-2 rounded-md cursor-pointer",
            "hover:bg-muted/50 dark:hover:bg-zinc-800/50",
            "transition-colors duration-150"
          ),
          style: { paddingLeft: `${depth * 16 + 8}px` },
          onClick: handleClick,
          children: [
            hasChildren && /* @__PURE__ */ (0, import_jsx_runtime47.jsx)(
              "svg",
              {
                className: cn(
                  "w-3 h-3 text-muted-foreground transition-transform duration-150",
                  isExpanded && "rotate-90"
                ),
                fill: "none",
                viewBox: "0 0 24 24",
                stroke: "currentColor",
                strokeWidth: 2,
                children: /* @__PURE__ */ (0, import_jsx_runtime47.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M9 5l7 7-7 7" })
              }
            ),
            !hasChildren && /* @__PURE__ */ (0, import_jsx_runtime47.jsx)("span", { className: "w-3" }),
            node.icon || getDefaultIcon(),
            /* @__PURE__ */ (0, import_jsx_runtime47.jsx)("span", { className: "text-foreground", children: node.name })
          ]
        }
      ),
      hasChildren && isExpanded && /* @__PURE__ */ (0, import_jsx_runtime47.jsx)("div", { children: node.children.map((child, index2) => /* @__PURE__ */ (0, import_jsx_runtime47.jsx)(
        FileTreeItem,
        {
          node: child,
          depth: depth + 1,
          onSelect
        },
        index2
      )) })
    ] });
  };
  function getFileColor(ext) {
    const colors3 = {
      ts: "text-blue-500",
      tsx: "text-blue-500",
      js: "text-yellow-500",
      jsx: "text-yellow-500",
      css: "text-purple-500",
      html: "text-orange-500",
      json: "text-green-500",
      md: "text-gray-500",
      py: "text-green-400",
      go: "text-cyan-500",
      rs: "text-orange-600"
    };
    return colors3[ext || ""] || "text-muted-foreground";
  }

  // src/components/FlipCard.tsx
  var import_react77 = __toESM(require_react());
  var import_jsx_runtime48 = __toESM(require_jsx_runtime());
  var FlipCard = ({
    front,
    back,
    flipOnHover = true,
    flipOnClick = false,
    className
  }) => {
    const [isFlipped, setIsFlipped] = import_react77.default.useState(false);
    const handleClick = () => {
      if (flipOnClick) {
        setIsFlipped(!isFlipped);
      }
    };
    return /* @__PURE__ */ (0, import_jsx_runtime48.jsx)(
      "div",
      {
        className: cn(
          "group perspective-[1000px] cursor-pointer",
          className
        ),
        onClick: handleClick,
        children: /* @__PURE__ */ (0, import_jsx_runtime48.jsxs)(
          "div",
          {
            className: cn(
              "relative w-full h-full transition-transform duration-500 ease-out transform-style-preserve-3d",
              flipOnHover && "group-hover:rotate-y-180",
              isFlipped && "rotate-y-180"
            ),
            style: {
              transformStyle: "preserve-3d",
              transform: isFlipped ? "rotateY(180deg)" : "rotateY(0deg)"
            },
            children: [
              /* @__PURE__ */ (0, import_jsx_runtime48.jsx)(
                "div",
                {
                  className: "absolute inset-0 backface-hidden rounded-2xl overflow-hidden",
                  style: { backfaceVisibility: "hidden" },
                  children: /* @__PURE__ */ (0, import_jsx_runtime48.jsx)("div", { className: "w-full h-full rounded-2xl border border-border/50 bg-background/80 backdrop-blur-sm dark:bg-zinc-900/80 dark:border-zinc-800", children: front })
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime48.jsx)(
                "div",
                {
                  className: "absolute inset-0 backface-hidden rounded-2xl overflow-hidden rotate-y-180",
                  style: {
                    backfaceVisibility: "hidden",
                    transform: "rotateY(180deg)"
                  },
                  children: /* @__PURE__ */ (0, import_jsx_runtime48.jsx)("div", { className: "w-full h-full rounded-2xl border border-border/50 bg-background/80 backdrop-blur-sm dark:bg-zinc-900/80 dark:border-zinc-800", children: back })
                }
              )
            ]
          }
        )
      }
    );
  };

  // src/components/FlipWords.tsx
  var import_react78 = __toESM(require_react());
  var import_jsx_runtime49 = __toESM(require_jsx_runtime());
  var FlipWords = ({
    words,
    duration = 3e3,
    className
  }) => {
    const [currentIndex, setCurrentIndex] = import_react78.default.useState(0);
    const [isAnimating2, setIsAnimating] = import_react78.default.useState(false);
    import_react78.default.useEffect(() => {
      const interval = setInterval(() => {
        setIsAnimating(true);
        setTimeout(() => {
          setCurrentIndex((prev) => (prev + 1) % words.length);
          setIsAnimating(false);
        }, 300);
      }, duration);
      return () => clearInterval(interval);
    }, [words.length, duration]);
    return /* @__PURE__ */ (0, import_jsx_runtime49.jsx)("span", { className: cn("relative inline-block overflow-hidden", className), children: /* @__PURE__ */ (0, import_jsx_runtime49.jsx)(
      "span",
      {
        className: cn(
          "inline-block transition-all duration-300 ease-out",
          isAnimating2 ? "opacity-0 -translate-y-full blur-sm" : "opacity-100 translate-y-0 blur-0"
        ),
        children: words[currentIndex]
      }
    ) });
  };
  var FlipWords3D = ({
    words,
    duration = 3e3,
    className
  }) => {
    const [currentIndex, setCurrentIndex] = import_react78.default.useState(0);
    const [isFlipping, setIsFlipping] = import_react78.default.useState(false);
    import_react78.default.useEffect(() => {
      const interval = setInterval(() => {
        setIsFlipping(true);
        setTimeout(() => {
          setCurrentIndex((prev) => (prev + 1) % words.length);
          setTimeout(() => setIsFlipping(false), 300);
        }, 300);
      }, duration);
      return () => clearInterval(interval);
    }, [words.length, duration]);
    return /* @__PURE__ */ (0, import_jsx_runtime49.jsx)(
      "span",
      {
        className: cn(
          "relative inline-block perspective-[1000px]",
          className
        ),
        children: /* @__PURE__ */ (0, import_jsx_runtime49.jsx)(
          "span",
          {
            className: cn(
              "inline-block transition-transform duration-300 ease-out transform-style-3d",
              isFlipping ? "rotate-x-90" : "rotate-x-0"
            ),
            style: {
              transformStyle: "preserve-3d",
              transform: isFlipping ? "rotateX(90deg)" : "rotateX(0deg)"
            },
            children: words[currentIndex]
          }
        )
      }
    );
  };

  // src/index.ts
  init_FloatingLines2();

  // src/components/Form.tsx
  var import_jsx_runtime51 = __toESM(require_jsx_runtime());
  function Form({ children, className, ...props }) {
    return /* @__PURE__ */ (0, import_jsx_runtime51.jsx)("form", { className: cn("space-y-4", className), ...props, children });
  }
  function FormField({ children, className }) {
    return /* @__PURE__ */ (0, import_jsx_runtime51.jsx)("div", { className: cn("space-y-2", className), children });
  }
  function FormLabel({ children, required, className, ...props }) {
    return /* @__PURE__ */ (0, import_jsx_runtime51.jsxs)(
      "label",
      {
        className: cn("text-sm font-medium text-foreground", className),
        ...props,
        children: [
          children,
          required && /* @__PURE__ */ (0, import_jsx_runtime51.jsx)("span", { className: "ml-1 text-destructive", children: "*" })
        ]
      }
    );
  }
  function FormDescription({ children, className }) {
    return /* @__PURE__ */ (0, import_jsx_runtime51.jsx)("p", { className: cn("text-xs text-muted-foreground", className), children });
  }
  function FormError({ children, className }) {
    return /* @__PURE__ */ (0, import_jsx_runtime51.jsx)("p", { className: cn("text-xs text-destructive", className), children });
  }

  // src/components/GlassCard.tsx
  var import_react80 = __toESM(require_react());
  var import_jsx_runtime52 = __toESM(require_jsx_runtime());
  var GlassCard = (0, import_react80.forwardRef)(
    ({ className, intensity = "medium", children, ...props }, ref) => {
      const intensities = {
        low: "bg-white/10 backdrop-blur-sm border-white/20",
        medium: "bg-white/10 backdrop-blur-md border-white/30",
        high: "bg-white/10 backdrop-blur-xl border-white/40"
      };
      return /* @__PURE__ */ (0, import_jsx_runtime52.jsxs)(
        "div",
        {
          ref,
          className: cn(
            "rounded-xl border shadow-xl overflow-hidden relative",
            intensities[intensity],
            className
          ),
          ...props,
          children: [
            /* @__PURE__ */ (0, import_jsx_runtime52.jsx)("div", { className: "absolute inset-0 opacity-5 pointer-events-none", style: { backgroundImage: `url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E")` } }),
            /* @__PURE__ */ (0, import_jsx_runtime52.jsx)("div", { className: "relative z-10 p-6", children })
          ]
        }
      );
    }
  );
  GlassCard.displayName = "GlassCard";

  // ../../node_modules/phenomenon/dist/phenomenon.mjs
  var t2 = ["x", "y", "z"];
  var e = function(t3) {
    Object.assign(this, { uniforms: {}, geometry: { vertices: [{ x: 0, y: 0, z: 0 }] }, mode: 0, modifiers: {}, attributes: [], multiplier: 1, buffers: [] }), Object.assign(this, t3), this.prepareProgram(), this.prepareUniforms(), this.prepareAttributes();
  };
  e.prototype.compileShader = function(t3, e2) {
    var i3 = this.gl.createShader(t3);
    return this.gl.shaderSource(i3, e2), this.gl.compileShader(i3), i3;
  }, e.prototype.prepareProgram = function() {
    var t3 = this.gl, e2 = this.vertex, i3 = this.fragment, r4 = t3.createProgram();
    t3.attachShader(r4, this.compileShader(35633, e2)), t3.attachShader(r4, this.compileShader(35632, i3)), t3.linkProgram(r4), t3.useProgram(r4), this.program = r4;
  }, e.prototype.prepareUniforms = function() {
    for (var t3 = Object.keys(this.uniforms), e2 = 0; e2 < t3.length; e2 += 1) {
      var i3 = this.gl.getUniformLocation(this.program, t3[e2]);
      this.uniforms[t3[e2]].location = i3;
    }
  }, e.prototype.prepareAttributes = function() {
    void 0 !== this.geometry.vertices && this.attributes.push({ name: "aPosition", size: 3 }), void 0 !== this.geometry.normal && this.attributes.push({ name: "aNormal", size: 3 }), this.attributeKeys = [];
    for (var t3 = 0; t3 < this.attributes.length; t3 += 1) this.attributeKeys.push(this.attributes[t3].name), this.prepareAttribute(this.attributes[t3]);
  }, e.prototype.prepareAttribute = function(e2) {
    for (var i3 = this.geometry, r4 = this.multiplier, s = i3.vertices, n2 = i3.normal, a = new Float32Array(r4 * s.length * e2.size), o = 0; o < r4; o += 1) for (var h = e2.data && e2.data(o, r4), u2 = o * s.length * e2.size, f2 = 0; f2 < s.length; f2 += 1) for (var c = 0; c < e2.size; c += 1) {
      var l2 = this.modifiers[e2.name];
      a[u2] = void 0 !== l2 ? l2(h, f2, c, this) : "aPosition" === e2.name ? s[f2][t2[c]] : "aNormal" === e2.name ? n2[f2][t2[c]] : h[c], u2 += 1;
    }
    this.attributes[this.attributeKeys.indexOf(e2.name)].data = a, this.prepareBuffer(this.attributes[this.attributeKeys.indexOf(e2.name)]);
  }, e.prototype.prepareBuffer = function(t3) {
    var e2 = t3.data, i3 = t3.name, r4 = t3.size, s = this.gl.createBuffer();
    this.gl.bindBuffer(34962, s), this.gl.bufferData(34962, e2, 35044);
    var n2 = this.gl.getAttribLocation(this.program, i3);
    this.gl.enableVertexAttribArray(n2), this.gl.vertexAttribPointer(n2, r4, 5126, false, 0, 0), this.buffers[this.attributeKeys.indexOf(t3.name)] = { buffer: s, location: n2, size: r4 };
  }, e.prototype.render = function(t3) {
    var e2 = this, i3 = this.uniforms, r4 = this.multiplier, s = this.gl;
    s.useProgram(this.program);
    for (var n2 = 0; n2 < this.buffers.length; n2 += 1) {
      var a = this.buffers[n2], o = a.location, h = a.buffer, u2 = a.size;
      s.enableVertexAttribArray(o), s.bindBuffer(34962, h), s.vertexAttribPointer(o, u2, 5126, false, 0, 0);
    }
    Object.keys(t3).forEach(function(e3) {
      i3[e3].value = t3[e3].value;
    }), Object.keys(i3).forEach(function(t4) {
      var r5 = i3[t4];
      e2.uniformMap[r5.type](r5.location, r5.value);
    }), s.drawArrays(this.mode, 0, r4 * this.geometry.vertices.length), this.onRender && this.onRender(this);
  }, e.prototype.destroy = function() {
    for (var t3 = 0; t3 < this.buffers.length; t3 += 1) this.gl.deleteBuffer(this.buffers[t3].buffer);
    this.gl.deleteProgram(this.program), this.gl = null;
  };
  var i = function(t3) {
    var e2 = this, i3 = t3 || {}, r4 = i3.canvas;
    void 0 === r4 && (r4 = document.querySelector("canvas"));
    var s = i3.context;
    void 0 === s && (s = {});
    var n2 = i3.contextType;
    void 0 === n2 && (n2 = "experimental-webgl");
    var a = i3.settings;
    void 0 === a && (a = {});
    var o = r4.getContext(n2, Object.assign({ alpha: false, antialias: false }, s));
    Object.assign(this, { gl: o, canvas: r4, uniforms: {}, instances: /* @__PURE__ */ new Map(), shouldRender: true }), Object.assign(this, { devicePixelRatio: 1, clearColor: [1, 1, 1, 1], position: { x: 0, y: 0, z: 2 }, clip: [1e-3, 100] }), Object.assign(this, a), this.uniformMap = { float: function(t4, e3) {
      return o.uniform1f(t4, e3);
    }, vec2: function(t4, e3) {
      return o.uniform2fv(t4, e3);
    }, vec3: function(t4, e3) {
      return o.uniform3fv(t4, e3);
    }, vec4: function(t4, e3) {
      return o.uniform4fv(t4, e3);
    }, mat2: function(t4, e3) {
      return o.uniformMatrix2fv(t4, false, e3);
    }, mat3: function(t4, e3) {
      return o.uniformMatrix3fv(t4, false, e3);
    }, mat4: function(t4, e3) {
      return o.uniformMatrix4fv(t4, false, e3);
    } }, o.enable(o.DEPTH_TEST), o.depthFunc(o.LEQUAL), false === o.getContextAttributes().alpha && (o.clearColor.apply(o, this.clearColor), o.clearDepth(1)), this.onSetup && this.onSetup(o), window.addEventListener("resize", function() {
      return e2.resize();
    }), this.resize(), this.render();
  };
  i.prototype.resize = function() {
    var t3 = this.gl, e2 = this.canvas, i3 = this.devicePixelRatio, r4 = this.position;
    e2.width = e2.clientWidth * i3, e2.height = e2.clientHeight * i3;
    var s = t3.drawingBufferWidth, n2 = t3.drawingBufferHeight, a = s / n2;
    t3.viewport(0, 0, s, n2);
    var o = Math.tan(Math.PI / 180 * 22.5), h = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, r4.x, r4.y, (a < 1 ? 1 : a) * -r4.z, 1];
    this.uniforms.uProjectionMatrix = { type: "mat4", value: [0.5 / o, 0, 0, 0, 0, a / o * 0.5, 0, 0, 0, 0, -(this.clip[1] + this.clip[0]) / (this.clip[1] - this.clip[0]), -1, 0, 0, -2 * this.clip[1] * (this.clip[0] / (this.clip[1] - this.clip[0])), 0] }, this.uniforms.uViewMatrix = { type: "mat4", value: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] }, this.uniforms.uModelMatrix = { type: "mat4", value: h };
  }, i.prototype.toggle = function(t3) {
    t3 !== this.shouldRender && (this.shouldRender = void 0 !== t3 ? t3 : !this.shouldRender, this.shouldRender && this.render());
  }, i.prototype.render = function() {
    var t3 = this;
    this.gl.clear(16640), this.instances.forEach(function(e2) {
      e2.render(t3.uniforms);
    }), this.onRender && this.onRender(this), this.shouldRender && requestAnimationFrame(function() {
      return t3.render();
    });
  }, i.prototype.add = function(t3, i3) {
    void 0 === i3 && (i3 = { uniforms: {} }), void 0 === i3.uniforms && (i3.uniforms = {}), Object.assign(i3.uniforms, JSON.parse(JSON.stringify(this.uniforms))), Object.assign(i3, { gl: this.gl, uniformMap: this.uniformMap });
    var r4 = new e(i3);
    return this.instances.set(t3, r4), r4;
  }, i.prototype.remove = function(t3) {
    var e2 = this.instances.get(t3);
    void 0 !== e2 && (e2.destroy(), this.instances.delete(t3));
  }, i.prototype.destroy = function() {
    var t3 = this;
    this.instances.forEach(function(e2, i3) {
      e2.destroy(), t3.instances.delete(i3);
    }), this.toggle(false);
  };
  var phenomenon_default = i;

  // ../../node_modules/cobe/dist/index.esm.js
  var C = "phi";
  var U2 = "theta";
  var r3 = "mapSamples";
  var p2 = "mapBrightness";
  var v = "baseColor";
  var D2 = "markerColor";
  var B3 = "glowColor";
  var i2 = "markers";
  var w = "diffuse";
  var y = "devicePixelRatio";
  var F = "dark";
  var b = "offset";
  var g = "scale";
  var H2 = "opacity";
  var K3 = "mapBaseBrightness";
  var k3 = { [C]: "z", [U2]: "A", [r3]: "k", [p2]: "D", [v]: "S", [D2]: "T", [B3]: "y", [w]: "E", [F]: "F", [b]: "x", [g]: "B", [H2]: "U", [K3]: "G" };
  var { PI: M, sin: X3, cos: f, sqrt: z, atan2: V, floor: A, max: J2, pow: Q, log2: Z2 } = Math;
  var Y3 = 2.23606797749979;
  var q = 1.618033988749895;
  var $2 = 0.7202100452062783;
  var l = 6.283185307179586;
  var W2 = 3.8832220774509327;
  var m2 = 0.618033988749895;
  var tt = (E2, n2) => {
    let _2 = [E2[0], E2[2], E2[1]], c = 1 / n2, a = J2(2, A(Z2(Y3 * n2 * M * (1 - _2[2] * _2[2])) * $2)), t3 = Q(q, a) / Y3, e2 = [A(t3 + 0.5), A(t3 * q + 0.5)], o = [(e2[0] + 1) * m2 % 1 * l - W2, (e2[1] + 1) * m2 % 1 * l - W2], L2 = [-2 * e2[0], -2 * e2[1]], S2 = [V(_2[1], _2[0]), _2[2] - 1], s = o[0] * L2[1] - L2[0] * o[1], T2 = [A((L2[1] * S2[0] - o[1] * (S2[1] * n2 + 1)) / s), A((-L2[0] * S2[0] + o[0] * (S2[1] * n2 + 1)) / s)], R = M, O = [0, 0, 0];
    for (let N2 = 0; N2 < 4; N2++) {
      let P2 = e2[0] * (T2[0] + N2 % 2) + e2[1] * (T2[1] + A(N2 * 0.5));
      if (P2 > n2) continue;
      let d = P2 * m2 % 1 * l, u2 = 1 - 2 * P2 * c, I2 = z(1 - u2 * u2), G3 = [f(d) * I2, X3(d) * I2, u2], h = z((_2[0] - G3[0]) ** 2 + (_2[1] - G3[1]) ** 2 + (_2[2] - G3[2]) ** 2);
      h < R && (R = h, O = G3);
    }
    return [O[0], O[2], O[1]];
  };
  var x = (E2, n2) => [].concat(...E2.map((_2) => {
    let [c, a] = _2.location;
    c = c * M / 180, a = a * M / 180 - M;
    let t3 = f(c), e2 = [-t3 * f(a), X3(c), t3 * X3(a)];
    return [...tt(e2, n2), _2.size, ..._2.color ? [..._2.color, 1] : [0, 0, 0, 0]];
  }), [0, 0, 0, 0, 0, 0, 0, 0]);
  var _t = (E2, n2) => {
    let _2 = (t3, e2, o) => ({ type: t3, value: typeof n2[e2] == "undefined" ? o : n2[e2] }), c = E2.getContext("webgl2") ? "webgl2" : E2.getContext("webgl") ? "webgl" : "experimental-webgl", a = new phenomenon_default({ canvas: E2, contextType: c, context: { alpha: true, stencil: false, antialias: true, depth: false, preserveDrawingBuffer: false, ...n2.context }, settings: { [y]: n2[y] || 1, onSetup: (t3) => {
      let e2 = t3.RGB, o = t3.UNSIGNED_BYTE, L2 = t3.TEXTURE_2D, S2 = t3.createTexture();
      t3.bindTexture(L2, S2), t3.texImage2D(L2, 0, e2, 1, 1, 0, e2, o, new Uint8Array([0, 0, 0, 0]));
      let s = new Image();
      s.onload = () => {
        t3.bindTexture(L2, S2), t3.texImage2D(L2, 0, e2, e2, o, s), t3.generateMipmap(L2);
        let T2 = t3.getParameter(t3.CURRENT_PROGRAM), R = t3.getUniformLocation(T2, "H");
        t3.texParameteri(L2, t3.TEXTURE_MIN_FILTER, t3.NEAREST), t3.texParameteri(L2, t3.TEXTURE_MAG_FILTER, t3.NEAREST), t3.uniform1i(R, 0);
      }, s.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAACAAQAAAADMzoqnAAAAAXNSR0IArs4c6QAABA5JREFUeNrV179uHEUAx/Hf3JpbF+E2VASBsmVKTBcpKJs3SMEDcDwBiVJAAewYEBUivIHT0uUBIt0YCovKD0CRjUC4QfHYh8hYXu+P25vZ2Zm9c66gMd/GJ/tz82d3bk8GN4SrByYF2366FNTACIAkivVAAazQdnf3MvAlbNUQfOPAdQDvSAimMWhwy4I2g4SU+Kp04ISLpPBAKLxPyic3O/CCi+Y7rUJbiodcpDOFY7CgxCEXmdYD2EYK2s5lApOx5pEDDYCUwM1XdJUwBV11QQMg59kePSCaPAASQMEL2hwo6TJFgxpg+TgC2ymXPbuvc40awr3D1QCFfbH9kcoqAOkZozpQo0aqAGQRKCog/+tjkgbNFEtg2FffBvBGlSxHoAaAa1u6X4PBAwDiR8FFsrQgeUhfJTSALaB9jy5NCybJPn1SVFiWk7ywN+KzhH1aKAuydhGkbEF4lWohLXDXavlyFgHY7LBnLRdlAP6BS5Cc8RfVDXbkwN/oIvmY+6obbNeBP0JwTuMGu9gTzy1Q4RS/cWpfzszeYwd+CAFrtBW/Hur0gLbJGlD+/OjVwe/drfBxkbbg63dndEDfiEBlAd7ac0BPe1D6Jd8dfbLH+RI0OzseFB5s01/M+gMdAeluLOCAuaUA9Lezo/vSgXoCX9rtEiXnp7Q1W/CNyWcd8DXoS6jH/YZ5vAJEWY2dXFQe2TUgaFaNejCzJ98g6HnlVrsE58sDcYqg+9XY75fPqdoh/kRQWiXKg8MWlJQxUFMPjqnyujhFBE7UxIMjyszk0QwQlFsezImsyvUYYYVED2pk6m0Tg8T04Fwjk2kdAwSACqlM6gRRt3vQYAFGX0Ah7Ebx1H+MDRI5ui0QldH4j7FGcm90XdxD2Jg1AOEAVAKhEFXSn4cKUELurIAKwJ3MArypPscQaLhJFICJ0ohjDySAdH8AhDtCiTuMycH8CXzhH9jUACAO5uMhoAwA5i+T6WAKmmAqnLy80wxHqIPFYpqCwxGaYLt4Dyievg5kEoVEUAhs6pqKgFtDQYOuaXypaWKQfIuwwoGSZgfLsu/XAtI8cGN+h7Cc1A5oLOMhwlIPXuhu48AIvsSBkvtV9wsJRKCyYLfq5lTrQMFd1a262oqBck9K1V0YjQg0iEYYgpS1A9GlXQV5cykwm4A7BzVsxQqo7E+zCegO7Ma7yKgsuOcfKbMBwLC8wvVNYDsANYalEpOAa6zpWjTeMKGwEwC1CiQewJc5EKfgy7GmRAZA4vUVGwE2dPM/g0xuAInE/yG5aZ8ISxWGfYigUVbdyBElTHh2uCwGdfCkOLGgQVBh3Ewp+/QK4CDlR5Ws/Zf7yhCf8pH7vinWAvoVCQ6zz0NX5V/6GkAVV+2/5qsJ/gU8bsxpM8IeAQAAAABJRU5ErkJggg==";
    } } });
    return a.add("", { vertex: "attribute vec3 aPosition;uniform mat4 uProjectionMatrix;uniform mat4 uModelMatrix;uniform mat4 uViewMatrix;void main(){gl_Position=uProjectionMatrix*uModelMatrix*uViewMatrix*vec4(aPosition,1.);}", fragment: "precision highp float;uniform vec2 w,x;uniform vec3 S,T,y;uniform vec4 u[64*2];uniform float z,A,k,B,C,D,E,F,U,G;uniform sampler2D H;float I=1./k;mat3 J(float a,float b){float c=cos(a),d=cos(b),e=sin(a),f=sin(b);return mat3(d,f*e,-f*c,0.,c,e,f,d*-e,d*c);}vec3 K(vec3 c,out float v){c=c.xzy;float p=max(2.,floor(log2(2.236068*k*3.141593*(1.-c.z*c.z))*.72021));vec2 g=floor(pow(1.618034,p)/2.236068*vec2(1,1.618034)+.5),d=fract((g+1.)*.618034)*6.283185-3.883222,e=-2.*g,f=vec2(atan(c.y,c.x),c.z-1.),q=floor(vec2(e.y*f.x-d.y*(f.y*k+1.),-e.x*f.x+d.x*(f.y*k+1.))/(d.x*e.y-e.x*d.y));float n=3.141593;vec3 r;for(float h=0.;h<4.;h+=1.){vec2 s=vec2(mod(h,2.),floor(h*.5));float j=dot(g,q+s);if(j>k)continue;float a=j,b=0.;if(a>=524288.)a-=524288.,b+=.803894;if(a>=262144.)a-=262144.,b+=.901947;if(a>=131072.)a-=131072.,b+=.950973;if(a>=65536.)a-=65536.,b+=.475487;if(a>=32768.)a-=32768.,b+=.737743;if(a>=16384.)a-=16384.,b+=.868872;if(a>=8192.)a-=8192.,b+=.934436;if(a>=4096.)a-=4096.,b+=.467218;if(a>=2048.)a-=2048.,b+=.733609;if(a>=1024.)a-=1024.,b+=.866804;if(a>=512.)a-=512.,b+=.433402;if(a>=256.)a-=256.,b+=.216701;if(a>=128.)a-=128.,b+=.108351;if(a>=64.)a-=64.,b+=.554175;if(a>=32.)a-=32.,b+=.777088;if(a>=16.)a-=16.,b+=.888544;if(a>=8.)a-=8.,b+=.944272;if(a>=4.)a-=4.,b+=.472136;if(a>=2.)a-=2.,b+=.236068;if(a>=1.)a-=1.,b+=.618034;float l=fract(b)*6.283185,i=1.-2.*j*I,m=sqrt(1.-i*i);vec3 o=vec3(cos(l)*m,sin(l)*m,i);float t=length(c-o);if(t<n)n=t,r=o;}v=n;return r.xzy;}void main(){vec2 f=1./w,a=(gl_FragCoord.xy*f*2.-1.)/B-x*vec2(1,-1)*f;a.x*=w.x*f.y;float c=dot(a,a);vec4 t=vec4(0);float j=0.;int V=int(C);if(c<=.64){float b;vec4 e=vec4(0);vec3 v=vec3(0,0,1),l=normalize(vec3(a,sqrt(.64-c)));mat3 L=J(A,z);float g=dot(l,v);vec3 m=l*L,h=K(m,b);float n=asin(h.y),i=acos(-h.x/cos(n));i=h.z<0.?-i:i;float M=max(texture2D(H,vec2(i*.5/3.141593,-(n/3.141593+.5))).x,G),N=smoothstep(8e-3,0.,b),o=pow(g,E)*D,p=M*N*o,W=mix((1.-p)*pow(g,.4),p,F)+.1;e+=vec4(S*W,1.);float X=0.;for(int d=0;d<128;d+=2){if(d>=V)break;vec4 q=u[d],O=u[d+1];vec3 P=q.xyz;float r=q.w;vec3 Y=P-m;b=length(Y);if(b<r){float Q=r*.5,s=smoothstep(Q,0.,b);X+=s,e.xyz=O.w>.5?mix(e.xyz,O.xyz,s*o):mix(e.xyz,T,s*o);}}e.xyz+=pow(1.-g,4.)*y,t+=e*(1.+U)*.5,j=pow(dot(normalize(vec3(-a,sqrt(1.-c))),vec3(0,0,1)),4.)*smoothstep(0.,1.,.2/(c-.64));}else{float R=sqrt(.2/(c-.64));j=smoothstep(.5,1.,R/(R+1.));}gl_FragColor=t+vec4(j*y,j);}", uniforms: { w: { type: "vec2", value: [n2.width, n2.height] }, z: _2("float", C), A: _2("float", U2), k: _2("float", r3), D: _2("float", p2), G: _2("float", K3), S: _2("vec3", v), T: _2("vec3", D2), E: _2("float", w), y: _2("vec3", B3), F: _2("float", F), u: { type: "vec4", value: x(n2[i2], n2[r3]) }, C: { type: "float", value: n2[i2].length * 2 }, x: _2("vec2", b, [0, 0]), B: _2("float", g, 1), U: _2("float", H2, 1) }, mode: 4, geometry: { vertices: [{ x: -100, y: 100, z: 0 }, { x: -100, y: -100, z: 0 }, { x: 100, y: 100, z: 0 }, { x: 100, y: -100, z: 0 }, { x: -100, y: -100, z: 0 }, { x: 100, y: 100, z: 0 }] }, onRender: ({ uniforms: t3 }) => {
      let e2 = {};
      if (n2.onRender) {
        e2 = n2.onRender(e2) || e2;
        for (let o in k3) e2[o] !== void 0 && (t3[k3[o]].value = e2[o]);
        if (e2[i2] !== void 0) {
          let o = e2[r3] !== void 0 ? e2[r3] : t3["k"].value;
          t3["u"].value = x(e2[i2], o), t3["C"].value = e2[i2].length;
        }
        e2.width && e2.height && (t3["w"].value = [e2.width, e2.height]), e2[r3] !== void 0 && (t3["u"].value = x(e2[i2] || n2[i2], e2[r3]));
      }
    } }), a;
  };

  // src/components/Globe.tsx
  var import_react95 = __toESM(require_react());

  // ../../node_modules/@react-spring/rafz/dist/react-spring_rafz.modern.mjs
  var updateQueue = makeQueue();
  var raf = (fn) => schedule(fn, updateQueue);
  var writeQueue = makeQueue();
  raf.write = (fn) => schedule(fn, writeQueue);
  var onStartQueue = makeQueue();
  raf.onStart = (fn) => schedule(fn, onStartQueue);
  var onFrameQueue = makeQueue();
  raf.onFrame = (fn) => schedule(fn, onFrameQueue);
  var onFinishQueue = makeQueue();
  raf.onFinish = (fn) => schedule(fn, onFinishQueue);
  var timeouts = [];
  raf.setTimeout = (handler, ms) => {
    const time2 = raf.now() + ms;
    const cancel = () => {
      const i3 = timeouts.findIndex((t3) => t3.cancel == cancel);
      if (~i3) timeouts.splice(i3, 1);
      pendingCount -= ~i3 ? 1 : 0;
    };
    const timeout = { time: time2, handler, cancel };
    timeouts.splice(findTimeout(time2), 0, timeout);
    pendingCount += 1;
    start();
    return timeout;
  };
  var findTimeout = (time2) => ~(~timeouts.findIndex((t3) => t3.time > time2) || ~timeouts.length);
  raf.cancel = (fn) => {
    onStartQueue.delete(fn);
    onFrameQueue.delete(fn);
    onFinishQueue.delete(fn);
    updateQueue.delete(fn);
    writeQueue.delete(fn);
  };
  raf.sync = (fn) => {
    sync = true;
    raf.batchedUpdates(fn);
    sync = false;
  };
  raf.throttle = (fn) => {
    let lastArgs;
    function queuedFn() {
      try {
        fn(...lastArgs);
      } finally {
        lastArgs = null;
      }
    }
    function throttled(...args) {
      lastArgs = args;
      raf.onStart(queuedFn);
    }
    throttled.handler = fn;
    throttled.cancel = () => {
      onStartQueue.delete(queuedFn);
      lastArgs = null;
    };
    return throttled;
  };
  var nativeRaf = typeof window != "undefined" ? window.requestAnimationFrame : (
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    (() => {
    })
  );
  raf.use = (impl) => nativeRaf = impl;
  raf.now = typeof performance != "undefined" ? () => performance.now() : Date.now;
  raf.batchedUpdates = (fn) => fn();
  raf.catch = console.error;
  raf.frameLoop = "always";
  raf.advance = () => {
    if (raf.frameLoop !== "demand") {
      console.warn(
        "Cannot call the manual advancement of rafz whilst frameLoop is not set as demand"
      );
    } else {
      update();
    }
  };
  var ts = -1;
  var pendingCount = 0;
  var sync = false;
  function schedule(fn, queue) {
    if (sync) {
      queue.delete(fn);
      fn(0);
    } else {
      queue.add(fn);
      start();
    }
  }
  function start() {
    if (ts < 0) {
      ts = 0;
      if (raf.frameLoop !== "demand") {
        nativeRaf(loop);
      }
    }
  }
  function stop() {
    ts = -1;
  }
  function loop() {
    if (~ts) {
      nativeRaf(loop);
      raf.batchedUpdates(update);
    }
  }
  function update() {
    const prevTs = ts;
    ts = raf.now();
    const count3 = findTimeout(ts);
    if (count3) {
      eachSafely(timeouts.splice(0, count3), (t3) => t3.handler());
      pendingCount -= count3;
    }
    if (!pendingCount) {
      stop();
      return;
    }
    onStartQueue.flush();
    updateQueue.flush(prevTs ? Math.min(64, ts - prevTs) : 16.667);
    onFrameQueue.flush();
    writeQueue.flush();
    onFinishQueue.flush();
  }
  function makeQueue() {
    let next = /* @__PURE__ */ new Set();
    let current = next;
    return {
      add(fn) {
        pendingCount += current == next && !next.has(fn) ? 1 : 0;
        next.add(fn);
      },
      delete(fn) {
        pendingCount -= current == next && next.has(fn) ? 1 : 0;
        return next.delete(fn);
      },
      flush(arg) {
        if (current.size) {
          next = /* @__PURE__ */ new Set();
          pendingCount -= current.size;
          eachSafely(current, (fn) => fn(arg) && next.add(fn));
          pendingCount += next.size;
          current = next;
        }
      }
    };
  }
  function eachSafely(values, each2) {
    values.forEach((value) => {
      try {
        each2(value);
      } catch (e2) {
        raf.catch(e2);
      }
    });
  }

  // ../../node_modules/@react-spring/shared/dist/react-spring_shared.modern.mjs
  var import_react81 = __toESM(require_react2(), 1);
  var import_react82 = __toESM(require_react2(), 1);
  var import_react83 = __toESM(require_react2(), 1);
  var import_react84 = __toESM(require_react2(), 1);
  var import_react85 = __toESM(require_react2(), 1);
  var import_react86 = __toESM(require_react2(), 1);
  var import_react87 = __toESM(require_react2(), 1);
  var import_react88 = __toESM(require_react2(), 1);
  var __defProp2 = Object.defineProperty;
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var globals_exports = {};
  __export2(globals_exports, {
    assign: () => assign,
    colors: () => colors,
    createStringInterpolator: () => createStringInterpolator,
    skipAnimation: () => skipAnimation,
    to: () => to,
    willAdvance: () => willAdvance
  });
  function noop2() {
  }
  var defineHidden = (obj, key, value) => Object.defineProperty(obj, key, { value, writable: true, configurable: true });
  var is = {
    arr: Array.isArray,
    obj: (a) => !!a && a.constructor.name === "Object",
    fun: (a) => typeof a === "function",
    str: (a) => typeof a === "string",
    num: (a) => typeof a === "number",
    und: (a) => a === void 0
  };
  function isEqual(a, b2) {
    if (is.arr(a)) {
      if (!is.arr(b2) || a.length !== b2.length) return false;
      for (let i3 = 0; i3 < a.length; i3++) {
        if (a[i3] !== b2[i3]) return false;
      }
      return true;
    }
    return a === b2;
  }
  var each = (obj, fn) => obj.forEach(fn);
  function eachProp(obj, fn, ctx) {
    if (is.arr(obj)) {
      for (let i3 = 0; i3 < obj.length; i3++) {
        fn.call(ctx, obj[i3], `${i3}`);
      }
      return;
    }
    for (const key in obj) {
      if (obj.hasOwnProperty(key)) {
        fn.call(ctx, obj[key], key);
      }
    }
  }
  var toArray = (a) => is.und(a) ? [] : is.arr(a) ? a : [a];
  function flush(queue, iterator) {
    if (queue.size) {
      const items = Array.from(queue);
      queue.clear();
      each(items, iterator);
    }
  }
  var flushCalls = (queue, ...args) => flush(queue, (fn) => fn(...args));
  var isSSR = () => typeof window === "undefined" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent);
  var createStringInterpolator;
  var to;
  var colors = null;
  var skipAnimation = false;
  var willAdvance = noop2;
  var assign = (globals) => {
    if (globals.to) to = globals.to;
    if (globals.now) raf.now = globals.now;
    if (globals.colors !== void 0) colors = globals.colors;
    if (globals.skipAnimation != null) skipAnimation = globals.skipAnimation;
    if (globals.createStringInterpolator)
      createStringInterpolator = globals.createStringInterpolator;
    if (globals.requestAnimationFrame) raf.use(globals.requestAnimationFrame);
    if (globals.batchedUpdates) raf.batchedUpdates = globals.batchedUpdates;
    if (globals.willAdvance) willAdvance = globals.willAdvance;
    if (globals.frameLoop) raf.frameLoop = globals.frameLoop;
  };
  var startQueue = /* @__PURE__ */ new Set();
  var currentFrame = [];
  var prevFrame = [];
  var priority = 0;
  var frameLoop = {
    get idle() {
      return !startQueue.size && !currentFrame.length;
    },
    /** Advance the given animation on every frame until idle. */
    start(animation) {
      if (priority > animation.priority) {
        startQueue.add(animation);
        raf.onStart(flushStartQueue);
      } else {
        startSafely(animation);
        raf(advance);
      }
    },
    /** Advance all animations by the given time. */
    advance,
    /** Call this when an animation's priority changes. */
    sort(animation) {
      if (priority) {
        raf.onFrame(() => frameLoop.sort(animation));
      } else {
        const prevIndex = currentFrame.indexOf(animation);
        if (~prevIndex) {
          currentFrame.splice(prevIndex, 1);
          startUnsafely(animation);
        }
      }
    },
    /**
     * Clear all animations. For testing purposes.
     *
     *  Never call this from within the frameloop.
     */
    clear() {
      currentFrame = [];
      startQueue.clear();
    }
  };
  function flushStartQueue() {
    startQueue.forEach(startSafely);
    startQueue.clear();
    raf(advance);
  }
  function startSafely(animation) {
    if (!currentFrame.includes(animation)) startUnsafely(animation);
  }
  function startUnsafely(animation) {
    currentFrame.splice(
      findIndex2(currentFrame, (other) => other.priority > animation.priority),
      0,
      animation
    );
  }
  function advance(dt2) {
    const nextFrame = prevFrame;
    for (let i3 = 0; i3 < currentFrame.length; i3++) {
      const animation = currentFrame[i3];
      priority = animation.priority;
      if (!animation.idle) {
        willAdvance(animation);
        animation.advance(dt2);
        if (!animation.idle) {
          nextFrame.push(animation);
        }
      }
    }
    priority = 0;
    prevFrame = currentFrame;
    prevFrame.length = 0;
    currentFrame = nextFrame;
    return currentFrame.length > 0;
  }
  function findIndex2(arr, test2) {
    const index2 = arr.findIndex(test2);
    return index2 < 0 ? arr.length : index2;
  }
  var clamp2 = (min3, max3, v2) => Math.min(Math.max(v2, min3), max3);
  var colors2 = {
    transparent: 0,
    aliceblue: 4042850303,
    antiquewhite: 4209760255,
    aqua: 16777215,
    aquamarine: 2147472639,
    azure: 4043309055,
    beige: 4126530815,
    bisque: 4293182719,
    black: 255,
    blanchedalmond: 4293643775,
    blue: 65535,
    blueviolet: 2318131967,
    brown: 2771004159,
    burlywood: 3736635391,
    burntsienna: 3934150143,
    cadetblue: 1604231423,
    chartreuse: 2147418367,
    chocolate: 3530104575,
    coral: 4286533887,
    cornflowerblue: 1687547391,
    cornsilk: 4294499583,
    crimson: 3692313855,
    cyan: 16777215,
    darkblue: 35839,
    darkcyan: 9145343,
    darkgoldenrod: 3095792639,
    darkgray: 2846468607,
    darkgreen: 6553855,
    darkgrey: 2846468607,
    darkkhaki: 3182914559,
    darkmagenta: 2332068863,
    darkolivegreen: 1433087999,
    darkorange: 4287365375,
    darkorchid: 2570243327,
    darkred: 2332033279,
    darksalmon: 3918953215,
    darkseagreen: 2411499519,
    darkslateblue: 1211993087,
    darkslategray: 793726975,
    darkslategrey: 793726975,
    darkturquoise: 13554175,
    darkviolet: 2483082239,
    deeppink: 4279538687,
    deepskyblue: 12582911,
    dimgray: 1768516095,
    dimgrey: 1768516095,
    dodgerblue: 512819199,
    firebrick: 2988581631,
    floralwhite: 4294635775,
    forestgreen: 579543807,
    fuchsia: 4278255615,
    gainsboro: 3705462015,
    ghostwhite: 4177068031,
    gold: 4292280575,
    goldenrod: 3668254975,
    gray: 2155905279,
    green: 8388863,
    greenyellow: 2919182335,
    grey: 2155905279,
    honeydew: 4043305215,
    hotpink: 4285117695,
    indianred: 3445382399,
    indigo: 1258324735,
    ivory: 4294963455,
    khaki: 4041641215,
    lavender: 3873897215,
    lavenderblush: 4293981695,
    lawngreen: 2096890111,
    lemonchiffon: 4294626815,
    lightblue: 2916673279,
    lightcoral: 4034953471,
    lightcyan: 3774873599,
    lightgoldenrodyellow: 4210742015,
    lightgray: 3553874943,
    lightgreen: 2431553791,
    lightgrey: 3553874943,
    lightpink: 4290167295,
    lightsalmon: 4288707327,
    lightseagreen: 548580095,
    lightskyblue: 2278488831,
    lightslategray: 2005441023,
    lightslategrey: 2005441023,
    lightsteelblue: 2965692159,
    lightyellow: 4294959359,
    lime: 16711935,
    limegreen: 852308735,
    linen: 4210091775,
    magenta: 4278255615,
    maroon: 2147483903,
    mediumaquamarine: 1724754687,
    mediumblue: 52735,
    mediumorchid: 3126187007,
    mediumpurple: 2473647103,
    mediumseagreen: 1018393087,
    mediumslateblue: 2070474495,
    mediumspringgreen: 16423679,
    mediumturquoise: 1221709055,
    mediumvioletred: 3340076543,
    midnightblue: 421097727,
    mintcream: 4127193855,
    mistyrose: 4293190143,
    moccasin: 4293178879,
    navajowhite: 4292783615,
    navy: 33023,
    oldlace: 4260751103,
    olive: 2155872511,
    olivedrab: 1804477439,
    orange: 4289003775,
    orangered: 4282712319,
    orchid: 3664828159,
    palegoldenrod: 4008225535,
    palegreen: 2566625535,
    paleturquoise: 2951671551,
    palevioletred: 3681588223,
    papayawhip: 4293907967,
    peachpuff: 4292524543,
    peru: 3448061951,
    pink: 4290825215,
    plum: 3718307327,
    powderblue: 2967529215,
    purple: 2147516671,
    rebeccapurple: 1714657791,
    red: 4278190335,
    rosybrown: 3163525119,
    royalblue: 1097458175,
    saddlebrown: 2336560127,
    salmon: 4202722047,
    sandybrown: 4104413439,
    seagreen: 780883967,
    seashell: 4294307583,
    sienna: 2689740287,
    silver: 3233857791,
    skyblue: 2278484991,
    slateblue: 1784335871,
    slategray: 1887473919,
    slategrey: 1887473919,
    snow: 4294638335,
    springgreen: 16744447,
    steelblue: 1182971135,
    tan: 3535047935,
    teal: 8421631,
    thistle: 3636451583,
    tomato: 4284696575,
    turquoise: 1088475391,
    violet: 4001558271,
    wheat: 4125012991,
    white: 4294967295,
    whitesmoke: 4126537215,
    yellow: 4294902015,
    yellowgreen: 2597139199
  };
  var NUMBER = "[-+]?\\d*\\.?\\d+";
  var PERCENTAGE = NUMBER + "%";
  function call(...parts) {
    return "\\(\\s*(" + parts.join(")\\s*,\\s*(") + ")\\s*\\)";
  }
  var rgb = new RegExp("rgb" + call(NUMBER, NUMBER, NUMBER));
  var rgba2 = new RegExp("rgba" + call(NUMBER, NUMBER, NUMBER, NUMBER));
  var hsl = new RegExp("hsl" + call(NUMBER, PERCENTAGE, PERCENTAGE));
  var hsla2 = new RegExp(
    "hsla" + call(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER)
  );
  var hex3 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
  var hex4 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
  var hex6 = /^#([0-9a-fA-F]{6})$/;
  var hex8 = /^#([0-9a-fA-F]{8})$/;
  function normalizeColor(color2) {
    let match2;
    if (typeof color2 === "number") {
      return color2 >>> 0 === color2 && color2 >= 0 && color2 <= 4294967295 ? color2 : null;
    }
    if (match2 = hex6.exec(color2))
      return parseInt(match2[1] + "ff", 16) >>> 0;
    if (colors && colors[color2] !== void 0) {
      return colors[color2];
    }
    if (match2 = rgb.exec(color2)) {
      return (parse255(match2[1]) << 24 | // r
      parse255(match2[2]) << 16 | // g
      parse255(match2[3]) << 8 | // b
      255) >>> // a
      0;
    }
    if (match2 = rgba2.exec(color2)) {
      return (parse255(match2[1]) << 24 | // r
      parse255(match2[2]) << 16 | // g
      parse255(match2[3]) << 8 | // b
      parse1(match2[4])) >>> // a
      0;
    }
    if (match2 = hex3.exec(color2)) {
      return parseInt(
        match2[1] + match2[1] + // r
        match2[2] + match2[2] + // g
        match2[3] + match2[3] + // b
        "ff",
        // a
        16
      ) >>> 0;
    }
    if (match2 = hex8.exec(color2)) return parseInt(match2[1], 16) >>> 0;
    if (match2 = hex4.exec(color2)) {
      return parseInt(
        match2[1] + match2[1] + // r
        match2[2] + match2[2] + // g
        match2[3] + match2[3] + // b
        match2[4] + match2[4],
        // a
        16
      ) >>> 0;
    }
    if (match2 = hsl.exec(color2)) {
      return (hslToRgb(
        parse360(match2[1]),
        // h
        parsePercentage(match2[2]),
        // s
        parsePercentage(match2[3])
        // l
      ) | 255) >>> // a
      0;
    }
    if (match2 = hsla2.exec(color2)) {
      return (hslToRgb(
        parse360(match2[1]),
        // h
        parsePercentage(match2[2]),
        // s
        parsePercentage(match2[3])
        // l
      ) | parse1(match2[4])) >>> // a
      0;
    }
    return null;
  }
  function hue2rgb(p3, q3, t3) {
    if (t3 < 0) t3 += 1;
    if (t3 > 1) t3 -= 1;
    if (t3 < 1 / 6) return p3 + (q3 - p3) * 6 * t3;
    if (t3 < 1 / 2) return q3;
    if (t3 < 2 / 3) return p3 + (q3 - p3) * (2 / 3 - t3) * 6;
    return p3;
  }
  function hslToRgb(h, s, l2) {
    const q3 = l2 < 0.5 ? l2 * (1 + s) : l2 + s - l2 * s;
    const p3 = 2 * l2 - q3;
    const r4 = hue2rgb(p3, q3, h + 1 / 3);
    const g2 = hue2rgb(p3, q3, h);
    const b2 = hue2rgb(p3, q3, h - 1 / 3);
    return Math.round(r4 * 255) << 24 | Math.round(g2 * 255) << 16 | Math.round(b2 * 255) << 8;
  }
  function parse255(str) {
    const int2 = parseInt(str, 10);
    if (int2 < 0) return 0;
    if (int2 > 255) return 255;
    return int2;
  }
  function parse360(str) {
    const int2 = parseFloat(str);
    return (int2 % 360 + 360) % 360 / 360;
  }
  function parse1(str) {
    const num = parseFloat(str);
    if (num < 0) return 0;
    if (num > 1) return 255;
    return Math.round(num * 255);
  }
  function parsePercentage(str) {
    const int2 = parseFloat(str);
    if (int2 < 0) return 0;
    if (int2 > 100) return 1;
    return int2 / 100;
  }
  function colorToRgba(input) {
    let int32Color = normalizeColor(input);
    if (int32Color === null) return input;
    int32Color = int32Color || 0;
    const r4 = (int32Color & 4278190080) >>> 24;
    const g2 = (int32Color & 16711680) >>> 16;
    const b2 = (int32Color & 65280) >>> 8;
    const a = (int32Color & 255) / 255;
    return `rgba(${r4}, ${g2}, ${b2}, ${a})`;
  }
  var createInterpolator = (range, output, extrapolate) => {
    if (is.fun(range)) {
      return range;
    }
    if (is.arr(range)) {
      return createInterpolator({
        range,
        output,
        extrapolate
      });
    }
    if (is.str(range.output[0])) {
      return createStringInterpolator(range);
    }
    const config2 = range;
    const outputRange = config2.output;
    const inputRange = config2.range || [0, 1];
    const extrapolateLeft = config2.extrapolateLeft || config2.extrapolate || "extend";
    const extrapolateRight = config2.extrapolateRight || config2.extrapolate || "extend";
    const easing = config2.easing || ((t3) => t3);
    return (input) => {
      const range2 = findRange(input, inputRange);
      return interpolate2(
        input,
        inputRange[range2],
        inputRange[range2 + 1],
        outputRange[range2],
        outputRange[range2 + 1],
        easing,
        extrapolateLeft,
        extrapolateRight,
        config2.map
      );
    };
  };
  function interpolate2(input, inputMin, inputMax, outputMin, outputMax, easing, extrapolateLeft, extrapolateRight, map) {
    let result = map ? map(input) : input;
    if (result < inputMin) {
      if (extrapolateLeft === "identity") return result;
      else if (extrapolateLeft === "clamp") result = inputMin;
    }
    if (result > inputMax) {
      if (extrapolateRight === "identity") return result;
      else if (extrapolateRight === "clamp") result = inputMax;
    }
    if (outputMin === outputMax) return outputMin;
    if (inputMin === inputMax) return input <= inputMin ? outputMin : outputMax;
    if (inputMin === -Infinity) result = -result;
    else if (inputMax === Infinity) result = result - inputMin;
    else result = (result - inputMin) / (inputMax - inputMin);
    result = easing(result);
    if (outputMin === -Infinity) result = -result;
    else if (outputMax === Infinity) result = result + outputMin;
    else result = result * (outputMax - outputMin) + outputMin;
    return result;
  }
  function findRange(input, inputRange) {
    for (var i3 = 1; i3 < inputRange.length - 1; ++i3)
      if (inputRange[i3] >= input) break;
    return i3 - 1;
  }
  var steps = (steps2, direction = "end") => (progress2) => {
    progress2 = direction === "end" ? Math.min(progress2, 0.999) : Math.max(progress2, 1e-3);
    const expanded = progress2 * steps2;
    const rounded = direction === "end" ? Math.floor(expanded) : Math.ceil(expanded);
    return clamp2(0, 1, rounded / steps2);
  };
  var c1 = 1.70158;
  var c2 = c1 * 1.525;
  var c3 = c1 + 1;
  var c4 = 2 * Math.PI / 3;
  var c5 = 2 * Math.PI / 4.5;
  var bounceOut = (x2) => {
    const n1 = 7.5625;
    const d1 = 2.75;
    if (x2 < 1 / d1) {
      return n1 * x2 * x2;
    } else if (x2 < 2 / d1) {
      return n1 * (x2 -= 1.5 / d1) * x2 + 0.75;
    } else if (x2 < 2.5 / d1) {
      return n1 * (x2 -= 2.25 / d1) * x2 + 0.9375;
    } else {
      return n1 * (x2 -= 2.625 / d1) * x2 + 0.984375;
    }
  };
  var easings = {
    linear: (x2) => x2,
    easeInQuad: (x2) => x2 * x2,
    easeOutQuad: (x2) => 1 - (1 - x2) * (1 - x2),
    easeInOutQuad: (x2) => x2 < 0.5 ? 2 * x2 * x2 : 1 - Math.pow(-2 * x2 + 2, 2) / 2,
    easeInCubic: (x2) => x2 * x2 * x2,
    easeOutCubic: (x2) => 1 - Math.pow(1 - x2, 3),
    easeInOutCubic: (x2) => x2 < 0.5 ? 4 * x2 * x2 * x2 : 1 - Math.pow(-2 * x2 + 2, 3) / 2,
    easeInQuart: (x2) => x2 * x2 * x2 * x2,
    easeOutQuart: (x2) => 1 - Math.pow(1 - x2, 4),
    easeInOutQuart: (x2) => x2 < 0.5 ? 8 * x2 * x2 * x2 * x2 : 1 - Math.pow(-2 * x2 + 2, 4) / 2,
    easeInQuint: (x2) => x2 * x2 * x2 * x2 * x2,
    easeOutQuint: (x2) => 1 - Math.pow(1 - x2, 5),
    easeInOutQuint: (x2) => x2 < 0.5 ? 16 * x2 * x2 * x2 * x2 * x2 : 1 - Math.pow(-2 * x2 + 2, 5) / 2,
    easeInSine: (x2) => 1 - Math.cos(x2 * Math.PI / 2),
    easeOutSine: (x2) => Math.sin(x2 * Math.PI / 2),
    easeInOutSine: (x2) => -(Math.cos(Math.PI * x2) - 1) / 2,
    easeInExpo: (x2) => x2 === 0 ? 0 : Math.pow(2, 10 * x2 - 10),
    easeOutExpo: (x2) => x2 === 1 ? 1 : 1 - Math.pow(2, -10 * x2),
    easeInOutExpo: (x2) => x2 === 0 ? 0 : x2 === 1 ? 1 : x2 < 0.5 ? Math.pow(2, 20 * x2 - 10) / 2 : (2 - Math.pow(2, -20 * x2 + 10)) / 2,
    easeInCirc: (x2) => 1 - Math.sqrt(1 - Math.pow(x2, 2)),
    easeOutCirc: (x2) => Math.sqrt(1 - Math.pow(x2 - 1, 2)),
    easeInOutCirc: (x2) => x2 < 0.5 ? (1 - Math.sqrt(1 - Math.pow(2 * x2, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * x2 + 2, 2)) + 1) / 2,
    easeInBack: (x2) => c3 * x2 * x2 * x2 - c1 * x2 * x2,
    easeOutBack: (x2) => 1 + c3 * Math.pow(x2 - 1, 3) + c1 * Math.pow(x2 - 1, 2),
    easeInOutBack: (x2) => x2 < 0.5 ? Math.pow(2 * x2, 2) * ((c2 + 1) * 2 * x2 - c2) / 2 : (Math.pow(2 * x2 - 2, 2) * ((c2 + 1) * (x2 * 2 - 2) + c2) + 2) / 2,
    easeInElastic: (x2) => x2 === 0 ? 0 : x2 === 1 ? 1 : -Math.pow(2, 10 * x2 - 10) * Math.sin((x2 * 10 - 10.75) * c4),
    easeOutElastic: (x2) => x2 === 0 ? 0 : x2 === 1 ? 1 : Math.pow(2, -10 * x2) * Math.sin((x2 * 10 - 0.75) * c4) + 1,
    easeInOutElastic: (x2) => x2 === 0 ? 0 : x2 === 1 ? 1 : x2 < 0.5 ? -(Math.pow(2, 20 * x2 - 10) * Math.sin((20 * x2 - 11.125) * c5)) / 2 : Math.pow(2, -20 * x2 + 10) * Math.sin((20 * x2 - 11.125) * c5) / 2 + 1,
    easeInBounce: (x2) => 1 - bounceOut(1 - x2),
    easeOutBounce: bounceOut,
    easeInOutBounce: (x2) => x2 < 0.5 ? (1 - bounceOut(1 - 2 * x2)) / 2 : (1 + bounceOut(2 * x2 - 1)) / 2,
    steps
  };
  var $get = /* @__PURE__ */ Symbol.for("FluidValue.get");
  var $observers = /* @__PURE__ */ Symbol.for("FluidValue.observers");
  var hasFluidValue = (arg) => Boolean(arg && arg[$get]);
  var getFluidValue = (arg) => arg && arg[$get] ? arg[$get]() : arg;
  var getFluidObservers = (target) => target[$observers] || null;
  function callFluidObserver(observer2, event) {
    if (observer2.eventObserved) {
      observer2.eventObserved(event);
    } else {
      observer2(event);
    }
  }
  function callFluidObservers(target, event) {
    const observers2 = target[$observers];
    if (observers2) {
      observers2.forEach((observer2) => {
        callFluidObserver(observer2, event);
      });
    }
  }
  var FluidValue = class {
    constructor(get) {
      if (!get && !(get = this.get)) {
        throw Error("Unknown getter");
      }
      setFluidGetter(this, get);
    }
  };
  var setFluidGetter = (target, get) => setHidden(target, $get, get);
  function addFluidObserver(target, observer2) {
    if (target[$get]) {
      let observers2 = target[$observers];
      if (!observers2) {
        setHidden(target, $observers, observers2 = /* @__PURE__ */ new Set());
      }
      if (!observers2.has(observer2)) {
        observers2.add(observer2);
        if (target.observerAdded) {
          target.observerAdded(observers2.size, observer2);
        }
      }
    }
    return observer2;
  }
  function removeFluidObserver(target, observer2) {
    const observers2 = target[$observers];
    if (observers2 && observers2.has(observer2)) {
      const count3 = observers2.size - 1;
      if (count3) {
        observers2.delete(observer2);
      } else {
        target[$observers] = null;
      }
      if (target.observerRemoved) {
        target.observerRemoved(count3, observer2);
      }
    }
  }
  var setHidden = (target, key, value) => Object.defineProperty(target, key, {
    value,
    writable: true,
    configurable: true
  });
  var numberRegex = /[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
  var colorRegex2 = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d\.]+%?\))/gi;
  var unitRegex = new RegExp(`(${numberRegex.source})(%|[a-z]+)`, "i");
  var rgbaRegex = /rgba\(([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+)\)/gi;
  var cssVariableRegex = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
  var variableToRgba = (input) => {
    const [token, fallback] = parseCSSVariable2(input);
    if (!token || isSSR()) {
      return input;
    }
    const value = window.getComputedStyle(document.documentElement).getPropertyValue(token);
    if (value) {
      return value.trim();
    } else if (fallback && fallback.startsWith("--")) {
      const value2 = window.getComputedStyle(document.documentElement).getPropertyValue(fallback);
      if (value2) {
        return value2;
      } else {
        return input;
      }
    } else if (fallback && cssVariableRegex.test(fallback)) {
      return variableToRgba(fallback);
    } else if (fallback) {
      return fallback;
    }
    return input;
  };
  var parseCSSVariable2 = (current) => {
    const match2 = cssVariableRegex.exec(current);
    if (!match2) return [,];
    const [, token, fallback] = match2;
    return [token, fallback];
  };
  var namedColorRegex;
  var rgbaRound = (_2, p1, p22, p3, p4) => `rgba(${Math.round(p1)}, ${Math.round(p22)}, ${Math.round(p3)}, ${p4})`;
  var createStringInterpolator2 = (config2) => {
    if (!namedColorRegex)
      namedColorRegex = colors ? (
        // match color names, ignore partial matches
        new RegExp(`(${Object.keys(colors).join("|")})(?!\\w)`, "g")
      ) : (
        // never match
        /^\b$/
      );
    const output = config2.output.map((value) => {
      return getFluidValue(value).replace(cssVariableRegex, variableToRgba).replace(colorRegex2, colorToRgba).replace(namedColorRegex, colorToRgba);
    });
    const keyframes2 = output.map((value) => value.match(numberRegex).map(Number));
    const outputRanges = keyframes2[0].map(
      (_2, i3) => keyframes2.map((values) => {
        if (!(i3 in values)) {
          throw Error('The arity of each "output" value must be equal');
        }
        return values[i3];
      })
    );
    const interpolators = outputRanges.map(
      (output2) => createInterpolator({ ...config2, output: output2 })
    );
    return (input) => {
      const missingUnit = !unitRegex.test(output[0]) && output.find((value) => unitRegex.test(value))?.replace(numberRegex, "");
      let i3 = 0;
      return output[0].replace(
        numberRegex,
        () => `${interpolators[i3++](input)}${missingUnit || ""}`
      ).replace(rgbaRegex, rgbaRound);
    };
  };
  var prefix = "react-spring: ";
  var once = (fn) => {
    const func = fn;
    let called = false;
    if (typeof func != "function") {
      throw new TypeError(`${prefix}once requires a function parameter`);
    }
    return (...args) => {
      if (!called) {
        func(...args);
        called = true;
      }
    };
  };
  var warnInterpolate = once(console.warn);
  function deprecateInterpolate() {
    warnInterpolate(
      `${prefix}The "interpolate" function is deprecated in v9 (use "to" instead)`
    );
  }
  var warnDirectCall = once(console.warn);
  function deprecateDirectCall() {
    warnDirectCall(
      `${prefix}Directly calling start instead of using the api object is deprecated in v9 (use ".start" instead), this will be removed in later 0.X.0 versions`
    );
  }
  function isAnimatedString(value) {
    return is.str(value) && (value[0] == "#" || /\d/.test(value) || // Do not identify a CSS variable as an AnimatedString if its SSR
    !isSSR() && cssVariableRegex.test(value) || value in (colors || {}));
  }
  var useIsomorphicLayoutEffect3 = isSSR() ? import_react84.useEffect : import_react84.useLayoutEffect;
  var useIsMounted = () => {
    const isMounted = (0, import_react83.useRef)(false);
    useIsomorphicLayoutEffect3(() => {
      isMounted.current = true;
      return () => {
        isMounted.current = false;
      };
    }, []);
    return isMounted;
  };
  function useForceUpdate() {
    const update3 = (0, import_react82.useState)()[1];
    const isMounted = useIsMounted();
    return () => {
      if (isMounted.current) {
        update3(Math.random());
      }
    };
  }
  var useOnce = (effect) => (0, import_react86.useEffect)(effect, emptyDeps);
  var emptyDeps = [];
  function usePrev(value) {
    const prevRef = (0, import_react87.useRef)(void 0);
    (0, import_react87.useEffect)(() => {
      prevRef.current = value;
    });
    return prevRef.current;
  }

  // ../../node_modules/@react-spring/core/dist/react-spring_core.modern.mjs
  var import_react90 = __toESM(require_react2(), 1);

  // ../../node_modules/@react-spring/animated/dist/react-spring_animated.modern.mjs
  var React75 = __toESM(require_react2(), 1);
  var import_react89 = __toESM(require_react2(), 1);
  var $node = /* @__PURE__ */ Symbol.for("Animated:node");
  var isAnimated = (value) => !!value && value[$node] === value;
  var getAnimated = (owner) => owner && owner[$node];
  var setAnimated = (owner, node) => defineHidden(owner, $node, node);
  var getPayload = (owner) => owner && owner[$node] && owner[$node].getPayload();
  var Animated = class {
    constructor() {
      setAnimated(this, this);
    }
    /** Get every `AnimatedValue` used by this node. */
    getPayload() {
      return this.payload || [];
    }
  };
  var AnimatedValue = class _AnimatedValue extends Animated {
    constructor(_value) {
      super();
      this._value = _value;
      this.done = true;
      this.durationProgress = 0;
      if (is.num(this._value)) {
        this.lastPosition = this._value;
      }
    }
    /** @internal */
    static create(value) {
      return new _AnimatedValue(value);
    }
    getPayload() {
      return [this];
    }
    getValue() {
      return this._value;
    }
    setValue(value, step) {
      if (is.num(value)) {
        this.lastPosition = value;
        if (step) {
          value = Math.round(value / step) * step;
          if (this.done) {
            this.lastPosition = value;
          }
        }
      }
      if (this._value === value) {
        return false;
      }
      this._value = value;
      return true;
    }
    reset() {
      const { done } = this;
      this.done = false;
      if (is.num(this._value)) {
        this.elapsedTime = 0;
        this.durationProgress = 0;
        this.lastPosition = this._value;
        if (done) this.lastVelocity = null;
        this.v0 = null;
      }
    }
  };
  var AnimatedString = class _AnimatedString extends AnimatedValue {
    constructor(value) {
      super(0);
      this._string = null;
      this._toString = createInterpolator({
        output: [value, value]
      });
    }
    /** @internal */
    static create(value) {
      return new _AnimatedString(value);
    }
    getValue() {
      const value = this._string;
      return value == null ? this._string = this._toString(this._value) : value;
    }
    setValue(value) {
      if (is.str(value)) {
        if (value == this._string) {
          return false;
        }
        this._string = value;
        this._value = 1;
      } else if (super.setValue(value)) {
        this._string = null;
      } else {
        return false;
      }
      return true;
    }
    reset(goal) {
      if (goal) {
        this._toString = createInterpolator({
          output: [this.getValue(), goal]
        });
      }
      this._value = 0;
      super.reset();
    }
  };
  var TreeContext = { dependencies: null };
  var AnimatedObject = class extends Animated {
    constructor(source) {
      super();
      this.source = source;
      this.setValue(source);
    }
    getValue(animated2) {
      const values = {};
      eachProp(this.source, (source, key) => {
        if (isAnimated(source)) {
          values[key] = source.getValue(animated2);
        } else if (hasFluidValue(source)) {
          values[key] = getFluidValue(source);
        } else if (!animated2) {
          values[key] = source;
        }
      });
      return values;
    }
    /** Replace the raw object data */
    setValue(source) {
      this.source = source;
      this.payload = this._makePayload(source);
    }
    reset() {
      if (this.payload) {
        each(this.payload, (node) => node.reset());
      }
    }
    /** Create a payload set. */
    _makePayload(source) {
      if (source) {
        const payload = /* @__PURE__ */ new Set();
        eachProp(source, this._addToPayload, payload);
        return Array.from(payload);
      }
    }
    /** Add to a payload set. */
    _addToPayload(source) {
      if (TreeContext.dependencies && hasFluidValue(source)) {
        TreeContext.dependencies.add(source);
      }
      const payload = getPayload(source);
      if (payload) {
        each(payload, (node) => this.add(node));
      }
    }
  };
  var AnimatedArray = class _AnimatedArray extends AnimatedObject {
    constructor(source) {
      super(source);
    }
    /** @internal */
    static create(source) {
      return new _AnimatedArray(source);
    }
    getValue() {
      return this.source.map((node) => node.getValue());
    }
    setValue(source) {
      const payload = this.getPayload();
      if (source.length == payload.length) {
        return payload.map((node, i3) => node.setValue(source[i3])).some(Boolean);
      }
      super.setValue(source.map(makeAnimated));
      return true;
    }
  };
  function makeAnimated(value) {
    const nodeType = isAnimatedString(value) ? AnimatedString : AnimatedValue;
    return nodeType.create(value);
  }
  function getAnimatedType(value) {
    const parentNode = getAnimated(value);
    return parentNode ? parentNode.constructor : is.arr(value) ? AnimatedArray : isAnimatedString(value) ? AnimatedString : AnimatedValue;
  }
  var withAnimated = (Component3, host2) => {
    const hasInstance = (
      // Function components must use "forwardRef" to avoid being
      // re-rendered on every animation frame.
      !is.fun(Component3) || Component3.prototype && Component3.prototype.isReactComponent
    );
    return (0, import_react89.forwardRef)((givenProps, givenRef) => {
      const instanceRef = (0, import_react89.useRef)(null);
      const ref = hasInstance && // eslint-disable-next-line react-hooks/rules-of-hooks
      (0, import_react89.useCallback)(
        (value) => {
          instanceRef.current = updateRef(givenRef, value);
        },
        [givenRef]
      );
      const [props, deps] = getAnimatedState(givenProps, host2);
      const forceUpdate = useForceUpdate();
      const callback = () => {
        const instance = instanceRef.current;
        if (hasInstance && !instance) {
          return;
        }
        const didUpdate = instance ? host2.applyAnimatedValues(instance, props.getValue(true)) : false;
        if (didUpdate === false) {
          forceUpdate();
        }
      };
      const observer2 = new PropsObserver(callback, deps);
      const observerRef = (0, import_react89.useRef)(void 0);
      useIsomorphicLayoutEffect3(() => {
        observerRef.current = observer2;
        each(deps, (dep) => addFluidObserver(dep, observer2));
        return () => {
          if (observerRef.current) {
            each(
              observerRef.current.deps,
              (dep) => removeFluidObserver(dep, observerRef.current)
            );
            raf.cancel(observerRef.current.update);
          }
        };
      });
      (0, import_react89.useEffect)(callback, []);
      useOnce(() => () => {
        const observer22 = observerRef.current;
        each(observer22.deps, (dep) => removeFluidObserver(dep, observer22));
      });
      const usedProps = host2.getComponentProps(props.getValue());
      return /* @__PURE__ */ React75.createElement(Component3, { ...usedProps, ref });
    });
  };
  var PropsObserver = class {
    constructor(update3, deps) {
      this.update = update3;
      this.deps = deps;
    }
    eventObserved(event) {
      if (event.type == "change") {
        raf.write(this.update);
      }
    }
  };
  function getAnimatedState(props, host2) {
    const dependencies = /* @__PURE__ */ new Set();
    TreeContext.dependencies = dependencies;
    if (props.style)
      props = {
        ...props,
        style: host2.createAnimatedStyle(props.style)
      };
    props = new AnimatedObject(props);
    TreeContext.dependencies = null;
    return [props, dependencies];
  }
  function updateRef(ref, value) {
    if (ref) {
      if (is.fun(ref)) ref(value);
      else ref.current = value;
    }
    return value;
  }
  var cacheKey = /* @__PURE__ */ Symbol.for("AnimatedComponent");
  var createHost = (components, {
    applyAnimatedValues: applyAnimatedValues2 = () => false,
    createAnimatedStyle = (style) => new AnimatedObject(style),
    getComponentProps = (props) => props
  } = {}) => {
    const hostConfig = {
      applyAnimatedValues: applyAnimatedValues2,
      createAnimatedStyle,
      getComponentProps
    };
    const animated2 = (Component3) => {
      const displayName = getDisplayName(Component3) || "Anonymous";
      if (is.str(Component3)) {
        Component3 = animated2[Component3] || (animated2[Component3] = withAnimated(Component3, hostConfig));
      } else {
        Component3 = Component3[cacheKey] || (Component3[cacheKey] = withAnimated(Component3, hostConfig));
      }
      Component3.displayName = `Animated(${displayName})`;
      return Component3;
    };
    eachProp(components, (Component3, key) => {
      if (is.arr(components)) {
        key = getDisplayName(Component3);
      }
      animated2[key] = animated2(Component3);
    });
    return {
      animated: animated2
    };
  };
  var getDisplayName = (arg) => is.str(arg) ? arg : arg && is.str(arg.displayName) ? arg.displayName : is.fun(arg) && arg.name || null;

  // ../../node_modules/@react-spring/core/dist/react-spring_core.modern.mjs
  var React76 = __toESM(require_react2(), 1);
  var import_react91 = __toESM(require_react2(), 1);
  var import_react92 = __toESM(require_react2(), 1);
  var React212 = __toESM(require_react2(), 1);
  var import_react93 = __toESM(require_react2(), 1);
  var import_react94 = __toESM(require_react2(), 1);
  function callProp(value, ...args) {
    return is.fun(value) ? value(...args) : value;
  }
  var matchProp = (value, key) => value === true || !!(key && value && (is.fun(value) ? value(key) : toArray(value).includes(key)));
  var resolveProp = (prop, key) => is.obj(prop) ? key && prop[key] : prop;
  var getDefaultProp = (props, key) => props.default === true ? props[key] : props.default ? props.default[key] : void 0;
  var noopTransform = (value) => value;
  var getDefaultProps = (props, transform2 = noopTransform) => {
    let keys2 = DEFAULT_PROPS;
    if (props.default && props.default !== true) {
      props = props.default;
      keys2 = Object.keys(props);
    }
    const defaults2 = {};
    for (const key of keys2) {
      const value = transform2(props[key], key);
      if (!is.und(value)) {
        defaults2[key] = value;
      }
    }
    return defaults2;
  };
  var DEFAULT_PROPS = [
    "config",
    "onProps",
    "onStart",
    "onChange",
    "onPause",
    "onResume",
    "onRest"
  ];
  var RESERVED_PROPS = {
    config: 1,
    from: 1,
    to: 1,
    ref: 1,
    loop: 1,
    reset: 1,
    pause: 1,
    cancel: 1,
    reverse: 1,
    immediate: 1,
    default: 1,
    delay: 1,
    onProps: 1,
    onStart: 1,
    onChange: 1,
    onPause: 1,
    onResume: 1,
    onRest: 1,
    onResolve: 1,
    // Transition props
    items: 1,
    trail: 1,
    sort: 1,
    expires: 1,
    initial: 1,
    enter: 1,
    update: 1,
    leave: 1,
    children: 1,
    onDestroyed: 1,
    // Internal props
    keys: 1,
    callId: 1,
    parentId: 1
  };
  function getForwardProps(props) {
    const forward = {};
    let count3 = 0;
    eachProp(props, (value, prop) => {
      if (!RESERVED_PROPS[prop]) {
        forward[prop] = value;
        count3++;
      }
    });
    if (count3) {
      return forward;
    }
  }
  function inferTo(props) {
    const to2 = getForwardProps(props);
    if (to2) {
      const out = { to: to2 };
      eachProp(props, (val, key) => key in to2 || (out[key] = val));
      return out;
    }
    return { ...props };
  }
  function computeGoal(value) {
    value = getFluidValue(value);
    return is.arr(value) ? value.map(computeGoal) : isAnimatedString(value) ? globals_exports.createStringInterpolator({
      range: [0, 1],
      output: [value, value]
    })(1) : value;
  }
  function hasProps(props) {
    for (const _2 in props) return true;
    return false;
  }
  function isAsyncTo(to2) {
    return is.fun(to2) || is.arr(to2) && is.obj(to2[0]);
  }
  function detachRefs(ctrl, ref) {
    ctrl.ref?.delete(ctrl);
    ref?.delete(ctrl);
  }
  function replaceRef(ctrl, ref) {
    if (ref && ctrl.ref !== ref) {
      ctrl.ref?.delete(ctrl);
      ref.add(ctrl);
      ctrl.ref = ref;
    }
  }
  var config = {
    default: { tension: 170, friction: 26 },
    gentle: { tension: 120, friction: 14 },
    wobbly: { tension: 180, friction: 12 },
    stiff: { tension: 210, friction: 20 },
    slow: { tension: 280, friction: 60 },
    molasses: { tension: 280, friction: 120 }
  };
  var defaults = {
    ...config.default,
    mass: 1,
    damping: 1,
    easing: easings.linear,
    clamp: false
  };
  var AnimationConfig = class {
    constructor() {
      this.velocity = 0;
      Object.assign(this, defaults);
    }
  };
  function mergeConfig(config2, newConfig, defaultConfig) {
    if (defaultConfig) {
      defaultConfig = { ...defaultConfig };
      sanitizeConfig(defaultConfig, newConfig);
      newConfig = { ...defaultConfig, ...newConfig };
    }
    sanitizeConfig(config2, newConfig);
    Object.assign(config2, newConfig);
    for (const key in defaults) {
      if (config2[key] == null) {
        config2[key] = defaults[key];
      }
    }
    let { frequency, damping } = config2;
    const { mass } = config2;
    if (!is.und(frequency)) {
      if (frequency < 0.01) frequency = 0.01;
      if (damping < 0) damping = 0;
      config2.tension = Math.pow(2 * Math.PI / frequency, 2) * mass;
      config2.friction = 4 * Math.PI * damping * mass / frequency;
    }
    return config2;
  }
  function sanitizeConfig(config2, props) {
    if (!is.und(props.decay)) {
      config2.duration = void 0;
    } else {
      const isTensionConfig = !is.und(props.tension) || !is.und(props.friction);
      if (isTensionConfig || !is.und(props.frequency) || !is.und(props.damping) || !is.und(props.mass)) {
        config2.duration = void 0;
        config2.decay = void 0;
      }
      if (isTensionConfig) {
        config2.frequency = void 0;
      }
    }
  }
  var emptyArray = [];
  var Animation2 = class {
    constructor() {
      this.changed = false;
      this.values = emptyArray;
      this.toValues = null;
      this.fromValues = emptyArray;
      this.config = new AnimationConfig();
      this.immediate = false;
    }
  };
  function scheduleProps(callId, { key, props, defaultProps, state, actions }) {
    return new Promise((resolve, reject) => {
      let delay2;
      let timeout;
      let cancel = matchProp(props.cancel ?? defaultProps?.cancel, key);
      if (cancel) {
        onStart();
      } else {
        if (!is.und(props.pause)) {
          state.paused = matchProp(props.pause, key);
        }
        let pause = defaultProps?.pause;
        if (pause !== true) {
          pause = state.paused || matchProp(pause, key);
        }
        delay2 = callProp(props.delay || 0, key);
        if (pause) {
          state.resumeQueue.add(onResume);
          actions.pause();
        } else {
          actions.resume();
          onResume();
        }
      }
      function onPause() {
        state.resumeQueue.add(onResume);
        state.timeouts.delete(timeout);
        timeout.cancel();
        delay2 = timeout.time - raf.now();
      }
      function onResume() {
        if (delay2 > 0 && !globals_exports.skipAnimation) {
          state.delayed = true;
          timeout = raf.setTimeout(onStart, delay2);
          state.pauseQueue.add(onPause);
          state.timeouts.add(timeout);
        } else {
          onStart();
        }
      }
      function onStart() {
        if (state.delayed) {
          state.delayed = false;
        }
        state.pauseQueue.delete(onPause);
        state.timeouts.delete(timeout);
        if (callId <= (state.cancelId || 0)) {
          cancel = true;
        }
        try {
          actions.start({ ...props, callId, cancel }, resolve);
        } catch (err) {
          reject(err);
        }
      }
    });
  }
  var getCombinedResult = (target, results) => results.length == 1 ? results[0] : results.some((result) => result.cancelled) ? getCancelledResult(target.get()) : results.every((result) => result.noop) ? getNoopResult(target.get()) : getFinishedResult(
    target.get(),
    results.every((result) => result.finished)
  );
  var getNoopResult = (value) => ({
    value,
    noop: true,
    finished: true,
    cancelled: false
  });
  var getFinishedResult = (value, finished, cancelled = false) => ({
    value,
    finished,
    cancelled
  });
  var getCancelledResult = (value) => ({
    value,
    cancelled: true,
    finished: false
  });
  function runAsync(to2, props, state, target) {
    const { callId, parentId, onRest } = props;
    const { asyncTo: prevTo, promise: prevPromise } = state;
    if (!parentId && to2 === prevTo && !props.reset) {
      return prevPromise;
    }
    return state.promise = (async () => {
      state.asyncId = callId;
      state.asyncTo = to2;
      const defaultProps = getDefaultProps(
        props,
        (value, key) => (
          // The `onRest` prop is only called when the `runAsync` promise is resolved.
          key === "onRest" ? void 0 : value
        )
      );
      let preventBail;
      let bail;
      const bailPromise = new Promise(
        (resolve, reject) => (preventBail = resolve, bail = reject)
      );
      const bailIfEnded = (bailSignal) => {
        const bailResult = (
          // The `cancel` prop or `stop` method was used.
          callId <= (state.cancelId || 0) && getCancelledResult(target) || // The async `to` prop was replaced.
          callId !== state.asyncId && getFinishedResult(target, false)
        );
        if (bailResult) {
          bailSignal.result = bailResult;
          bail(bailSignal);
          throw bailSignal;
        }
      };
      const animate = (arg1, arg2) => {
        const bailSignal = new BailSignal();
        const skipAnimationSignal = new SkipAnimationSignal();
        return (async () => {
          if (globals_exports.skipAnimation) {
            stopAsync(state);
            skipAnimationSignal.result = getFinishedResult(target, false);
            bail(skipAnimationSignal);
            throw skipAnimationSignal;
          }
          bailIfEnded(bailSignal);
          const props2 = is.obj(arg1) ? { ...arg1 } : { ...arg2, to: arg1 };
          props2.parentId = callId;
          eachProp(defaultProps, (value, key) => {
            if (is.und(props2[key])) {
              props2[key] = value;
            }
          });
          const result2 = await target.start(props2);
          bailIfEnded(bailSignal);
          if (state.paused) {
            await new Promise((resume) => {
              state.resumeQueue.add(resume);
            });
          }
          return result2;
        })();
      };
      let result;
      if (globals_exports.skipAnimation) {
        stopAsync(state);
        return getFinishedResult(target, false);
      }
      try {
        let animating;
        if (is.arr(to2)) {
          animating = (async (queue) => {
            for (const props2 of queue) {
              await animate(props2);
            }
          })(to2);
        } else {
          animating = Promise.resolve(to2(animate, target.stop.bind(target)));
        }
        await Promise.all([animating.then(preventBail), bailPromise]);
        result = getFinishedResult(target.get(), true, false);
      } catch (err) {
        if (err instanceof BailSignal) {
          result = err.result;
        } else if (err instanceof SkipAnimationSignal) {
          result = err.result;
        } else {
          throw err;
        }
      } finally {
        if (callId == state.asyncId) {
          state.asyncId = parentId;
          state.asyncTo = parentId ? prevTo : void 0;
          state.promise = parentId ? prevPromise : void 0;
        }
      }
      if (is.fun(onRest)) {
        raf.batchedUpdates(() => {
          onRest(result, target, target.item);
        });
      }
      return result;
    })();
  }
  function stopAsync(state, cancelId) {
    flush(state.timeouts, (t3) => t3.cancel());
    state.pauseQueue.clear();
    state.resumeQueue.clear();
    state.asyncId = state.asyncTo = state.promise = void 0;
    if (cancelId) state.cancelId = cancelId;
  }
  var BailSignal = class extends Error {
    constructor() {
      super(
        "An async animation has been interrupted. You see this error because you forgot to use `await` or `.catch(...)` on its returned promise."
      );
    }
  };
  var SkipAnimationSignal = class extends Error {
    constructor() {
      super("SkipAnimationSignal");
    }
  };
  var isFrameValue = (value) => value instanceof FrameValue;
  var nextId = 1;
  var FrameValue = class extends FluidValue {
    constructor() {
      super(...arguments);
      this.id = nextId++;
      this._priority = 0;
    }
    get priority() {
      return this._priority;
    }
    set priority(priority2) {
      if (this._priority != priority2) {
        this._priority = priority2;
        this._onPriorityChange(priority2);
      }
    }
    /** Get the current value */
    get() {
      const node = getAnimated(this);
      return node && node.getValue();
    }
    /** Create a spring that maps our value to another value */
    to(...args) {
      return globals_exports.to(this, args);
    }
    /** @deprecated Use the `to` method instead. */
    interpolate(...args) {
      deprecateInterpolate();
      return globals_exports.to(this, args);
    }
    toJSON() {
      return this.get();
    }
    observerAdded(count3) {
      if (count3 == 1) this._attach();
    }
    observerRemoved(count3) {
      if (count3 == 0) this._detach();
    }
    /** Called when the first child is added. */
    _attach() {
    }
    /** Called when the last child is removed. */
    _detach() {
    }
    /** Tell our children about our new value */
    _onChange(value, idle = false) {
      callFluidObservers(this, {
        type: "change",
        parent: this,
        value,
        idle
      });
    }
    /** Tell our children about our new priority */
    _onPriorityChange(priority2) {
      if (!this.idle) {
        frameLoop.sort(this);
      }
      callFluidObservers(this, {
        type: "priority",
        parent: this,
        priority: priority2
      });
    }
  };
  var $P = /* @__PURE__ */ Symbol.for("SpringPhase");
  var HAS_ANIMATED = 1;
  var IS_ANIMATING = 2;
  var IS_PAUSED = 4;
  var hasAnimated = (target) => (target[$P] & HAS_ANIMATED) > 0;
  var isAnimating = (target) => (target[$P] & IS_ANIMATING) > 0;
  var isPaused = (target) => (target[$P] & IS_PAUSED) > 0;
  var setActiveBit = (target, active) => active ? target[$P] |= IS_ANIMATING | HAS_ANIMATED : target[$P] &= ~IS_ANIMATING;
  var setPausedBit = (target, paused) => paused ? target[$P] |= IS_PAUSED : target[$P] &= ~IS_PAUSED;
  var SpringValue = class extends FrameValue {
    constructor(arg1, arg2) {
      super();
      this.animation = new Animation2();
      this.defaultProps = {};
      this._state = {
        paused: false,
        delayed: false,
        pauseQueue: /* @__PURE__ */ new Set(),
        resumeQueue: /* @__PURE__ */ new Set(),
        timeouts: /* @__PURE__ */ new Set()
      };
      this._pendingCalls = /* @__PURE__ */ new Set();
      this._lastCallId = 0;
      this._lastToId = 0;
      this._memoizedDuration = 0;
      if (!is.und(arg1) || !is.und(arg2)) {
        const props = is.obj(arg1) ? { ...arg1 } : { ...arg2, from: arg1 };
        if (is.und(props.default)) {
          props.default = true;
        }
        this.start(props);
      }
    }
    /** Equals true when not advancing on each frame. */
    get idle() {
      return !(isAnimating(this) || this._state.asyncTo) || isPaused(this);
    }
    get goal() {
      return getFluidValue(this.animation.to);
    }
    get velocity() {
      const node = getAnimated(this);
      return node instanceof AnimatedValue ? node.lastVelocity || 0 : node.getPayload().map((node2) => node2.lastVelocity || 0);
    }
    /**
     * When true, this value has been animated at least once.
     */
    get hasAnimated() {
      return hasAnimated(this);
    }
    /**
     * When true, this value has an unfinished animation,
     * which is either active or paused.
     */
    get isAnimating() {
      return isAnimating(this);
    }
    /**
     * When true, all current and future animations are paused.
     */
    get isPaused() {
      return isPaused(this);
    }
    /**
     *
     *
     */
    get isDelayed() {
      return this._state.delayed;
    }
    /** Advance the current animation by a number of milliseconds */
    advance(dt2) {
      let idle = true;
      let changed = false;
      const anim = this.animation;
      let { toValues } = anim;
      const { config: config2 } = anim;
      const payload = getPayload(anim.to);
      if (!payload && hasFluidValue(anim.to)) {
        toValues = toArray(getFluidValue(anim.to));
      }
      anim.values.forEach((node2, i3) => {
        if (node2.done) return;
        const to2 = (
          // Animated strings always go from 0 to 1.
          node2.constructor == AnimatedString ? 1 : payload ? payload[i3].lastPosition : toValues[i3]
        );
        let finished = anim.immediate;
        let position = to2;
        if (!finished) {
          position = node2.lastPosition;
          if (config2.tension <= 0) {
            node2.done = true;
            return;
          }
          let elapsed = node2.elapsedTime += dt2;
          const from = anim.fromValues[i3];
          const v0 = node2.v0 != null ? node2.v0 : node2.v0 = is.arr(config2.velocity) ? config2.velocity[i3] : config2.velocity;
          let velocity;
          const precision = config2.precision || (from == to2 ? 5e-3 : Math.min(1, Math.abs(to2 - from) * 1e-3));
          if (!is.und(config2.duration)) {
            let p3 = 1;
            if (config2.duration > 0) {
              if (this._memoizedDuration !== config2.duration) {
                this._memoizedDuration = config2.duration;
                if (node2.durationProgress > 0) {
                  node2.elapsedTime = config2.duration * node2.durationProgress;
                  elapsed = node2.elapsedTime += dt2;
                }
              }
              p3 = (config2.progress || 0) + elapsed / this._memoizedDuration;
              p3 = p3 > 1 ? 1 : p3 < 0 ? 0 : p3;
              node2.durationProgress = p3;
            }
            position = from + config2.easing(p3) * (to2 - from);
            velocity = (position - node2.lastPosition) / dt2;
            finished = p3 == 1;
          } else if (config2.decay) {
            const decay = config2.decay === true ? 0.998 : config2.decay;
            const e2 = Math.exp(-(1 - decay) * elapsed);
            position = from + v0 / (1 - decay) * (1 - e2);
            finished = Math.abs(node2.lastPosition - position) <= precision;
            velocity = v0 * e2;
          } else {
            velocity = node2.lastVelocity == null ? v0 : node2.lastVelocity;
            const restVelocity = config2.restVelocity || precision / 10;
            const bounceFactor = config2.clamp ? 0 : config2.bounce;
            const canBounce = !is.und(bounceFactor);
            const isGrowing = from == to2 ? node2.v0 > 0 : from < to2;
            let isMoving;
            let isBouncing = false;
            const step = 1;
            const numSteps = Math.ceil(dt2 / step);
            for (let n2 = 0; n2 < numSteps; ++n2) {
              isMoving = Math.abs(velocity) > restVelocity;
              if (!isMoving) {
                finished = Math.abs(to2 - position) <= precision;
                if (finished) {
                  break;
                }
              }
              if (canBounce) {
                isBouncing = position == to2 || position > to2 == isGrowing;
                if (isBouncing) {
                  velocity = -velocity * bounceFactor;
                  position = to2;
                }
              }
              const springForce = -config2.tension * 1e-6 * (position - to2);
              const dampingForce = -config2.friction * 1e-3 * velocity;
              const acceleration = (springForce + dampingForce) / config2.mass;
              velocity = velocity + acceleration * step;
              position = position + velocity * step;
            }
          }
          node2.lastVelocity = velocity;
          if (Number.isNaN(position)) {
            console.warn(`Got NaN while animating:`, this);
            finished = true;
          }
        }
        if (payload && !payload[i3].done) {
          finished = false;
        }
        if (finished) {
          node2.done = true;
        } else {
          idle = false;
        }
        if (node2.setValue(position, config2.round)) {
          changed = true;
        }
      });
      const node = getAnimated(this);
      const currVal = node.getValue();
      if (idle) {
        const finalVal = getFluidValue(anim.to);
        if ((currVal !== finalVal || changed) && !config2.decay) {
          node.setValue(finalVal);
          this._onChange(finalVal);
        } else if (changed && config2.decay) {
          this._onChange(currVal);
        }
        this._stop();
      } else if (changed) {
        this._onChange(currVal);
      }
    }
    /** Set the current value, while stopping the current animation */
    set(value) {
      raf.batchedUpdates(() => {
        this._stop();
        this._focus(value);
        this._set(value);
      });
      return this;
    }
    /**
     * Freeze the active animation in time, as well as any updates merged
     * before `resume` is called.
     */
    pause() {
      this._update({ pause: true });
    }
    /** Resume the animation if paused. */
    resume() {
      this._update({ pause: false });
    }
    /** Skip to the end of the current animation. */
    finish() {
      if (isAnimating(this)) {
        const { to: to2, config: config2 } = this.animation;
        raf.batchedUpdates(() => {
          this._onStart();
          if (!config2.decay) {
            this._set(to2, false);
          }
          this._stop();
        });
      }
      return this;
    }
    /** Push props into the pending queue. */
    update(props) {
      const queue = this.queue || (this.queue = []);
      queue.push(props);
      return this;
    }
    start(to2, arg2) {
      let queue;
      if (!is.und(to2)) {
        queue = [is.obj(to2) ? to2 : { ...arg2, to: to2 }];
      } else {
        queue = this.queue || [];
        this.queue = [];
      }
      return Promise.all(
        queue.map((props) => {
          const up = this._update(props);
          return up;
        })
      ).then((results) => getCombinedResult(this, results));
    }
    /**
     * Stop the current animation, and cancel any delayed updates.
     *
     * Pass `true` to call `onRest` with `cancelled: true`.
     */
    stop(cancel) {
      const { to: to2 } = this.animation;
      this._focus(this.get());
      stopAsync(this._state, cancel && this._lastCallId);
      raf.batchedUpdates(() => this._stop(to2, cancel));
      return this;
    }
    /** Restart the animation. */
    reset() {
      this._update({ reset: true });
    }
    /** @internal */
    eventObserved(event) {
      if (event.type == "change") {
        this._start();
      } else if (event.type == "priority") {
        this.priority = event.priority + 1;
      }
    }
    /**
     * Parse the `to` and `from` range from the given `props` object.
     *
     * This also ensures the initial value is available to animated components
     * during the render phase.
     */
    _prepareNode(props) {
      const key = this.key || "";
      let { to: to2, from } = props;
      to2 = is.obj(to2) ? to2[key] : to2;
      if (to2 == null || isAsyncTo(to2)) {
        to2 = void 0;
      }
      from = is.obj(from) ? from[key] : from;
      if (from == null) {
        from = void 0;
      }
      const range = { to: to2, from };
      if (!hasAnimated(this)) {
        if (props.reverse) [to2, from] = [from, to2];
        from = getFluidValue(from);
        if (!is.und(from)) {
          this._set(from);
        } else if (!getAnimated(this)) {
          this._set(to2);
        }
      }
      return range;
    }
    /** Every update is processed by this method before merging. */
    _update({ ...props }, isLoop) {
      const { key, defaultProps } = this;
      if (props.default)
        Object.assign(
          defaultProps,
          getDefaultProps(
            props,
            (value, prop) => /^on/.test(prop) ? resolveProp(value, key) : value
          )
        );
      mergeActiveFn(this, props, "onProps");
      sendEvent(this, "onProps", props, this);
      const range = this._prepareNode(props);
      if (Object.isFrozen(this)) {
        throw Error(
          "Cannot animate a `SpringValue` object that is frozen. Did you forget to pass your component to `animated(...)` before animating its props?"
        );
      }
      const state = this._state;
      return scheduleProps(++this._lastCallId, {
        key,
        props,
        defaultProps,
        state,
        actions: {
          pause: () => {
            if (!isPaused(this)) {
              setPausedBit(this, true);
              flushCalls(state.pauseQueue);
              sendEvent(
                this,
                "onPause",
                getFinishedResult(this, checkFinished(this, this.animation.to)),
                this
              );
            }
          },
          resume: () => {
            if (isPaused(this)) {
              setPausedBit(this, false);
              if (isAnimating(this)) {
                this._resume();
              }
              flushCalls(state.resumeQueue);
              sendEvent(
                this,
                "onResume",
                getFinishedResult(this, checkFinished(this, this.animation.to)),
                this
              );
            }
          },
          start: this._merge.bind(this, range)
        }
      }).then((result) => {
        if (props.loop && result.finished && !(isLoop && result.noop)) {
          const nextProps = createLoopUpdate(props);
          if (nextProps) {
            return this._update(nextProps, true);
          }
        }
        return result;
      });
    }
    /** Merge props into the current animation */
    _merge(range, props, resolve) {
      if (props.cancel) {
        this.stop(true);
        return resolve(getCancelledResult(this));
      }
      const hasToProp = !is.und(range.to);
      const hasFromProp = !is.und(range.from);
      if (hasToProp || hasFromProp) {
        if (props.callId > this._lastToId) {
          this._lastToId = props.callId;
        } else {
          return resolve(getCancelledResult(this));
        }
      }
      const { key, defaultProps, animation: anim } = this;
      const { to: prevTo, from: prevFrom } = anim;
      let { to: to2 = prevTo, from = prevFrom } = range;
      if (hasFromProp && !hasToProp && (!props.default || is.und(to2))) {
        to2 = from;
      }
      if (props.reverse) [to2, from] = [from, to2];
      const hasFromChanged = !isEqual(from, prevFrom);
      if (hasFromChanged) {
        anim.from = from;
      }
      from = getFluidValue(from);
      const hasToChanged = !isEqual(to2, prevTo);
      if (hasToChanged) {
        this._focus(to2);
      }
      const hasAsyncTo = isAsyncTo(props.to);
      const { config: config2 } = anim;
      const { decay, velocity } = config2;
      if (hasToProp || hasFromProp) {
        config2.velocity = 0;
      }
      if (props.config && !hasAsyncTo) {
        mergeConfig(
          config2,
          callProp(props.config, key),
          // Avoid calling the same "config" prop twice.
          props.config !== defaultProps.config ? callProp(defaultProps.config, key) : void 0
        );
      }
      let node = getAnimated(this);
      if (!node || is.und(to2)) {
        return resolve(getFinishedResult(this, true));
      }
      const reset = (
        // When `reset` is undefined, the `from` prop implies `reset: true`,
        // except for declarative updates. When `reset` is defined, there
        // must exist a value to animate from.
        is.und(props.reset) ? hasFromProp && !props.default : !is.und(from) && matchProp(props.reset, key)
      );
      const value = reset ? from : this.get();
      const goal = computeGoal(to2);
      const isAnimatable2 = is.num(goal) || is.arr(goal) || isAnimatedString(goal);
      const immediate = !hasAsyncTo && (!isAnimatable2 || matchProp(defaultProps.immediate || props.immediate, key));
      if (hasToChanged) {
        const nodeType = getAnimatedType(to2);
        if (nodeType !== node.constructor) {
          if (immediate) {
            node = this._set(goal);
          } else
            throw Error(
              `Cannot animate between ${node.constructor.name} and ${nodeType.name}, as the "to" prop suggests`
            );
        }
      }
      const goalType = node.constructor;
      let started = hasFluidValue(to2);
      let finished = false;
      if (!started) {
        const hasValueChanged = reset || !hasAnimated(this) && hasFromChanged;
        if (hasToChanged || hasValueChanged) {
          finished = isEqual(computeGoal(value), goal);
          started = !finished;
        }
        if (!isEqual(anim.immediate, immediate) && !immediate || !isEqual(config2.decay, decay) || !isEqual(config2.velocity, velocity)) {
          started = true;
        }
      }
      if (finished && isAnimating(this)) {
        if (anim.changed && !reset) {
          started = true;
        } else if (!started) {
          this._stop(prevTo);
        }
      }
      if (!hasAsyncTo) {
        if (started || hasFluidValue(prevTo)) {
          anim.values = node.getPayload();
          anim.toValues = hasFluidValue(to2) ? null : goalType == AnimatedString ? [1] : toArray(goal);
        }
        if (anim.immediate != immediate) {
          anim.immediate = immediate;
          if (!immediate && !reset) {
            this._set(prevTo);
          }
        }
        if (started) {
          const { onRest } = anim;
          each(ACTIVE_EVENTS, (type) => mergeActiveFn(this, props, type));
          const result = getFinishedResult(this, checkFinished(this, prevTo));
          flushCalls(this._pendingCalls, result);
          this._pendingCalls.add(resolve);
          if (anim.changed)
            raf.batchedUpdates(() => {
              anim.changed = !reset;
              onRest?.(result, this);
              if (reset) {
                callProp(defaultProps.onRest, result);
              } else {
                anim.onStart?.(result, this);
              }
            });
        }
      }
      if (reset) {
        this._set(value);
      }
      if (hasAsyncTo) {
        resolve(runAsync(props.to, props, this._state, this));
      } else if (started) {
        this._start();
      } else if (isAnimating(this) && !hasToChanged) {
        this._pendingCalls.add(resolve);
      } else {
        resolve(getNoopResult(value));
      }
    }
    /** Update the `animation.to` value, which might be a `FluidValue` */
    _focus(value) {
      const anim = this.animation;
      if (value !== anim.to) {
        if (getFluidObservers(this)) {
          this._detach();
        }
        anim.to = value;
        if (getFluidObservers(this)) {
          this._attach();
        }
      }
    }
    _attach() {
      let priority2 = 0;
      const { to: to2 } = this.animation;
      if (hasFluidValue(to2)) {
        addFluidObserver(to2, this);
        if (isFrameValue(to2)) {
          priority2 = to2.priority + 1;
        }
      }
      this.priority = priority2;
    }
    _detach() {
      const { to: to2 } = this.animation;
      if (hasFluidValue(to2)) {
        removeFluidObserver(to2, this);
      }
    }
    /**
     * Update the current value from outside the frameloop,
     * and return the `Animated` node.
     */
    _set(arg, idle = true) {
      const value = getFluidValue(arg);
      if (!is.und(value)) {
        const oldNode = getAnimated(this);
        if (!oldNode || !isEqual(value, oldNode.getValue())) {
          const nodeType = getAnimatedType(value);
          if (!oldNode || oldNode.constructor != nodeType) {
            setAnimated(this, nodeType.create(value));
          } else {
            oldNode.setValue(value);
          }
          if (oldNode) {
            raf.batchedUpdates(() => {
              this._onChange(value, idle);
            });
          }
        }
      }
      return getAnimated(this);
    }
    _onStart() {
      const anim = this.animation;
      if (!anim.changed) {
        anim.changed = true;
        sendEvent(
          this,
          "onStart",
          getFinishedResult(this, checkFinished(this, anim.to)),
          this
        );
      }
    }
    _onChange(value, idle) {
      if (!idle) {
        this._onStart();
        callProp(this.animation.onChange, value, this);
      }
      callProp(this.defaultProps.onChange, value, this);
      super._onChange(value, idle);
    }
    // This method resets the animation state (even if already animating) to
    // ensure the latest from/to range is used, and it also ensures this spring
    // is added to the frameloop.
    _start() {
      const anim = this.animation;
      getAnimated(this).reset(getFluidValue(anim.to));
      if (!anim.immediate) {
        anim.fromValues = anim.values.map((node) => node.lastPosition);
      }
      if (!isAnimating(this)) {
        setActiveBit(this, true);
        if (!isPaused(this)) {
          this._resume();
        }
      }
    }
    _resume() {
      if (globals_exports.skipAnimation) {
        this.finish();
      } else {
        frameLoop.start(this);
      }
    }
    /**
     * Exit the frameloop and notify `onRest` listeners.
     *
     * Always wrap `_stop` calls with `batchedUpdates`.
     */
    _stop(goal, cancel) {
      if (isAnimating(this)) {
        setActiveBit(this, false);
        const anim = this.animation;
        each(anim.values, (node) => {
          node.done = true;
        });
        if (anim.toValues) {
          anim.onChange = anim.onPause = anim.onResume = void 0;
        }
        callFluidObservers(this, {
          type: "idle",
          parent: this
        });
        const result = cancel ? getCancelledResult(this.get()) : getFinishedResult(this.get(), checkFinished(this, goal ?? anim.to));
        flushCalls(this._pendingCalls, result);
        if (anim.changed) {
          anim.changed = false;
          sendEvent(this, "onRest", result, this);
        }
      }
    }
  };
  function checkFinished(target, to2) {
    const goal = computeGoal(to2);
    const value = computeGoal(target.get());
    return isEqual(value, goal);
  }
  function createLoopUpdate(props, loop2 = props.loop, to2 = props.to) {
    const loopRet = callProp(loop2);
    if (loopRet) {
      const overrides = loopRet !== true && inferTo(loopRet);
      const reverse = (overrides || props).reverse;
      const reset = !overrides || overrides.reset;
      return createUpdate({
        ...props,
        loop: loop2,
        // Avoid updating default props when looping.
        default: false,
        // Never loop the `pause` prop.
        pause: void 0,
        // For the "reverse" prop to loop as expected, the "to" prop
        // must be undefined. The "reverse" prop is ignored when the
        // "to" prop is an array or function.
        to: !reverse || isAsyncTo(to2) ? to2 : void 0,
        // Ignore the "from" prop except on reset.
        from: reset ? props.from : void 0,
        reset,
        // The "loop" prop can return a "useSpring" props object to
        // override any of the original props.
        ...overrides
      });
    }
  }
  function createUpdate(props) {
    const { to: to2, from } = props = inferTo(props);
    const keys2 = /* @__PURE__ */ new Set();
    if (is.obj(to2)) findDefined(to2, keys2);
    if (is.obj(from)) findDefined(from, keys2);
    props.keys = keys2.size ? Array.from(keys2) : null;
    return props;
  }
  function declareUpdate(props) {
    const update22 = createUpdate(props);
    if (is.und(update22.default)) {
      update22.default = getDefaultProps(update22);
    }
    return update22;
  }
  function findDefined(values, keys2) {
    eachProp(values, (value, key) => value != null && keys2.add(key));
  }
  var ACTIVE_EVENTS = [
    "onStart",
    "onRest",
    "onChange",
    "onPause",
    "onResume"
  ];
  function mergeActiveFn(target, props, type) {
    target.animation[type] = props[type] !== getDefaultProp(props, type) ? resolveProp(props[type], target.key) : void 0;
  }
  function sendEvent(target, type, ...args) {
    target.animation[type]?.(...args);
    target.defaultProps[type]?.(...args);
  }
  var BATCHED_EVENTS = ["onStart", "onChange", "onRest"];
  var nextId2 = 1;
  var Controller = class {
    constructor(props, flush3) {
      this.id = nextId2++;
      this.springs = {};
      this.queue = [];
      this._lastAsyncId = 0;
      this._active = /* @__PURE__ */ new Set();
      this._changed = /* @__PURE__ */ new Set();
      this._started = false;
      this._state = {
        paused: false,
        pauseQueue: /* @__PURE__ */ new Set(),
        resumeQueue: /* @__PURE__ */ new Set(),
        timeouts: /* @__PURE__ */ new Set()
      };
      this._events = {
        onStart: /* @__PURE__ */ new Map(),
        onChange: /* @__PURE__ */ new Map(),
        onRest: /* @__PURE__ */ new Map()
      };
      this._onFrame = this._onFrame.bind(this);
      if (flush3) {
        this._flush = flush3;
      }
      if (props) {
        this.start({ default: true, ...props });
      }
    }
    /**
     * Equals `true` when no spring values are in the frameloop, and
     * no async animation is currently active.
     */
    get idle() {
      return !this._state.asyncTo && Object.values(this.springs).every((spring2) => {
        return spring2.idle && !spring2.isDelayed && !spring2.isPaused;
      });
    }
    get item() {
      return this._item;
    }
    set item(item) {
      this._item = item;
    }
    /** Get the current values of our springs */
    get() {
      const values = {};
      this.each((spring2, key) => values[key] = spring2.get());
      return values;
    }
    /** Set the current values without animating. */
    set(values) {
      for (const key in values) {
        const value = values[key];
        if (!is.und(value)) {
          this.springs[key].set(value);
        }
      }
    }
    /** Push an update onto the queue of each value. */
    update(props) {
      if (props) {
        this.queue.push(createUpdate(props));
      }
      return this;
    }
    /**
     * Start the queued animations for every spring, and resolve the returned
     * promise once all queued animations have finished or been cancelled.
     *
     * When you pass a queue (instead of nothing), that queue is used instead of
     * the queued animations added with the `update` method, which are left alone.
     */
    start(props) {
      let { queue } = this;
      if (props) {
        queue = toArray(props).map(createUpdate);
      } else {
        this.queue = [];
      }
      if (this._flush) {
        return this._flush(this, queue);
      }
      prepareKeys(this, queue);
      return flushUpdateQueue(this, queue);
    }
    /** @internal */
    stop(arg, keys2) {
      if (arg !== !!arg) {
        keys2 = arg;
      }
      if (keys2) {
        const springs = this.springs;
        each(toArray(keys2), (key) => springs[key].stop(!!arg));
      } else {
        stopAsync(this._state, this._lastAsyncId);
        this.each((spring2) => spring2.stop(!!arg));
      }
      return this;
    }
    /** Freeze the active animation in time */
    pause(keys2) {
      if (is.und(keys2)) {
        this.start({ pause: true });
      } else {
        const springs = this.springs;
        each(toArray(keys2), (key) => springs[key].pause());
      }
      return this;
    }
    /** Resume the animation if paused. */
    resume(keys2) {
      if (is.und(keys2)) {
        this.start({ pause: false });
      } else {
        const springs = this.springs;
        each(toArray(keys2), (key) => springs[key].resume());
      }
      return this;
    }
    /** Call a function once per spring value */
    each(iterator) {
      eachProp(this.springs, iterator);
    }
    /** @internal Called at the end of every animation frame */
    _onFrame() {
      const { onStart, onChange, onRest } = this._events;
      const active = this._active.size > 0;
      const changed = this._changed.size > 0;
      if (active && !this._started || changed && !this._started) {
        this._started = true;
        flush(onStart, ([onStart2, result]) => {
          result.value = this.get();
          onStart2(result, this, this._item);
        });
      }
      const idle = !active && this._started;
      const values = changed || idle && onRest.size ? this.get() : null;
      if (changed && onChange.size) {
        flush(onChange, ([onChange2, result]) => {
          result.value = values;
          onChange2(result, this, this._item);
        });
      }
      if (idle) {
        this._started = false;
        flush(onRest, ([onRest2, result]) => {
          result.value = values;
          onRest2(result, this, this._item);
        });
      }
    }
    /** @internal */
    eventObserved(event) {
      if (event.type == "change") {
        this._changed.add(event.parent);
        if (!event.idle) {
          this._active.add(event.parent);
        }
      } else if (event.type == "idle") {
        this._active.delete(event.parent);
      } else return;
      raf.onFrame(this._onFrame);
    }
  };
  function flushUpdateQueue(ctrl, queue) {
    return Promise.all(queue.map((props) => flushUpdate(ctrl, props))).then(
      (results) => getCombinedResult(ctrl, results)
    );
  }
  async function flushUpdate(ctrl, props, isLoop) {
    const { keys: keys2, to: to2, from, loop: loop2, onRest, onResolve } = props;
    const defaults2 = is.obj(props.default) && props.default;
    if (loop2) {
      props.loop = false;
    }
    if (to2 === false) props.to = null;
    if (from === false) props.from = null;
    const asyncTo = is.arr(to2) || is.fun(to2) ? to2 : void 0;
    if (asyncTo) {
      props.to = void 0;
      props.onRest = void 0;
      if (defaults2) {
        defaults2.onRest = void 0;
      }
    } else {
      each(BATCHED_EVENTS, (key) => {
        const handler = props[key];
        if (is.fun(handler)) {
          const queue = ctrl["_events"][key];
          props[key] = ({ finished, cancelled }) => {
            const result2 = queue.get(handler);
            if (result2) {
              if (!finished) result2.finished = false;
              if (cancelled) result2.cancelled = true;
            } else {
              queue.set(handler, {
                value: null,
                finished: finished || false,
                cancelled: cancelled || false
              });
            }
          };
          if (defaults2) {
            defaults2[key] = props[key];
          }
        }
      });
    }
    const state = ctrl["_state"];
    if (props.pause === !state.paused) {
      state.paused = props.pause;
      flushCalls(props.pause ? state.pauseQueue : state.resumeQueue);
    } else if (state.paused) {
      props.pause = true;
    }
    const promises = (keys2 || Object.keys(ctrl.springs)).map(
      (key) => ctrl.springs[key].start(props)
    );
    const cancel = props.cancel === true || getDefaultProp(props, "cancel") === true;
    if (asyncTo || cancel && state.asyncId) {
      promises.push(
        scheduleProps(++ctrl["_lastAsyncId"], {
          props,
          state,
          actions: {
            pause: noop2,
            resume: noop2,
            start(props2, resolve) {
              if (cancel) {
                stopAsync(state, ctrl["_lastAsyncId"]);
                resolve(getCancelledResult(ctrl));
              } else {
                props2.onRest = onRest;
                resolve(
                  runAsync(
                    asyncTo,
                    props2,
                    state,
                    ctrl
                  )
                );
              }
            }
          }
        })
      );
    }
    if (state.paused) {
      await new Promise((resume) => {
        state.resumeQueue.add(resume);
      });
    }
    const result = getCombinedResult(ctrl, await Promise.all(promises));
    if (loop2 && result.finished && !(isLoop && result.noop)) {
      const nextProps = createLoopUpdate(props, loop2, to2);
      if (nextProps) {
        prepareKeys(ctrl, [nextProps]);
        return flushUpdate(ctrl, nextProps, true);
      }
    }
    if (onResolve) {
      raf.batchedUpdates(() => onResolve(result, ctrl, ctrl.item));
    }
    return result;
  }
  function getSprings(ctrl, props) {
    const springs = { ...ctrl.springs };
    if (props) {
      each(toArray(props), (props2) => {
        if (is.und(props2.keys)) {
          props2 = createUpdate(props2);
        }
        if (!is.obj(props2.to)) {
          props2 = { ...props2, to: void 0 };
        }
        prepareSprings(springs, props2, (key) => {
          return createSpring(key);
        });
      });
    }
    setSprings(ctrl, springs);
    return springs;
  }
  function setSprings(ctrl, springs) {
    eachProp(springs, (spring2, key) => {
      if (!ctrl.springs[key]) {
        ctrl.springs[key] = spring2;
        addFluidObserver(spring2, ctrl);
      }
    });
  }
  function createSpring(key, observer2) {
    const spring2 = new SpringValue();
    spring2.key = key;
    if (observer2) {
      addFluidObserver(spring2, observer2);
    }
    return spring2;
  }
  function prepareSprings(springs, props, create) {
    if (props.keys) {
      each(props.keys, (key) => {
        const spring2 = springs[key] || (springs[key] = create(key));
        spring2["_prepareNode"](props);
      });
    }
  }
  function prepareKeys(ctrl, queue) {
    each(queue, (props) => {
      prepareSprings(ctrl.springs, props, (key) => {
        return createSpring(key, ctrl);
      });
    });
  }
  var SpringContext = React76.createContext({
    pause: false,
    immediate: false
  });
  var SpringRef = () => {
    const current = [];
    const SpringRef2 = function(props) {
      deprecateDirectCall();
      const results = [];
      each(current, (ctrl, i3) => {
        if (is.und(props)) {
          results.push(ctrl.start());
        } else {
          const update22 = _getProps(props, ctrl, i3);
          if (update22) {
            results.push(ctrl.start(update22));
          }
        }
      });
      return results;
    };
    SpringRef2.current = current;
    SpringRef2.add = function(ctrl) {
      if (!current.includes(ctrl)) {
        current.push(ctrl);
      }
    };
    SpringRef2.delete = function(ctrl) {
      const i3 = current.indexOf(ctrl);
      if (~i3) current.splice(i3, 1);
    };
    SpringRef2.pause = function() {
      each(current, (ctrl) => ctrl.pause(...arguments));
      return this;
    };
    SpringRef2.resume = function() {
      each(current, (ctrl) => ctrl.resume(...arguments));
      return this;
    };
    SpringRef2.set = function(values) {
      each(current, (ctrl, i3) => {
        const update22 = is.fun(values) ? values(i3, ctrl) : values;
        if (update22) {
          ctrl.set(update22);
        }
      });
    };
    SpringRef2.start = function(props) {
      const results = [];
      each(current, (ctrl, i3) => {
        if (is.und(props)) {
          results.push(ctrl.start());
        } else {
          const update22 = this._getProps(props, ctrl, i3);
          if (update22) {
            results.push(ctrl.start(update22));
          }
        }
      });
      return results;
    };
    SpringRef2.stop = function() {
      each(current, (ctrl) => ctrl.stop(...arguments));
      return this;
    };
    SpringRef2.update = function(props) {
      each(current, (ctrl, i3) => ctrl.update(this._getProps(props, ctrl, i3)));
      return this;
    };
    const _getProps = function(arg, ctrl, index2) {
      return is.fun(arg) ? arg(index2, ctrl) : arg;
    };
    SpringRef2._getProps = _getProps;
    return SpringRef2;
  };
  function useSprings(length, props, deps) {
    const propsFn = is.fun(props) && props;
    if (propsFn && !deps) deps = [];
    const ref = (0, import_react90.useMemo)(
      () => propsFn || arguments.length == 3 ? SpringRef() : void 0,
      []
    );
    const layoutId = (0, import_react90.useRef)(0);
    const forceUpdate = useForceUpdate();
    const state = (0, import_react90.useMemo)(
      () => ({
        ctrls: [],
        queue: [],
        flush(ctrl, updates2) {
          const springs2 = getSprings(ctrl, updates2);
          const canFlushSync = layoutId.current > 0 && !state.queue.length && !Object.keys(springs2).some((key) => !ctrl.springs[key]);
          return canFlushSync ? flushUpdateQueue(ctrl, updates2) : new Promise((resolve) => {
            setSprings(ctrl, springs2);
            state.queue.push(() => {
              resolve(flushUpdateQueue(ctrl, updates2));
            });
            forceUpdate();
          });
        }
      }),
      []
    );
    const ctrls = (0, import_react90.useRef)([...state.ctrls]);
    const updates = (0, import_react90.useRef)([]);
    const prevLength = usePrev(length) || 0;
    (0, import_react90.useMemo)(() => {
      each(ctrls.current.slice(length, prevLength), (ctrl) => {
        detachRefs(ctrl, ref);
        ctrl.stop(true);
      });
      ctrls.current.length = length;
      declareUpdates(prevLength, length);
    }, [length]);
    (0, import_react90.useMemo)(() => {
      declareUpdates(0, Math.min(prevLength, length));
    }, deps);
    function declareUpdates(startIndex, endIndex) {
      for (let i3 = startIndex; i3 < endIndex; i3++) {
        const ctrl = ctrls.current[i3] || (ctrls.current[i3] = new Controller(null, state.flush));
        const update22 = propsFn ? propsFn(i3, ctrl) : props[i3];
        if (update22) {
          updates.current[i3] = declareUpdate(update22);
        }
      }
    }
    const springs = ctrls.current.map(
      (ctrl, i3) => getSprings(ctrl, updates.current[i3])
    );
    const context = (0, import_react90.useContext)(SpringContext);
    const prevContext = usePrev(context);
    const hasContext = context !== prevContext && hasProps(context);
    useIsomorphicLayoutEffect3(() => {
      layoutId.current++;
      state.ctrls = ctrls.current;
      const { queue } = state;
      if (queue.length) {
        state.queue = [];
        each(queue, (cb) => cb());
      }
      each(ctrls.current, (ctrl, i3) => {
        ref?.add(ctrl);
        if (hasContext) {
          ctrl.start({ default: context });
        }
        const update22 = updates.current[i3];
        if (update22) {
          replaceRef(ctrl, update22.ref);
          if (ctrl.ref) {
            ctrl.queue.push(update22);
          } else {
            ctrl.start(update22);
          }
        }
      });
    });
    useOnce(() => () => {
      each(state.ctrls, (ctrl) => ctrl.stop(true));
    });
    const values = springs.map((x2) => ({ ...x2 }));
    return ref ? [values, ref] : values;
  }
  function useSpring2(props, deps) {
    const isFn = is.fun(props);
    const [[values], ref] = useSprings(
      1,
      isFn ? props : [props],
      isFn ? deps || [] : deps
    );
    return isFn || arguments.length == 2 ? [values, ref] : values;
  }
  var Interpolation = class extends FrameValue {
    constructor(source, args) {
      super();
      this.source = source;
      this.idle = true;
      this._active = /* @__PURE__ */ new Set();
      this.calc = createInterpolator(...args);
      const value = this._get();
      const nodeType = getAnimatedType(value);
      setAnimated(this, nodeType.create(value));
    }
    advance(_dt) {
      const value = this._get();
      const oldValue = this.get();
      if (!isEqual(value, oldValue)) {
        getAnimated(this).setValue(value);
        this._onChange(value, this.idle);
      }
      if (!this.idle && checkIdle(this._active)) {
        becomeIdle(this);
      }
    }
    _get() {
      const inputs = is.arr(this.source) ? this.source.map(getFluidValue) : toArray(getFluidValue(this.source));
      return this.calc(...inputs);
    }
    _start() {
      if (this.idle && !checkIdle(this._active)) {
        this.idle = false;
        each(getPayload(this), (node) => {
          node.done = false;
        });
        if (globals_exports.skipAnimation) {
          raf.batchedUpdates(() => this.advance());
          becomeIdle(this);
        } else {
          frameLoop.start(this);
        }
      }
    }
    // Observe our sources only when we're observed.
    _attach() {
      let priority2 = 1;
      each(toArray(this.source), (source) => {
        if (hasFluidValue(source)) {
          addFluidObserver(source, this);
        }
        if (isFrameValue(source)) {
          if (!source.idle) {
            this._active.add(source);
          }
          priority2 = Math.max(priority2, source.priority + 1);
        }
      });
      this.priority = priority2;
      this._start();
    }
    // Stop observing our sources once we have no observers.
    _detach() {
      each(toArray(this.source), (source) => {
        if (hasFluidValue(source)) {
          removeFluidObserver(source, this);
        }
      });
      this._active.clear();
      becomeIdle(this);
    }
    /** @internal */
    eventObserved(event) {
      if (event.type == "change") {
        if (event.idle) {
          this.advance();
        } else {
          this._active.add(event.parent);
          this._start();
        }
      } else if (event.type == "idle") {
        this._active.delete(event.parent);
      } else if (event.type == "priority") {
        this.priority = toArray(this.source).reduce(
          (highest, parent) => Math.max(highest, (isFrameValue(parent) ? parent.priority : 0) + 1),
          0
        );
      }
    }
  };
  function isIdle(source) {
    return source.idle !== false;
  }
  function checkIdle(active) {
    return !active.size || Array.from(active).every(isIdle);
  }
  function becomeIdle(self2) {
    if (!self2.idle) {
      self2.idle = true;
      each(getPayload(self2), (node) => {
        node.done = true;
      });
      callFluidObservers(self2, {
        type: "idle",
        parent: self2
      });
    }
  }
  globals_exports.assign({
    createStringInterpolator: createStringInterpolator2,
    to: (source, args) => new Interpolation(source, args)
  });
  var update2 = frameLoop.advance;

  // ../../node_modules/@react-spring/web/dist/react-spring_web.modern.mjs
  var import_react_dom2 = __toESM(require_react_dom(), 1);
  var isCustomPropRE = /^--/;
  function dangerousStyleValue(name, value) {
    if (value == null || typeof value === "boolean" || value === "") return "";
    if (typeof value === "number" && value !== 0 && !isCustomPropRE.test(name) && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]))
      return value + "px";
    return ("" + value).trim();
  }
  var attributeCache = {};
  function applyAnimatedValues(instance, props) {
    if (!instance.nodeType || !instance.setAttribute) {
      return false;
    }
    const isFilterElement = instance.nodeName === "filter" || instance.parentNode && instance.parentNode.nodeName === "filter";
    const {
      className,
      style,
      children,
      scrollTop,
      scrollLeft,
      viewBox,
      ...attributes
    } = props;
    const values = Object.values(attributes);
    const names = Object.keys(attributes).map(
      (name) => isFilterElement || instance.hasAttribute(name) ? name : attributeCache[name] || (attributeCache[name] = name.replace(
        /([A-Z])/g,
        // Attributes are written in dash case
        (n2) => "-" + n2.toLowerCase()
      ))
    );
    if (children !== void 0) {
      instance.textContent = children;
    }
    for (const name in style) {
      if (style.hasOwnProperty(name)) {
        const value = dangerousStyleValue(name, style[name]);
        if (isCustomPropRE.test(name)) {
          instance.style.setProperty(name, value);
        } else {
          instance.style[name] = value;
        }
      }
    }
    names.forEach((name, i3) => {
      instance.setAttribute(name, values[i3]);
    });
    if (className !== void 0) {
      instance.className = className;
    }
    if (scrollTop !== void 0) {
      instance.scrollTop = scrollTop;
    }
    if (scrollLeft !== void 0) {
      instance.scrollLeft = scrollLeft;
    }
    if (viewBox !== void 0) {
      instance.setAttribute("viewBox", viewBox);
    }
  }
  var isUnitlessNumber = {
    animationIterationCount: true,
    borderImageOutset: true,
    borderImageSlice: true,
    borderImageWidth: true,
    boxFlex: true,
    boxFlexGroup: true,
    boxOrdinalGroup: true,
    columnCount: true,
    columns: true,
    flex: true,
    flexGrow: true,
    flexPositive: true,
    flexShrink: true,
    flexNegative: true,
    flexOrder: true,
    gridRow: true,
    gridRowEnd: true,
    gridRowSpan: true,
    gridRowStart: true,
    gridColumn: true,
    gridColumnEnd: true,
    gridColumnSpan: true,
    gridColumnStart: true,
    fontWeight: true,
    lineClamp: true,
    lineHeight: true,
    opacity: true,
    order: true,
    orphans: true,
    tabSize: true,
    widows: true,
    zIndex: true,
    zoom: true,
    // SVG-related properties
    fillOpacity: true,
    floodOpacity: true,
    stopOpacity: true,
    strokeDasharray: true,
    strokeDashoffset: true,
    strokeMiterlimit: true,
    strokeOpacity: true,
    strokeWidth: true
  };
  var prefixKey = (prefix2, key) => prefix2 + key.charAt(0).toUpperCase() + key.substring(1);
  var prefixes = ["Webkit", "Ms", "Moz", "O"];
  isUnitlessNumber = Object.keys(isUnitlessNumber).reduce((acc, prop) => {
    prefixes.forEach((prefix2) => acc[prefixKey(prefix2, prop)] = acc[prop]);
    return acc;
  }, isUnitlessNumber);
  var domTransforms = /^(matrix|translate|scale|rotate|skew)/;
  var pxTransforms = /^(translate)/;
  var degTransforms = /^(rotate|skew)/;
  var addUnit = (value, unit) => is.num(value) && value !== 0 ? value + unit : value;
  var isValueIdentity = (value, id3) => is.arr(value) ? value.every((v2) => isValueIdentity(v2, id3)) : is.num(value) ? value === id3 : parseFloat(value) === id3;
  var AnimatedStyle = class extends AnimatedObject {
    constructor({ x: x2, y: y2, z: z3, ...style }) {
      const inputs = [];
      const transforms = [];
      if (x2 || y2 || z3) {
        inputs.push([x2 || 0, y2 || 0, z3 || 0]);
        transforms.push((xyz) => [
          `translate3d(${xyz.map((v2) => addUnit(v2, "px")).join(",")})`,
          // prettier-ignore
          isValueIdentity(xyz, 0)
        ]);
      }
      eachProp(style, (value, key) => {
        if (key === "transform") {
          inputs.push([value || ""]);
          transforms.push((transform2) => [transform2, transform2 === ""]);
        } else if (domTransforms.test(key)) {
          delete style[key];
          if (is.und(value)) return;
          const unit = pxTransforms.test(key) ? "px" : degTransforms.test(key) ? "deg" : "";
          inputs.push(toArray(value));
          transforms.push(
            key === "rotate3d" ? ([x22, y22, z22, deg]) => [
              `rotate3d(${x22},${y22},${z22},${addUnit(deg, unit)})`,
              isValueIdentity(deg, 0)
            ] : (input) => [
              `${key}(${input.map((v2) => addUnit(v2, unit)).join(",")})`,
              isValueIdentity(input, key.startsWith("scale") ? 1 : 0)
            ]
          );
        }
      });
      if (inputs.length) {
        style.transform = new FluidTransform(inputs, transforms);
      }
      super(style);
    }
  };
  var FluidTransform = class extends FluidValue {
    constructor(inputs, transforms) {
      super();
      this.inputs = inputs;
      this.transforms = transforms;
      this._value = null;
    }
    get() {
      return this._value || (this._value = this._get());
    }
    _get() {
      let transform2 = "";
      let identity = true;
      each(this.inputs, (input, i3) => {
        const arg1 = getFluidValue(input[0]);
        const [t3, id3] = this.transforms[i3](
          is.arr(arg1) ? arg1 : input.map(getFluidValue)
        );
        transform2 += " " + t3;
        identity = identity && id3;
      });
      return identity ? "none" : transform2;
    }
    // Start observing our inputs once we have an observer.
    observerAdded(count3) {
      if (count3 == 1)
        each(
          this.inputs,
          (input) => each(
            input,
            (value) => hasFluidValue(value) && addFluidObserver(value, this)
          )
        );
    }
    // Stop observing our inputs once we have no observers.
    observerRemoved(count3) {
      if (count3 == 0)
        each(
          this.inputs,
          (input) => each(
            input,
            (value) => hasFluidValue(value) && removeFluidObserver(value, this)
          )
        );
    }
    eventObserved(event) {
      if (event.type == "change") {
        this._value = null;
      }
      callFluidObservers(this, event);
    }
  };
  var primitives = [
    "a",
    "abbr",
    "address",
    "area",
    "article",
    "aside",
    "audio",
    "b",
    "base",
    "bdi",
    "bdo",
    "big",
    "blockquote",
    "body",
    "br",
    "button",
    "canvas",
    "caption",
    "cite",
    "code",
    "col",
    "colgroup",
    "data",
    "datalist",
    "dd",
    "del",
    "details",
    "dfn",
    "dialog",
    "div",
    "dl",
    "dt",
    "em",
    "embed",
    "fieldset",
    "figcaption",
    "figure",
    "footer",
    "form",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "head",
    "header",
    "hgroup",
    "hr",
    "html",
    "i",
    "iframe",
    "img",
    "input",
    "ins",
    "kbd",
    "keygen",
    "label",
    "legend",
    "li",
    "link",
    "main",
    "map",
    "mark",
    "menu",
    "menuitem",
    "meta",
    "meter",
    "nav",
    "noscript",
    "object",
    "ol",
    "optgroup",
    "option",
    "output",
    "p",
    "param",
    "picture",
    "pre",
    "progress",
    "q",
    "rp",
    "rt",
    "ruby",
    "s",
    "samp",
    "script",
    "section",
    "select",
    "small",
    "source",
    "span",
    "strong",
    "style",
    "sub",
    "summary",
    "sup",
    "table",
    "tbody",
    "td",
    "textarea",
    "tfoot",
    "th",
    "thead",
    "time",
    "title",
    "tr",
    "track",
    "u",
    "ul",
    "var",
    "video",
    "wbr",
    // SVG
    "circle",
    "clipPath",
    "defs",
    "ellipse",
    "foreignObject",
    "g",
    "image",
    "line",
    "linearGradient",
    "mask",
    "path",
    "pattern",
    "polygon",
    "polyline",
    "radialGradient",
    "rect",
    "stop",
    "svg",
    "text",
    "tspan"
  ];
  globals_exports.assign({
    batchedUpdates: import_react_dom2.unstable_batchedUpdates,
    createStringInterpolator: createStringInterpolator2,
    colors: colors2
  });
  var host = createHost(primitives, {
    applyAnimatedValues,
    createAnimatedStyle: (style) => new AnimatedStyle(style),
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getComponentProps: ({ scrollTop, scrollLeft, ...props }) => props
  });
  var animated = host.animated;

  // src/components/Globe.tsx
  var import_jsx_runtime53 = __toESM(require_jsx_runtime());
  function Globe({
    className,
    globeConfig = {
      width: 800,
      height: 800,
      onRender: () => {
      },
      devicePixelRatio: 2,
      phi: 0,
      theta: 0.3,
      dark: 0,
      diffuse: 1.2,
      mapSamples: 16e3,
      mapBrightness: 6,
      baseColor: [1, 1, 1],
      markerColor: [0.1, 0.8, 1],
      glowColor: [1, 1, 1],
      markers: []
    },
    data = []
  }) {
    const canvasRef = (0, import_react95.useRef)(null);
    const pointerInteracting = (0, import_react95.useRef)(null);
    const pointerInteractionMovement = (0, import_react95.useRef)(0);
    const [{ r: r4 }, api] = useSpring2(() => ({
      r: 0,
      config: {
        mass: 1,
        tension: 280,
        friction: 60,
        precision: 1e-3
      }
    }));
    const updatePointerInteraction = (clientX) => {
      if (pointerInteracting.current !== null) {
        const delta = clientX - pointerInteracting.current;
        pointerInteractionMovement.current = delta;
        api.start({
          r: delta / 200
        });
      }
    };
    const updateMovement = (clientX) => {
      if (pointerInteracting.current !== null) {
        return;
      }
      api.start({
        r: 0
      });
    };
    (0, import_react95.useEffect)(() => {
      let phi = 0;
      let width = 0;
      const onResize2 = () => canvasRef.current && (width = canvasRef.current.offsetWidth);
      window.addEventListener("resize", onResize2);
      onResize2();
      const globe = _t(canvasRef.current, {
        ...globeConfig,
        width: width * 2,
        height: width * 2,
        onRender: (state) => {
          if (!pointerInteracting.current) {
            phi += 5e-3;
          }
          state.phi = phi + r4.get();
          state.width = width * 2;
          state.height = width * 2;
        }
      });
      setTimeout(() => canvasRef.current.style.opacity = "1");
      return () => globe.destroy();
    }, [globeConfig, r4]);
    return /* @__PURE__ */ (0, import_jsx_runtime53.jsx)(
      "div",
      {
        className: cn(
          "absolute inset-0 mx-auto aspect-[1/1] w-full max-w-[600px]",
          className
        ),
        children: /* @__PURE__ */ (0, import_jsx_runtime53.jsx)(
          "canvas",
          {
            className: cn(
              "h-full w-full opacity-0 transition-opacity duration-500 [contain:layout_paint_size]"
            ),
            ref: canvasRef,
            onPointerDown: (e2) => {
              pointerInteracting.current = e2.clientX - pointerInteractionMovement.current;
              canvasRef.current.style.cursor = "grabbing";
            },
            onPointerUp: () => {
              pointerInteracting.current = null;
              canvasRef.current.style.cursor = "grab";
            },
            onPointerOut: () => {
              pointerInteracting.current = null;
              canvasRef.current.style.cursor = "grab";
            },
            onMouseMove: (e2) => {
              if (pointerInteracting.current !== null) {
                const delta = e2.clientX - pointerInteracting.current;
                pointerInteractionMovement.current = delta;
                api.start({
                  r: delta / 100
                });
              }
            },
            onTouchMove: (e2) => {
              if (pointerInteracting.current !== null && e2.touches[0]) {
                const delta = e2.touches[0].clientX - pointerInteracting.current;
                pointerInteractionMovement.current = delta;
                api.start({
                  r: delta / 100
                });
              }
            }
          }
        )
      }
    );
  }

  // src/components/GridPattern.tsx
  var import_react96 = __toESM(require_react());
  var import_jsx_runtime54 = __toESM(require_jsx_runtime());
  var GridPattern = ({
    size: size4 = 40,
    className,
    strokeDasharray = "0",
    squares,
    fade = true
  }) => {
    const id3 = import_react96.default.useId();
    return /* @__PURE__ */ (0, import_jsx_runtime54.jsxs)(
      "svg",
      {
        className: cn(
          "absolute inset-0 h-full w-full pointer-events-none",
          fade && "[mask-image:radial-gradient(ellipse_at_center,white,transparent_80%)]",
          className
        ),
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime54.jsx)("defs", { children: /* @__PURE__ */ (0, import_jsx_runtime54.jsx)(
            "pattern",
            {
              id: id3,
              width: size4,
              height: size4,
              patternUnits: "userSpaceOnUse",
              children: /* @__PURE__ */ (0, import_jsx_runtime54.jsx)(
                "path",
                {
                  d: `M ${size4} 0 L 0 0 0 ${size4}`,
                  fill: "none",
                  stroke: "currentColor",
                  strokeWidth: "1",
                  strokeDasharray,
                  className: "text-border/40 dark:text-zinc-800"
                }
              )
            }
          ) }),
          /* @__PURE__ */ (0, import_jsx_runtime54.jsx)("rect", { width: "100%", height: "100%", fill: `url(#${id3})` }),
          squares && /* @__PURE__ */ (0, import_jsx_runtime54.jsx)("svg", { className: "absolute inset-0 h-full w-full", children: squares.map(([x2, y2], index2) => /* @__PURE__ */ (0, import_jsx_runtime54.jsx)(
            "rect",
            {
              x: x2 * size4,
              y: y2 * size4,
              width: size4 - 1,
              height: size4 - 1,
              className: "fill-[#007AFF]/10 dark:fill-[#0A84FF]/10"
            },
            index2
          )) })
        ]
      }
    );
  };

  // src/components/HoverCard.tsx
  var import_react97 = __toESM(require_react());
  var import_jsx_runtime55 = __toESM(require_jsx_runtime());
  var HoverCard = ({
    trigger,
    children,
    side = "bottom",
    align = "center",
    openDelay = 200,
    closeDelay = 100,
    className
  }) => {
    const [isOpen, setIsOpen] = import_react97.default.useState(false);
    const openTimeout = import_react97.default.useRef(void 0);
    const closeTimeout = import_react97.default.useRef(void 0);
    const handleMouseEnter = () => {
      if (closeTimeout.current) clearTimeout(closeTimeout.current);
      openTimeout.current = setTimeout(() => setIsOpen(true), openDelay);
    };
    const handleMouseLeave = () => {
      if (openTimeout.current) clearTimeout(openTimeout.current);
      closeTimeout.current = setTimeout(() => setIsOpen(false), closeDelay);
    };
    const sideClasses = {
      top: "bottom-full mb-3",
      bottom: "top-full mt-3",
      left: "right-full mr-3",
      right: "left-full ml-3"
    };
    const alignClasses = {
      start: side === "top" || side === "bottom" ? "left-0" : "top-0",
      center: side === "top" || side === "bottom" ? "left-1/2 -translate-x-1/2" : "top-1/2 -translate-y-1/2",
      end: side === "top" || side === "bottom" ? "right-0" : "bottom-0"
    };
    return /* @__PURE__ */ (0, import_jsx_runtime55.jsxs)(
      "div",
      {
        className: "relative inline-block",
        onMouseEnter: handleMouseEnter,
        onMouseLeave: handleMouseLeave,
        children: [
          trigger,
          isOpen && /* @__PURE__ */ (0, import_jsx_runtime55.jsx)(
            "div",
            {
              className: cn(
                "absolute z-50 w-80",
                "rounded-xl border border-border/50 bg-background/95 backdrop-blur-xl",
                "shadow-xl shadow-black/10 dark:shadow-black/30",
                "p-4 animate-in fade-in-0 zoom-in-95 duration-200",
                "dark:bg-zinc-900/95 dark:border-zinc-800",
                sideClasses[side],
                alignClasses[align],
                className
              ),
              onMouseEnter: handleMouseEnter,
              onMouseLeave: handleMouseLeave,
              children
            }
          )
        ]
      }
    );
  };
  var HoverCardContent = ({
    avatar,
    title,
    subtitle,
    description,
    stats
  }) => {
    return /* @__PURE__ */ (0, import_jsx_runtime55.jsxs)("div", { className: "space-y-3", children: [
      /* @__PURE__ */ (0, import_jsx_runtime55.jsxs)("div", { className: "flex items-center gap-3", children: [
        avatar && /* @__PURE__ */ (0, import_jsx_runtime55.jsx)(
          "img",
          {
            src: avatar,
            alt: title,
            className: "w-10 h-10 rounded-full object-cover"
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime55.jsxs)("div", { children: [
          /* @__PURE__ */ (0, import_jsx_runtime55.jsx)("div", { className: "font-semibold text-foreground", children: title }),
          subtitle && /* @__PURE__ */ (0, import_jsx_runtime55.jsx)("div", { className: "text-sm text-muted-foreground", children: subtitle })
        ] })
      ] }),
      description && /* @__PURE__ */ (0, import_jsx_runtime55.jsx)("p", { className: "text-sm text-muted-foreground", children: description }),
      stats && stats.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime55.jsx)("div", { className: "flex gap-4 pt-2 border-t border-border/50 dark:border-zinc-800", children: stats.map((stat, index2) => /* @__PURE__ */ (0, import_jsx_runtime55.jsxs)("div", { children: [
        /* @__PURE__ */ (0, import_jsx_runtime55.jsx)("div", { className: "font-semibold text-foreground", children: stat.value }),
        /* @__PURE__ */ (0, import_jsx_runtime55.jsx)("div", { className: "text-xs text-muted-foreground", children: stat.label })
      ] }, index2)) })
    ] });
  };

  // src/components/IPhoneMockup.tsx
  var import_jsx_runtime56 = __toESM(require_jsx_runtime());
  var IPhoneMockup = ({
    children,
    variant = "space-gray",
    showNotch = true,
    showStatusBar = true,
    className
  }) => {
    const variantColors = {
      silver: "bg-gradient-to-b from-zinc-300 to-zinc-400 dark:from-zinc-600 dark:to-zinc-700",
      "space-gray": "bg-gradient-to-b from-zinc-700 to-zinc-900",
      gold: "bg-gradient-to-b from-amber-200 to-amber-300 dark:from-amber-600 dark:to-amber-700"
    };
    return /* @__PURE__ */ (0, import_jsx_runtime56.jsxs)(
      "div",
      {
        className: cn(
          "relative w-[280px] h-[580px] rounded-[40px] p-[12px]",
          variantColors[variant],
          "shadow-xl shadow-black/30",
          className
        ),
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime56.jsx)("div", { className: "absolute -right-[3px] top-[100px] w-[3px] h-[60px] rounded-r bg-zinc-600" }),
          /* @__PURE__ */ (0, import_jsx_runtime56.jsx)("div", { className: "absolute -left-[3px] top-[80px] w-[3px] h-[24px] rounded-l bg-zinc-600" }),
          /* @__PURE__ */ (0, import_jsx_runtime56.jsx)("div", { className: "absolute -left-[3px] top-[120px] w-[3px] h-[40px] rounded-l bg-zinc-600" }),
          /* @__PURE__ */ (0, import_jsx_runtime56.jsx)("div", { className: "absolute -left-[3px] top-[170px] w-[3px] h-[40px] rounded-l bg-zinc-600" }),
          /* @__PURE__ */ (0, import_jsx_runtime56.jsxs)("div", { className: "relative w-full h-full rounded-[30px] bg-black overflow-hidden", children: [
            showNotch && /* @__PURE__ */ (0, import_jsx_runtime56.jsx)("div", { className: "absolute top-2 left-1/2 -translate-x-1/2 w-[100px] h-[28px] bg-black rounded-full z-20" }),
            showStatusBar && /* @__PURE__ */ (0, import_jsx_runtime56.jsxs)("div", { className: "absolute top-0 left-0 right-0 h-12 flex items-center justify-between px-6 z-10", children: [
              /* @__PURE__ */ (0, import_jsx_runtime56.jsx)("span", { className: "text-white text-xs font-medium", children: "9:41" }),
              /* @__PURE__ */ (0, import_jsx_runtime56.jsxs)("div", { className: "flex items-center gap-1", children: [
                /* @__PURE__ */ (0, import_jsx_runtime56.jsx)("svg", { className: "w-4 h-4 text-white", fill: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime56.jsx)("path", { d: "M12 3L2 12h3v8h6v-6h2v6h6v-8h3L12 3z" }) }),
                /* @__PURE__ */ (0, import_jsx_runtime56.jsx)("svg", { className: "w-4 h-4 text-white", fill: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime56.jsx)("path", { d: "M2 18h2v-4h3v4h2V8H7v4H4V8H2v10zm7-10v2h3v8h2v-8h3V8H9z" }) }),
                /* @__PURE__ */ (0, import_jsx_runtime56.jsx)("div", { className: "w-6 h-3 bg-white rounded-sm relative", children: /* @__PURE__ */ (0, import_jsx_runtime56.jsx)("div", { className: "absolute inset-[2px] bg-green-500 rounded-[2px]", style: { width: "80%" } }) })
              ] })
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime56.jsx)("div", { className: "absolute inset-0 pt-12", children }),
            /* @__PURE__ */ (0, import_jsx_runtime56.jsx)("div", { className: "absolute bottom-2 left-1/2 -translate-x-1/2 w-[100px] h-1 bg-white/30 rounded-full" })
          ] })
        ]
      }
    );
  };

  // src/components/Input.tsx
  var import_react98 = __toESM(require_react());
  var import_jsx_runtime57 = __toESM(require_jsx_runtime());
  var Input = (0, import_react98.forwardRef)(
    ({ className, error, inputSize = "md", variant = "box", disabled, ...props }, ref) => {
      return /* @__PURE__ */ (0, import_jsx_runtime57.jsxs)("div", { className: "relative w-full", children: [
        /* @__PURE__ */ (0, import_jsx_runtime57.jsx)(
          "input",
          {
            ref,
            disabled,
            placeholder: variant === "floating" ? " " : props.placeholder,
            className: cn(
              "w-full text-foreground transition-all placeholder:text-muted-foreground focus:outline-none disabled:cursor-not-allowed disabled:opacity-50",
              // Variant: Box (Default)
              variant === "box" && "rounded-[2rem] border bg-background/50 backdrop-blur-sm focus:ring-2 focus:ring-violet-500/50 focus:ring-offset-2",
              variant === "box" && (!error ? "border-border" : "border-destructive focus:ring-destructive"),
              // Variant: Line (Underline)
              variant === "line" && "rounded-none border-b-2 border-border bg-transparent px-0 focus:border-violet-500",
              variant === "line" && error && "border-destructive",
              // Variant: Floating (Material-like)
              variant === "floating" && "peer rounded-lg border bg-background px-4 pt-4 pb-1 focus:ring-2 focus:ring-violet-500/20",
              variant === "floating" && (!error ? "border-border" : "border-destructive"),
              {
                "h-8 text-sm": inputSize === "sm" && variant !== "line",
                "h-10 text-sm": inputSize === "md" && variant !== "line",
                "h-12 text-base": inputSize === "lg" && variant !== "line",
                "py-1 text-sm": variant === "line"
                // Line variant needs less padding
              },
              variant === "box" && { "px-4": true },
              className
            ),
            ...props
          }
        ),
        variant === "floating" && props.placeholder && /* @__PURE__ */ (0, import_jsx_runtime57.jsx)("label", { className: "pointer-events-none absolute left-4 top-4 origin-[0] -translate-y-2.5 scale-75 transform text-sm text-muted-foreground duration-200 peer-placeholder-shown:translate-y-0 peer-placeholder-shown:scale-100 peer-focus:-translate-y-2.5 peer-focus:scale-75 peer-focus:text-violet-500", children: props.placeholder })
      ] });
    }
  );
  Input.displayName = "Input";

  // src/components/InputOTP.tsx
  var React79 = __toESM(require_react());

  // ../../node_modules/input-otp/dist/index.mjs
  var n = __toESM(require_react2(), 1);
  var U3 = __toESM(require_react2(), 1);
  var S = __toESM(require_react2(), 1);
  var Bt = Object.defineProperty;
  var At = Object.defineProperties;
  var kt = Object.getOwnPropertyDescriptors;
  var Y4 = Object.getOwnPropertySymbols;
  var gt = Object.prototype.hasOwnProperty;
  var Et = Object.prototype.propertyIsEnumerable;
  var vt = (r4, s, e2) => s in r4 ? Bt(r4, s, { enumerable: true, configurable: true, writable: true, value: e2 }) : r4[s] = e2;
  var St = (r4, s) => {
    for (var e2 in s || (s = {})) gt.call(s, e2) && vt(r4, e2, s[e2]);
    if (Y4) for (var e2 of Y4(s)) Et.call(s, e2) && vt(r4, e2, s[e2]);
    return r4;
  };
  var bt = (r4, s) => At(r4, kt(s));
  var Pt = (r4, s) => {
    var e2 = {};
    for (var u2 in r4) gt.call(r4, u2) && s.indexOf(u2) < 0 && (e2[u2] = r4[u2]);
    if (r4 != null && Y4) for (var u2 of Y4(r4)) s.indexOf(u2) < 0 && Et.call(r4, u2) && (e2[u2] = r4[u2]);
    return e2;
  };
  function ht(r4) {
    let s = setTimeout(r4, 0), e2 = setTimeout(r4, 10), u2 = setTimeout(r4, 50);
    return [s, e2, u2];
  }
  function _t2(r4) {
    let s = U3.useRef();
    return U3.useEffect(() => {
      s.current = r4;
    }), s.current;
  }
  var Ot = 18;
  var wt = 40;
  var Gt = `${wt}px`;
  var xt = ["[data-lastpass-icon-root]", "com-1password-button", "[data-dashlanecreated]", '[style$="2147483647 !important;"]'].join(",");
  function Tt({ containerRef: r4, inputRef: s, pushPasswordManagerStrategy: e2, isFocused: u2 }) {
    let [P2, D4] = S.useState(false), [G3, H4] = S.useState(false), [F3, W3] = S.useState(false), Z4 = S.useMemo(() => e2 === "none" ? false : (e2 === "increase-width" || e2 === "experimental-no-flickering") && P2 && G3, [P2, G3, e2]), T2 = S.useCallback(() => {
      let f2 = r4.current, h = s.current;
      if (!f2 || !h || F3 || e2 === "none") return;
      let a = f2, B5 = a.getBoundingClientRect().left + a.offsetWidth, A3 = a.getBoundingClientRect().top + a.offsetHeight / 2, z3 = B5 - Ot, q3 = A3;
      document.querySelectorAll(xt).length === 0 && document.elementFromPoint(z3, q3) === f2 || (D4(true), W3(true));
    }, [r4, s, F3, e2]);
    return S.useEffect(() => {
      let f2 = r4.current;
      if (!f2 || e2 === "none") return;
      function h() {
        let A3 = window.innerWidth - f2.getBoundingClientRect().right;
        H4(A3 >= wt);
      }
      h();
      let a = setInterval(h, 1e3);
      return () => {
        clearInterval(a);
      };
    }, [r4, e2]), S.useEffect(() => {
      let f2 = u2 || document.activeElement === s.current;
      if (e2 === "none" || !f2) return;
      let h = setTimeout(T2, 0), a = setTimeout(T2, 2e3), B5 = setTimeout(T2, 5e3), A3 = setTimeout(() => {
        W3(true);
      }, 6e3);
      return () => {
        clearTimeout(h), clearTimeout(a), clearTimeout(B5), clearTimeout(A3);
      };
    }, [s, u2, e2, T2]), { hasPWMBadge: P2, willPushPWMBadge: Z4, PWM_BADGE_SPACE_WIDTH: Gt };
  }
  var jt = n.createContext({});
  var Lt = n.forwardRef((A3, B5) => {
    var z3 = A3, { value: r4, onChange: s, maxLength: e2, textAlign: u2 = "left", pattern: P2, placeholder: D4, inputMode: G3 = "numeric", onComplete: H4, pushPasswordManagerStrategy: F3 = "increase-width", pasteTransformer: W3, containerClassName: Z4, noScriptCSSFallback: T2 = Nt, render: f2, children: h } = z3, a = Pt(z3, ["value", "onChange", "maxLength", "textAlign", "pattern", "placeholder", "inputMode", "onComplete", "pushPasswordManagerStrategy", "pasteTransformer", "containerClassName", "noScriptCSSFallback", "render", "children"]);
    var X5, lt2, ut2, dt2, ft2;
    let [q3, nt2] = n.useState(typeof a.defaultValue == "string" ? a.defaultValue : ""), i3 = r4 != null ? r4 : q3, I2 = _t2(i3), x2 = n.useCallback((t3) => {
      s == null || s(t3), nt2(t3);
    }, [s]), m3 = n.useMemo(() => P2 ? typeof P2 == "string" ? new RegExp(P2) : P2 : null, [P2]), l2 = n.useRef(null), K5 = n.useRef(null), J3 = n.useRef({ value: i3, onChange: x2, isIOS: typeof window != "undefined" && ((lt2 = (X5 = window == null ? void 0 : window.CSS) == null ? void 0 : X5.supports) == null ? void 0 : lt2.call(X5, "-webkit-touch-callout", "none")) }), V3 = n.useRef({ prev: [(ut2 = l2.current) == null ? void 0 : ut2.selectionStart, (dt2 = l2.current) == null ? void 0 : dt2.selectionEnd, (ft2 = l2.current) == null ? void 0 : ft2.selectionDirection] });
    n.useImperativeHandle(B5, () => l2.current, []), n.useEffect(() => {
      let t3 = l2.current, o = K5.current;
      if (!t3 || !o) return;
      J3.current.value !== t3.value && J3.current.onChange(t3.value), V3.current.prev = [t3.selectionStart, t3.selectionEnd, t3.selectionDirection];
      function d() {
        if (document.activeElement !== t3) {
          L2(null), N2(null);
          return;
        }
        let c = t3.selectionStart, b2 = t3.selectionEnd, mt2 = t3.selectionDirection, v2 = t3.maxLength, C2 = t3.value, _2 = V3.current.prev, g2 = -1, E2 = -1, w2;
        if (C2.length !== 0 && c !== null && b2 !== null) {
          let Dt = c === b2, Ht = c === C2.length && C2.length < v2;
          if (Dt && !Ht) {
            let y2 = c;
            if (y2 === 0) g2 = 0, E2 = 1, w2 = "forward";
            else if (y2 === v2) g2 = y2 - 1, E2 = y2, w2 = "backward";
            else if (v2 > 1 && C2.length > 1) {
              let et2 = 0;
              if (_2[0] !== null && _2[1] !== null) {
                w2 = y2 < _2[1] ? "backward" : "forward";
                let Wt = _2[0] === _2[1] && _2[0] < v2;
                w2 === "backward" && !Wt && (et2 = -1);
              }
              g2 = et2 + y2, E2 = et2 + y2 + 1;
            }
          }
          g2 !== -1 && E2 !== -1 && g2 !== E2 && l2.current.setSelectionRange(g2, E2, w2);
        }
        let pt2 = g2 !== -1 ? g2 : c, Rt2 = E2 !== -1 ? E2 : b2, yt2 = w2 != null ? w2 : mt2;
        L2(pt2), N2(Rt2), V3.current.prev = [pt2, Rt2, yt2];
      }
      if (document.addEventListener("selectionchange", d, { capture: true }), d(), document.activeElement === t3 && Q3(true), !document.getElementById("input-otp-style")) {
        let c = document.createElement("style");
        if (c.id = "input-otp-style", document.head.appendChild(c), c.sheet) {
          let b2 = "background: transparent !important; color: transparent !important; border-color: transparent !important; opacity: 0 !important; box-shadow: none !important; -webkit-box-shadow: none !important; -webkit-text-fill-color: transparent !important;";
          $3(c.sheet, "[data-input-otp]::selection { background: transparent !important; color: transparent !important; }"), $3(c.sheet, `[data-input-otp]:autofill { ${b2} }`), $3(c.sheet, `[data-input-otp]:-webkit-autofill { ${b2} }`), $3(c.sheet, "@supports (-webkit-touch-callout: none) { [data-input-otp] { letter-spacing: -.6em !important; font-weight: 100 !important; font-stretch: ultra-condensed; font-optical-sizing: none !important; left: -1px !important; right: 1px !important; } }"), $3(c.sheet, "[data-input-otp] + * { pointer-events: all !important; }");
        }
      }
      let R = () => {
        o && o.style.setProperty("--root-height", `${t3.clientHeight}px`);
      };
      R();
      let p3 = new ResizeObserver(R);
      return p3.observe(t3), () => {
        document.removeEventListener("selectionchange", d, { capture: true }), p3.disconnect();
      };
    }, []);
    let [ot2, rt2] = n.useState(false), [j2, Q3] = n.useState(false), [M3, L2] = n.useState(null), [k5, N2] = n.useState(null);
    n.useEffect(() => {
      ht(() => {
        var R, p3, c, b2;
        (R = l2.current) == null || R.dispatchEvent(new Event("input"));
        let t3 = (p3 = l2.current) == null ? void 0 : p3.selectionStart, o = (c = l2.current) == null ? void 0 : c.selectionEnd, d = (b2 = l2.current) == null ? void 0 : b2.selectionDirection;
        t3 !== null && o !== null && (L2(t3), N2(o), V3.current.prev = [t3, o, d]);
      });
    }, [i3, j2]), n.useEffect(() => {
      I2 !== void 0 && i3 !== I2 && I2.length < e2 && i3.length === e2 && (H4 == null || H4(i3));
    }, [e2, H4, I2, i3]);
    let O = Tt({ containerRef: K5, inputRef: l2, pushPasswordManagerStrategy: F3, isFocused: j2 }), st2 = n.useCallback((t3) => {
      let o = t3.currentTarget.value.slice(0, e2);
      if (o.length > 0 && m3 && !m3.test(o)) {
        t3.preventDefault();
        return;
      }
      typeof I2 == "string" && o.length < I2.length && document.dispatchEvent(new Event("selectionchange")), x2(o);
    }, [e2, x2, I2, m3]), at2 = n.useCallback(() => {
      var t3;
      if (l2.current) {
        let o = Math.min(l2.current.value.length, e2 - 1), d = l2.current.value.length;
        (t3 = l2.current) == null || t3.setSelectionRange(o, d), L2(o), N2(d);
      }
      Q3(true);
    }, [e2]), ct2 = n.useCallback((t3) => {
      var g2, E2;
      let o = l2.current;
      if (!W3 && (!J3.current.isIOS || !t3.clipboardData || !o)) return;
      let d = t3.clipboardData.getData("text/plain"), R = W3 ? W3(d) : d;
      t3.preventDefault();
      let p3 = (g2 = l2.current) == null ? void 0 : g2.selectionStart, c = (E2 = l2.current) == null ? void 0 : E2.selectionEnd, v2 = (p3 !== c ? i3.slice(0, p3) + R + i3.slice(c) : i3.slice(0, p3) + R + i3.slice(p3)).slice(0, e2);
      if (v2.length > 0 && m3 && !m3.test(v2)) return;
      o.value = v2, x2(v2);
      let C2 = Math.min(v2.length, e2 - 1), _2 = v2.length;
      o.setSelectionRange(C2, _2), L2(C2), N2(_2);
    }, [e2, x2, m3, i3]), It = n.useMemo(() => ({ position: "relative", cursor: a.disabled ? "default" : "text", userSelect: "none", WebkitUserSelect: "none", pointerEvents: "none" }), [a.disabled]), it2 = n.useMemo(() => ({ position: "absolute", inset: 0, width: O.willPushPWMBadge ? `calc(100% + ${O.PWM_BADGE_SPACE_WIDTH})` : "100%", clipPath: O.willPushPWMBadge ? `inset(0 ${O.PWM_BADGE_SPACE_WIDTH} 0 0)` : void 0, height: "100%", display: "flex", textAlign: u2, opacity: "1", color: "transparent", pointerEvents: "all", background: "transparent", caretColor: "transparent", border: "0 solid transparent", outline: "0 solid transparent", boxShadow: "none", lineHeight: "1", letterSpacing: "-.5em", fontSize: "var(--root-height)", fontFamily: "monospace", fontVariantNumeric: "tabular-nums" }), [O.PWM_BADGE_SPACE_WIDTH, O.willPushPWMBadge, u2]), Mt2 = n.useMemo(() => n.createElement("input", bt(St({ autoComplete: a.autoComplete || "one-time-code" }, a), { "data-input-otp": true, "data-input-otp-placeholder-shown": i3.length === 0 || void 0, "data-input-otp-mss": M3, "data-input-otp-mse": k5, inputMode: G3, pattern: m3 == null ? void 0 : m3.source, "aria-placeholder": D4, style: it2, maxLength: e2, value: i3, ref: l2, onPaste: (t3) => {
      var o;
      ct2(t3), (o = a.onPaste) == null || o.call(a, t3);
    }, onChange: st2, onMouseOver: (t3) => {
      var o;
      rt2(true), (o = a.onMouseOver) == null || o.call(a, t3);
    }, onMouseLeave: (t3) => {
      var o;
      rt2(false), (o = a.onMouseLeave) == null || o.call(a, t3);
    }, onFocus: (t3) => {
      var o;
      at2(), (o = a.onFocus) == null || o.call(a, t3);
    }, onBlur: (t3) => {
      var o;
      Q3(false), (o = a.onBlur) == null || o.call(a, t3);
    } })), [st2, at2, ct2, G3, it2, e2, k5, M3, a, m3 == null ? void 0 : m3.source, i3]), tt3 = n.useMemo(() => ({ slots: Array.from({ length: e2 }).map((t3, o) => {
      var c;
      let d = j2 && M3 !== null && k5 !== null && (M3 === k5 && o === M3 || o >= M3 && o < k5), R = i3[o] !== void 0 ? i3[o] : null, p3 = i3[0] !== void 0 ? null : (c = D4 == null ? void 0 : D4[o]) != null ? c : null;
      return { char: R, placeholderChar: p3, isActive: d, hasFakeCaret: d && R === null };
    }), isFocused: j2, isHovering: !a.disabled && ot2 }), [j2, ot2, e2, k5, M3, a.disabled, i3]), Ct2 = n.useMemo(() => f2 ? f2(tt3) : n.createElement(jt.Provider, { value: tt3 }, h), [h, tt3, f2]);
    return n.createElement(n.Fragment, null, T2 !== null && n.createElement("noscript", null, n.createElement("style", null, T2)), n.createElement("div", { ref: K5, "data-input-otp-container": true, style: It, className: Z4 }, Ct2, n.createElement("div", { style: { position: "absolute", inset: 0, pointerEvents: "none" } }, Mt2)));
  });
  Lt.displayName = "Input";
  function $3(r4, s) {
    try {
      r4.insertRule(s);
    } catch (e2) {
      console.error("input-otp could not insert CSS rule:", s);
    }
  }
  var Nt = `
[data-input-otp] {
  --nojs-bg: white !important;
  --nojs-fg: black !important;

  background-color: var(--nojs-bg) !important;
  color: var(--nojs-fg) !important;
  caret-color: var(--nojs-fg) !important;
  letter-spacing: .25em !important;
  text-align: center !important;
  border: 1px solid var(--nojs-fg) !important;
  border-radius: 4px !important;
  width: 100% !important;
}
@media (prefers-color-scheme: dark) {
  [data-input-otp] {
    --nojs-bg: black !important;
    --nojs-fg: white !important;
  }
}`;

  // src/components/InputOTP.tsx
  var import_jsx_runtime58 = __toESM(require_jsx_runtime());
  var InputOTP = React79.forwardRef(({ className, containerClassName, ...props }, ref) => /* @__PURE__ */ (0, import_jsx_runtime58.jsx)(
    Lt,
    {
      ref,
      containerClassName: cn(
        "flex items-center gap-2 has-[:disabled]:opacity-50",
        containerClassName
      ),
      className: cn("disabled:cursor-not-allowed", className),
      ...props
    }
  ));
  InputOTP.displayName = "InputOTP";
  var InputOTPGroup = React79.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ (0, import_jsx_runtime58.jsx)("div", { ref, className: cn("flex items-center", className), ...props }));
  InputOTPGroup.displayName = "InputOTPGroup";
  var InputOTPSlot = React79.forwardRef(({ index: index2, className, ...props }, ref) => {
    const inputOTPContext = React79.useContext(jt);
    const { char, hasFakeCaret, isActive } = inputOTPContext.slots[index2];
    return /* @__PURE__ */ (0, import_jsx_runtime58.jsxs)(
      "div",
      {
        ref,
        className: cn(
          "relative flex h-10 w-10 items-center justify-center border-y border-r border-input text-sm transition-all first:rounded-l-md first:border-l last:rounded-r-md",
          isActive && "z-10 ring-2 ring-ring ring-offset-background",
          className
        ),
        ...props,
        children: [
          char,
          hasFakeCaret && /* @__PURE__ */ (0, import_jsx_runtime58.jsx)("div", { className: "pointer-events-none absolute inset-0 flex items-center justify-center", children: /* @__PURE__ */ (0, import_jsx_runtime58.jsx)("div", { className: "h-4 w-px animate-caret-blink bg-foreground duration-1000" }) })
        ]
      }
    );
  });
  InputOTPSlot.displayName = "InputOTPSlot";
  var InputOTPSeparator = React79.forwardRef(({ ...props }, ref) => /* @__PURE__ */ (0, import_jsx_runtime58.jsx)("div", { ref, role: "separator", ...props, children: /* @__PURE__ */ (0, import_jsx_runtime58.jsx)(Dot, {}) }));
  InputOTPSeparator.displayName = "InputOTPSeparator";

  // src/components/Kbd.tsx
  var import_react99 = __toESM(require_react());
  var import_jsx_runtime59 = __toESM(require_jsx_runtime());
  var Kbd = ({
    children,
    size: size4 = "md",
    className
  }) => {
    const sizeClasses2 = {
      sm: "text-[10px] px-1 py-0.5 min-w-[18px]",
      md: "text-xs px-1.5 py-0.5 min-w-[22px]",
      lg: "text-sm px-2 py-1 min-w-[28px]"
    };
    return /* @__PURE__ */ (0, import_jsx_runtime59.jsx)(
      "kbd",
      {
        className: cn(
          sizeClasses2[size4],
          "inline-flex items-center justify-center rounded-md",
          "font-mono font-medium",
          "bg-muted/80 border border-border/50",
          "text-muted-foreground",
          "shadow-[0_1px_0_1px] shadow-border/50",
          "dark:bg-zinc-800 dark:border-zinc-700 dark:shadow-zinc-900",
          className
        ),
        children
      }
    );
  };
  var Shortcut = ({
    keys: keys2,
    separator = "+",
    size: size4 = "md",
    className
  }) => {
    const formatKey = (key) => {
      const keyMap = {
        cmd: "\u2318",
        command: "\u2318",
        ctrl: "\u2303",
        control: "\u2303",
        alt: "\u2325",
        option: "\u2325",
        shift: "\u21E7",
        enter: "\u21B5",
        return: "\u21B5",
        backspace: "\u232B",
        delete: "\u2326",
        escape: "\u238B",
        esc: "\u238B",
        tab: "\u21E5",
        up: "\u2191",
        down: "\u2193",
        left: "\u2190",
        right: "\u2192",
        space: "\u2423"
      };
      return keyMap[key.toLowerCase()] || key.toUpperCase();
    };
    return /* @__PURE__ */ (0, import_jsx_runtime59.jsx)("span", { className: cn("inline-flex items-center gap-0.5", className), children: keys2.map((key, index2) => /* @__PURE__ */ (0, import_jsx_runtime59.jsxs)(import_react99.default.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime59.jsx)(Kbd, { size: size4, children: formatKey(key) }),
      index2 < keys2.length - 1 && /* @__PURE__ */ (0, import_jsx_runtime59.jsx)("span", { className: "text-muted-foreground/50 text-xs mx-0.5", children: separator })
    ] }, index2)) });
  };

  // src/components/MacBookMockup.tsx
  var import_jsx_runtime60 = __toESM(require_jsx_runtime());
  var MacBookMockup = ({
    children,
    variant = "space-gray",
    className
  }) => {
    const variantColors = {
      silver: "bg-gradient-to-b from-zinc-300 to-zinc-400 dark:from-zinc-500 dark:to-zinc-600",
      "space-gray": "bg-gradient-to-b from-zinc-600 to-zinc-800"
    };
    return /* @__PURE__ */ (0, import_jsx_runtime60.jsxs)("div", { className: cn("relative", className), children: [
      /* @__PURE__ */ (0, import_jsx_runtime60.jsxs)(
        "div",
        {
          className: cn(
            "relative rounded-t-xl p-[10px] pb-0",
            variantColors[variant]
          ),
          children: [
            /* @__PURE__ */ (0, import_jsx_runtime60.jsx)("div", { className: "absolute top-[5px] left-1/2 -translate-x-1/2 w-2 h-2 rounded-full bg-zinc-900/50" }),
            /* @__PURE__ */ (0, import_jsx_runtime60.jsx)("div", { className: "relative w-[600px] h-[375px] bg-black rounded-[6px] overflow-hidden", children })
          ]
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime60.jsx)("div", { className: cn("h-3", variantColors[variant]), children: /* @__PURE__ */ (0, import_jsx_runtime60.jsx)("div", { className: "absolute left-1/2 -translate-x-1/2 bottom-0 w-[200px] h-1 bg-zinc-400/20 rounded-b-sm" }) }),
      /* @__PURE__ */ (0, import_jsx_runtime60.jsx)(
        "div",
        {
          className: cn(
            "relative h-3 rounded-b-xl -mt-1",
            variantColors[variant],
            "shadow-lg shadow-black/30"
          ),
          style: {
            width: "calc(100% + 30px)",
            marginLeft: "-15px"
          },
          children: /* @__PURE__ */ (0, import_jsx_runtime60.jsx)("div", { className: "absolute top-0 left-1/2 -translate-x-1/2 w-[60px] h-[4px] bg-zinc-600/30 rounded-b-lg" })
        }
      )
    ] });
  };

  // src/components/MagicCard.tsx
  var import_react100 = __toESM(require_react());
  var import_jsx_runtime61 = __toESM(require_jsx_runtime());
  function MagicCard({
    children,
    className,
    gradientSize = 200,
    gradientColor = "#262626",
    gradientOpacity = 0.8,
    ...props
  }) {
    const cardRef = (0, import_react100.useRef)(null);
    const [position, setPosition] = (0, import_react100.useState)({ x: -gradientSize, y: -gradientSize });
    const [opacity, setOpacity] = (0, import_react100.useState)(0);
    const handleMouseMove = (e2) => {
      if (!cardRef.current) return;
      const rect = cardRef.current.getBoundingClientRect();
      setPosition({ x: e2.clientX - rect.left, y: e2.clientY - rect.top });
      setOpacity(1);
    };
    const handleMouseLeave = () => {
      setOpacity(0);
    };
    return /* @__PURE__ */ (0, import_jsx_runtime61.jsxs)(
      "div",
      {
        ref: cardRef,
        onMouseMove: handleMouseMove,
        onMouseLeave: handleMouseLeave,
        className: cn(
          "group relative flex h-full w-full overflow-hidden rounded-xl border border-neutral-200 bg-neutral-100 dark:border-neutral-800 dark:bg-neutral-900 text-black dark:text-white",
          className
        ),
        ...props,
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime61.jsx)("div", { className: "relative z-10", children }),
          /* @__PURE__ */ (0, import_jsx_runtime61.jsx)(
            "div",
            {
              className: "pointer-events-none absolute -inset-px rounded-xl transition-opacity duration-300",
              style: {
                opacity,
                background: `radial-gradient(${gradientSize}px circle at ${position.x}px ${position.y}px, ${gradientColor}, transparent 100%)`
              }
            }
          )
        ]
      }
    );
  }

  // src/components/Marquee.tsx
  var import_jsx_runtime62 = __toESM(require_jsx_runtime());
  function Marquee({
    className,
    reverse,
    pauseOnHover = false,
    children,
    vertical = false,
    repeat = 4,
    ...props
  }) {
    return /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(
      "div",
      {
        ...props,
        className: cn(
          "group flex overflow-hidden p-2 [--duration:40s] [--gap:1rem] [gap:var(--gap)]",
          {
            "flex-row": !vertical,
            "flex-col": vertical
          },
          className
        ),
        children: Array(repeat).fill(0).map((_2, i3) => /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(
          "div",
          {
            className: cn("flex shrink-0 justify-around [gap:var(--gap)]", {
              "animate-marquee flex-row": !vertical,
              "animate-marquee-vertical flex-col": vertical,
              "group-hover:[animation-play-state:paused]": pauseOnHover,
              "[animation-direction:reverse]": reverse
            }),
            children
          },
          i3
        ))
      }
    );
  }

  // src/components/Meteors.tsx
  var import_react101 = __toESM(require_react());
  var import_jsx_runtime63 = __toESM(require_jsx_runtime());
  var Meteors = ({ number: number2 = 20 }) => {
    const [styles, setStyles] = (0, import_react101.useState)([]);
    (0, import_react101.useEffect)(() => {
      const styles2 = [...new Array(number2)].map(() => ({
        top: 0,
        left: Math.floor(Math.random() * (400 - -400) + -400) + "px",
        animationDelay: Math.random() * (0.8 - 0.2) + 0.2 + "s",
        animationDuration: Math.floor(Math.random() * (10 - 2) + 2) + "s"
      }));
      setStyles(styles2);
    }, [number2]);
    return /* @__PURE__ */ (0, import_jsx_runtime63.jsx)(import_jsx_runtime63.Fragment, { children: styles.map((style, idx) => (
      // Meteor Head
      /* @__PURE__ */ (0, import_jsx_runtime63.jsx)(
        "span",
        {
          className: cn(
            "pointer-events-none absolute left-1/2 top-1/2 h-0.5 w-0.5 rotate-[215deg] animate-meteor opacity-0 shadow-[0_0_0_1px_#ffffff10]"
          ),
          style,
          children: /* @__PURE__ */ (0, import_jsx_runtime63.jsx)("div", { className: "pointer-events-none absolute top-1/2 -z-10 h-[1px] w-[50px] -translate-y-1/2 bg-gradient-to-r from-slate-500 to-transparent" })
        },
        idx
      )
    )) });
  };

  // src/components/Modal.tsx
  var import_react102 = __toESM(require_react());
  var import_jsx_runtime64 = __toESM(require_jsx_runtime());
  function Modal({
    isOpen,
    onClose,
    children,
    size: size4 = "md",
    closeOnBackdrop = true,
    className,
    variant = "default"
  }) {
    const handleKeyDown = (0, import_react102.useCallback)(
      (e2) => {
        if (e2.key === "Escape") {
          onClose();
        }
      },
      [onClose]
    );
    (0, import_react102.useEffect)(() => {
      if (isOpen) {
        document.addEventListener("keydown", handleKeyDown);
        document.body.style.overflow = "hidden";
      }
      return () => {
        document.removeEventListener("keydown", handleKeyDown);
        document.body.style.overflow = "unset";
      };
    }, [isOpen, handleKeyDown]);
    if (!isOpen) return null;
    return /* @__PURE__ */ (0, import_jsx_runtime64.jsxs)("div", { className: cn(
      "fixed inset-0 z-50 flex items-center justify-center p-4",
      variant === "bottom-sheet" && "items-end p-0",
      variant === "drawer" && "items-stretch justify-end p-0"
    ), children: [
      /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(
        "div",
        {
          className: "absolute inset-0 bg-black/60 backdrop-blur-md transition-opacity duration-300 animate-in fade-in",
          onClick: closeOnBackdrop ? onClose : void 0,
          "aria-hidden": "true"
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime64.jsxs)(
        "div",
        {
          role: "dialog",
          "aria-modal": "true",
          className: cn(
            "relative z-10 w-full border border-border bg-background/80 shadow-2xl backdrop-blur-xl transition-all duration-300",
            // Base/Default
            variant === "default" && "rounded-[2rem] p-6 animate-in fade-in zoom-in-95",
            // Bottom Sheet
            variant === "bottom-sheet" && "rounded-t-[2rem] p-6 pb-10 max-w-full animate-in slide-in-from-bottom duration-500",
            // Drawer
            variant === "drawer" && "h-full max-w-md rounded-l-[2rem] p-8 animate-in slide-in-from-right duration-500",
            {
              "max-w-sm": size4 === "sm" && variant !== "bottom-sheet",
              "max-w-md": size4 === "md" && variant !== "bottom-sheet",
              "max-w-lg": size4 === "lg" && variant !== "bottom-sheet",
              "max-w-xl": size4 === "xl" && variant !== "bottom-sheet"
            },
            className
          ),
          children: [
            variant === "bottom-sheet" && /* @__PURE__ */ (0, import_jsx_runtime64.jsx)("div", { className: "mx-auto h-1.5 w-12 rounded-full bg-zinc-300/50 dark:bg-zinc-700/50 mb-4" }),
            children
          ]
        }
      )
    ] });
  }
  function ModalHeader({ children, className }) {
    return /* @__PURE__ */ (0, import_jsx_runtime64.jsx)("div", { className: cn("mb-4", className), children });
  }
  function ModalTitle({ children, className }) {
    return /* @__PURE__ */ (0, import_jsx_runtime64.jsx)("h2", { className: cn("text-lg font-semibold", className), children });
  }
  function ModalBody({ children, className }) {
    return /* @__PURE__ */ (0, import_jsx_runtime64.jsx)("div", { className: cn("text-sm text-muted-foreground", className), children });
  }
  function ModalFooter({ children, className }) {
    return /* @__PURE__ */ (0, import_jsx_runtime64.jsx)("div", { className: cn("mt-6 flex items-center justify-end gap-2", className), children });
  }

  // src/components/Navbar.tsx
  var import_react103 = __toESM(require_react());
  var import_jsx_runtime65 = __toESM(require_jsx_runtime());
  function Navbar({
    logo,
    items = [],
    rightAction,
    className,
    mobileMenuOpen: controlledMobileMenuOpen,
    onMobileMenuToggle,
    LinkComponent = "a"
    // Default to anchor tag
  }) {
    const [internalMobileMenuOpen, setInternalMobileMenuOpen] = (0, import_react103.useState)(false);
    const isMobileMenuOpen = controlledMobileMenuOpen ?? internalMobileMenuOpen;
    const toggleMobileMenu = () => {
      const newState = !isMobileMenuOpen;
      setInternalMobileMenuOpen(newState);
      onMobileMenuToggle?.(newState);
    };
    const Link2 = LinkComponent;
    return /* @__PURE__ */ (0, import_jsx_runtime65.jsx)(import_jsx_runtime65.Fragment, { children: /* @__PURE__ */ (0, import_jsx_runtime65.jsxs)("header", { className: cn("fixed top-4 left-1/2 -translate-x-1/2 z-50 w-[95%] max-w-3xl", className), children: [
      /* @__PURE__ */ (0, import_jsx_runtime65.jsxs)(
        "div",
        {
          className: cn(
            "flex items-center justify-between rounded-[2rem] transition-all duration-500",
            "px-6 py-3",
            // Glass effect - Standard Tailwind Dark Mode
            "bg-white/60 dark:bg-white/5",
            "backdrop-blur-2xl",
            "border border-white/20 dark:border-white/10",
            "shadow-[0_8px_32px_rgba(0,0,0,0.1)] dark:shadow-[0_8px_32px_rgba(0,0,0,0.3)]"
          ),
          children: [
            /* @__PURE__ */ (0, import_jsx_runtime65.jsx)("div", { className: "flex items-center gap-2 group", children: logo || /* @__PURE__ */ (0, import_jsx_runtime65.jsx)("span", { className: "text-lg font-bold tracking-tight text-zinc-900 dark:text-white", children: "Brand" }) }),
            /* @__PURE__ */ (0, import_jsx_runtime65.jsxs)("div", { className: "flex items-center gap-1.5", children: [
              rightAction,
              /* @__PURE__ */ (0, import_jsx_runtime65.jsx)(
                "button",
                {
                  className: "md:hidden h-9 w-9 inline-flex items-center justify-center rounded-full text-zinc-500 dark:text-zinc-400 bg-black/5 dark:bg-white/10 hover:bg-black/10 dark:hover:bg-white/20 transition-all",
                  onClick: toggleMobileMenu,
                  "aria-label": "Menu",
                  children: isMobileMenuOpen ? /* @__PURE__ */ (0, import_jsx_runtime65.jsx)("svg", { className: "h-4 w-4", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", strokeWidth: 2, children: /* @__PURE__ */ (0, import_jsx_runtime65.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M6 18L18 6M6 6l12 12" }) }) : /* @__PURE__ */ (0, import_jsx_runtime65.jsx)("svg", { className: "h-4 w-4", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", strokeWidth: 2, children: /* @__PURE__ */ (0, import_jsx_runtime65.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M4 6h16M4 12h16M4 18h16" }) })
                }
              )
            ] })
          ]
        }
      ),
      isMobileMenuOpen && /* @__PURE__ */ (0, import_jsx_runtime65.jsx)(
        "div",
        {
          className: cn(
            "md:hidden mt-2 mx-2 rounded-[1.5rem] backdrop-blur-3xl overflow-hidden animate-in slide-in-from-top-2 duration-300",
            // Use standard dark classes
            "bg-white dark:bg-zinc-900/95",
            "border border-black/[0.05] dark:border-white/[0.08]",
            "shadow-2xl dark:shadow-[0_8px_32px_rgba(0,0,0,0.5)]"
          ),
          children: /* @__PURE__ */ (0, import_jsx_runtime65.jsx)("nav", { className: "p-2 space-y-1", children: items.map((item) => /* @__PURE__ */ (0, import_jsx_runtime65.jsx)(
            Link2,
            {
              href: item.href,
              className: cn(
                "block px-4 py-3 rounded-xl text-sm font-medium transition-all duration-200",
                "text-zinc-600 dark:text-zinc-400 hover:bg-zinc-50 dark:hover:bg-zinc-800/50 hover:text-zinc-900 dark:hover:text-white"
              ),
              onClick: () => {
                setInternalMobileMenuOpen(false);
                onMobileMenuToggle?.(false);
              },
              children: item.name
            },
            item.href
          )) })
        }
      )
    ] }) });
  }

  // src/components/NeonButton.tsx
  var import_react104 = __toESM(require_react());
  var import_jsx_runtime66 = __toESM(require_jsx_runtime());
  var NeonButton = (0, import_react104.forwardRef)(
    ({ className, variant = "cyan", neonSize = "md", children, ...props }, ref) => {
      const variants = {
        cyan: "border-cyan-400 text-cyan-400 shadow-[0_0_10px_#22d3ee] hover:shadow-[0_0_20px_#22d3ee] hover:bg-cyan-400 hover:text-black",
        magenta: "border-fuchsia-400 text-fuchsia-400 shadow-[0_0_10px_#e879f9] hover:shadow-[0_0_20px_#e879f9] hover:bg-fuchsia-400 hover:text-black",
        lime: "border-lime-400 text-lime-400 shadow-[0_0_10px_#a3e635] hover:shadow-[0_0_20px_#a3e635] hover:bg-lime-400 hover:text-black",
        violet: "border-violet-400 text-violet-400 shadow-[0_0_10px_#a78bfa] hover:shadow-[0_0_20px_#a78bfa] hover:bg-violet-400 hover:text-white"
      };
      const sizes = {
        sm: "px-3 py-1 text-sm",
        md: "px-6 py-2 text-base",
        lg: "px-8 py-3 text-lg"
      };
      return /* @__PURE__ */ (0, import_jsx_runtime66.jsxs)(
        "button",
        {
          ref,
          className: cn(
            "relative inline-flex items-center justify-center rounded-lg border-2 bg-transparent font-bold transition-all duration-300 focus:outline-none focus:ring-2 focus:ring-offset-2 disabled:opacity-50 disabled:pointer-events-none",
            variants[variant],
            sizes[neonSize],
            className
          ),
          ...props,
          children: [
            /* @__PURE__ */ (0, import_jsx_runtime66.jsx)("span", { className: "relative z-10 filter drop-shadow-sm", children }),
            /* @__PURE__ */ (0, import_jsx_runtime66.jsx)("div", { className: "absolute inset-0 rounded-lg opacity-0 transition-opacity duration-300 hover:opacity-20 bg-current" })
          ]
        }
      );
    }
  );
  NeonButton.displayName = "NeonButton";

  // src/components/NumberField.tsx
  var import_react105 = __toESM(require_react());
  var import_jsx_runtime67 = __toESM(require_jsx_runtime());
  var NumberField = import_react105.default.forwardRef(
    ({
      value,
      defaultValue = 0,
      onChange,
      min: min3 = -Infinity,
      max: max3 = Infinity,
      step = 1,
      disabled = false,
      size: size4 = "md",
      className,
      showControls = true,
      label
    }, ref) => {
      const [internalValue, setInternalValue] = import_react105.default.useState(defaultValue);
      const controlledValue = value !== void 0 ? value : internalValue;
      const updateValue = (newValue) => {
        const clampedValue = Math.min(Math.max(newValue, min3), max3);
        if (value === void 0) {
          setInternalValue(clampedValue);
        }
        onChange?.(clampedValue);
      };
      const increment = () => updateValue(controlledValue + step);
      const decrement = () => updateValue(controlledValue - step);
      const handleInputChange = (e2) => {
        const newValue = parseFloat(e2.target.value);
        if (!isNaN(newValue)) {
          updateValue(newValue);
        }
      };
      const sizeClasses2 = {
        sm: "h-8 text-sm",
        md: "h-10 text-sm",
        lg: "h-12 text-base"
      };
      const buttonSizes = {
        sm: "w-8 h-8",
        md: "w-10 h-10",
        lg: "w-12 h-12"
      };
      const iconSizes = {
        sm: "w-3 h-3",
        md: "w-4 h-4",
        lg: "w-5 h-5"
      };
      return /* @__PURE__ */ (0, import_jsx_runtime67.jsxs)("div", { className: cn("flex flex-col gap-1.5", className), children: [
        label && /* @__PURE__ */ (0, import_jsx_runtime67.jsx)("label", { className: "text-sm font-medium text-foreground", children: label }),
        /* @__PURE__ */ (0, import_jsx_runtime67.jsxs)(
          "div",
          {
            className: cn(
              "flex items-center rounded-xl border border-border/50 bg-muted/30 overflow-hidden",
              "dark:bg-zinc-900/50 dark:border-zinc-800",
              disabled && "opacity-50 cursor-not-allowed"
            ),
            children: [
              showControls && /* @__PURE__ */ (0, import_jsx_runtime67.jsx)(
                "button",
                {
                  type: "button",
                  onClick: decrement,
                  disabled: disabled || controlledValue <= min3,
                  className: cn(
                    buttonSizes[size4],
                    "flex items-center justify-center border-r border-border/50",
                    "text-muted-foreground hover:text-foreground hover:bg-muted/50",
                    "transition-colors duration-150",
                    "disabled:opacity-50 disabled:cursor-not-allowed disabled:hover:bg-transparent",
                    "dark:border-zinc-800 dark:hover:bg-zinc-800/50"
                  ),
                  children: /* @__PURE__ */ (0, import_jsx_runtime67.jsx)(
                    "svg",
                    {
                      className: iconSizes[size4],
                      fill: "none",
                      viewBox: "0 0 24 24",
                      stroke: "currentColor",
                      strokeWidth: 2,
                      children: /* @__PURE__ */ (0, import_jsx_runtime67.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M20 12H4" })
                    }
                  )
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime67.jsx)(
                "input",
                {
                  ref,
                  type: "number",
                  value: controlledValue,
                  onChange: handleInputChange,
                  disabled,
                  min: min3,
                  max: max3,
                  step,
                  className: cn(
                    sizeClasses2[size4],
                    "flex-1 min-w-[60px] bg-transparent text-center px-3",
                    "focus:outline-none",
                    "[appearance:textfield] [&::-webkit-outer-spin-button]:appearance-none [&::-webkit-inner-spin-button]:appearance-none"
                  )
                }
              ),
              showControls && /* @__PURE__ */ (0, import_jsx_runtime67.jsx)(
                "button",
                {
                  type: "button",
                  onClick: increment,
                  disabled: disabled || controlledValue >= max3,
                  className: cn(
                    buttonSizes[size4],
                    "flex items-center justify-center border-l border-border/50",
                    "text-muted-foreground hover:text-foreground hover:bg-muted/50",
                    "transition-colors duration-150",
                    "disabled:opacity-50 disabled:cursor-not-allowed disabled:hover:bg-transparent",
                    "dark:border-zinc-800 dark:hover:bg-zinc-800/50"
                  ),
                  children: /* @__PURE__ */ (0, import_jsx_runtime67.jsx)(
                    "svg",
                    {
                      className: iconSizes[size4],
                      fill: "none",
                      viewBox: "0 0 24 24",
                      stroke: "currentColor",
                      strokeWidth: 2,
                      children: /* @__PURE__ */ (0, import_jsx_runtime67.jsx)(
                        "path",
                        {
                          strokeLinecap: "round",
                          strokeLinejoin: "round",
                          d: "M12 4v16m8-8H4"
                        }
                      )
                    }
                  )
                }
              )
            ]
          }
        )
      ] });
    }
  );
  NumberField.displayName = "NumberField";

  // src/components/NumberTicker.tsx
  var import_react106 = __toESM(require_react());
  var import_jsx_runtime68 = __toESM(require_jsx_runtime());
  function NumberTicker({
    value,
    direction = "up",
    delay: delay2 = 0,
    className
  }) {
    const ref = (0, import_react106.useRef)(null);
    const motionValue2 = useMotionValue(direction === "down" ? value : 0);
    const springValue2 = useSpring(motionValue2, {
      damping: 60,
      stiffness: 100
    });
    const isInView = useInView(ref, { once: true, margin: "0px" });
    (0, import_react106.useEffect)(() => {
      if (isInView) {
        setTimeout(() => {
          motionValue2.set(direction === "down" ? 0 : value);
        }, delay2 * 1e3);
      }
    }, [motionValue2, isInView, delay2, value, direction]);
    (0, import_react106.useEffect)(() => {
      springValue2.on("change", (latest) => {
        if (ref.current) {
          ref.current.textContent = Intl.NumberFormat("en-US").format(
            Math.round(latest)
          );
        }
      });
    }, [springValue2]);
    return /* @__PURE__ */ (0, import_jsx_runtime68.jsx)(
      "span",
      {
        className: cn(
          "inline-block tabular-nums text-black dark:text-white tracking-wider",
          className
        ),
        ref
      }
    );
  }

  // src/components/Pagination.tsx
  var import_jsx_runtime69 = __toESM(require_jsx_runtime());
  var Pagination = ({
    currentPage,
    totalPages,
    onPageChange,
    siblingCount = 1,
    showFirstLast = true,
    size: size4 = "md",
    className
  }) => {
    const range = (start2, end) => {
      return Array.from({ length: end - start2 + 1 }, (_2, i3) => start2 + i3);
    };
    const generatePages = () => {
      const totalNumbers = siblingCount * 2 + 3;
      const totalBlocks = totalNumbers + 2;
      if (totalPages <= totalBlocks) {
        return range(1, totalPages);
      }
      const leftSiblingIndex = Math.max(currentPage - siblingCount, 1);
      const rightSiblingIndex = Math.min(currentPage + siblingCount, totalPages);
      const shouldShowLeftDots = leftSiblingIndex > 2;
      const shouldShowRightDots = rightSiblingIndex < totalPages - 1;
      if (!shouldShowLeftDots && shouldShowRightDots) {
        const leftItemCount = 3 + 2 * siblingCount;
        return [...range(1, leftItemCount), "...", totalPages];
      }
      if (shouldShowLeftDots && !shouldShowRightDots) {
        const rightItemCount = 3 + 2 * siblingCount;
        return [1, "...", ...range(totalPages - rightItemCount + 1, totalPages)];
      }
      return [1, "...", ...range(leftSiblingIndex, rightSiblingIndex), "...", totalPages];
    };
    const pages = generatePages();
    const sizeClasses2 = {
      sm: "w-7 h-7 text-xs",
      md: "w-9 h-9 text-sm",
      lg: "w-11 h-11 text-base"
    };
    const iconSizes = {
      sm: "w-3 h-3",
      md: "w-4 h-4",
      lg: "w-5 h-5"
    };
    const PageButton = ({ page, isActive, disabled, onClick, children }) => /* @__PURE__ */ (0, import_jsx_runtime69.jsx)(
      "button",
      {
        onClick,
        disabled,
        className: cn(
          sizeClasses2[size4],
          "flex items-center justify-center rounded-lg font-medium transition-all duration-200",
          isActive ? "bg-[#007AFF] text-white dark:bg-[#0A84FF]" : "text-muted-foreground hover:bg-muted/50 dark:hover:bg-zinc-800/50",
          disabled && "opacity-50 cursor-not-allowed hover:bg-transparent"
        ),
        children: children || page
      }
    );
    return /* @__PURE__ */ (0, import_jsx_runtime69.jsxs)(
      "nav",
      {
        className: cn("flex items-center gap-1", className),
        role: "navigation",
        "aria-label": "Pagination",
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime69.jsx)(
            PageButton,
            {
              page: "prev",
              disabled: currentPage === 1,
              onClick: () => onPageChange(currentPage - 1),
              children: /* @__PURE__ */ (0, import_jsx_runtime69.jsx)("svg", { className: iconSizes[size4], fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", strokeWidth: 2, children: /* @__PURE__ */ (0, import_jsx_runtime69.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M15 19l-7-7 7-7" }) })
            }
          ),
          pages.map((page, index2) => {
            if (page === "...") {
              return /* @__PURE__ */ (0, import_jsx_runtime69.jsx)(
                "span",
                {
                  className: cn(sizeClasses2[size4], "flex items-center justify-center text-muted-foreground"),
                  children: "\u22EF"
                },
                `dots-${index2}`
              );
            }
            return /* @__PURE__ */ (0, import_jsx_runtime69.jsx)(
              PageButton,
              {
                page,
                isActive: currentPage === page,
                onClick: () => onPageChange(page)
              },
              page
            );
          }),
          /* @__PURE__ */ (0, import_jsx_runtime69.jsx)(
            PageButton,
            {
              page: "next",
              disabled: currentPage === totalPages,
              onClick: () => onPageChange(currentPage + 1),
              children: /* @__PURE__ */ (0, import_jsx_runtime69.jsx)("svg", { className: iconSizes[size4], fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", strokeWidth: 2, children: /* @__PURE__ */ (0, import_jsx_runtime69.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M9 5l7 7-7 7" }) })
            }
          )
        ]
      }
    );
  };

  // src/components/Particles.tsx
  var import_react107 = __toESM(require_react());
  var import_jsx_runtime70 = __toESM(require_jsx_runtime());
  var Particles = ({
    quantity = 50,
    size: size4 = { min: 1, max: 3 },
    speed = { min: 10, max: 30 },
    color: color2 = "#007AFF",
    className
  }) => {
    const particles = import_react107.default.useMemo(() => {
      return Array.from({ length: quantity }, (_2, i3) => ({
        id: i3,
        x: Math.random() * 100,
        y: Math.random() * 100,
        size: size4.min + Math.random() * (size4.max - size4.min),
        duration: speed.min + Math.random() * (speed.max - speed.min),
        delay: Math.random() * 10
      }));
    }, [quantity, size4.min, size4.max, speed.min, speed.max]);
    return /* @__PURE__ */ (0, import_jsx_runtime70.jsx)(
      "div",
      {
        className: cn(
          "absolute inset-0 overflow-hidden pointer-events-none",
          className
        ),
        children: particles.map((particle) => /* @__PURE__ */ (0, import_jsx_runtime70.jsx)(
          "div",
          {
            className: "absolute rounded-full animate-float-particle",
            style: {
              left: `${particle.x}%`,
              top: `${particle.y}%`,
              width: particle.size,
              height: particle.size,
              backgroundColor: color2,
              opacity: 0.4 + Math.random() * 0.4,
              animationDuration: `${particle.duration}s`,
              animationDelay: `${particle.delay}s`
            }
          },
          particle.id
        ))
      }
    );
  };
  var GlowingParticles = ({
    quantity = 20,
    color: color2 = "#007AFF",
    className
  }) => {
    const particles = import_react107.default.useMemo(() => {
      return Array.from({ length: quantity }, (_2, i3) => ({
        id: i3,
        x: Math.random() * 100,
        y: Math.random() * 100,
        size: 2 + Math.random() * 4,
        duration: 15 + Math.random() * 25,
        delay: Math.random() * 10
      }));
    }, [quantity]);
    return /* @__PURE__ */ (0, import_jsx_runtime70.jsx)(
      "div",
      {
        className: cn(
          "absolute inset-0 overflow-hidden pointer-events-none",
          className
        ),
        children: particles.map((particle) => /* @__PURE__ */ (0, import_jsx_runtime70.jsx)(
          "div",
          {
            className: "absolute rounded-full animate-glow-particle",
            style: {
              left: `${particle.x}%`,
              top: `${particle.y}%`,
              width: particle.size,
              height: particle.size,
              backgroundColor: color2,
              boxShadow: `0 0 ${particle.size * 3}px ${color2}, 0 0 ${particle.size * 6}px ${color2}40`,
              animationDuration: `${particle.duration}s`,
              animationDelay: `${particle.delay}s`
            }
          },
          particle.id
        ))
      }
    );
  };
  var particlesStyles = `
@keyframes float-particle {
  0%, 100% {
    transform: translateY(0) translateX(0);
  }
  25% {
    transform: translateY(-20px) translateX(10px);
  }
  50% {
    transform: translateY(-10px) translateX(-10px);
  }
  75% {
    transform: translateY(-30px) translateX(5px);
  }
}

@keyframes glow-particle {
  0%, 100% {
    transform: translateY(0) translateX(0) scale(1);
    opacity: 0.6;
  }
  33% {
    transform: translateY(-50px) translateX(30px) scale(1.2);
    opacity: 0.8;
  }
  66% {
    transform: translateY(-20px) translateX(-20px) scale(0.8);
    opacity: 0.4;
  }
}

.animate-float-particle {
  animation: float-particle 20s ease-in-out infinite;
}

.animate-glow-particle {
  animation: glow-particle 20s ease-in-out infinite;
}
`;
  if (typeof document !== "undefined") {
    const styleId = "auralix-particles-styles";
    if (!document.getElementById(styleId)) {
      const style = document.createElement("style");
      style.id = styleId;
      style.textContent = particlesStyles;
      document.head.appendChild(style);
    }
  }

  // src/components/Progress.tsx
  var import_jsx_runtime71 = __toESM(require_jsx_runtime());
  var Progress = ({
    value,
    max: max3 = 100,
    size: size4 = "md",
    variant = "default",
    showValue = false,
    animated: animated2 = false,
    className,
    label
  }) => {
    const percentage = Math.min(Math.max(value / max3 * 100, 0), 100);
    const sizeClasses2 = {
      sm: "h-1.5",
      md: "h-2.5",
      lg: "h-4"
    };
    const barVariants = {
      default: "bg-[#007AFF] dark:bg-[#0A84FF]",
      gradient: "bg-gradient-to-r from-[#007AFF] via-[#5856D6] to-[#AF52DE]",
      striped: "bg-[#007AFF] dark:bg-[#0A84FF] bg-stripes"
    };
    return /* @__PURE__ */ (0, import_jsx_runtime71.jsxs)("div", { className: cn("w-full", className), children: [
      (label || showValue) && /* @__PURE__ */ (0, import_jsx_runtime71.jsxs)("div", { className: "flex justify-between items-center mb-1.5", children: [
        label && /* @__PURE__ */ (0, import_jsx_runtime71.jsx)("span", { className: "text-sm font-medium text-foreground", children: label }),
        showValue && /* @__PURE__ */ (0, import_jsx_runtime71.jsxs)("span", { className: "text-sm text-muted-foreground", children: [
          Math.round(percentage),
          "%"
        ] })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime71.jsx)(
        "div",
        {
          className: cn(
            sizeClasses2[size4],
            "w-full rounded-full bg-muted/50 overflow-hidden",
            "dark:bg-zinc-800"
          ),
          role: "progressbar",
          "aria-valuenow": value,
          "aria-valuemin": 0,
          "aria-valuemax": max3,
          children: /* @__PURE__ */ (0, import_jsx_runtime71.jsx)(
            "div",
            {
              className: cn(
                "h-full rounded-full transition-all duration-300 ease-out",
                barVariants[variant],
                animated2 && "animate-pulse"
              ),
              style: { width: `${percentage}%` }
            }
          )
        }
      )
    ] });
  };
  var progressStyles = `
.bg-stripes {
  background-image: linear-gradient(
    45deg,
    rgba(255, 255, 255, 0.15) 25%,
    transparent 25%,
    transparent 50%,
    rgba(255, 255, 255, 0.15) 50%,
    rgba(255, 255, 255, 0.15) 75%,
    transparent 75%,
    transparent
  );
  background-size: 1rem 1rem;
  animation: progress-stripes 1s linear infinite;
}

@keyframes progress-stripes {
  from {
    background-position: 1rem 0;
  }
  to {
    background-position: 0 0;
  }
}
`;
  if (typeof document !== "undefined") {
    const styleId = "auralix-progress-styles";
    if (!document.getElementById(styleId)) {
      const style = document.createElement("style");
      style.id = styleId;
      style.textContent = progressStyles;
      document.head.appendChild(style);
    }
  }

  // src/components/Radio.tsx
  var import_react108 = __toESM(require_react());
  var import_jsx_runtime72 = __toESM(require_jsx_runtime());
  var RadioGroup = ({
    options,
    value,
    defaultValue,
    onChange,
    name,
    orientation = "vertical",
    size: size4 = "md",
    className
  }) => {
    const [selected, setSelected] = import_react108.default.useState(defaultValue || "");
    const controlledValue = value !== void 0 ? value : selected;
    const handleSelect = (optionValue) => {
      if (value === void 0) {
        setSelected(optionValue);
      }
      onChange?.(optionValue);
    };
    return /* @__PURE__ */ (0, import_jsx_runtime72.jsx)(
      "div",
      {
        role: "radiogroup",
        className: cn(
          "flex",
          orientation === "vertical" ? "flex-col gap-3" : "flex-row gap-4 flex-wrap",
          className
        ),
        children: options.map((option) => /* @__PURE__ */ (0, import_jsx_runtime72.jsx)(
          Radio,
          {
            option,
            name,
            size: size4,
            checked: controlledValue === option.value,
            onSelect: handleSelect
          },
          option.value
        ))
      }
    );
  };
  var Radio = ({
    option,
    name,
    size: size4,
    checked,
    onSelect
  }) => {
    const sizeClasses2 = {
      sm: "w-4 h-4",
      md: "w-5 h-5",
      lg: "w-6 h-6"
    };
    const dotSizes = {
      sm: "w-1.5 h-1.5",
      md: "w-2 h-2",
      lg: "w-2.5 h-2.5"
    };
    return /* @__PURE__ */ (0, import_jsx_runtime72.jsxs)(
      "label",
      {
        className: cn(
          "inline-flex items-start gap-3 cursor-pointer select-none group",
          option.disabled && "cursor-not-allowed opacity-50"
        ),
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime72.jsxs)("div", { className: "relative flex items-center justify-center pt-0.5", children: [
            /* @__PURE__ */ (0, import_jsx_runtime72.jsx)(
              "input",
              {
                type: "radio",
                name,
                value: option.value,
                checked,
                onChange: () => !option.disabled && onSelect(option.value),
                disabled: option.disabled,
                className: "sr-only"
              }
            ),
            /* @__PURE__ */ (0, import_jsx_runtime72.jsx)(
              "div",
              {
                className: cn(
                  sizeClasses2[size4],
                  "rounded-full border-2 transition-all duration-200 ease-out flex items-center justify-center",
                  checked ? "border-[#007AFF] bg-[#007AFF]" : "border-border/60 bg-background group-hover:border-[#007AFF]/50",
                  "dark:border-zinc-700 dark:bg-zinc-900",
                  checked && "dark:border-[#0A84FF] dark:bg-[#0A84FF]"
                ),
                children: /* @__PURE__ */ (0, import_jsx_runtime72.jsx)(
                  "div",
                  {
                    className: cn(
                      dotSizes[size4],
                      "rounded-full bg-white transition-all duration-200",
                      checked ? "opacity-100 scale-100" : "opacity-0 scale-0"
                    )
                  }
                )
              }
            )
          ] }),
          (option.label || option.description) && /* @__PURE__ */ (0, import_jsx_runtime72.jsxs)("div", { className: "flex flex-col", children: [
            option.label && /* @__PURE__ */ (0, import_jsx_runtime72.jsx)("span", { className: "text-sm font-medium text-foreground", children: option.label }),
            option.description && /* @__PURE__ */ (0, import_jsx_runtime72.jsx)("span", { className: "text-xs text-muted-foreground mt-0.5", children: option.description })
          ] })
        ]
      }
    );
  };

  // ../../node_modules/react-resizable-panels/dist/react-resizable-panels.js
  var import_jsx_runtime73 = __toESM(require_jsx_runtime2(), 1);
  var import_react109 = __toESM(require_react2(), 1);
  function z2(e2, t3 = "Assertion error") {
    if (!e2)
      throw Error(t3);
  }
  function V2({
    group: e2
  }) {
    const { orientation: t3, panels: n2 } = e2;
    return n2.reduce((o, i3) => (o += t3 === "horizontal" ? i3.element.offsetWidth : i3.element.offsetHeight, o), 0);
  }
  function le2(e2, t3) {
    return t3.sort(
      e2 === "horizontal" ? qe : Ye
    );
  }
  function qe(e2, t3) {
    const n2 = e2.element.offsetLeft - t3.element.offsetLeft;
    return n2 !== 0 ? n2 : e2.element.offsetWidth - t3.element.offsetWidth;
  }
  function Ye(e2, t3) {
    const n2 = e2.element.offsetTop - t3.element.offsetTop;
    return n2 !== 0 ? n2 : e2.element.offsetHeight - t3.element.offsetHeight;
  }
  function Me2(e2) {
    return e2 !== null && typeof e2 == "object" && "nodeType" in e2 && e2.nodeType === Node.ELEMENT_NODE;
  }
  function Ee2(e2, t3) {
    return {
      x: e2.x >= t3.left && e2.x <= t3.right ? 0 : Math.min(
        Math.abs(e2.x - t3.left),
        Math.abs(e2.x - t3.right)
      ),
      y: e2.y >= t3.top && e2.y <= t3.bottom ? 0 : Math.min(
        Math.abs(e2.y - t3.top),
        Math.abs(e2.y - t3.bottom)
      )
    };
  }
  function Je({
    orientation: e2,
    rects: t3,
    targetRect: n2
  }) {
    const o = {
      x: n2.x + n2.width / 2,
      y: n2.y + n2.height / 2
    };
    let i3, a = Number.MAX_VALUE;
    for (const l2 of t3) {
      const { x: r4, y: s } = Ee2(o, l2), u2 = e2 === "horizontal" ? r4 : s;
      u2 < a && (a = u2, i3 = l2);
    }
    return z2(i3, "No rect found"), i3;
  }
  function ke2(e2) {
    const { element: t3, orientation: n2, panels: o, separators: i3 } = e2, a = le2(
      n2,
      Array.from(t3.children).filter(Me2).map((f2) => ({ element: f2 }))
    ).map(({ element: f2 }) => f2), l2 = [];
    let r4 = false, s, u2 = [];
    for (const f2 of a)
      if (f2.hasAttribute("data-panel")) {
        const p3 = o.find(
          (h) => h.element === f2
        );
        if (p3) {
          if (s) {
            const h = s.element.getBoundingClientRect(), m3 = f2.getBoundingClientRect();
            let c;
            if (r4) {
              const d = n2 === "horizontal" ? new DOMRect(h.right, h.top, 0, h.height) : new DOMRect(
                h.left,
                h.bottom,
                h.width,
                0
              ), S2 = n2 === "horizontal" ? new DOMRect(m3.left, m3.top, 0, m3.height) : new DOMRect(m3.left, m3.top, m3.width, 0);
              switch (u2.length) {
                case 0: {
                  c = [
                    d,
                    S2
                  ];
                  break;
                }
                case 1: {
                  const y2 = u2[0], v2 = Je({
                    orientation: n2,
                    rects: [h, m3],
                    targetRect: y2.element.getBoundingClientRect()
                  });
                  c = [
                    y2,
                    v2 === h ? S2 : d
                  ];
                  break;
                }
                default: {
                  c = u2;
                  break;
                }
              }
            } else
              u2.length ? c = u2 : c = [
                n2 === "horizontal" ? new DOMRect(
                  h.right,
                  m3.top,
                  m3.left - h.right,
                  m3.height
                ) : new DOMRect(
                  m3.left,
                  h.bottom,
                  m3.width,
                  m3.top - h.bottom
                )
              ];
            for (const d of c)
              l2.push({
                group: e2,
                groupSize: V2({ group: e2 }),
                panels: [s, p3],
                separator: "width" in d ? void 0 : d,
                rect: "width" in d ? d : d.element.getBoundingClientRect()
              });
          }
          r4 = false, s = p3, u2 = [];
        }
      } else if (f2.hasAttribute("data-separator")) {
        const p3 = i3.find(
          (h) => h.element === f2
        );
        p3 ? u2.push(p3) : (s = void 0, u2 = []);
      } else
        r4 = true;
    return l2;
  }
  function Ze(e2, t3) {
    const n2 = getComputedStyle(e2), o = parseFloat(n2.fontSize);
    return t3 * o;
  }
  function Qe(e2, t3) {
    const n2 = getComputedStyle(e2.ownerDocument.body), o = parseFloat(n2.fontSize);
    return t3 * o;
  }
  function et(e2) {
    return e2 / 100 * window.innerHeight;
  }
  function tt2(e2) {
    return e2 / 100 * window.innerWidth;
  }
  function nt(e2) {
    switch (typeof e2) {
      case "number":
        return [e2, "px"];
      case "string": {
        const t3 = parseFloat(e2);
        return e2.endsWith("%") ? [t3, "%"] : e2.endsWith("px") ? [t3, "px"] : e2.endsWith("rem") ? [t3, "rem"] : e2.endsWith("em") ? [t3, "em"] : e2.endsWith("vh") ? [t3, "vh"] : e2.endsWith("vw") ? [t3, "vw"] : [t3, "%"];
      }
    }
  }
  function Z3({
    groupSize: e2,
    panelElement: t3,
    styleProp: n2
  }) {
    let o;
    const [i3, a] = nt(n2);
    switch (a) {
      case "%": {
        o = i3 / 100 * e2;
        break;
      }
      case "px": {
        o = i3;
        break;
      }
      case "rem": {
        o = Qe(t3, i3);
        break;
      }
      case "em": {
        o = Ze(t3, i3);
        break;
      }
      case "vh": {
        o = et(i3);
        break;
      }
      case "vw": {
        o = tt2(i3);
        break;
      }
    }
    return o;
  }
  function G2(e2) {
    return parseFloat(e2.toFixed(3));
  }
  function pe2(e2) {
    const { panels: t3 } = e2, n2 = V2({ group: e2 });
    return n2 === 0 ? t3.map((o) => ({
      collapsedSize: 0,
      collapsible: o.panelConstraints.collapsible === true,
      defaultSize: void 0,
      minSize: 0,
      maxSize: 100,
      panelId: o.id
    })) : t3.map((o) => {
      const { element: i3, panelConstraints: a } = o;
      let l2 = 0;
      if (a.collapsedSize) {
        const f2 = Z3({
          groupSize: n2,
          panelElement: i3,
          styleProp: a.collapsedSize
        });
        l2 = G2(f2 / n2 * 100);
      }
      let r4;
      if (a.defaultSize) {
        const f2 = Z3({
          groupSize: n2,
          panelElement: i3,
          styleProp: a.defaultSize
        });
        r4 = G2(f2 / n2 * 100);
      }
      let s = 0;
      if (a.minSize) {
        const f2 = Z3({
          groupSize: n2,
          panelElement: i3,
          styleProp: a.minSize
        });
        s = G2(f2 / n2 * 100);
      }
      let u2 = 100;
      if (a.maxSize) {
        const f2 = Z3({
          groupSize: n2,
          panelElement: i3,
          styleProp: a.maxSize
        });
        u2 = G2(f2 / n2 * 100);
      }
      return {
        collapsedSize: l2,
        collapsible: a.collapsible === true,
        defaultSize: r4,
        minSize: s,
        maxSize: u2,
        panelId: o.id
      };
    });
  }
  var _e2;
  var ot = class {
    constructor() {
      __privateAdd(this, _e2, {});
    }
    addListener(t3, n2) {
      const o = __privateGet(this, _e2)[t3];
      return o === void 0 ? __privateGet(this, _e2)[t3] = [n2] : o.includes(n2) || o.push(n2), () => {
        this.removeListener(t3, n2);
      };
    }
    emit(t3, n2) {
      const o = __privateGet(this, _e2)[t3];
      if (o !== void 0)
        if (o.length === 1)
          o[0].call(null, n2);
        else {
          let i3 = false, a = null;
          const l2 = Array.from(o);
          for (let r4 = 0; r4 < l2.length; r4++) {
            const s = l2[r4];
            try {
              s.call(null, n2);
            } catch (u2) {
              a === null && (i3 = true, a = u2);
            }
          }
          if (i3)
            throw a;
        }
    }
    removeAllListeners() {
      __privateSet(this, _e2, {});
    }
    removeListener(t3, n2) {
      const o = __privateGet(this, _e2)[t3];
      if (o !== void 0) {
        const i3 = o.indexOf(n2);
        i3 >= 0 && o.splice(i3, 1);
      }
    }
  };
  _e2 = new WeakMap();
  function M2(e2, t3, n2 = 0) {
    return Math.abs(G2(e2) - G2(t3)) <= n2;
  }
  var E = {
    cursorFlags: 0,
    interactionState: {
      state: "inactive"
    },
    mountedGroups: /* @__PURE__ */ new Map()
  };
  var A2 = new ot();
  function D3() {
    return E;
  }
  function I(e2) {
    const t3 = typeof e2 == "function" ? e2(E) : e2;
    if (E === t3)
      return E;
    const n2 = E;
    return E = {
      ...E,
      ...t3
    }, t3.cursorFlags !== void 0 && A2.emit("cursorFlagsChange", E.cursorFlags), t3.interactionState !== void 0 && A2.emit("interactionStateChange", E.interactionState), t3.mountedGroups !== void 0 && (E.mountedGroups.forEach((o, i3) => {
      o.derivedPanelConstraints.forEach((a) => {
        if (a.collapsible) {
          const { layout: l2 } = n2.mountedGroups.get(i3) ?? {};
          if (l2) {
            const r4 = M2(
              a.collapsedSize,
              o.layout[a.panelId]
            ), s = M2(
              a.collapsedSize,
              l2[a.panelId]
            );
            r4 && !s && (i3.inMemoryLastExpandedPanelSizes[a.panelId] = l2[a.panelId]);
          }
        }
      });
    }), A2.emit("mountedGroupsChange", E.mountedGroups)), E;
  }
  function rt(e2, t3) {
    if (e2.length !== t3.length)
      return false;
    for (let n2 = 0; n2 < e2.length; n2++)
      if (e2[n2] != t3[n2])
        return false;
    return true;
  }
  function X4(e2, t3) {
    return M2(e2, t3) ? 0 : e2 > t3 ? 1 : -1;
  }
  function H3({
    panelConstraints: e2,
    size: t3
  }) {
    const {
      collapsedSize: n2 = 0,
      collapsible: o,
      maxSize: i3 = 100,
      minSize: a = 0
    } = e2;
    if (X4(t3, a) < 0)
      if (o) {
        const l2 = (n2 + a) / 2;
        X4(t3, l2) < 0 ? t3 = n2 : t3 = a;
      } else
        t3 = a;
    return t3 = Math.min(i3, t3), t3 = G2(t3), t3;
  }
  function q2({
    delta: e2,
    initialLayout: t3,
    panelConstraints: n2,
    pivotIndices: o,
    prevLayout: i3,
    trigger: a
  }) {
    if (M2(e2, 0))
      return t3;
    const l2 = Object.values(t3), r4 = Object.values(i3), s = [...l2], [u2, f2] = o;
    z2(u2 != null, "Invalid first pivot index"), z2(f2 != null, "Invalid second pivot index");
    let p3 = 0;
    if (a === "keyboard") {
      {
        const c = e2 < 0 ? f2 : u2, d = n2[c];
        z2(
          d,
          `Panel constraints not found for index ${c}`
        );
        const {
          collapsedSize: S2 = 0,
          collapsible: y2,
          minSize: v2 = 0
        } = d;
        if (y2) {
          const x2 = l2[c];
          if (z2(
            x2 != null,
            `Previous layout not found for panel index ${c}`
          ), M2(x2, S2)) {
            const g2 = v2 - x2;
            X4(g2, Math.abs(e2)) > 0 && (e2 = e2 < 0 ? 0 - g2 : g2);
          }
        }
      }
      {
        const c = e2 < 0 ? u2 : f2, d = n2[c];
        z2(
          d,
          `No panel constraints found for index ${c}`
        );
        const {
          collapsedSize: S2 = 0,
          collapsible: y2,
          minSize: v2 = 0
        } = d;
        if (y2) {
          const x2 = l2[c];
          if (z2(
            x2 != null,
            `Previous layout not found for panel index ${c}`
          ), M2(x2, v2)) {
            const g2 = x2 - S2;
            X4(g2, Math.abs(e2)) > 0 && (e2 = e2 < 0 ? 0 - g2 : g2);
          }
        }
      }
    }
    {
      const c = e2 < 0 ? 1 : -1;
      let d = e2 < 0 ? f2 : u2, S2 = 0;
      for (; ; ) {
        const v2 = l2[d];
        z2(
          v2 != null,
          `Previous layout not found for panel index ${d}`
        );
        const g2 = H3({
          panelConstraints: n2[d],
          size: 100
        }) - v2;
        if (S2 += g2, d += c, d < 0 || d >= n2.length)
          break;
      }
      const y2 = Math.min(Math.abs(e2), Math.abs(S2));
      e2 = e2 < 0 ? 0 - y2 : y2;
    }
    {
      let d = e2 < 0 ? u2 : f2;
      for (; d >= 0 && d < n2.length; ) {
        const S2 = Math.abs(e2) - Math.abs(p3), y2 = l2[d];
        z2(
          y2 != null,
          `Previous layout not found for panel index ${d}`
        );
        const v2 = y2 - S2, x2 = H3({
          panelConstraints: n2[d],
          size: v2
        });
        if (!M2(y2, x2) && (p3 += y2 - x2, s[d] = x2, p3.toFixed(3).localeCompare(Math.abs(e2).toFixed(3), void 0, {
          numeric: true
        }) >= 0))
          break;
        e2 < 0 ? d-- : d++;
      }
    }
    if (rt(r4, s))
      return i3;
    {
      const c = e2 < 0 ? f2 : u2, d = l2[c];
      z2(
        d != null,
        `Previous layout not found for panel index ${c}`
      );
      const S2 = d + p3, y2 = H3({
        panelConstraints: n2[c],
        size: S2
      });
      if (s[c] = y2, !M2(y2, S2)) {
        let v2 = S2 - y2, g2 = e2 < 0 ? f2 : u2;
        for (; g2 >= 0 && g2 < n2.length; ) {
          const L2 = s[g2];
          z2(
            L2 != null,
            `Previous layout not found for panel index ${g2}`
          );
          const P2 = L2 + v2, R = H3({
            panelConstraints: n2[g2],
            size: P2
          });
          if (M2(L2, R) || (v2 -= R - L2, s[g2] = R), M2(v2, 0))
            break;
          e2 > 0 ? g2-- : g2++;
        }
      }
    }
    const h = Object.values(s).reduce(
      (c, d) => d + c,
      0
    );
    if (!M2(h, 100, 0.1))
      return i3;
    const m3 = Object.keys(i3);
    return s.reduce((c, d, S2) => (c[m3[S2]] = d, c), {});
  }
  function ee2(e2) {
    const { mountedGroups: t3 } = D3();
    for (const [n2] of t3)
      if (n2.separators.some(
        (o) => o.element === e2
      ))
        return n2;
    throw Error("Could not find parent Group for separator element");
  }
  function U4(e2, t3) {
    if (Object.keys(e2).length !== Object.keys(t3).length)
      return false;
    for (const n2 in e2)
      if (t3[n2] === void 0 || X4(e2[n2], t3[n2]) !== 0)
        return false;
    return true;
  }
  function F2({
    layout: e2,
    panelConstraints: t3
  }) {
    const o = [...Object.values(e2)], i3 = o.reduce(
      (r4, s) => r4 + s,
      0
    );
    if (o.length !== t3.length)
      throw Error(
        `Invalid ${t3.length} panel layout: ${o.map((r4) => `${r4}%`).join(", ")}`
      );
    if (!M2(i3, 100) && o.length > 0)
      for (let r4 = 0; r4 < t3.length; r4++) {
        const s = o[r4];
        z2(s != null, `No layout data found for index ${r4}`);
        const u2 = 100 / i3 * s;
        o[r4] = u2;
      }
    let a = 0;
    for (let r4 = 0; r4 < t3.length; r4++) {
      const s = o[r4];
      z2(s != null, `No layout data found for index ${r4}`);
      const u2 = H3({
        panelConstraints: t3[r4],
        size: s
      });
      s != u2 && (a += s - u2, o[r4] = u2);
    }
    if (!M2(a, 0))
      for (let r4 = 0; r4 < t3.length; r4++) {
        const s = o[r4];
        z2(s != null, `No layout data found for index ${r4}`);
        const u2 = s + a, f2 = H3({
          panelConstraints: t3[r4],
          size: u2
        });
        if (s !== f2 && (a -= f2 - s, o[r4] = f2, M2(a, 0)))
          break;
      }
    const l2 = Object.keys(e2);
    return o.reduce((r4, s, u2) => (r4[l2[u2]] = s, r4), {});
  }
  function Ie2({
    groupId: e2
  }) {
    const t3 = () => {
      const { mountedGroups: n2 } = D3();
      for (const [o, i3] of n2)
        if (o.id === e2)
          return { group: o, ...i3 };
      throw Error(`Could not find Group with id "${e2}"`);
    };
    return {
      getLayout() {
        const { defaultLayoutDeferred: n2, layout: o } = t3();
        return n2 ? {} : o;
      },
      setLayout(n2) {
        const {
          defaultLayoutDeferred: o,
          derivedPanelConstraints: i3,
          group: a,
          layout: l2,
          separatorToPanels: r4
        } = t3(), s = F2({
          layout: n2,
          panelConstraints: i3
        });
        return o ? l2 : (U4(l2, s) || I((u2) => ({
          mountedGroups: new Map(u2.mountedGroups).set(a, {
            defaultLayoutDeferred: o,
            derivedPanelConstraints: i3,
            layout: s,
            separatorToPanels: r4
          })
        })), s);
      }
    };
  }
  function Ge(e2) {
    const { mountedGroups: t3 } = D3(), n2 = t3.get(e2);
    return z2(n2, `Mounted Group ${e2.id} not found`), n2;
  }
  function _(e2, t3) {
    const n2 = ee2(e2), o = Ge(n2), i3 = n2.separators.find(
      (p3) => p3.element === e2
    );
    z2(i3, "Matching separator not found");
    const a = o.separatorToPanels.get(i3);
    z2(a, "Matching panels not found");
    const l2 = a.map((p3) => n2.panels.indexOf(p3)), s = Ie2({ groupId: n2.id }).getLayout(), u2 = q2({
      delta: t3,
      initialLayout: s,
      panelConstraints: o.derivedPanelConstraints,
      pivotIndices: l2,
      prevLayout: s,
      trigger: "keyboard"
    }), f2 = F2({
      layout: u2,
      panelConstraints: o.derivedPanelConstraints
    });
    U4(s, f2) || I((p3) => ({
      mountedGroups: new Map(p3.mountedGroups).set(n2, {
        defaultLayoutDeferred: o.defaultLayoutDeferred,
        derivedPanelConstraints: o.derivedPanelConstraints,
        layout: f2,
        separatorToPanels: o.separatorToPanels
      })
    }));
  }
  function he2(e2) {
    if (e2.defaultPrevented)
      return;
    const t3 = e2.currentTarget, n2 = ee2(t3);
    if (!n2.disabled)
      switch (e2.key) {
        case "ArrowDown": {
          e2.preventDefault(), n2.orientation === "vertical" && _(t3, 5);
          break;
        }
        case "ArrowLeft": {
          e2.preventDefault(), n2.orientation === "horizontal" && _(t3, -5);
          break;
        }
        case "ArrowRight": {
          e2.preventDefault(), n2.orientation === "horizontal" && _(t3, 5);
          break;
        }
        case "ArrowUp": {
          e2.preventDefault(), n2.orientation === "vertical" && _(t3, -5);
          break;
        }
        case "End": {
          e2.preventDefault(), _(t3, 100);
          break;
        }
        case "Enter": {
          e2.preventDefault();
          const o = ee2(t3), { derivedPanelConstraints: i3, layout: a, separatorToPanels: l2 } = Ge(o), r4 = o.separators.find(
            (p3) => p3.element === t3
          );
          z2(r4, "Matching separator not found");
          const s = l2.get(r4);
          z2(s, "Matching panels not found");
          const u2 = s[0], f2 = i3.find(
            (p3) => p3.panelId === u2.id
          );
          if (z2(f2, "Panel metadata not found"), f2.collapsible) {
            const p3 = a[u2.id], h = f2.collapsedSize === p3 ? o.inMemoryLastExpandedPanelSizes[u2.id] ?? f2.minSize : f2.collapsedSize;
            _(t3, h - p3);
          }
          break;
        }
        case "F6": {
          e2.preventDefault();
          const i3 = ee2(t3).separators.map(
            (s) => s.element
          ), a = Array.from(i3).findIndex(
            (s) => s === e2.currentTarget
          );
          z2(a !== null, "Index not found");
          const l2 = e2.shiftKey ? a > 0 ? a - 1 : i3.length - 1 : a + 1 < i3.length ? a + 1 : 0;
          i3[l2].focus();
          break;
        }
        case "Home": {
          e2.preventDefault(), _(t3, -100);
          break;
        }
      }
  }
  var it = (e2) => e2;
  var ie = () => {
  };
  var De2 = 1;
  var Oe = 2;
  var Te2 = 4;
  var Ne = 8;
  var me2 = {
    coarse: 10,
    precise: 5
  };
  function st(e2, t3, n2) {
    let o, i3 = {
      x: 1 / 0,
      y: 1 / 0
    };
    for (const a of t3) {
      const l2 = Ee2(n2, a.rect);
      switch (e2) {
        case "horizontal": {
          l2.x <= i3.x && (o = a, i3 = l2);
          break;
        }
        case "vertical": {
          l2.y <= i3.y && (o = a, i3 = l2);
          break;
        }
      }
    }
    return o ? {
      distance: i3,
      hitRegion: o
    } : void 0;
  }
  var Q2;
  function at() {
    return Q2 === void 0 && (typeof matchMedia == "function" ? Q2 = !!matchMedia("(pointer:coarse)").matches : Q2 = false), Q2;
  }
  function lt(e2) {
    return e2 !== null && typeof e2 == "object" && "nodeType" in e2 && e2.nodeType === Node.DOCUMENT_FRAGMENT_NODE;
  }
  function ut(e2, t3) {
    if (e2 === t3) throw new Error("Cannot compare node with itself");
    const n2 = {
      a: Se2(e2),
      b: Se2(t3)
    };
    let o;
    for (; n2.a.at(-1) === n2.b.at(-1); )
      e2 = n2.a.pop(), t3 = n2.b.pop(), o = e2;
    z2(
      o,
      "Stacking order can only be calculated for elements with a common ancestor"
    );
    const i3 = {
      a: ge(ye2(n2.a)),
      b: ge(ye2(n2.b))
    };
    if (i3.a === i3.b) {
      const a = o.childNodes, l2 = {
        a: n2.a.at(-1),
        b: n2.b.at(-1)
      };
      let r4 = a.length;
      for (; r4--; ) {
        const s = a[r4];
        if (s === l2.a) return 1;
        if (s === l2.b) return -1;
      }
    }
    return Math.sign(i3.a - i3.b);
  }
  var ct = /\b(?:position|zIndex|opacity|transform|webkitTransform|mixBlendMode|filter|webkitFilter|isolation)\b/;
  function ft(e2) {
    const t3 = getComputedStyle(_e3(e2) ?? e2).display;
    return t3 === "flex" || t3 === "inline-flex";
  }
  function dt(e2) {
    const t3 = getComputedStyle(e2);
    return !!(t3.position === "fixed" || t3.zIndex !== "auto" && (t3.position !== "static" || ft(e2)) || +t3.opacity < 1 || "transform" in t3 && t3.transform !== "none" || "webkitTransform" in t3 && t3.webkitTransform !== "none" || "mixBlendMode" in t3 && t3.mixBlendMode !== "normal" || "filter" in t3 && t3.filter !== "none" || "webkitFilter" in t3 && t3.webkitFilter !== "none" || "isolation" in t3 && t3.isolation === "isolate" || ct.test(t3.willChange) || t3.webkitOverflowScrolling === "touch");
  }
  function ye2(e2) {
    let t3 = e2.length;
    for (; t3--; ) {
      const n2 = e2[t3];
      if (z2(n2, "Missing node"), dt(n2)) return n2;
    }
    return null;
  }
  function ge(e2) {
    return e2 && Number(getComputedStyle(e2).zIndex) || 0;
  }
  function Se2(e2) {
    const t3 = [];
    for (; e2; )
      t3.push(e2), e2 = _e3(e2);
    return t3;
  }
  function _e3(e2) {
    const { parentNode: t3 } = e2;
    return lt(t3) ? t3.host : t3;
  }
  function pt(e2, t3) {
    return e2.x < t3.x + t3.width && e2.x + e2.width > t3.x && e2.y < t3.y + t3.height && e2.y + e2.height > t3.y;
  }
  function ht2({
    groupElement: e2,
    hitRegion: t3,
    pointerEventTarget: n2
  }) {
    if (!Me2(n2) || n2.contains(e2) || e2.contains(n2))
      return true;
    if (ut(n2, e2) > 0) {
      let o = n2;
      for (; o; ) {
        if (o.contains(e2))
          return true;
        if (pt(o.getBoundingClientRect(), t3))
          return false;
        o = o.parentElement;
      }
    }
    return true;
  }
  function Ae(e2, t3) {
    const n2 = [];
    return t3.forEach((o, i3) => {
      if (i3.disabled)
        return;
      const a = at() ? me2.coarse : me2.precise, l2 = ke2(i3), r4 = st(i3.orientation, l2, {
        x: e2.clientX,
        y: e2.clientY
      });
      r4 && r4.distance.x <= a && r4.distance.y <= a && ht2({
        groupElement: i3.element,
        hitRegion: r4.hitRegion.rect,
        pointerEventTarget: e2.target
      }) && n2.push(r4.hitRegion);
    }), n2;
  }
  function ve2(e2) {
    if (e2.defaultPrevented)
      return;
    if (e2.pointerType === "mouse" && e2.button > 0)
      return;
    const { mountedGroups: t3 } = D3(), n2 = Ae(e2, t3), o = /* @__PURE__ */ new Set(), i3 = /* @__PURE__ */ new Set(), a = /* @__PURE__ */ new Set(), l2 = /* @__PURE__ */ new Map();
    let r4 = false;
    n2.forEach((s) => {
      o.add(s.group), s.panels.forEach((f2) => {
        i3.add(f2);
      }), s.separator && (a.add(s.separator), r4 || (r4 = true, s.separator.element.focus()));
      const u2 = t3.get(s.group);
      u2 && l2.set(s.group, u2.layout);
    }), I({
      interactionState: {
        hitRegions: n2,
        initialLayoutMap: l2,
        pointerDownAtPoint: { x: e2.clientX, y: e2.clientY },
        state: "active"
      }
    }), n2.length && e2.preventDefault();
  }
  function mt({
    cursorFlags: e2,
    groups: t3,
    state: n2
  }) {
    let o = 0, i3 = 0;
    switch (n2) {
      case "active":
      case "hover":
        t3.forEach((a) => {
          if (!a.disableCursor)
            switch (a.orientation) {
              case "horizontal": {
                o++;
                break;
              }
              case "vertical": {
                i3++;
                break;
              }
            }
        });
    }
    if (o === 0 && i3 === 0)
      return null;
    switch (n2) {
      case "active": {
        const a = (e2 & De2) !== 0, l2 = (e2 & Oe) !== 0, r4 = (e2 & Te2) !== 0, s = (e2 & Ne) !== 0;
        if (e2) {
          if (a)
            return r4 ? "se-resize" : s ? "ne-resize" : "e-resize";
          if (l2)
            return r4 ? "sw-resize" : s ? "nw-resize" : "w-resize";
          if (r4)
            return "s-resize";
          if (s)
            return "n-resize";
        }
        break;
      }
    }
    return o > 0 && i3 > 0 ? "move" : o > 0 ? "ew-resize" : "ns-resize";
  }
  var xe2 = /* @__PURE__ */ new WeakMap();
  function ue2(e2) {
    if (e2.defaultView === null || e2.defaultView === void 0)
      return;
    let { prevStyle: t3, styleSheet: n2 } = xe2.get(e2) ?? {};
    n2 === void 0 && (n2 = new e2.defaultView.CSSStyleSheet(), e2.adoptedStyleSheets = [n2]);
    const { cursorFlags: o, interactionState: i3 } = D3();
    switch (i3.state) {
      case "active":
      case "hover": {
        const a = mt({
          cursorFlags: o,
          groups: i3.hitRegions.map((r4) => r4.group),
          state: i3.state
        }), l2 = `*{cursor: ${a} !important; ${i3.state === "active" ? "touch-action: none;" : ""} }`;
        if (t3 === l2)
          return;
        t3 = l2, a ? n2.cssRules.length === 0 ? n2.insertRule(l2) : n2.replaceSync(l2) : n2.cssRules.length === 1 && n2.deleteRule(0);
        break;
      }
      case "inactive": {
        t3 = void 0, n2.cssRules.length === 1 && n2.deleteRule(0);
        break;
      }
    }
    xe2.set(e2, {
      prevStyle: t3,
      styleSheet: n2
    });
  }
  function Fe({
    document: e2,
    event: t3,
    hitRegions: n2,
    initialLayoutMap: o,
    mountedGroups: i3,
    pointerDownAtPoint: a
  }) {
    let l2 = 0;
    const r4 = new Map(i3);
    n2.forEach((s) => {
      const { group: u2, groupSize: f2 } = s, { disableCursor: p3, orientation: h, panels: m3 } = u2;
      let c = 0;
      a ? h === "horizontal" ? c = (t3.clientX - a.x) / f2 * 100 : c = (t3.clientY - a.y) / f2 * 100 : h === "horizontal" ? c = t3.clientX < 0 ? -100 : 100 : c = t3.clientY < 0 ? -100 : 100;
      const d = o.get(u2), {
        defaultLayoutDeferred: S2,
        derivedPanelConstraints: y2,
        layout: v2,
        separatorToPanels: x2
      } = i3.get(u2) ?? { defaultLayoutDeferred: false };
      if (y2 && d && v2 && x2) {
        const g2 = q2({
          delta: c,
          initialLayout: d,
          panelConstraints: y2,
          pivotIndices: s.panels.map((L2) => m3.indexOf(L2)),
          prevLayout: v2,
          trigger: "mouse-or-touch"
        });
        if (U4(g2, v2)) {
          if (c !== 0 && !p3)
            switch (h) {
              case "horizontal": {
                l2 |= c < 0 ? De2 : Oe;
                break;
              }
              case "vertical": {
                l2 |= c < 0 ? Te2 : Ne;
                break;
              }
            }
        } else {
          r4.set(s.group, {
            defaultLayoutDeferred: S2,
            derivedPanelConstraints: y2,
            layout: g2,
            separatorToPanels: x2
          });
          const L2 = s.group.panels.map(({ id: P2 }) => P2).join(",");
          s.group.inMemoryLayouts[L2] = g2;
        }
      }
    }), I({
      cursorFlags: l2,
      mountedGroups: r4
    }), ue2(e2);
  }
  function ze(e2) {
    const { interactionState: t3, mountedGroups: n2 } = D3();
    switch (t3.state) {
      case "active":
        Fe({
          document: e2.currentTarget,
          event: e2,
          hitRegions: t3.hitRegions,
          initialLayoutMap: t3.initialLayoutMap,
          mountedGroups: n2
        });
    }
  }
  function be2(e2) {
    if (e2.defaultPrevented)
      return;
    const { interactionState: t3, mountedGroups: n2 } = D3();
    switch (t3.state) {
      case "active": {
        if (
          // Skip this check for "pointerleave" events, else Firefox triggers a false positive (see #514)
          e2.buttons === 0
        ) {
          I(
            (o) => o.interactionState.state === "inactive" ? o : {
              cursorFlags: 0,
              interactionState: {
                state: "inactive"
              }
            }
          );
          return;
        }
        Fe({
          document: e2.currentTarget,
          event: e2,
          hitRegions: t3.hitRegions,
          initialLayoutMap: t3.initialLayoutMap,
          mountedGroups: n2,
          pointerDownAtPoint: t3.pointerDownAtPoint
        });
        break;
      }
      default: {
        const o = Ae(e2, n2);
        o.length === 0 ? t3.state !== "inactive" && I({
          interactionState: { state: "inactive" }
        }) : I({
          interactionState: {
            hitRegions: o,
            state: "hover"
          }
        }), ue2(e2.currentTarget);
        break;
      }
    }
  }
  function we2(e2) {
    if (e2.defaultPrevented)
      return;
    if (e2.pointerType === "mouse" && e2.button > 0)
      return;
    e2.preventDefault();
    const { interactionState: t3 } = D3();
    switch (t3.state) {
      case "active":
        I({
          cursorFlags: 0,
          interactionState: {
            state: "inactive"
          }
        }), ue2(e2.currentTarget);
    }
  }
  function Le(e2) {
    let t3 = 0, n2 = 0;
    const o = {};
    for (const a of e2)
      if (a.defaultSize !== void 0) {
        t3++;
        const l2 = G2(a.defaultSize);
        n2 += l2, o[a.panelId] = l2;
      } else
        o[a.panelId] = void 0;
    const i3 = e2.length - t3;
    if (i3 !== 0) {
      const a = G2((100 - n2) / i3);
      for (const l2 of e2)
        l2.defaultSize === void 0 && (o[l2.panelId] = a);
    }
    return o;
  }
  function yt(e2, t3, n2) {
    if (!n2[0])
      return;
    const i3 = e2.panels.find((u2) => u2.element === t3);
    if (!i3 || !i3.onResize)
      return;
    const a = V2({ group: e2 }), l2 = e2.orientation === "horizontal" ? i3.element.offsetWidth : i3.element.offsetHeight, r4 = i3.mutableValues.prevSize, s = {
      asPercentage: G2(l2 / a * 100),
      inPixels: l2
    };
    i3.mutableValues.prevSize = s, i3.onResize(s, i3.id, r4);
  }
  function gt2(e2, t3) {
    if (Object.keys(e2).length !== Object.keys(t3).length)
      return false;
    for (const o in e2)
      if (e2[o] !== t3[o])
        return false;
    return true;
  }
  function St2(e2, t3) {
    const n2 = e2.map((i3) => i3.id), o = Object.keys(t3);
    if (n2.length !== o.length)
      return false;
    for (const i3 of n2)
      if (!o.includes(i3))
        return false;
    return true;
  }
  var j = /* @__PURE__ */ new Map();
  function vt2(e2) {
    let t3 = true;
    z2(
      e2.element.ownerDocument.defaultView,
      "Cannot register an unmounted Group"
    );
    const n2 = e2.element.ownerDocument.defaultView.ResizeObserver, o = /* @__PURE__ */ new Set(), i3 = /* @__PURE__ */ new Set(), a = new n2((c) => {
      for (const d of c) {
        const { borderBoxSize: S2, target: y2 } = d;
        if (y2 === e2.element) {
          if (t3) {
            if (V2({ group: e2 }) === 0)
              return;
            I((x2) => {
              const g2 = x2.mountedGroups.get(e2);
              if (g2) {
                const L2 = pe2(e2), P2 = g2.defaultLayoutDeferred ? Le(L2) : g2.layout, R = F2({
                  layout: P2,
                  panelConstraints: L2
                });
                return !g2.defaultLayoutDeferred && U4(P2, R) && gt2(
                  g2.derivedPanelConstraints,
                  L2
                ) ? x2 : {
                  mountedGroups: new Map(x2.mountedGroups).set(e2, {
                    defaultLayoutDeferred: false,
                    derivedPanelConstraints: L2,
                    layout: R,
                    separatorToPanels: g2.separatorToPanels
                  })
                };
              }
              return x2;
            });
          }
        } else
          yt(e2, y2, S2);
      }
    });
    a.observe(e2.element), e2.panels.forEach((c) => {
      z2(
        !o.has(c.id),
        `Panel ids must be unique; id "${c.id}" was used more than once`
      ), o.add(c.id), c.onResize && a.observe(c.element);
    });
    const l2 = V2({ group: e2 }), r4 = pe2(e2), s = e2.panels.map(({ id: c }) => c).join(",");
    let u2 = e2.defaultLayout;
    u2 && (St2(e2.panels, u2) || (u2 = void 0));
    const f2 = e2.inMemoryLayouts[s] ?? u2 ?? Le(r4), p3 = F2({
      layout: f2,
      panelConstraints: r4
    }), h = ke2(e2), m3 = e2.element.ownerDocument;
    return I((c) => {
      const d = /* @__PURE__ */ new Map();
      return j.set(
        m3,
        (j.get(m3) ?? 0) + 1
      ), h.forEach((S2) => {
        S2.separator && d.set(S2.separator, S2.panels);
      }), {
        mountedGroups: new Map(c.mountedGroups).set(e2, {
          defaultLayoutDeferred: l2 === 0,
          derivedPanelConstraints: r4,
          layout: p3,
          separatorToPanels: d
        })
      };
    }), e2.separators.forEach((c) => {
      z2(
        !i3.has(c.id),
        `Separator ids must be unique; id "${c.id}" was used more than once`
      ), i3.add(c.id), c.element.addEventListener("keydown", he2);
    }), j.get(m3) === 1 && (m3.addEventListener("pointerdown", ve2, true), m3.addEventListener("pointerleave", ze), m3.addEventListener("pointermove", be2), m3.addEventListener("pointerup", we2, true)), function() {
      t3 = false, j.set(
        m3,
        Math.max(0, (j.get(m3) ?? 0) - 1)
      ), I((d) => {
        const S2 = new Map(d.mountedGroups);
        return S2.delete(e2), { mountedGroups: S2 };
      }), e2.separators.forEach((d) => {
        d.element.removeEventListener("keydown", he2);
      }), j.get(m3) || (m3.removeEventListener(
        "pointerdown",
        ve2,
        true
      ), m3.removeEventListener("pointerleave", ze), m3.removeEventListener("pointermove", be2), m3.removeEventListener("pointerup", we2, true)), a.disconnect();
    };
  }
  function $e() {
    const [e2, t3] = (0, import_react109.useState)({}), n2 = (0, import_react109.useCallback)(() => t3({}), []);
    return [e2, n2];
  }
  function ce2(e2) {
    const t3 = (0, import_react109.useId)();
    return `${e2 ?? t3}`;
  }
  var $4 = typeof window < "u" ? import_react109.useLayoutEffect : import_react109.useEffect;
  function te(e2) {
    const t3 = (0, import_react109.useRef)(e2);
    return $4(() => {
      t3.current = e2;
    }, [e2]), (0, import_react109.useCallback)(
      (...n2) => t3.current?.(...n2),
      [t3]
    );
  }
  function fe2(...e2) {
    return te((t3) => {
      e2.forEach((n2) => {
        if (n2)
          switch (typeof n2) {
            case "function": {
              n2(t3);
              break;
            }
            case "object": {
              n2.current = t3;
              break;
            }
          }
      });
    });
  }
  function xt2(e2) {
    const t3 = (0, import_react109.useRef)({ ...e2 });
    return $4(() => {
      for (const n2 in e2)
        t3.current[n2] = e2[n2];
    }, [e2]), t3.current;
  }
  var je = (0, import_react109.createContext)(null);
  function zt(e2, t3) {
    const n2 = (0, import_react109.useRef)({
      getLayout: () => ({}),
      setLayout: it
    });
    (0, import_react109.useImperativeHandle)(t3, () => n2.current, []), $4(() => {
      Object.assign(
        n2.current,
        Ie2({ groupId: e2 })
      );
    });
  }
  function bt2({
    children: e2,
    className: t3,
    defaultLayout: n2,
    disableCursor: o,
    disabled: i3,
    elementRef: a,
    groupRef: l2,
    id: r4,
    onLayoutChange: s,
    orientation: u2 = "horizontal",
    style: f2,
    ...p3
  }) {
    const h = (0, import_react109.useRef)({}), m3 = te((b2) => {
      U4(h.current, b2) || (h.current = b2, s?.(b2));
    }), c = ce2(r4), d = (0, import_react109.useRef)(null), [S2, y2] = $e(), v2 = (0, import_react109.useRef)({
      lastExpandedPanelSizes: {},
      layouts: {},
      panels: [],
      separators: []
    }), x2 = fe2(d, a);
    zt(c, l2);
    const g2 = te(
      (b2, w2) => {
        const { interactionState: C2, mountedGroups: O } = D3();
        for (const T2 of O.keys())
          if (T2.id === b2) {
            const N2 = O.get(T2);
            if (N2) {
              let Y5 = false;
              switch (C2.state) {
                case "active": {
                  Y5 = C2.hitRegions.some(
                    (ne) => ne.group === T2
                  );
                  break;
                }
              }
              return {
                flexGrow: N2.layout[w2] ?? 1,
                pointerEvents: Y5 ? "none" : void 0
              };
            }
          }
        return {
          flexGrow: n2?.[w2] ?? 1
        };
      }
    ), L2 = (0, import_react109.useMemo)(
      () => ({
        getPanelStyles: g2,
        id: c,
        orientation: u2,
        registerPanel: (b2) => {
          const w2 = v2.current;
          return w2.panels = le2(u2, [
            ...w2.panels,
            b2
          ]), y2(), () => {
            w2.panels = w2.panels.filter(
              (C2) => C2 !== b2
            ), y2();
          };
        },
        registerSeparator: (b2) => {
          const w2 = v2.current;
          return w2.separators = le2(u2, [
            ...w2.separators,
            b2
          ]), y2(), () => {
            w2.separators = w2.separators.filter(
              (C2) => C2 !== b2
            ), y2();
          };
        }
      }),
      [g2, c, y2, u2]
    ), P2 = xt2({
      defaultLayout: n2,
      disableCursor: o
    }), R = (0, import_react109.useRef)(null);
    return $4(() => {
      const b2 = d.current;
      if (b2 === null)
        return;
      const w2 = v2.current, C2 = {
        defaultLayout: P2.defaultLayout,
        disableCursor: !!P2.disableCursor,
        disabled: !!i3,
        element: b2,
        id: c,
        inMemoryLastExpandedPanelSizes: v2.current.lastExpandedPanelSizes,
        inMemoryLayouts: v2.current.layouts,
        orientation: u2,
        panels: w2.panels,
        separators: w2.separators
      };
      R.current = C2;
      const O = vt2(C2), N2 = D3().mountedGroups.get(C2);
      if (N2) {
        const { defaultLayoutDeferred: W3, derivedPanelConstraints: J3, layout: oe } = N2;
        !W3 && J3.length > 0 && (m3?.(oe), w2.panels.forEach((re2) => {
          re2.scheduleUpdate();
        }));
      }
      const Y5 = A2.addListener(
        "interactionStateChange",
        () => {
          w2.panels.forEach((W3) => {
            W3.scheduleUpdate();
          });
        }
      ), ne = A2.addListener(
        "mountedGroupsChange",
        (W3) => {
          const J3 = W3.get(C2);
          if (J3) {
            const { defaultLayoutDeferred: oe, derivedPanelConstraints: re2, layout: He } = J3;
            if (oe || re2.length === 0)
              return;
            m3?.(He), w2.panels.forEach((Ve) => {
              Ve.scheduleUpdate();
            });
          }
        }
      );
      return () => {
        R.current = null, O(), Y5(), ne();
      };
    }, [
      i3,
      c,
      m3,
      u2,
      S2,
      P2
    ]), (0, import_react109.useEffect)(() => {
      const b2 = R.current;
      b2 && (b2.defaultLayout = n2, b2.disableCursor = !!o);
    }), /* @__PURE__ */ (0, import_jsx_runtime73.jsx)(je.Provider, { value: L2, children: /* @__PURE__ */ (0, import_jsx_runtime73.jsx)(
      "div",
      {
        ...p3,
        "aria-orientation": u2,
        className: t3,
        "data-group": true,
        "data-testid": c,
        id: c,
        ref: x2,
        style: {
          height: "100%",
          width: "100%",
          overflow: "hidden",
          ...f2,
          display: "flex",
          flexDirection: u2 === "horizontal" ? "row" : "column",
          flexWrap: "nowrap"
        },
        children: e2
      }
    ) });
  }
  bt2.displayName = "Group";
  function de2() {
    const e2 = (0, import_react109.useContext)(je);
    return z2(
      e2,
      "Group Context not found; did you render a Panel or Separator outside of a Group?"
    ), e2;
  }
  function Pt2({
    groupId: e2,
    panelId: t3
  }) {
    const n2 = () => {
      const { mountedGroups: r4 } = D3();
      for (const [
        s,
        {
          defaultLayoutDeferred: u2,
          derivedPanelConstraints: f2,
          layout: p3,
          separatorToPanels: h
        }
      ] of r4)
        if (s.id === e2)
          return {
            defaultLayoutDeferred: u2,
            derivedPanelConstraints: f2,
            group: s,
            layout: p3,
            separatorToPanels: h
          };
      throw Error(`Group ${e2} not found`);
    }, o = () => {
      const r4 = n2().derivedPanelConstraints.find(
        (s) => s.panelId === t3
      );
      if (r4 !== void 0)
        return r4;
      throw Error(`Panel constraints not found for Panel ${t3}`);
    }, i3 = () => {
      const r4 = n2().group.panels.find((s) => s.id === t3);
      if (r4 !== void 0)
        return r4;
      throw Error(`Layout not found for Panel ${t3}`);
    }, a = () => {
      const r4 = n2().layout[t3];
      if (r4 !== void 0)
        return r4;
      throw Error(`Layout not found for Panel ${t3}`);
    }, l2 = (r4) => {
      const s = a();
      if (r4 === s)
        return;
      const {
        defaultLayoutDeferred: u2,
        derivedPanelConstraints: f2,
        group: p3,
        layout: h,
        separatorToPanels: m3
      } = n2(), c = p3.panels.findIndex((v2) => v2.id === t3), d = c === p3.panels.length - 1, S2 = q2({
        delta: d ? s - r4 : r4 - s,
        initialLayout: h,
        panelConstraints: f2,
        pivotIndices: d ? [c - 1, c] : [c, c + 1],
        prevLayout: h,
        trigger: "imperative-api"
      }), y2 = F2({
        layout: S2,
        panelConstraints: f2
      });
      U4(h, y2) || I((v2) => ({
        mountedGroups: new Map(v2.mountedGroups).set(p3, {
          defaultLayoutDeferred: u2,
          derivedPanelConstraints: f2,
          layout: y2,
          separatorToPanels: m3
        })
      }));
    };
    return {
      collapse: () => {
        const { collapsible: r4, collapsedSize: s } = o(), { mutableValues: u2 } = i3(), f2 = a();
        r4 && f2 !== s && (u2.expandToSize = f2, l2(s));
      },
      expand: () => {
        const { collapsible: r4, collapsedSize: s, minSize: u2 } = o(), { mutableValues: f2 } = i3(), p3 = a();
        if (r4 && p3 === s) {
          let h = f2.expandToSize ?? u2;
          h === 0 && (h = 1), l2(h);
        }
      },
      getSize: () => {
        const { group: r4 } = n2(), s = a(), { element: u2 } = i3(), f2 = r4.orientation === "horizontal" ? u2.offsetWidth : u2.offsetHeight;
        return {
          asPercentage: s,
          inPixels: f2
        };
      },
      isCollapsed: () => {
        const { collapsible: r4, collapsedSize: s } = o(), u2 = a();
        return r4 && M2(s, u2);
      },
      resize: (r4) => {
        if (a() !== r4) {
          let u2;
          switch (typeof r4) {
            case "number": {
              const { group: f2 } = n2(), p3 = V2({ group: f2 });
              u2 = G2(r4 / p3 * 100);
              break;
            }
            case "string": {
              u2 = parseFloat(r4);
              break;
            }
          }
          l2(u2);
        }
      }
    };
  }
  function Rt(e2, t3) {
    const { id: n2 } = de2(), o = (0, import_react109.useRef)({
      collapse: ie,
      expand: ie,
      getSize: () => ({
        asPercentage: 0,
        inPixels: 0
      }),
      isCollapsed: () => false,
      resize: ie
    });
    (0, import_react109.useImperativeHandle)(t3, () => o.current, []), $4(() => {
      Object.assign(
        o.current,
        Pt2({ groupId: n2, panelId: e2 })
      );
    });
  }
  function Ct({
    children: e2,
    className: t3,
    collapsedSize: n2 = "0%",
    collapsible: o = false,
    defaultSize: i3,
    elementRef: a,
    id: l2,
    maxSize: r4 = "100%",
    minSize: s = "0%",
    onResize: u2,
    panelRef: f2,
    style: p3,
    ...h
  }) {
    const m3 = !!l2, c = ce2(l2), d = (0, import_react109.useRef)(null), S2 = fe2(d, a), [, y2] = $e(), { getPanelStyles: v2, id: x2, registerPanel: g2 } = de2(), L2 = u2 !== null, P2 = te(
      (b2, w2, C2) => {
        u2?.(b2, l2, C2);
      }
    );
    $4(() => {
      const b2 = d.current;
      if (b2 !== null)
        return g2({
          element: b2,
          id: c,
          idIsStable: m3,
          mutableValues: {
            expandToSize: void 0,
            prevSize: void 0
          },
          onResize: L2 ? P2 : void 0,
          panelConstraints: {
            collapsedSize: n2,
            collapsible: o,
            defaultSize: i3,
            maxSize: r4,
            minSize: s
          },
          scheduleUpdate: y2
        });
    }, [
      n2,
      o,
      i3,
      y2,
      L2,
      c,
      m3,
      r4,
      s,
      P2,
      g2
    ]), Rt(c, f2);
    const R = v2(x2, c);
    return /* @__PURE__ */ (0, import_jsx_runtime73.jsx)(
      "div",
      {
        ...h,
        "data-panel": true,
        "data-testid": c,
        id: c,
        ref: S2,
        style: {
          ...Mt,
          flexBasis: 0,
          flexShrink: 1,
          // Prevent Panel content from interfering with panel size
          overflow: "hidden",
          ...R
        },
        children: /* @__PURE__ */ (0, import_jsx_runtime73.jsx)(
          "div",
          {
            className: t3,
            style: {
              width: "100%",
              height: "100%",
              ...p3
            },
            children: e2
          }
        )
      }
    );
  }
  Ct.displayName = "Panel";
  var Mt = {
    minHeight: 0,
    maxHeight: "100%",
    height: "auto",
    minWidth: 0,
    maxWidth: "100%",
    width: "auto",
    border: "none",
    borderWidth: 0,
    padding: 0,
    margin: 0
  };
  function Et2({
    layout: e2,
    panelConstraints: t3,
    panelId: n2,
    panelIndex: o
  }) {
    let i3, a;
    const l2 = e2[n2], r4 = t3.find(
      (s) => s.panelId === n2
    );
    if (r4) {
      const s = r4.maxSize, u2 = a = r4.collapsible ? r4.collapsedSize : r4.minSize, f2 = [o, o + 1];
      a = F2({
        layout: q2({
          delta: u2 - l2,
          initialLayout: e2,
          panelConstraints: t3,
          pivotIndices: f2,
          prevLayout: e2,
          trigger: "keyboard"
        }),
        panelConstraints: t3
      })[n2], i3 = F2({
        layout: q2({
          delta: s - l2,
          initialLayout: e2,
          panelConstraints: t3,
          pivotIndices: f2,
          prevLayout: e2,
          trigger: "keyboard"
        }),
        panelConstraints: t3
      })[n2];
    }
    return {
      valueControls: n2,
      valueMax: i3,
      valueMin: a,
      valueNow: l2
    };
  }
  function kt2({
    children: e2,
    className: t3,
    elementRef: n2,
    id: o,
    style: i3,
    ...a
  }) {
    const l2 = ce2(o), [r4, s] = (0, import_react109.useState)({}), [u2, f2] = (0, import_react109.useState)("inactive"), p3 = (0, import_react109.useRef)(null), h = fe2(p3, n2), {
      id: m3,
      orientation: c,
      registerSeparator: d
    } = de2(), S2 = c === "horizontal" ? "vertical" : "horizontal";
    return $4(() => {
      const y2 = p3.current;
      if (y2 !== null) {
        const v2 = {
          element: y2,
          id: l2
        }, x2 = d(v2), g2 = A2.addListener(
          "interactionStateChange",
          (P2) => {
            f2(
              P2.state !== "inactive" && P2.hitRegions.some(
                (R) => R.separator === v2
              ) ? P2.state : "inactive"
            );
          }
        ), L2 = A2.addListener(
          "mountedGroupsChange",
          (P2) => {
            P2.forEach(
              ({ derivedPanelConstraints: R, layout: b2, separatorToPanels: w2 }, C2) => {
                if (C2.id === m3) {
                  const O = w2.get(v2);
                  if (O) {
                    const T2 = O[0], N2 = C2.panels.indexOf(T2);
                    s(
                      Et2({
                        layout: b2,
                        panelConstraints: R,
                        panelId: T2.id,
                        panelIndex: N2
                      })
                    );
                  }
                }
              }
            );
          }
        );
        return () => {
          g2(), L2(), x2();
        };
      }
    }, [m3, l2, d]), /* @__PURE__ */ (0, import_jsx_runtime73.jsx)(
      "div",
      {
        ...a,
        "aria-controls": r4.valueControls,
        "aria-orientation": S2,
        "aria-valuemax": r4.valueMax,
        "aria-valuemin": r4.valueMin,
        "aria-valuenow": r4.valueNow,
        children: e2,
        className: t3,
        "data-separator": u2,
        "data-testid": l2,
        id: l2,
        ref: h,
        role: "separator",
        style: {
          flexBasis: "auto",
          ...i3,
          flexGrow: 0,
          flexShrink: 0
        },
        tabIndex: 0
      }
    );
  }
  kt2.displayName = "Separator";

  // src/components/Resizable.tsx
  var import_jsx_runtime74 = __toESM(require_jsx_runtime());
  var ResizablePanelGroup = ({
    className,
    ...props
  }) => /* @__PURE__ */ (0, import_jsx_runtime74.jsx)(
    bt2,
    {
      className: cn(
        "flex h-full w-full data-[panel-group-direction=vertical]:flex-col",
        className
      ),
      ...props
    }
  );
  var ResizablePanel = Ct;
  var ResizableHandle = ({
    withHandle,
    className,
    ...props
  }) => /* @__PURE__ */ (0, import_jsx_runtime74.jsx)(
    kt2,
    {
      className: cn(
        "relative flex w-px items-center justify-center bg-border after:absolute after:inset-y-0 after:left-1/2 after:w-1 after:-translate-x-1/2 focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring focus-visible:ring-offset-1 data-[panel-group-direction=vertical]:h-px data-[panel-group-direction=vertical]:w-full data-[panel-group-direction=vertical]:after:left-0 data-[panel-group-direction=vertical]:after:h-1 data-[panel-group-direction=vertical]:after:w-full data-[panel-group-direction=vertical]:after:translate-y-1/2 data-[panel-group-direction=vertical]:after:translate-x-0 [&[data-panel-group-direction=vertical]>div]:rotate-90",
        className
      ),
      ...props,
      children: withHandle && /* @__PURE__ */ (0, import_jsx_runtime74.jsx)("div", { className: "z-10 flex h-4 w-3 items-center justify-center rounded-sm border bg-border", children: /* @__PURE__ */ (0, import_jsx_runtime74.jsx)(GripVertical, { className: "h-2.5 w-2.5" }) })
    }
  );

  // src/components/Ripple.tsx
  var import_react110 = __toESM(require_react());
  var import_jsx_runtime75 = __toESM(require_jsx_runtime());
  var Ripple = ({
    className,
    color: color2 = "#007AFF",
    duration = 600
  }) => {
    const [ripples, setRipples] = import_react110.default.useState([]);
    const handleClick = (e2) => {
      const rect = e2.currentTarget.getBoundingClientRect();
      const x2 = e2.clientX - rect.left;
      const y2 = e2.clientY - rect.top;
      const id3 = Date.now();
      setRipples((prev) => [...prev, { x: x2, y: y2, id: id3 }]);
      setTimeout(() => {
        setRipples((prev) => prev.filter((r4) => r4.id !== id3));
      }, duration);
    };
    return /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(
      "div",
      {
        className: cn("absolute inset-0 overflow-hidden", className),
        onClick: handleClick,
        children: ripples.map((ripple) => /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(
          "span",
          {
            className: "absolute rounded-full animate-ripple pointer-events-none",
            style: {
              left: ripple.x,
              top: ripple.y,
              backgroundColor: color2,
              animationDuration: `${duration}ms`
            }
          },
          ripple.id
        ))
      }
    );
  };
  var RippleButton = ({
    children,
    rippleColor = "rgba(255, 255, 255, 0.3)",
    className,
    ...props
  }) => {
    const [ripples, setRipples] = import_react110.default.useState([]);
    const handleClick = (e2) => {
      const rect = e2.currentTarget.getBoundingClientRect();
      const x2 = e2.clientX - rect.left;
      const y2 = e2.clientY - rect.top;
      const id3 = Date.now();
      setRipples((prev) => [...prev, { x: x2, y: y2, id: id3 }]);
      setTimeout(() => {
        setRipples((prev) => prev.filter((r4) => r4.id !== id3));
      }, 600);
      props.onClick?.(e2);
    };
    return /* @__PURE__ */ (0, import_jsx_runtime75.jsxs)(
      "button",
      {
        className: cn(
          "relative overflow-hidden px-4 py-2 rounded-xl font-medium",
          "bg-[#007AFF] text-white hover:bg-[#0056D2] transition-colors",
          "dark:bg-[#0A84FF] dark:hover:bg-[#0070E0]",
          className
        ),
        onClick: handleClick,
        ...props,
        children: [
          children,
          ripples.map((ripple) => /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(
            "span",
            {
              className: "absolute rounded-full animate-ripple pointer-events-none",
              style: {
                left: ripple.x,
                top: ripple.y,
                backgroundColor: rippleColor
              }
            },
            ripple.id
          ))
        ]
      }
    );
  };
  var rippleStyles = `
@keyframes ripple {
  0% {
    transform: translate(-50%, -50%) scale(0);
    opacity: 0.5;
  }
  100% {
    transform: translate(-50%, -50%) scale(4);
    opacity: 0;
  }
}
.animate-ripple {
  animation: ripple 600ms ease-out forwards;
  width: 100px;
  height: 100px;
}
`;
  if (typeof document !== "undefined") {
    const styleId = "auralix-ripple-styles";
    if (!document.getElementById(styleId)) {
      const style = document.createElement("style");
      style.id = styleId;
      style.textContent = rippleStyles;
      document.head.appendChild(style);
    }
  }

  // src/components/SafariMockup.tsx
  var import_jsx_runtime76 = __toESM(require_jsx_runtime());
  var SafariMockup = ({
    url = "auralix-ui.dev",
    children,
    className
  }) => {
    return /* @__PURE__ */ (0, import_jsx_runtime76.jsxs)(
      "div",
      {
        className: cn(
          "rounded-xl overflow-hidden border border-border/50 bg-background shadow-xl shadow-black/10",
          "dark:bg-zinc-900 dark:border-zinc-800 dark:shadow-black/30",
          className
        ),
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime76.jsxs)("div", { className: "flex items-center gap-2 px-4 py-3 bg-muted/30 border-b border-border/50 dark:bg-zinc-800/50 dark:border-zinc-800", children: [
            /* @__PURE__ */ (0, import_jsx_runtime76.jsxs)("div", { className: "flex items-center gap-1.5", children: [
              /* @__PURE__ */ (0, import_jsx_runtime76.jsx)("div", { className: "w-3 h-3 rounded-full bg-red-500" }),
              /* @__PURE__ */ (0, import_jsx_runtime76.jsx)("div", { className: "w-3 h-3 rounded-full bg-yellow-500" }),
              /* @__PURE__ */ (0, import_jsx_runtime76.jsx)("div", { className: "w-3 h-3 rounded-full bg-green-500" })
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime76.jsx)("div", { className: "flex-1 flex justify-center", children: /* @__PURE__ */ (0, import_jsx_runtime76.jsxs)("div", { className: "flex items-center gap-2 px-4 py-1.5 rounded-md bg-muted/50 dark:bg-zinc-900", children: [
              /* @__PURE__ */ (0, import_jsx_runtime76.jsx)(
                "svg",
                {
                  className: "w-3.5 h-3.5 text-muted-foreground/60",
                  fill: "none",
                  viewBox: "0 0 24 24",
                  stroke: "currentColor",
                  strokeWidth: 2,
                  children: /* @__PURE__ */ (0, import_jsx_runtime76.jsx)(
                    "path",
                    {
                      strokeLinecap: "round",
                      strokeLinejoin: "round",
                      d: "M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z"
                    }
                  )
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime76.jsx)("span", { className: "text-xs text-muted-foreground", children: url })
            ] }) }),
            /* @__PURE__ */ (0, import_jsx_runtime76.jsxs)("div", { className: "flex items-center gap-2", children: [
              /* @__PURE__ */ (0, import_jsx_runtime76.jsx)(
                "svg",
                {
                  className: "w-4 h-4 text-muted-foreground/60",
                  fill: "none",
                  viewBox: "0 0 24 24",
                  stroke: "currentColor",
                  strokeWidth: 2,
                  children: /* @__PURE__ */ (0, import_jsx_runtime76.jsx)(
                    "path",
                    {
                      strokeLinecap: "round",
                      strokeLinejoin: "round",
                      d: "M8.684 13.342C8.886 12.938 9 12.482 9 12c0-.482-.114-.938-.316-1.342m0 2.684a3 3 0 110-2.684m0 2.684l6.632 3.316m-6.632-6l6.632-3.316m0 0a3 3 0 105.367-2.684 3 3 0 00-5.367 2.684zm0 9.316a3 3 0 105.368 2.684 3 3 0 00-5.368-2.684z"
                    }
                  )
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime76.jsx)(
                "svg",
                {
                  className: "w-4 h-4 text-muted-foreground/60",
                  fill: "none",
                  viewBox: "0 0 24 24",
                  stroke: "currentColor",
                  strokeWidth: 2,
                  children: /* @__PURE__ */ (0, import_jsx_runtime76.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M12 4v16m8-8H4" })
                }
              )
            ] })
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime76.jsx)("div", { className: "relative", children })
        ]
      }
    );
  };

  // src/components/ScrollAnimation.tsx
  var import_react111 = __toESM(require_react());
  var import_jsx_runtime77 = __toESM(require_jsx_runtime());
  function ScrollAnimation({
    children,
    animation = "fade-up",
    className,
    delay: delay2 = 0
  }) {
    const [isVisible, setIsVisible] = (0, import_react111.useState)(false);
    const ref = (0, import_react111.useRef)(null);
    (0, import_react111.useEffect)(() => {
      const observer2 = new IntersectionObserver(
        ([entry]) => {
          if (entry.isIntersecting) {
            setIsVisible(true);
            observer2.unobserve(entry.target);
          }
        },
        {
          root: null,
          rootMargin: "0px",
          threshold: 0.1
          // Trigger when 10% visible
        }
      );
      if (ref.current) {
        observer2.observe(ref.current);
      }
      return () => {
        if (ref.current) {
          observer2.unobserve(ref.current);
        }
      };
    }, []);
    const animationClass = {
      "fade-up": "reveal-fade-up",
      "scale": "reveal-scale",
      "fade-in": "reveal-fade-in"
    }[animation];
    return /* @__PURE__ */ (0, import_jsx_runtime77.jsx)(
      "div",
      {
        ref,
        className: cn(
          "reveal-on-scroll",
          animationClass,
          isVisible && "is-visible",
          className
        ),
        style: { transitionDelay: `${delay2}ms` },
        children
      }
    );
  }

  // src/components/SearchField.tsx
  var import_react112 = __toESM(require_react());
  var import_jsx_runtime78 = __toESM(require_jsx_runtime());
  var SearchField = import_react112.default.forwardRef(
    ({
      value,
      onChange,
      onSearch,
      placeholder = "Search...",
      size: size4 = "md",
      showClearButton = true,
      loading = false,
      className,
      ...props
    }, ref) => {
      const [internalValue, setInternalValue] = import_react112.default.useState("");
      const controlledValue = value !== void 0 ? value : internalValue;
      const handleChange = (e2) => {
        const newValue = e2.target.value;
        if (value === void 0) {
          setInternalValue(newValue);
        }
        onChange?.(newValue);
      };
      const handleClear = () => {
        if (value === void 0) {
          setInternalValue("");
        }
        onChange?.("");
      };
      const handleKeyDown = (e2) => {
        if (e2.key === "Enter") {
          onSearch?.(controlledValue);
        }
      };
      const sizeClasses2 = {
        sm: "h-8 text-sm pl-8 pr-8",
        md: "h-10 text-sm pl-10 pr-10",
        lg: "h-12 text-base pl-12 pr-12"
      };
      const iconSizes = {
        sm: "w-3.5 h-3.5",
        md: "w-4 h-4",
        lg: "w-5 h-5"
      };
      const iconPositions = {
        sm: "left-2.5",
        md: "left-3",
        lg: "left-4"
      };
      const clearPositions = {
        sm: "right-2",
        md: "right-3",
        lg: "right-4"
      };
      return /* @__PURE__ */ (0, import_jsx_runtime78.jsxs)("div", { className: cn("relative", className), children: [
        /* @__PURE__ */ (0, import_jsx_runtime78.jsx)(
          "div",
          {
            className: cn(
              "absolute top-1/2 -translate-y-1/2 text-muted-foreground pointer-events-none",
              iconPositions[size4]
            ),
            children: /* @__PURE__ */ (0, import_jsx_runtime78.jsx)(
              "svg",
              {
                className: iconSizes[size4],
                fill: "none",
                viewBox: "0 0 24 24",
                stroke: "currentColor",
                strokeWidth: 2,
                children: /* @__PURE__ */ (0, import_jsx_runtime78.jsx)(
                  "path",
                  {
                    strokeLinecap: "round",
                    strokeLinejoin: "round",
                    d: "M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"
                  }
                )
              }
            )
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime78.jsx)(
          "input",
          {
            ref,
            type: "text",
            value: controlledValue,
            onChange: handleChange,
            onKeyDown: handleKeyDown,
            placeholder,
            className: cn(
              sizeClasses2[size4],
              "w-full rounded-xl border border-border/50 bg-muted/30",
              "placeholder:text-muted-foreground/60",
              "focus:outline-none focus:ring-2 focus:ring-[#007AFF]/30 focus:border-[#007AFF]",
              "transition-all duration-200",
              "dark:bg-zinc-900/50 dark:border-zinc-800 dark:focus:ring-[#0A84FF]/30 dark:focus:border-[#0A84FF]"
            ),
            ...props
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime78.jsx)(
          "div",
          {
            className: cn(
              "absolute top-1/2 -translate-y-1/2 flex items-center",
              clearPositions[size4]
            ),
            children: loading ? /* @__PURE__ */ (0, import_jsx_runtime78.jsx)(
              "div",
              {
                className: cn(
                  iconSizes[size4],
                  "border-2 border-muted-foreground/30 border-t-[#007AFF] rounded-full animate-spin"
                )
              }
            ) : showClearButton && controlledValue && /* @__PURE__ */ (0, import_jsx_runtime78.jsx)(
              "button",
              {
                type: "button",
                onClick: handleClear,
                className: "text-muted-foreground/60 hover:text-muted-foreground transition-colors",
                children: /* @__PURE__ */ (0, import_jsx_runtime78.jsx)(
                  "svg",
                  {
                    className: iconSizes[size4],
                    fill: "none",
                    viewBox: "0 0 24 24",
                    stroke: "currentColor",
                    strokeWidth: 2,
                    children: /* @__PURE__ */ (0, import_jsx_runtime78.jsx)(
                      "path",
                      {
                        strokeLinecap: "round",
                        strokeLinejoin: "round",
                        d: "M6 18L18 6M6 6l12 12"
                      }
                    )
                  }
                )
              }
            )
          }
        )
      ] });
    }
  );
  SearchField.displayName = "SearchField";

  // src/components/SegmentedControl.tsx
  var import_jsx_runtime79 = __toESM(require_jsx_runtime());
  function SegmentedControl({
    options,
    selected,
    onChange,
    className
  }) {
    return /* @__PURE__ */ (0, import_jsx_runtime79.jsx)(
      "div",
      {
        className: cn(
          "flex p-1 bg-neutral-100 dark:bg-neutral-800 rounded-lg relative",
          className
        ),
        children: options.map((option) => /* @__PURE__ */ (0, import_jsx_runtime79.jsxs)(
          "button",
          {
            onClick: () => onChange(option),
            className: cn(
              "flex-1 relative z-10 px-4 py-2 text-sm font-medium transition-colors duration-200",
              selected === option ? "text-black dark:text-white" : "text-neutral-500 hover:text-neutral-700 dark:text-neutral-400 dark:hover:text-neutral-200"
            ),
            children: [
              selected === option && /* @__PURE__ */ (0, import_jsx_runtime79.jsx)(
                motion.div,
                {
                  layoutId: "segmented-indicator",
                  className: "absolute inset-0 bg-white dark:bg-neutral-600 rounded-md shadow-sm",
                  transition: {
                    type: "spring",
                    stiffness: 300,
                    damping: 30
                  },
                  style: { zIndex: -1 }
                }
              ),
              option
            ]
          },
          option
        ))
      }
    );
  }

  // src/components/Select.tsx
  var import_react113 = __toESM(require_react());
  var import_jsx_runtime80 = __toESM(require_jsx_runtime());
  var Select2 = (0, import_react113.forwardRef)(
    ({ className, options, placeholder, error, selectSize = "md", variant = "standard", disabled, ...props }, ref) => {
      return /* @__PURE__ */ (0, import_jsx_runtime80.jsx)("div", { className: "relative w-full", children: /* @__PURE__ */ (0, import_jsx_runtime80.jsxs)(
        "select",
        {
          ref,
          disabled,
          className: cn(
            "w-full appearance-none transition-all text-foreground focus:outline-none disabled:cursor-not-allowed disabled:opacity-50",
            // Standard
            variant === "standard" && "rounded-[2rem] border bg-background/50 backdrop-blur-sm focus:ring-2 focus:ring-violet-500/50 focus:ring-offset-2",
            variant === "standard" && (!error ? "border-border" : "border-destructive focus:ring-destructive"),
            // Minimal (No visible border until hover/focus)
            variant === "minimal" && "rounded-lg bg-transparent hover:bg-muted/50 focus:bg-muted focus:ring-0 border-b border-transparent focus:border-violet-500",
            // Combobox (Simulated look)
            variant === "combobox" && "rounded-md border bg-background shadow-sm hover:bg-accent/50 focus:ring-1 focus:ring-violet-500",
            variant === "combobox" && (!error ? "border-input" : "border-destructive"),
            {
              "h-8 text-sm": selectSize === "sm",
              "h-10 text-sm": selectSize === "md",
              "h-12 text-base": selectSize === "lg"
            },
            variant !== "minimal" && "px-4",
            variant === "minimal" && "px-2",
            "bg-[url('data:image/svg+xml;charset=UTF-8,%3csvg%20xmlns%3d%22http%3a%2f%2fwww.w3.org%2f2000%2fsvg%22%20width%3d%2224%22%20height%3d%2224%22%20viewBox%3d%220%200%2024%2024%22%20fill%3d%22none%22%20stroke%3d%22%2371717a%22%20stroke-width%3d%222%22%20stroke-linecap%3d%22round%22%20stroke-linejoin%3d%22round%22%3e%3cpolyline%20points%3d%226%209%2012%2015%2018%209%22%3e%3c%2fpolyline%3e%3c%2fsvg%3e')] bg-[length:1.25rem] bg-[right_0.5rem_center] bg-no-repeat pr-10",
            className
          ),
          ...props,
          children: [
            placeholder && /* @__PURE__ */ (0, import_jsx_runtime80.jsx)("option", { value: "", disabled: true, children: placeholder }),
            options.map((option) => /* @__PURE__ */ (0, import_jsx_runtime80.jsx)("option", { value: option.value, disabled: option.disabled, children: option.label }, option.value))
          ]
        }
      ) });
    }
  );
  Select2.displayName = "Select";

  // src/components/Sheet.tsx
  var React89 = __toESM(require_react());
  var import_jsx_runtime81 = __toESM(require_jsx_runtime());
  var Sheet = Root3;
  var SheetTrigger = Trigger;
  var SheetClose = Close;
  var SheetPortal = Portal2;
  var SheetOverlay = React89.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ (0, import_jsx_runtime81.jsx)(
    Overlay,
    {
      className: cn(
        "fixed inset-0 z-50 bg-black/40 backdrop-blur-sm data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
        className
      ),
      ...props,
      ref
    }
  ));
  SheetOverlay.displayName = Overlay.displayName;
  var sheetVariants = cva(
    "fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
    {
      variants: {
        side: {
          top: "inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top",
          bottom: "inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom",
          left: "inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm",
          right: "inset-y-0 right-0 h-full w-3/4 border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm"
        }
      },
      defaultVariants: {
        side: "right"
      }
    }
  );
  var SheetContent = React89.forwardRef(({ side = "right", className, children, ...props }, ref) => /* @__PURE__ */ (0, import_jsx_runtime81.jsxs)(SheetPortal, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime81.jsx)(SheetOverlay, {}),
    /* @__PURE__ */ (0, import_jsx_runtime81.jsxs)(
      Content,
      {
        ref,
        className: cn(sheetVariants({ side }), className),
        ...props,
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime81.jsxs)(SheetClose, { className: "absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary", children: [
            /* @__PURE__ */ (0, import_jsx_runtime81.jsx)(X, { className: "h-4 w-4" }),
            /* @__PURE__ */ (0, import_jsx_runtime81.jsx)("span", { className: "sr-only", children: "Close" })
          ] }),
          children
        ]
      }
    )
  ] }));
  SheetContent.displayName = Content.displayName;
  var SheetHeader = ({
    className,
    ...props
  }) => /* @__PURE__ */ (0, import_jsx_runtime81.jsx)(
    "div",
    {
      className: cn(
        "flex flex-col space-y-2 text-center sm:text-left",
        className
      ),
      ...props
    }
  );
  SheetHeader.displayName = "SheetHeader";
  var SheetFooter = ({
    className,
    ...props
  }) => /* @__PURE__ */ (0, import_jsx_runtime81.jsx)(
    "div",
    {
      className: cn(
        "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
        className
      ),
      ...props
    }
  );
  SheetFooter.displayName = "SheetFooter";
  var SheetTitle = React89.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ (0, import_jsx_runtime81.jsx)(
    Title,
    {
      ref,
      className: cn("text-lg font-semibold text-foreground", className),
      ...props
    }
  ));
  SheetTitle.displayName = Title.displayName;
  var SheetDescription = React89.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ (0, import_jsx_runtime81.jsx)(
    Description,
    {
      ref,
      className: cn("text-sm text-muted-foreground", className),
      ...props
    }
  ));
  SheetDescription.displayName = Description.displayName;

  // src/components/ShinyText.tsx
  var import_jsx_runtime82 = __toESM(require_jsx_runtime());
  var ShinyText = ({
    children,
    shimmerWidth = 100,
    duration = 2,
    className
  }) => {
    return /* @__PURE__ */ (0, import_jsx_runtime82.jsx)(
      "span",
      {
        className: cn(
          "relative inline-block bg-clip-text text-transparent",
          "bg-gradient-to-r from-foreground via-foreground/60 to-foreground",
          "bg-[length:200%_100%] animate-shimmer-text",
          className
        ),
        style: {
          backgroundSize: `${shimmerWidth}% 100%`,
          animationDuration: `${duration}s`
        },
        children
      }
    );
  };
  var GlowingText = ({
    children,
    color: color2 = "#007AFF",
    className
  }) => {
    return /* @__PURE__ */ (0, import_jsx_runtime82.jsx)(
      "span",
      {
        className: cn(
          "relative inline-block animate-glow-pulse",
          className
        ),
        style: {
          textShadow: `0 0 10px ${color2}40, 0 0 20px ${color2}30, 0 0 30px ${color2}20`
        },
        children
      }
    );
  };
  var GradientText = ({
    children,
    colors: colors3 = ["#007AFF", "#AF52DE", "#FF2D55", "#007AFF"],
    duration = 4,
    className
  }) => {
    const gradientColors = colors3.join(", ");
    return /* @__PURE__ */ (0, import_jsx_runtime82.jsx)(
      "span",
      {
        className: cn(
          "inline-block bg-clip-text text-transparent bg-gradient-to-r animate-gradient-x",
          className
        ),
        style: {
          backgroundImage: `linear-gradient(90deg, ${gradientColors})`,
          backgroundSize: "300% 100%",
          animationDuration: `${duration}s`
        },
        children
      }
    );
  };
  var shinyTextStyles = `
@keyframes shimmer-text {
  0% {
    background-position: 100% 50%;
  }
  100% {
    background-position: 0% 50%;
  }
}

@keyframes gradient-x {
  0%, 100% {
    background-position: 0% 50%;
  }
  50% {
    background-position: 100% 50%;
  }
}

.animate-shimmer-text {
  animation: shimmer-text 2s linear infinite;
}

.animate-gradient-x {
  animation: gradient-x 4s ease infinite;
}
`;
  if (typeof document !== "undefined") {
    const styleId = "auralix-shiny-text-styles";
    if (!document.getElementById(styleId)) {
      const style = document.createElement("style");
      style.id = styleId;
      style.textContent = shinyTextStyles;
      document.head.appendChild(style);
    }
  }

  // src/components/Skeleton.tsx
  var import_jsx_runtime83 = __toESM(require_jsx_runtime());
  function Skeleton({
    className,
    ...props
  }) {
    return /* @__PURE__ */ (0, import_jsx_runtime83.jsx)(
      "div",
      {
        className: cn("animate-pulse rounded-md bg-muted/50", className),
        ...props
      }
    );
  }

  // src/components/Slider.tsx
  var React95 = __toESM(require_react());

  // ../../node_modules/@radix-ui/react-slider/dist/index.mjs
  var React94 = __toESM(require_react2(), 1);

  // ../../node_modules/@radix-ui/number/dist/index.mjs
  function clamp3(value, [min3, max3]) {
    return Math.min(max3, Math.max(min3, value));
  }

  // ../../node_modules/@radix-ui/react-direction/dist/index.mjs
  var React90 = __toESM(require_react2(), 1);
  var import_jsx_runtime84 = __toESM(require_jsx_runtime2(), 1);
  var DirectionContext = React90.createContext(void 0);
  function useDirection(localDir) {
    const globalDir = React90.useContext(DirectionContext);
    return localDir || globalDir || "ltr";
  }

  // ../../node_modules/@radix-ui/react-use-previous/dist/index.mjs
  var React91 = __toESM(require_react2(), 1);
  function usePrevious(value) {
    const ref = React91.useRef({ value, previous: value });
    return React91.useMemo(() => {
      if (ref.current.value !== value) {
        ref.current.previous = ref.current.value;
        ref.current.value = value;
      }
      return ref.current.previous;
    }, [value]);
  }

  // ../../node_modules/@radix-ui/react-use-size/dist/index.mjs
  var React92 = __toESM(require_react2(), 1);
  function useSize(element) {
    const [size4, setSize] = React92.useState(void 0);
    useLayoutEffect22(() => {
      if (element) {
        setSize({ width: element.offsetWidth, height: element.offsetHeight });
        const resizeObserver = new ResizeObserver((entries) => {
          if (!Array.isArray(entries)) {
            return;
          }
          if (!entries.length) {
            return;
          }
          const entry = entries[0];
          let width;
          let height;
          if ("borderBoxSize" in entry) {
            const borderSizeEntry = entry["borderBoxSize"];
            const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
            width = borderSize["inlineSize"];
            height = borderSize["blockSize"];
          } else {
            width = element.offsetWidth;
            height = element.offsetHeight;
          }
          setSize({ width, height });
        });
        resizeObserver.observe(element, { box: "border-box" });
        return () => resizeObserver.unobserve(element);
      } else {
        setSize(void 0);
      }
    }, [element]);
    return size4;
  }

  // ../../node_modules/@radix-ui/react-collection/dist/index.mjs
  var import_react114 = __toESM(require_react2(), 1);
  var import_jsx_runtime85 = __toESM(require_jsx_runtime2(), 1);
  var import_react115 = __toESM(require_react2(), 1);
  var import_jsx_runtime86 = __toESM(require_jsx_runtime2(), 1);
  function createCollection(name) {
    const PROVIDER_NAME2 = name + "CollectionProvider";
    const [createCollectionContext, createCollectionScope3] = createContextScope2(PROVIDER_NAME2);
    const [CollectionProviderImpl, useCollectionContext] = createCollectionContext(
      PROVIDER_NAME2,
      { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
    );
    const CollectionProvider = (props) => {
      const { scope, children } = props;
      const ref = import_react114.default.useRef(null);
      const itemMap = import_react114.default.useRef(/* @__PURE__ */ new Map()).current;
      return /* @__PURE__ */ (0, import_jsx_runtime85.jsx)(CollectionProviderImpl, { scope, itemMap, collectionRef: ref, children });
    };
    CollectionProvider.displayName = PROVIDER_NAME2;
    const COLLECTION_SLOT_NAME = name + "CollectionSlot";
    const CollectionSlotImpl = createSlot2(COLLECTION_SLOT_NAME);
    const CollectionSlot = import_react114.default.forwardRef(
      (props, forwardedRef) => {
        const { scope, children } = props;
        const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);
        const composedRefs = useComposedRefs2(forwardedRef, context.collectionRef);
        return /* @__PURE__ */ (0, import_jsx_runtime85.jsx)(CollectionSlotImpl, { ref: composedRefs, children });
      }
    );
    CollectionSlot.displayName = COLLECTION_SLOT_NAME;
    const ITEM_SLOT_NAME = name + "CollectionItemSlot";
    const ITEM_DATA_ATTR = "data-radix-collection-item";
    const CollectionItemSlotImpl = createSlot2(ITEM_SLOT_NAME);
    const CollectionItemSlot = import_react114.default.forwardRef(
      (props, forwardedRef) => {
        const { scope, children, ...itemData } = props;
        const ref = import_react114.default.useRef(null);
        const composedRefs = useComposedRefs2(forwardedRef, ref);
        const context = useCollectionContext(ITEM_SLOT_NAME, scope);
        import_react114.default.useEffect(() => {
          context.itemMap.set(ref, { ref, ...itemData });
          return () => void context.itemMap.delete(ref);
        });
        return /* @__PURE__ */ (0, import_jsx_runtime85.jsx)(CollectionItemSlotImpl, { ...{ [ITEM_DATA_ATTR]: "" }, ref: composedRefs, children });
      }
    );
    CollectionItemSlot.displayName = ITEM_SLOT_NAME;
    function useCollection3(scope) {
      const context = useCollectionContext(name + "CollectionConsumer", scope);
      const getItems = import_react114.default.useCallback(() => {
        const collectionNode = context.collectionRef.current;
        if (!collectionNode) return [];
        const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));
        const items = Array.from(context.itemMap.values());
        const orderedItems = items.sort(
          (a, b2) => orderedNodes.indexOf(a.ref.current) - orderedNodes.indexOf(b2.ref.current)
        );
        return orderedItems;
      }, [context.collectionRef, context.itemMap]);
      return getItems;
    }
    return [
      { Provider: CollectionProvider, Slot: CollectionSlot, ItemSlot: CollectionItemSlot },
      useCollection3,
      createCollectionScope3
    ];
  }

  // ../../node_modules/@radix-ui/react-slider/dist/index.mjs
  var import_jsx_runtime87 = __toESM(require_jsx_runtime2(), 1);
  var PAGE_KEYS = ["PageUp", "PageDown"];
  var ARROW_KEYS = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"];
  var BACK_KEYS = {
    "from-left": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
    "from-right": ["Home", "PageDown", "ArrowDown", "ArrowRight"],
    "from-bottom": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
    "from-top": ["Home", "PageDown", "ArrowUp", "ArrowLeft"]
  };
  var SLIDER_NAME = "Slider";
  var [Collection, useCollection, createCollectionScope] = createCollection(SLIDER_NAME);
  var [createSliderContext, createSliderScope] = createContextScope2(SLIDER_NAME, [
    createCollectionScope
  ]);
  var [SliderProvider, useSliderContext] = createSliderContext(SLIDER_NAME);
  var Slider = React94.forwardRef(
    (props, forwardedRef) => {
      const {
        name,
        min: min3 = 0,
        max: max3 = 100,
        step = 1,
        orientation = "horizontal",
        disabled = false,
        minStepsBetweenThumbs = 0,
        defaultValue = [min3],
        value,
        onValueChange = () => {
        },
        onValueCommit = () => {
        },
        inverted = false,
        form,
        ...sliderProps
      } = props;
      const thumbRefs = React94.useRef(/* @__PURE__ */ new Set());
      const valueIndexToChangeRef = React94.useRef(0);
      const isHorizontal = orientation === "horizontal";
      const SliderOrientation = isHorizontal ? SliderHorizontal : SliderVertical;
      const [values = [], setValues] = useControllableState({
        prop: value,
        defaultProp: defaultValue,
        onChange: (value2) => {
          const thumbs = [...thumbRefs.current];
          thumbs[valueIndexToChangeRef.current]?.focus();
          onValueChange(value2);
        }
      });
      const valuesBeforeSlideStartRef = React94.useRef(values);
      function handleSlideStart(value2) {
        const closestIndex = getClosestValueIndex(values, value2);
        updateValues(value2, closestIndex);
      }
      function handleSlideMove(value2) {
        updateValues(value2, valueIndexToChangeRef.current);
      }
      function handleSlideEnd() {
        const prevValue = valuesBeforeSlideStartRef.current[valueIndexToChangeRef.current];
        const nextValue = values[valueIndexToChangeRef.current];
        const hasChanged = nextValue !== prevValue;
        if (hasChanged) onValueCommit(values);
      }
      function updateValues(value2, atIndex, { commit } = { commit: false }) {
        const decimalCount = getDecimalCount(step);
        const snapToStep = roundValue(Math.round((value2 - min3) / step) * step + min3, decimalCount);
        const nextValue = clamp3(snapToStep, [min3, max3]);
        setValues((prevValues = []) => {
          const nextValues = getNextSortedValues(prevValues, nextValue, atIndex);
          if (hasMinStepsBetweenValues(nextValues, minStepsBetweenThumbs * step)) {
            valueIndexToChangeRef.current = nextValues.indexOf(nextValue);
            const hasChanged = String(nextValues) !== String(prevValues);
            if (hasChanged && commit) onValueCommit(nextValues);
            return hasChanged ? nextValues : prevValues;
          } else {
            return prevValues;
          }
        });
      }
      return /* @__PURE__ */ (0, import_jsx_runtime87.jsx)(
        SliderProvider,
        {
          scope: props.__scopeSlider,
          name,
          disabled,
          min: min3,
          max: max3,
          valueIndexToChangeRef,
          thumbs: thumbRefs.current,
          values,
          orientation,
          form,
          children: /* @__PURE__ */ (0, import_jsx_runtime87.jsx)(Collection.Provider, { scope: props.__scopeSlider, children: /* @__PURE__ */ (0, import_jsx_runtime87.jsx)(Collection.Slot, { scope: props.__scopeSlider, children: /* @__PURE__ */ (0, import_jsx_runtime87.jsx)(
            SliderOrientation,
            {
              "aria-disabled": disabled,
              "data-disabled": disabled ? "" : void 0,
              ...sliderProps,
              ref: forwardedRef,
              onPointerDown: composeEventHandlers(sliderProps.onPointerDown, () => {
                if (!disabled) valuesBeforeSlideStartRef.current = values;
              }),
              min: min3,
              max: max3,
              inverted,
              onSlideStart: disabled ? void 0 : handleSlideStart,
              onSlideMove: disabled ? void 0 : handleSlideMove,
              onSlideEnd: disabled ? void 0 : handleSlideEnd,
              onHomeKeyDown: () => !disabled && updateValues(min3, 0, { commit: true }),
              onEndKeyDown: () => !disabled && updateValues(max3, values.length - 1, { commit: true }),
              onStepKeyDown: ({ event, direction: stepDirection }) => {
                if (!disabled) {
                  const isPageKey = PAGE_KEYS.includes(event.key);
                  const isSkipKey = isPageKey || event.shiftKey && ARROW_KEYS.includes(event.key);
                  const multiplier = isSkipKey ? 10 : 1;
                  const atIndex = valueIndexToChangeRef.current;
                  const value2 = values[atIndex];
                  const stepInDirection = step * multiplier * stepDirection;
                  updateValues(value2 + stepInDirection, atIndex, { commit: true });
                }
              }
            }
          ) }) })
        }
      );
    }
  );
  Slider.displayName = SLIDER_NAME;
  var [SliderOrientationProvider, useSliderOrientationContext] = createSliderContext(SLIDER_NAME, {
    startEdge: "left",
    endEdge: "right",
    size: "width",
    direction: 1
  });
  var SliderHorizontal = React94.forwardRef(
    (props, forwardedRef) => {
      const {
        min: min3,
        max: max3,
        dir,
        inverted,
        onSlideStart,
        onSlideMove,
        onSlideEnd,
        onStepKeyDown,
        ...sliderProps
      } = props;
      const [slider, setSlider] = React94.useState(null);
      const composedRefs = useComposedRefs2(forwardedRef, (node) => setSlider(node));
      const rectRef = React94.useRef(void 0);
      const direction = useDirection(dir);
      const isDirectionLTR = direction === "ltr";
      const isSlidingFromLeft = isDirectionLTR && !inverted || !isDirectionLTR && inverted;
      function getValueFromPointer(pointerPosition) {
        const rect = rectRef.current || slider.getBoundingClientRect();
        const input = [0, rect.width];
        const output = isSlidingFromLeft ? [min3, max3] : [max3, min3];
        const value = linearScale(input, output);
        rectRef.current = rect;
        return value(pointerPosition - rect.left);
      }
      return /* @__PURE__ */ (0, import_jsx_runtime87.jsx)(
        SliderOrientationProvider,
        {
          scope: props.__scopeSlider,
          startEdge: isSlidingFromLeft ? "left" : "right",
          endEdge: isSlidingFromLeft ? "right" : "left",
          direction: isSlidingFromLeft ? 1 : -1,
          size: "width",
          children: /* @__PURE__ */ (0, import_jsx_runtime87.jsx)(
            SliderImpl,
            {
              dir: direction,
              "data-orientation": "horizontal",
              ...sliderProps,
              ref: composedRefs,
              style: {
                ...sliderProps.style,
                ["--radix-slider-thumb-transform"]: "translateX(-50%)"
              },
              onSlideStart: (event) => {
                const value = getValueFromPointer(event.clientX);
                onSlideStart?.(value);
              },
              onSlideMove: (event) => {
                const value = getValueFromPointer(event.clientX);
                onSlideMove?.(value);
              },
              onSlideEnd: () => {
                rectRef.current = void 0;
                onSlideEnd?.();
              },
              onStepKeyDown: (event) => {
                const slideDirection = isSlidingFromLeft ? "from-left" : "from-right";
                const isBackKey = BACK_KEYS[slideDirection].includes(event.key);
                onStepKeyDown?.({ event, direction: isBackKey ? -1 : 1 });
              }
            }
          )
        }
      );
    }
  );
  var SliderVertical = React94.forwardRef(
    (props, forwardedRef) => {
      const {
        min: min3,
        max: max3,
        inverted,
        onSlideStart,
        onSlideMove,
        onSlideEnd,
        onStepKeyDown,
        ...sliderProps
      } = props;
      const sliderRef = React94.useRef(null);
      const ref = useComposedRefs2(forwardedRef, sliderRef);
      const rectRef = React94.useRef(void 0);
      const isSlidingFromBottom = !inverted;
      function getValueFromPointer(pointerPosition) {
        const rect = rectRef.current || sliderRef.current.getBoundingClientRect();
        const input = [0, rect.height];
        const output = isSlidingFromBottom ? [max3, min3] : [min3, max3];
        const value = linearScale(input, output);
        rectRef.current = rect;
        return value(pointerPosition - rect.top);
      }
      return /* @__PURE__ */ (0, import_jsx_runtime87.jsx)(
        SliderOrientationProvider,
        {
          scope: props.__scopeSlider,
          startEdge: isSlidingFromBottom ? "bottom" : "top",
          endEdge: isSlidingFromBottom ? "top" : "bottom",
          size: "height",
          direction: isSlidingFromBottom ? 1 : -1,
          children: /* @__PURE__ */ (0, import_jsx_runtime87.jsx)(
            SliderImpl,
            {
              "data-orientation": "vertical",
              ...sliderProps,
              ref,
              style: {
                ...sliderProps.style,
                ["--radix-slider-thumb-transform"]: "translateY(50%)"
              },
              onSlideStart: (event) => {
                const value = getValueFromPointer(event.clientY);
                onSlideStart?.(value);
              },
              onSlideMove: (event) => {
                const value = getValueFromPointer(event.clientY);
                onSlideMove?.(value);
              },
              onSlideEnd: () => {
                rectRef.current = void 0;
                onSlideEnd?.();
              },
              onStepKeyDown: (event) => {
                const slideDirection = isSlidingFromBottom ? "from-bottom" : "from-top";
                const isBackKey = BACK_KEYS[slideDirection].includes(event.key);
                onStepKeyDown?.({ event, direction: isBackKey ? -1 : 1 });
              }
            }
          )
        }
      );
    }
  );
  var SliderImpl = React94.forwardRef(
    (props, forwardedRef) => {
      const {
        __scopeSlider,
        onSlideStart,
        onSlideMove,
        onSlideEnd,
        onHomeKeyDown,
        onEndKeyDown,
        onStepKeyDown,
        ...sliderProps
      } = props;
      const context = useSliderContext(SLIDER_NAME, __scopeSlider);
      return /* @__PURE__ */ (0, import_jsx_runtime87.jsx)(
        Primitive2.span,
        {
          ...sliderProps,
          ref: forwardedRef,
          onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
            if (event.key === "Home") {
              onHomeKeyDown(event);
              event.preventDefault();
            } else if (event.key === "End") {
              onEndKeyDown(event);
              event.preventDefault();
            } else if (PAGE_KEYS.concat(ARROW_KEYS).includes(event.key)) {
              onStepKeyDown(event);
              event.preventDefault();
            }
          }),
          onPointerDown: composeEventHandlers(props.onPointerDown, (event) => {
            const target = event.target;
            target.setPointerCapture(event.pointerId);
            event.preventDefault();
            if (context.thumbs.has(target)) {
              target.focus();
            } else {
              onSlideStart(event);
            }
          }),
          onPointerMove: composeEventHandlers(props.onPointerMove, (event) => {
            const target = event.target;
            if (target.hasPointerCapture(event.pointerId)) onSlideMove(event);
          }),
          onPointerUp: composeEventHandlers(props.onPointerUp, (event) => {
            const target = event.target;
            if (target.hasPointerCapture(event.pointerId)) {
              target.releasePointerCapture(event.pointerId);
              onSlideEnd(event);
            }
          })
        }
      );
    }
  );
  var TRACK_NAME = "SliderTrack";
  var SliderTrack = React94.forwardRef(
    (props, forwardedRef) => {
      const { __scopeSlider, ...trackProps } = props;
      const context = useSliderContext(TRACK_NAME, __scopeSlider);
      return /* @__PURE__ */ (0, import_jsx_runtime87.jsx)(
        Primitive2.span,
        {
          "data-disabled": context.disabled ? "" : void 0,
          "data-orientation": context.orientation,
          ...trackProps,
          ref: forwardedRef
        }
      );
    }
  );
  SliderTrack.displayName = TRACK_NAME;
  var RANGE_NAME = "SliderRange";
  var SliderRange = React94.forwardRef(
    (props, forwardedRef) => {
      const { __scopeSlider, ...rangeProps } = props;
      const context = useSliderContext(RANGE_NAME, __scopeSlider);
      const orientation = useSliderOrientationContext(RANGE_NAME, __scopeSlider);
      const ref = React94.useRef(null);
      const composedRefs = useComposedRefs2(forwardedRef, ref);
      const valuesCount = context.values.length;
      const percentages = context.values.map(
        (value) => convertValueToPercentage(value, context.min, context.max)
      );
      const offsetStart = valuesCount > 1 ? Math.min(...percentages) : 0;
      const offsetEnd = 100 - Math.max(...percentages);
      return /* @__PURE__ */ (0, import_jsx_runtime87.jsx)(
        Primitive2.span,
        {
          "data-orientation": context.orientation,
          "data-disabled": context.disabled ? "" : void 0,
          ...rangeProps,
          ref: composedRefs,
          style: {
            ...props.style,
            [orientation.startEdge]: offsetStart + "%",
            [orientation.endEdge]: offsetEnd + "%"
          }
        }
      );
    }
  );
  SliderRange.displayName = RANGE_NAME;
  var THUMB_NAME = "SliderThumb";
  var SliderThumb = React94.forwardRef(
    (props, forwardedRef) => {
      const getItems = useCollection(props.__scopeSlider);
      const [thumb, setThumb] = React94.useState(null);
      const composedRefs = useComposedRefs2(forwardedRef, (node) => setThumb(node));
      const index2 = React94.useMemo(
        () => thumb ? getItems().findIndex((item) => item.ref.current === thumb) : -1,
        [getItems, thumb]
      );
      return /* @__PURE__ */ (0, import_jsx_runtime87.jsx)(SliderThumbImpl, { ...props, ref: composedRefs, index: index2 });
    }
  );
  var SliderThumbImpl = React94.forwardRef(
    (props, forwardedRef) => {
      const { __scopeSlider, index: index2, name, ...thumbProps } = props;
      const context = useSliderContext(THUMB_NAME, __scopeSlider);
      const orientation = useSliderOrientationContext(THUMB_NAME, __scopeSlider);
      const [thumb, setThumb] = React94.useState(null);
      const composedRefs = useComposedRefs2(forwardedRef, (node) => setThumb(node));
      const isFormControl = thumb ? context.form || !!thumb.closest("form") : true;
      const size4 = useSize(thumb);
      const value = context.values[index2];
      const percent2 = value === void 0 ? 0 : convertValueToPercentage(value, context.min, context.max);
      const label = getLabel(index2, context.values.length);
      const orientationSize = size4?.[orientation.size];
      const thumbInBoundsOffset = orientationSize ? getThumbInBoundsOffset(orientationSize, percent2, orientation.direction) : 0;
      React94.useEffect(() => {
        if (thumb) {
          context.thumbs.add(thumb);
          return () => {
            context.thumbs.delete(thumb);
          };
        }
      }, [thumb, context.thumbs]);
      return /* @__PURE__ */ (0, import_jsx_runtime87.jsxs)(
        "span",
        {
          style: {
            transform: "var(--radix-slider-thumb-transform)",
            position: "absolute",
            [orientation.startEdge]: `calc(${percent2}% + ${thumbInBoundsOffset}px)`
          },
          children: [
            /* @__PURE__ */ (0, import_jsx_runtime87.jsx)(Collection.ItemSlot, { scope: props.__scopeSlider, children: /* @__PURE__ */ (0, import_jsx_runtime87.jsx)(
              Primitive2.span,
              {
                role: "slider",
                "aria-label": props["aria-label"] || label,
                "aria-valuemin": context.min,
                "aria-valuenow": value,
                "aria-valuemax": context.max,
                "aria-orientation": context.orientation,
                "data-orientation": context.orientation,
                "data-disabled": context.disabled ? "" : void 0,
                tabIndex: context.disabled ? void 0 : 0,
                ...thumbProps,
                ref: composedRefs,
                style: value === void 0 ? { display: "none" } : props.style,
                onFocus: composeEventHandlers(props.onFocus, () => {
                  context.valueIndexToChangeRef.current = index2;
                })
              }
            ) }),
            isFormControl && /* @__PURE__ */ (0, import_jsx_runtime87.jsx)(
              SliderBubbleInput,
              {
                name: name ?? (context.name ? context.name + (context.values.length > 1 ? "[]" : "") : void 0),
                form: context.form,
                value
              },
              index2
            )
          ]
        }
      );
    }
  );
  SliderThumb.displayName = THUMB_NAME;
  var BUBBLE_INPUT_NAME = "RadioBubbleInput";
  var SliderBubbleInput = React94.forwardRef(
    ({ __scopeSlider, value, ...props }, forwardedRef) => {
      const ref = React94.useRef(null);
      const composedRefs = useComposedRefs2(ref, forwardedRef);
      const prevValue = usePrevious(value);
      React94.useEffect(() => {
        const input = ref.current;
        if (!input) return;
        const inputProto = window.HTMLInputElement.prototype;
        const descriptor = Object.getOwnPropertyDescriptor(inputProto, "value");
        const setValue = descriptor.set;
        if (prevValue !== value && setValue) {
          const event = new Event("input", { bubbles: true });
          setValue.call(input, value);
          input.dispatchEvent(event);
        }
      }, [prevValue, value]);
      return /* @__PURE__ */ (0, import_jsx_runtime87.jsx)(
        Primitive2.input,
        {
          style: { display: "none" },
          ...props,
          ref: composedRefs,
          defaultValue: value
        }
      );
    }
  );
  SliderBubbleInput.displayName = BUBBLE_INPUT_NAME;
  function getNextSortedValues(prevValues = [], nextValue, atIndex) {
    const nextValues = [...prevValues];
    nextValues[atIndex] = nextValue;
    return nextValues.sort((a, b2) => a - b2);
  }
  function convertValueToPercentage(value, min3, max3) {
    const maxSteps = max3 - min3;
    const percentPerStep = 100 / maxSteps;
    const percentage = percentPerStep * (value - min3);
    return clamp3(percentage, [0, 100]);
  }
  function getLabel(index2, totalValues) {
    if (totalValues > 2) {
      return `Value ${index2 + 1} of ${totalValues}`;
    } else if (totalValues === 2) {
      return ["Minimum", "Maximum"][index2];
    } else {
      return void 0;
    }
  }
  function getClosestValueIndex(values, nextValue) {
    if (values.length === 1) return 0;
    const distances = values.map((value) => Math.abs(value - nextValue));
    const closestDistance = Math.min(...distances);
    return distances.indexOf(closestDistance);
  }
  function getThumbInBoundsOffset(width, left, direction) {
    const halfWidth = width / 2;
    const halfPercent = 50;
    const offset4 = linearScale([0, halfPercent], [0, halfWidth]);
    return (halfWidth - offset4(left) * direction) * direction;
  }
  function getStepsBetweenValues(values) {
    return values.slice(0, -1).map((value, index2) => values[index2 + 1] - value);
  }
  function hasMinStepsBetweenValues(values, minStepsBetweenValues) {
    if (minStepsBetweenValues > 0) {
      const stepsBetweenValues = getStepsBetweenValues(values);
      const actualMinStepsBetweenValues = Math.min(...stepsBetweenValues);
      return actualMinStepsBetweenValues >= minStepsBetweenValues;
    }
    return true;
  }
  function linearScale(input, output) {
    return (value) => {
      if (input[0] === input[1] || output[0] === output[1]) return output[0];
      const ratio = (output[1] - output[0]) / (input[1] - input[0]);
      return output[0] + ratio * (value - input[0]);
    };
  }
  function getDecimalCount(value) {
    return (String(value).split(".")[1] || "").length;
  }
  function roundValue(value, decimalCount) {
    const rounder = Math.pow(10, decimalCount);
    return Math.round(value * rounder) / rounder;
  }
  var Root4 = Slider;
  var Track = SliderTrack;
  var Range = SliderRange;
  var Thumb = SliderThumb;

  // src/components/Slider.tsx
  var import_jsx_runtime88 = __toESM(require_jsx_runtime());
  var Slider2 = React95.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ (0, import_jsx_runtime88.jsxs)(
    Root4,
    {
      ref,
      className: cn(
        "relative flex w-full touch-none select-none items-center",
        className
      ),
      ...props,
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime88.jsx)(Track, { className: "relative h-2 w-full grow overflow-hidden rounded-full bg-secondary", children: /* @__PURE__ */ (0, import_jsx_runtime88.jsx)(Range, { className: "absolute h-full bg-primary" }) }),
        /* @__PURE__ */ (0, import_jsx_runtime88.jsx)(Thumb, { className: "block h-5 w-5 rounded-full border-2 border-primary bg-background ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50" })
      ]
    }
  ));
  Slider2.displayName = Root4.displayName;

  // src/components/Spinner.tsx
  var import_jsx_runtime89 = __toESM(require_jsx_runtime());
  var sizeClasses = {
    xs: "w-3 h-3 border",
    sm: "w-4 h-4 border-[1.5px]",
    md: "w-6 h-6 border-2",
    lg: "w-8 h-8 border-2",
    xl: "w-12 h-12 border-[3px]"
  };
  var colorClasses = {
    default: "border-muted-foreground/30 border-t-muted-foreground",
    primary: "border-[#007AFF]/30 border-t-[#007AFF] dark:border-[#0A84FF]/30 dark:border-t-[#0A84FF]",
    white: "border-white/30 border-t-white"
  };
  var Spinner = ({
    size: size4 = "md",
    color: color2 = "primary",
    className
  }) => {
    return /* @__PURE__ */ (0, import_jsx_runtime89.jsx)(
      "div",
      {
        className: cn(
          sizeClasses[size4],
          colorClasses[color2],
          "rounded-full animate-spin",
          className
        ),
        role: "status",
        "aria-label": "Loading"
      }
    );
  };
  var ActivityIndicator = ({
    size: size4 = "md",
    color: color2 = "default",
    className
  }) => {
    const sizes = {
      sm: { container: 16, line: 2, length: 4 },
      md: { container: 24, line: 2.5, length: 5 },
      lg: { container: 36, line: 3, length: 7 }
    };
    const colors3 = {
      default: "fill-muted-foreground",
      primary: "fill-[#007AFF] dark:fill-[#0A84FF]",
      white: "fill-white"
    };
    const { container, line, length } = sizes[size4];
    const lines = 8;
    return /* @__PURE__ */ (0, import_jsx_runtime89.jsx)(
      "svg",
      {
        width: container,
        height: container,
        viewBox: `0 0 ${container} ${container}`,
        className: cn("animate-ios-spinner", colors3[color2], className),
        role: "status",
        "aria-label": "Loading",
        children: Array.from({ length: lines }).map((_2, i3) => {
          const angle = i3 * 360 / lines;
          const opacity = (i3 + 1) / lines;
          return /* @__PURE__ */ (0, import_jsx_runtime89.jsx)(
            "rect",
            {
              x: container / 2 - line / 2,
              y: 2,
              width: line,
              height: length,
              rx: line / 2,
              opacity,
              transform: `rotate(${angle} ${container / 2} ${container / 2})`
            },
            i3
          );
        })
      }
    );
  };
  var spinnerStyles = `
@keyframes ios-spinner {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}
.animate-ios-spinner {
  animation: ios-spinner 0.8s steps(8) infinite;
}
`;
  if (typeof document !== "undefined") {
    const styleId = "auralix-spinner-styles";
    if (!document.getElementById(styleId)) {
      const style = document.createElement("style");
      style.id = styleId;
      style.textContent = spinnerStyles;
      document.head.appendChild(style);
    }
  }

  // src/components/SpotlightCard.tsx
  var import_react116 = __toESM(require_react());
  var import_jsx_runtime90 = __toESM(require_jsx_runtime());
  function SpotlightCard({
    children,
    className,
    spotlightColor = "rgba(139, 92, 246, 0.15)",
    // Violet-ish
    ...props
  }) {
    const divRef = (0, import_react116.useRef)(null);
    const [position, setPosition] = (0, import_react116.useState)({ x: 0, y: 0 });
    const [opacity, setOpacity] = (0, import_react116.useState)(0);
    const handleMouseMove = (e2) => {
      if (!divRef.current) return;
      const rect = divRef.current.getBoundingClientRect();
      setPosition({ x: e2.clientX - rect.left, y: e2.clientY - rect.top });
    };
    const handleMouseEnter = () => {
      setOpacity(1);
    };
    const handleMouseLeave = () => {
      setOpacity(0);
    };
    return /* @__PURE__ */ (0, import_jsx_runtime90.jsxs)(
      "div",
      {
        ref: divRef,
        onMouseMove: handleMouseMove,
        onMouseEnter: handleMouseEnter,
        onMouseLeave: handleMouseLeave,
        className: cn(
          "relative overflow-hidden rounded-[2rem] border border-white/10 bg-background/60 backdrop-blur-md transition-colors hover:border-violet-500/20",
          className
        ),
        ...props,
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime90.jsx)(
            "div",
            {
              className: "pointer-events-none absolute -inset-px opacity-0 transition-opacity duration-300",
              style: {
                opacity,
                background: `radial-gradient(600px circle at ${position.x}px ${position.y}px, ${spotlightColor}, transparent 40%)`
              }
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime90.jsx)("div", { className: "relative h-full", children })
        ]
      }
    );
  }

  // src/components/SpringButton.tsx
  var import_react117 = __toESM(require_react());
  var import_jsx_runtime91 = __toESM(require_jsx_runtime());
  function SpringButton({
    children,
    springConfig = { tension: 300, friction: 10 },
    className,
    ...props
  }) {
    const [isPressed, setIsPressed] = (0, import_react117.useState)(false);
    const [isHovered, setIsHovered] = (0, import_react117.useState)(false);
    const springs = useSpring2({
      transform: isPressed ? "scale(0.95)" : isHovered ? "scale(1.05)" : "scale(1)",
      config: springConfig
    });
    return /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(animated.div, { style: springs, className: "inline-block", children: /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
      Button,
      {
        className,
        onMouseDown: () => setIsPressed(true),
        onMouseUp: () => setIsPressed(false),
        onMouseEnter: () => setIsHovered(true),
        onMouseLeave: () => {
          setIsHovered(false);
          setIsPressed(false);
        },
        ...props,
        children
      }
    ) });
  }

  // src/components/StatusDot.tsx
  var import_jsx_runtime92 = __toESM(require_jsx_runtime());
  var StatusDot = ({
    status = "default",
    size: size4 = "md",
    pulse = false,
    className
  }) => {
    const statusColors = {
      online: "bg-green-500",
      offline: "bg-zinc-400 dark:bg-zinc-600",
      away: "bg-yellow-500",
      busy: "bg-red-500",
      default: "bg-[#007AFF] dark:bg-[#0A84FF]"
    };
    const sizeClasses2 = {
      sm: "w-2 h-2",
      md: "w-2.5 h-2.5",
      lg: "w-3 h-3"
    };
    return /* @__PURE__ */ (0, import_jsx_runtime92.jsxs)("span", { className: cn("relative inline-flex", className), children: [
      /* @__PURE__ */ (0, import_jsx_runtime92.jsx)(
        "span",
        {
          className: cn(
            "rounded-full",
            sizeClasses2[size4],
            statusColors[status]
          )
        }
      ),
      pulse && status === "online" && /* @__PURE__ */ (0, import_jsx_runtime92.jsx)(
        "span",
        {
          className: cn(
            "absolute inset-0 rounded-full animate-ping",
            statusColors[status],
            "opacity-75"
          )
        }
      )
    ] });
  };
  var StatusBadge = ({
    status,
    label,
    size: size4 = "md",
    className
  }) => {
    const defaultLabels = {
      online: "Online",
      offline: "Offline",
      away: "Away",
      busy: "Do not disturb"
    };
    const displayLabel = label || defaultLabels[status];
    const sizeClasses2 = {
      sm: "text-xs px-2 py-0.5 gap-1.5",
      md: "text-sm px-2.5 py-1 gap-2"
    };
    return /* @__PURE__ */ (0, import_jsx_runtime92.jsxs)(
      "span",
      {
        className: cn(
          "inline-flex items-center rounded-full",
          "bg-muted/50 dark:bg-zinc-800",
          sizeClasses2[size4],
          className
        ),
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime92.jsx)(StatusDot, { status, size: "sm" }),
          /* @__PURE__ */ (0, import_jsx_runtime92.jsx)("span", { className: "text-muted-foreground", children: displayLabel })
        ]
      }
    );
  };

  // src/components/Switch.tsx
  var React97 = __toESM(require_react());
  var import_jsx_runtime93 = __toESM(require_jsx_runtime());
  var Switch = React97.forwardRef(
    ({ className, checked, onCheckedChange, variant = "ios", ...props }, ref) => {
      const handleClick = (e2) => {
        onCheckedChange?.(!checked);
        props.onClick?.(e2);
      };
      return /* @__PURE__ */ (0, import_jsx_runtime93.jsx)(
        "button",
        {
          type: "button",
          role: "switch",
          "aria-checked": checked,
          ref,
          onClick: handleClick,
          className: cn(
            "peer inline-flex shrink-0 cursor-pointer items-center border-2 border-transparent transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50",
            // Base Sizing
            variant !== "material" && "h-6 w-11 rounded-full",
            // iOS & Cyber
            variant === "material" && "h-6 w-10 rounded-full",
            // Material
            // Variant: iOS (Default) - Glassy
            variant === "ios" && "backdrop-blur-md",
            variant === "ios" && (checked ? "bg-blue-500/50" : "bg-black/5 dark:bg-white/10 input"),
            // Variant: Material - Solid colors
            variant === "material" && (checked ? "bg-blue-600" : "bg-zinc-300 dark:bg-zinc-700"),
            // Variant: Cyber - Neon/Square
            variant === "cyber" && "rounded-sm border-2",
            variant === "cyber" && (checked ? "border-cyan-500 bg-cyan-950/50 shadow-[0_0_10px_rgba(6,182,212,0.5)]" : "border-zinc-700 bg-zinc-900 dark:bg-zinc-900"),
            className
          ),
          ...props,
          children: /* @__PURE__ */ (0, import_jsx_runtime93.jsx)(
            "span",
            {
              className: cn(
                "pointer-events-none block transition-transform",
                // iOS Thumb
                variant === "ios" && "h-5 w-5 rounded-full shadow-[0_0_10px_rgba(255,255,255,0.5)] ring-0",
                variant === "ios" && (checked ? "translate-x-5 bg-white" : "translate-x-0 bg-white/70"),
                // Material Thumb
                variant === "material" && "h-4 w-4 rounded-full shadow-md transition-all duration-200",
                variant === "material" && (checked ? "translate-x-5 bg-white" : "translate-x-1 bg-white"),
                // Cyber Thumb
                variant === "cyber" && "h-3 w-3 rounded-none bg-cyan-500 shadow-[0_0_5px_currentColor]",
                variant === "cyber" && (checked ? "translate-x-6 opacity-100" : "translate-x-1 opacity-20")
              )
            }
          )
        }
      );
    }
  );
  Switch.displayName = "Switch";

  // src/components/Table.tsx
  var React98 = __toESM(require_react());
  var import_jsx_runtime94 = __toESM(require_jsx_runtime());
  var TableContext = React98.createContext(null);
  function Table({
    className,
    variant = "simple",
    ...props
  }) {
    return /* @__PURE__ */ (0, import_jsx_runtime94.jsx)(TableContext.Provider, { value: { variant }, children: /* @__PURE__ */ (0, import_jsx_runtime94.jsx)("div", { className: cn(
      "relative w-full overflow-auto",
      variant === "bordered" && "rounded-lg border",
      className
    ), children: /* @__PURE__ */ (0, import_jsx_runtime94.jsx)(
      "table",
      {
        className: cn(
          "w-full caption-bottom text-sm",
          variant === "striped" && "overflow-hidden rounded-lg"
        ),
        ...props
      }
    ) }) });
  }
  Table.displayName = "Table";
  var TableHeader = React98.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ (0, import_jsx_runtime94.jsx)("thead", { ref, className: cn("[&_tr]:border-b", className), ...props }));
  TableHeader.displayName = "TableHeader";
  var TableBody = React98.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ (0, import_jsx_runtime94.jsx)(
    "tbody",
    {
      ref,
      className: cn("[&_tr:last-child]:border-0", className),
      ...props
    }
  ));
  TableBody.displayName = "TableBody";
  var TableFooter = React98.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ (0, import_jsx_runtime94.jsx)(
    "tfoot",
    {
      ref,
      className: cn(
        "border-t bg-muted/50 font-medium [&>tr]:last:border-b-0",
        className
      ),
      ...props
    }
  ));
  TableFooter.displayName = "TableFooter";
  var TableRow = React98.forwardRef(({ className, ...props }, ref) => {
    const context = React98.useContext(TableContext);
    const variant = context?.variant || "simple";
    return /* @__PURE__ */ (0, import_jsx_runtime94.jsx)(
      "tr",
      {
        ref,
        className: cn(
          "transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted",
          // Simple/Bordered: Bottom border
          (variant === "simple" || variant === "bordered") && "border-b border-border",
          // Striped: Alternating colors, no border usually, or subtle border
          variant === "striped" && "border-none odd:bg-black/5 dark:odd:bg-white/5 even:bg-transparent hover:bg-black/5 dark:hover:bg-white/10",
          className
        ),
        ...props
      }
    );
  });
  TableRow.displayName = "TableRow";
  var TableHead = React98.forwardRef(({ className, ...props }, ref) => {
    const context = React98.useContext(TableContext);
    const variant = context?.variant || "simple";
    return /* @__PURE__ */ (0, import_jsx_runtime94.jsx)(
      "th",
      {
        ref,
        className: cn(
          "h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0",
          variant === "bordered" && "border-r border-border last:border-r-0 bg-muted/50",
          className
        ),
        ...props
      }
    );
  });
  TableHead.displayName = "TableHead";
  var TableCell = React98.forwardRef(({ className, ...props }, ref) => {
    const context = React98.useContext(TableContext);
    const variant = context?.variant || "simple";
    return /* @__PURE__ */ (0, import_jsx_runtime94.jsx)(
      "td",
      {
        ref,
        className: cn(
          "p-4 align-middle [&:has([role=checkbox])]:pr-0",
          variant === "bordered" && "border-r border-border last:border-r-0",
          className
        ),
        ...props
      }
    );
  });
  TableCell.displayName = "TableCell";
  var TableCaption = React98.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ (0, import_jsx_runtime94.jsx)(
    "caption",
    {
      ref,
      className: cn("mt-4 text-sm text-muted-foreground", className),
      ...props
    }
  ));
  TableCaption.displayName = "TableCaption";

  // src/components/Tabs.tsx
  var React99 = __toESM(require_react());
  var import_jsx_runtime95 = __toESM(require_jsx_runtime());
  var TabsContext = React99.createContext(null);
  function Tabs({
    defaultValue,
    className,
    children,
    variant = "pill"
  }) {
    const [activeTab, setActiveTab] = React99.useState(defaultValue);
    return /* @__PURE__ */ (0, import_jsx_runtime95.jsx)(TabsContext.Provider, { value: { activeTab, setActiveTab, variant }, children: /* @__PURE__ */ (0, import_jsx_runtime95.jsx)("div", { className: cn("w-full", className), children }) });
  }
  function TabsList({
    className,
    children
  }) {
    const context = React99.useContext(TabsContext);
    const variant = context?.variant || "pill";
    return /* @__PURE__ */ (0, import_jsx_runtime95.jsx)(
      "div",
      {
        className: cn(
          "inline-flex items-center justify-center text-muted-foreground",
          // Pill (Default)
          variant === "pill" && "h-10 rounded-full bg-muted/50 p-1 backdrop-blur-md",
          // Line (Underline style)
          variant === "line" && "h-10 w-full justify-start border-b border-border bg-transparent rounded-none p-0 gap-6",
          // Segmented (iOS Style)
          variant === "segmented" && "h-9 rounded-lg bg-muted p-1 border border-border w-full",
          className
        ),
        children
      }
    );
  }
  function TabsTrigger({
    value,
    className,
    children
  }) {
    const context = React99.useContext(TabsContext);
    if (!context) throw new Error("TabsTrigger must be used within Tabs");
    const isActive = context.activeTab === value;
    const { variant } = context;
    return /* @__PURE__ */ (0, import_jsx_runtime95.jsx)(
      "button",
      {
        onClick: () => context.setActiveTab(value),
        className: cn(
          "inline-flex items-center justify-center whitespace-nowrap px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
          // Pill Variant
          variant === "pill" && "rounded-full hover:bg-muted hover:text-foreground",
          variant === "pill" && isActive && "bg-background text-foreground shadow-sm backdrop-blur-sm",
          // Line Variant
          variant === "line" && "rounded-none border-b-2 border-transparent px-1 hover:text-foreground",
          variant === "line" && isActive && "border-primary text-primary",
          // Segmented Variant
          variant === "segmented" && "rounded-md flex-1",
          variant === "segmented" && isActive && "bg-background text-foreground shadow-sm",
          variant === "segmented" && !isActive && "hover:bg-background/50",
          className
        ),
        children
      }
    );
  }
  function TabsContent({
    value,
    className,
    children
  }) {
    const context = React99.useContext(TabsContext);
    if (!context) throw new Error("TabsContent must be used within Tabs");
    if (context.activeTab !== value) return null;
    return /* @__PURE__ */ (0, import_jsx_runtime95.jsx)(
      "div",
      {
        className: cn(
          "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 animate-in fade-in zoom-in-95 duration-200",
          className
        ),
        children
      }
    );
  }

  // src/components/Tag.tsx
  var import_jsx_runtime96 = __toESM(require_jsx_runtime());
  var Tag = ({
    children,
    variant = "default",
    size: size4 = "md",
    removable = false,
    onRemove,
    className
  }) => {
    const variantClasses = {
      default: "bg-muted/50 text-foreground dark:bg-zinc-800",
      primary: "bg-[#007AFF]/10 text-[#007AFF] dark:bg-[#0A84FF]/10 dark:text-[#0A84FF]",
      success: "bg-emerald-500/10 text-emerald-600 dark:bg-emerald-500/10 dark:text-emerald-400",
      warning: "bg-amber-500/10 text-amber-600 dark:bg-amber-500/10 dark:text-amber-400",
      error: "bg-red-500/10 text-red-600 dark:bg-red-500/10 dark:text-red-400"
    };
    const sizeClasses2 = {
      sm: "text-xs px-2 py-0.5 gap-1",
      md: "text-sm px-2.5 py-1 gap-1.5",
      lg: "text-sm px-3 py-1.5 gap-2"
    };
    const iconSizes = {
      sm: "w-3 h-3",
      md: "w-3.5 h-3.5",
      lg: "w-4 h-4"
    };
    return /* @__PURE__ */ (0, import_jsx_runtime96.jsxs)(
      "span",
      {
        className: cn(
          "inline-flex items-center rounded-full font-medium transition-colors",
          variantClasses[variant],
          sizeClasses2[size4],
          className
        ),
        children: [
          children,
          removable && /* @__PURE__ */ (0, import_jsx_runtime96.jsx)(
            "button",
            {
              type: "button",
              onClick: onRemove,
              className: "opacity-60 hover:opacity-100 transition-opacity",
              children: /* @__PURE__ */ (0, import_jsx_runtime96.jsx)(
                "svg",
                {
                  className: iconSizes[size4],
                  fill: "none",
                  viewBox: "0 0 24 24",
                  stroke: "currentColor",
                  strokeWidth: 2,
                  children: /* @__PURE__ */ (0, import_jsx_runtime96.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M6 18L18 6M6 6l12 12" })
                }
              )
            }
          )
        ]
      }
    );
  };
  var TagGroup = ({ children, className }) => {
    return /* @__PURE__ */ (0, import_jsx_runtime96.jsx)("div", { className: cn("flex flex-wrap gap-2", className), children });
  };

  // src/components/TerminalMockup.tsx
  var import_react118 = __toESM(require_react());
  var import_jsx_runtime97 = __toESM(require_jsx_runtime());
  var TerminalMockup = ({
    children,
    title = "Terminal",
    className
  }) => {
    return /* @__PURE__ */ (0, import_jsx_runtime97.jsxs)(
      "div",
      {
        className: cn(
          "rounded-xl overflow-hidden border border-border/50 bg-zinc-900 shadow-xl shadow-black/20",
          "dark:border-zinc-800",
          className
        ),
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime97.jsxs)("div", { className: "flex items-center gap-2 px-4 py-3 bg-zinc-800 border-b border-zinc-700", children: [
            /* @__PURE__ */ (0, import_jsx_runtime97.jsxs)("div", { className: "flex items-center gap-1.5", children: [
              /* @__PURE__ */ (0, import_jsx_runtime97.jsx)("div", { className: "w-3 h-3 rounded-full bg-red-500" }),
              /* @__PURE__ */ (0, import_jsx_runtime97.jsx)("div", { className: "w-3 h-3 rounded-full bg-yellow-500" }),
              /* @__PURE__ */ (0, import_jsx_runtime97.jsx)("div", { className: "w-3 h-3 rounded-full bg-green-500" })
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime97.jsx)("div", { className: "flex-1 text-center", children: /* @__PURE__ */ (0, import_jsx_runtime97.jsx)("span", { className: "text-xs text-zinc-400 font-medium", children: title }) }),
            /* @__PURE__ */ (0, import_jsx_runtime97.jsx)("div", { className: "w-[52px]" })
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime97.jsx)("div", { className: "p-4 font-mono text-sm text-zinc-300", children })
        ]
      }
    );
  };
  var TerminalLine = ({
    prompt = "$",
    command,
    output,
    className
  }) => {
    return /* @__PURE__ */ (0, import_jsx_runtime97.jsxs)("div", { className: cn("mb-1", className), children: [
      command && /* @__PURE__ */ (0, import_jsx_runtime97.jsxs)("div", { className: "flex items-center gap-2", children: [
        /* @__PURE__ */ (0, import_jsx_runtime97.jsx)("span", { className: "text-green-400", children: prompt }),
        /* @__PURE__ */ (0, import_jsx_runtime97.jsx)("span", { className: "text-zinc-100", children: command })
      ] }),
      output && /* @__PURE__ */ (0, import_jsx_runtime97.jsx)("div", { className: "text-zinc-400 pl-4 mt-0.5 whitespace-pre-wrap", children: output })
    ] });
  };
  var AnimatedTerminal = ({
    lines,
    className
  }) => {
    const [visibleLines, setVisibleLines] = import_react118.default.useState(0);
    const [typedCommand, setTypedCommand] = import_react118.default.useState("");
    const [currentLine, setCurrentLine] = import_react118.default.useState(0);
    import_react118.default.useEffect(() => {
      if (currentLine >= lines.length) return;
      const line = lines[currentLine];
      const command = line.command || "";
      const delay2 = line.delay || 0;
      let charIndex = 0;
      const typeInterval = setInterval(() => {
        if (charIndex < command.length) {
          setTypedCommand(command.slice(0, charIndex + 1));
          charIndex++;
        } else {
          clearInterval(typeInterval);
          setTimeout(() => {
            setVisibleLines(currentLine + 1);
            setTypedCommand("");
            setCurrentLine(currentLine + 1);
          }, 500);
        }
      }, 50);
      return () => clearInterval(typeInterval);
    }, [currentLine, lines]);
    return /* @__PURE__ */ (0, import_jsx_runtime97.jsxs)(TerminalMockup, { className, children: [
      lines.slice(0, visibleLines).map((line, index2) => /* @__PURE__ */ (0, import_jsx_runtime97.jsx)(
        TerminalLine,
        {
          prompt: line.prompt,
          command: line.command,
          output: line.output
        },
        index2
      )),
      currentLine < lines.length && /* @__PURE__ */ (0, import_jsx_runtime97.jsx)(
        TerminalLine,
        {
          prompt: lines[currentLine].prompt,
          command: typedCommand + (typedCommand ? "\u258B" : "\u258B")
        }
      )
    ] });
  };

  // src/components/TextReveal.tsx
  var import_react119 = __toESM(require_react());
  var import_jsx_runtime98 = __toESM(require_jsx_runtime());
  var TextReveal = ({
    children,
    className
  }) => {
    const containerRef = import_react119.default.useRef(null);
    const [progress2, setProgress] = import_react119.default.useState(0);
    import_react119.default.useEffect(() => {
      const handleScroll2 = () => {
        if (!containerRef.current) return;
        const rect = containerRef.current.getBoundingClientRect();
        const windowHeight = window.innerHeight;
        const elementTop = rect.top;
        const elementHeight = rect.height;
        const start2 = windowHeight * 0.8;
        const end = windowHeight * 0.2;
        const currentProgress = Math.max(
          0,
          Math.min(1, (start2 - elementTop) / (start2 - end))
        );
        setProgress(currentProgress);
      };
      window.addEventListener("scroll", handleScroll2);
      handleScroll2();
      return () => window.removeEventListener("scroll", handleScroll2);
    }, []);
    const words = children.split(" ");
    const revealedWordCount = Math.ceil(progress2 * words.length);
    return /* @__PURE__ */ (0, import_jsx_runtime98.jsx)("div", { ref: containerRef, className: cn("relative", className), children: words.map((word, index2) => /* @__PURE__ */ (0, import_jsx_runtime98.jsx)(
      "span",
      {
        className: cn(
          "inline-block mr-[0.25em] transition-all duration-300",
          index2 < revealedWordCount ? "opacity-100 blur-0 text-foreground" : "opacity-30 blur-[1px] text-muted-foreground"
        ),
        children: word
      },
      index2
    )) });
  };
  var CharReveal = ({
    children,
    staggerDelay = 30,
    className
  }) => {
    const [isVisible, setIsVisible] = import_react119.default.useState(false);
    const ref = import_react119.default.useRef(null);
    import_react119.default.useEffect(() => {
      const observer2 = new IntersectionObserver(
        ([entry]) => {
          if (entry.isIntersecting) {
            setIsVisible(true);
          }
        },
        { threshold: 0.1 }
      );
      if (ref.current) {
        observer2.observe(ref.current);
      }
      return () => observer2.disconnect();
    }, []);
    const chars = children.split("");
    return /* @__PURE__ */ (0, import_jsx_runtime98.jsx)("div", { ref, className: cn("inline-block", className), children: chars.map((char, index2) => /* @__PURE__ */ (0, import_jsx_runtime98.jsx)(
      "span",
      {
        className: "inline-block transition-all duration-300",
        style: {
          opacity: isVisible ? 1 : 0,
          transform: isVisible ? "translateY(0)" : "translateY(20px)",
          transitionDelay: `${index2 * staggerDelay}ms`
        },
        children: char === " " ? "\xA0" : char
      },
      index2
    )) });
  };

  // src/components/Textarea.tsx
  var import_react120 = __toESM(require_react());
  var import_jsx_runtime99 = __toESM(require_jsx_runtime());
  var Textarea = (0, import_react120.forwardRef)(
    ({ className, error, variant = "default", disabled, ...props }, ref) => {
      return /* @__PURE__ */ (0, import_jsx_runtime99.jsx)(
        "textarea",
        {
          ref,
          disabled,
          className: cn(
            "flex min-h-[80px] w-full px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 transition-all",
            // Default: Boxed (matches original style)
            variant === "default" && "rounded-[2rem] border bg-background/50 px-4 py-3 text-foreground backdrop-blur-sm",
            variant === "default" && (!error ? "border-border" : "border-destructive focus:ring-destructive"),
            // Ghost: Minimal
            variant === "ghost" && "rounded-lg border-transparent bg-transparent hover:bg-muted/50 focus:bg-background focus:border-input",
            // Terminal: Code style
            variant === "terminal" && "rounded-none border-zinc-700 bg-black/90 text-green-400 font-mono placeholder:text-zinc-600 focus:ring-green-500/50",
            className
          ),
          ...props
        }
      );
    }
  );
  Textarea.displayName = "Textarea";

  // src/components/TiltCard.tsx
  var import_react121 = __toESM(require_react());
  var import_jsx_runtime100 = __toESM(require_jsx_runtime());
  var TiltCard = ({
    children,
    className,
    maxTilt = 15,
    scale: scale2 = 1.02,
    speed = 400,
    glare = true,
    glareMaxOpacity = 0.2
  }) => {
    const cardRef = import_react121.default.useRef(null);
    const [style, setStyle2] = import_react121.default.useState({});
    const [glareStyle, setGlareStyle] = import_react121.default.useState({});
    const handleMouseMove = (e2) => {
      if (!cardRef.current) return;
      const rect = cardRef.current.getBoundingClientRect();
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;
      const mouseX = e2.clientX - centerX;
      const mouseY = e2.clientY - centerY;
      const rotateX = -mouseY / (rect.height / 2) * maxTilt;
      const rotateY = mouseX / (rect.width / 2) * maxTilt;
      setStyle2({
        transform: `perspective(1000px) rotateX(${rotateX}deg) rotateY(${rotateY}deg) scale(${scale2})`,
        transition: `transform ${speed}ms cubic-bezier(0.03, 0.98, 0.52, 0.99)`
      });
      if (glare) {
        const glareX = (mouseX / rect.width + 0.5) * 100;
        const glareY = (mouseY / rect.height + 0.5) * 100;
        setGlareStyle({
          background: `radial-gradient(circle at ${glareX}% ${glareY}%, rgba(255,255,255,${glareMaxOpacity}), transparent 60%)`,
          opacity: 1
        });
      }
    };
    const handleMouseLeave = () => {
      setStyle2({
        transform: "perspective(1000px) rotateX(0deg) rotateY(0deg) scale(1)",
        transition: `transform ${speed}ms cubic-bezier(0.03, 0.98, 0.52, 0.99)`
      });
      setGlareStyle({ opacity: 0 });
    };
    return /* @__PURE__ */ (0, import_jsx_runtime100.jsxs)(
      "div",
      {
        ref: cardRef,
        className: cn(
          "relative rounded-2xl overflow-hidden",
          "border border-border/50 bg-background/80 backdrop-blur-sm",
          "dark:bg-zinc-900/80 dark:border-zinc-800",
          className
        ),
        style,
        onMouseMove: handleMouseMove,
        onMouseLeave: handleMouseLeave,
        children: [
          children,
          glare && /* @__PURE__ */ (0, import_jsx_runtime100.jsx)(
            "div",
            {
              className: "absolute inset-0 pointer-events-none transition-opacity duration-300",
              style: glareStyle
            }
          )
        ]
      }
    );
  };

  // src/components/Toast.tsx
  var import_react122 = __toESM(require_react());
  var import_jsx_runtime101 = __toESM(require_jsx_runtime());
  var ToastContext = (0, import_react122.createContext)(void 0);
  function ToastProvider({ children }) {
    const [toasts, setToasts] = (0, import_react122.useState)([]);
    const toast = (message2, type = "default", duration = 3e3) => {
      const id3 = Math.random().toString(36).substring(7);
      setToasts((prev) => [...prev, { id: id3, message: message2, type, duration }]);
      setTimeout(() => {
        removeToast(id3);
      }, duration);
    };
    const removeToast = (id3) => {
      setToasts((prev) => prev.filter((t3) => t3.id !== id3));
    };
    return /* @__PURE__ */ (0, import_jsx_runtime101.jsxs)(ToastContext.Provider, { value: { toast }, children: [
      children,
      /* @__PURE__ */ (0, import_jsx_runtime101.jsx)("div", { className: "fixed bottom-4 right-4 z-[9999] flex flex-col gap-2 pointer-events-none", children: /* @__PURE__ */ (0, import_jsx_runtime101.jsx)(AnimatePresence, { children: toasts.map((t3) => /* @__PURE__ */ (0, import_jsx_runtime101.jsxs)(
        motion.div,
        {
          initial: { opacity: 0, y: 20, scale: 0.9 },
          animate: { opacity: 1, y: 0, scale: 1 },
          exit: { opacity: 0, x: 20, scale: 0.9 },
          layout: true,
          className: cn(
            "pointer-events-auto flex items-center gap-3 px-4 py-3 rounded-xl shadow-lg border backdrop-blur-md min-w-[300px]",
            t3.type === "default" && "bg-background/80 border-border text-foreground",
            t3.type === "success" && "bg-green-500/10 border-green-500/20 text-green-600 dark:text-green-400",
            t3.type === "error" && "bg-red-500/10 border-red-500/20 text-red-600 dark:text-red-400",
            t3.type === "warning" && "bg-yellow-500/10 border-yellow-500/20 text-yellow-600 dark:text-yellow-400",
            t3.type === "info" && "bg-blue-500/10 border-blue-500/20 text-blue-600 dark:text-blue-400"
          ),
          children: [
            t3.type === "success" && /* @__PURE__ */ (0, import_jsx_runtime101.jsx)(Check, { className: "w-4 h-4" }),
            t3.type === "error" && /* @__PURE__ */ (0, import_jsx_runtime101.jsx)(CircleAlert, { className: "w-4 h-4" }),
            t3.type === "warning" && /* @__PURE__ */ (0, import_jsx_runtime101.jsx)(CircleAlert, { className: "w-4 h-4" }),
            t3.type === "info" && /* @__PURE__ */ (0, import_jsx_runtime101.jsx)(Info, { className: "w-4 h-4" }),
            /* @__PURE__ */ (0, import_jsx_runtime101.jsx)("span", { className: "text-sm font-medium", children: t3.message }),
            /* @__PURE__ */ (0, import_jsx_runtime101.jsx)(
              "button",
              {
                onClick: () => removeToast(t3.id),
                className: "ml-auto hover:bg-black/5 dark:hover:bg-white/10 rounded-full p-1 transition-colors",
                children: /* @__PURE__ */ (0, import_jsx_runtime101.jsx)(X, { className: "w-3 h-3 opacity-60" })
              }
            )
          ]
        },
        t3.id
      )) }) })
    ] });
  }
  function useToast() {
    const context = (0, import_react122.useContext)(ToastContext);
    if (!context) {
      throw new Error("useToast must be used within a ToastProvider");
    }
    return context;
  }

  // src/components/Toggle.tsx
  var React104 = __toESM(require_react());
  var import_jsx_runtime102 = __toESM(require_jsx_runtime());
  var toggleVariants = cva(
    "inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors hover:bg-muted hover:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground",
    {
      variants: {
        variant: {
          default: "bg-transparent",
          outline: "border border-input bg-transparent hover:bg-accent hover:text-accent-foreground"
        },
        size: {
          default: "h-10 px-3",
          sm: "h-9 px-2.5",
          lg: "h-11 px-5"
        }
      },
      defaultVariants: {
        variant: "default",
        size: "default"
      }
    }
  );
  var Toggle = React104.forwardRef(
    ({ className, variant, size: size4, pressed, onPressedChange, ...props }, ref) => {
      return /* @__PURE__ */ (0, import_jsx_runtime102.jsx)(
        "button",
        {
          ref,
          type: "button",
          "aria-pressed": pressed,
          "data-state": pressed ? "on" : "off",
          className: cn(toggleVariants({ variant, size: size4, className })),
          onClick: () => onPressedChange?.(!pressed),
          ...props
        }
      );
    }
  );
  Toggle.displayName = "Toggle";

  // src/components/ToggleGroup.tsx
  var React108 = __toESM(require_react());

  // ../../node_modules/@radix-ui/react-toggle-group/dist/index.mjs
  var import_react123 = __toESM(require_react2(), 1);

  // ../../node_modules/@radix-ui/react-roving-focus/dist/index.mjs
  var React105 = __toESM(require_react2(), 1);
  var import_jsx_runtime103 = __toESM(require_jsx_runtime2(), 1);
  var ENTRY_FOCUS = "rovingFocusGroup.onEntryFocus";
  var EVENT_OPTIONS2 = { bubbles: false, cancelable: true };
  var GROUP_NAME = "RovingFocusGroup";
  var [Collection2, useCollection2, createCollectionScope2] = createCollection(GROUP_NAME);
  var [createRovingFocusGroupContext, createRovingFocusGroupScope] = createContextScope2(
    GROUP_NAME,
    [createCollectionScope2]
  );
  var [RovingFocusProvider, useRovingFocusContext] = createRovingFocusGroupContext(GROUP_NAME);
  var RovingFocusGroup = React105.forwardRef(
    (props, forwardedRef) => {
      return /* @__PURE__ */ (0, import_jsx_runtime103.jsx)(Collection2.Provider, { scope: props.__scopeRovingFocusGroup, children: /* @__PURE__ */ (0, import_jsx_runtime103.jsx)(Collection2.Slot, { scope: props.__scopeRovingFocusGroup, children: /* @__PURE__ */ (0, import_jsx_runtime103.jsx)(RovingFocusGroupImpl, { ...props, ref: forwardedRef }) }) });
    }
  );
  RovingFocusGroup.displayName = GROUP_NAME;
  var RovingFocusGroupImpl = React105.forwardRef((props, forwardedRef) => {
    const {
      __scopeRovingFocusGroup,
      orientation,
      loop: loop2 = false,
      dir,
      currentTabStopId: currentTabStopIdProp,
      defaultCurrentTabStopId,
      onCurrentTabStopIdChange,
      onEntryFocus,
      preventScrollOnEntryFocus = false,
      ...groupProps
    } = props;
    const ref = React105.useRef(null);
    const composedRefs = useComposedRefs2(forwardedRef, ref);
    const direction = useDirection(dir);
    const [currentTabStopId, setCurrentTabStopId] = useControllableState({
      prop: currentTabStopIdProp,
      defaultProp: defaultCurrentTabStopId ?? null,
      onChange: onCurrentTabStopIdChange,
      caller: GROUP_NAME
    });
    const [isTabbingBackOut, setIsTabbingBackOut] = React105.useState(false);
    const handleEntryFocus = useCallbackRef(onEntryFocus);
    const getItems = useCollection2(__scopeRovingFocusGroup);
    const isClickFocusRef = React105.useRef(false);
    const [focusableItemsCount, setFocusableItemsCount] = React105.useState(0);
    React105.useEffect(() => {
      const node = ref.current;
      if (node) {
        node.addEventListener(ENTRY_FOCUS, handleEntryFocus);
        return () => node.removeEventListener(ENTRY_FOCUS, handleEntryFocus);
      }
    }, [handleEntryFocus]);
    return /* @__PURE__ */ (0, import_jsx_runtime103.jsx)(
      RovingFocusProvider,
      {
        scope: __scopeRovingFocusGroup,
        orientation,
        dir: direction,
        loop: loop2,
        currentTabStopId,
        onItemFocus: React105.useCallback(
          (tabStopId) => setCurrentTabStopId(tabStopId),
          [setCurrentTabStopId]
        ),
        onItemShiftTab: React105.useCallback(() => setIsTabbingBackOut(true), []),
        onFocusableItemAdd: React105.useCallback(
          () => setFocusableItemsCount((prevCount) => prevCount + 1),
          []
        ),
        onFocusableItemRemove: React105.useCallback(
          () => setFocusableItemsCount((prevCount) => prevCount - 1),
          []
        ),
        children: /* @__PURE__ */ (0, import_jsx_runtime103.jsx)(
          Primitive2.div,
          {
            tabIndex: isTabbingBackOut || focusableItemsCount === 0 ? -1 : 0,
            "data-orientation": orientation,
            ...groupProps,
            ref: composedRefs,
            style: { outline: "none", ...props.style },
            onMouseDown: composeEventHandlers(props.onMouseDown, () => {
              isClickFocusRef.current = true;
            }),
            onFocus: composeEventHandlers(props.onFocus, (event) => {
              const isKeyboardFocus = !isClickFocusRef.current;
              if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut) {
                const entryFocusEvent = new CustomEvent(ENTRY_FOCUS, EVENT_OPTIONS2);
                event.currentTarget.dispatchEvent(entryFocusEvent);
                if (!entryFocusEvent.defaultPrevented) {
                  const items = getItems().filter((item) => item.focusable);
                  const activeItem = items.find((item) => item.active);
                  const currentItem = items.find((item) => item.id === currentTabStopId);
                  const candidateItems = [activeItem, currentItem, ...items].filter(
                    Boolean
                  );
                  const candidateNodes = candidateItems.map((item) => item.ref.current);
                  focusFirst2(candidateNodes, preventScrollOnEntryFocus);
                }
              }
              isClickFocusRef.current = false;
            }),
            onBlur: composeEventHandlers(props.onBlur, () => setIsTabbingBackOut(false))
          }
        )
      }
    );
  });
  var ITEM_NAME = "RovingFocusGroupItem";
  var RovingFocusGroupItem = React105.forwardRef(
    (props, forwardedRef) => {
      const {
        __scopeRovingFocusGroup,
        focusable = true,
        active = false,
        tabStopId,
        children,
        ...itemProps
      } = props;
      const autoId = useId5();
      const id3 = tabStopId || autoId;
      const context = useRovingFocusContext(ITEM_NAME, __scopeRovingFocusGroup);
      const isCurrentTabStop = context.currentTabStopId === id3;
      const getItems = useCollection2(__scopeRovingFocusGroup);
      const { onFocusableItemAdd, onFocusableItemRemove, currentTabStopId } = context;
      React105.useEffect(() => {
        if (focusable) {
          onFocusableItemAdd();
          return () => onFocusableItemRemove();
        }
      }, [focusable, onFocusableItemAdd, onFocusableItemRemove]);
      return /* @__PURE__ */ (0, import_jsx_runtime103.jsx)(
        Collection2.ItemSlot,
        {
          scope: __scopeRovingFocusGroup,
          id: id3,
          focusable,
          active,
          children: /* @__PURE__ */ (0, import_jsx_runtime103.jsx)(
            Primitive2.span,
            {
              tabIndex: isCurrentTabStop ? 0 : -1,
              "data-orientation": context.orientation,
              ...itemProps,
              ref: forwardedRef,
              onMouseDown: composeEventHandlers(props.onMouseDown, (event) => {
                if (!focusable) event.preventDefault();
                else context.onItemFocus(id3);
              }),
              onFocus: composeEventHandlers(props.onFocus, () => context.onItemFocus(id3)),
              onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
                if (event.key === "Tab" && event.shiftKey) {
                  context.onItemShiftTab();
                  return;
                }
                if (event.target !== event.currentTarget) return;
                const focusIntent = getFocusIntent(event, context.orientation, context.dir);
                if (focusIntent !== void 0) {
                  if (event.metaKey || event.ctrlKey || event.altKey || event.shiftKey) return;
                  event.preventDefault();
                  const items = getItems().filter((item) => item.focusable);
                  let candidateNodes = items.map((item) => item.ref.current);
                  if (focusIntent === "last") candidateNodes.reverse();
                  else if (focusIntent === "prev" || focusIntent === "next") {
                    if (focusIntent === "prev") candidateNodes.reverse();
                    const currentIndex = candidateNodes.indexOf(event.currentTarget);
                    candidateNodes = context.loop ? wrapArray(candidateNodes, currentIndex + 1) : candidateNodes.slice(currentIndex + 1);
                  }
                  setTimeout(() => focusFirst2(candidateNodes));
                }
              }),
              children: typeof children === "function" ? children({ isCurrentTabStop, hasTabStop: currentTabStopId != null }) : children
            }
          )
        }
      );
    }
  );
  RovingFocusGroupItem.displayName = ITEM_NAME;
  var MAP_KEY_TO_FOCUS_INTENT = {
    ArrowLeft: "prev",
    ArrowUp: "prev",
    ArrowRight: "next",
    ArrowDown: "next",
    PageUp: "first",
    Home: "first",
    PageDown: "last",
    End: "last"
  };
  function getDirectionAwareKey(key, dir) {
    if (dir !== "rtl") return key;
    return key === "ArrowLeft" ? "ArrowRight" : key === "ArrowRight" ? "ArrowLeft" : key;
  }
  function getFocusIntent(event, orientation, dir) {
    const key = getDirectionAwareKey(event.key, dir);
    if (orientation === "vertical" && ["ArrowLeft", "ArrowRight"].includes(key)) return void 0;
    if (orientation === "horizontal" && ["ArrowUp", "ArrowDown"].includes(key)) return void 0;
    return MAP_KEY_TO_FOCUS_INTENT[key];
  }
  function focusFirst2(candidates, preventScroll = false) {
    const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
    for (const candidate of candidates) {
      if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;
      candidate.focus({ preventScroll });
      if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;
    }
  }
  function wrapArray(array, startIndex) {
    return array.map((_2, index2) => array[(startIndex + index2) % array.length]);
  }
  var Root5 = RovingFocusGroup;
  var Item = RovingFocusGroupItem;

  // ../../node_modules/@radix-ui/react-toggle/dist/index.mjs
  var React106 = __toESM(require_react2(), 1);
  var import_jsx_runtime104 = __toESM(require_jsx_runtime2(), 1);
  var NAME = "Toggle";
  var Toggle2 = React106.forwardRef((props, forwardedRef) => {
    const { pressed: pressedProp, defaultPressed, onPressedChange, ...buttonProps } = props;
    const [pressed, setPressed] = useControllableState({
      prop: pressedProp,
      onChange: onPressedChange,
      defaultProp: defaultPressed ?? false,
      caller: NAME
    });
    return /* @__PURE__ */ (0, import_jsx_runtime104.jsx)(
      Primitive2.button,
      {
        type: "button",
        "aria-pressed": pressed,
        "data-state": pressed ? "on" : "off",
        "data-disabled": props.disabled ? "" : void 0,
        ...buttonProps,
        ref: forwardedRef,
        onClick: composeEventHandlers(props.onClick, () => {
          if (!props.disabled) {
            setPressed(!pressed);
          }
        })
      }
    );
  });
  Toggle2.displayName = NAME;

  // ../../node_modules/@radix-ui/react-toggle-group/dist/index.mjs
  var import_jsx_runtime105 = __toESM(require_jsx_runtime2(), 1);
  var TOGGLE_GROUP_NAME = "ToggleGroup";
  var [createToggleGroupContext, createToggleGroupScope] = createContextScope2(TOGGLE_GROUP_NAME, [
    createRovingFocusGroupScope
  ]);
  var useRovingFocusGroupScope = createRovingFocusGroupScope();
  var ToggleGroup = import_react123.default.forwardRef((props, forwardedRef) => {
    const { type, ...toggleGroupProps } = props;
    if (type === "single") {
      const singleProps = toggleGroupProps;
      return /* @__PURE__ */ (0, import_jsx_runtime105.jsx)(ToggleGroupImplSingle, { ...singleProps, ref: forwardedRef });
    }
    if (type === "multiple") {
      const multipleProps = toggleGroupProps;
      return /* @__PURE__ */ (0, import_jsx_runtime105.jsx)(ToggleGroupImplMultiple, { ...multipleProps, ref: forwardedRef });
    }
    throw new Error(`Missing prop \`type\` expected on \`${TOGGLE_GROUP_NAME}\``);
  });
  ToggleGroup.displayName = TOGGLE_GROUP_NAME;
  var [ToggleGroupValueProvider, useToggleGroupValueContext] = createToggleGroupContext(TOGGLE_GROUP_NAME);
  var ToggleGroupImplSingle = import_react123.default.forwardRef((props, forwardedRef) => {
    const {
      value: valueProp,
      defaultValue,
      onValueChange = () => {
      },
      ...toggleGroupSingleProps
    } = props;
    const [value, setValue] = useControllableState({
      prop: valueProp,
      defaultProp: defaultValue ?? "",
      onChange: onValueChange,
      caller: TOGGLE_GROUP_NAME
    });
    return /* @__PURE__ */ (0, import_jsx_runtime105.jsx)(
      ToggleGroupValueProvider,
      {
        scope: props.__scopeToggleGroup,
        type: "single",
        value: import_react123.default.useMemo(() => value ? [value] : [], [value]),
        onItemActivate: setValue,
        onItemDeactivate: import_react123.default.useCallback(() => setValue(""), [setValue]),
        children: /* @__PURE__ */ (0, import_jsx_runtime105.jsx)(ToggleGroupImpl, { ...toggleGroupSingleProps, ref: forwardedRef })
      }
    );
  });
  var ToggleGroupImplMultiple = import_react123.default.forwardRef((props, forwardedRef) => {
    const {
      value: valueProp,
      defaultValue,
      onValueChange = () => {
      },
      ...toggleGroupMultipleProps
    } = props;
    const [value, setValue] = useControllableState({
      prop: valueProp,
      defaultProp: defaultValue ?? [],
      onChange: onValueChange,
      caller: TOGGLE_GROUP_NAME
    });
    const handleButtonActivate = import_react123.default.useCallback(
      (itemValue) => setValue((prevValue = []) => [...prevValue, itemValue]),
      [setValue]
    );
    const handleButtonDeactivate = import_react123.default.useCallback(
      (itemValue) => setValue((prevValue = []) => prevValue.filter((value2) => value2 !== itemValue)),
      [setValue]
    );
    return /* @__PURE__ */ (0, import_jsx_runtime105.jsx)(
      ToggleGroupValueProvider,
      {
        scope: props.__scopeToggleGroup,
        type: "multiple",
        value,
        onItemActivate: handleButtonActivate,
        onItemDeactivate: handleButtonDeactivate,
        children: /* @__PURE__ */ (0, import_jsx_runtime105.jsx)(ToggleGroupImpl, { ...toggleGroupMultipleProps, ref: forwardedRef })
      }
    );
  });
  ToggleGroup.displayName = TOGGLE_GROUP_NAME;
  var [ToggleGroupContext, useToggleGroupContext] = createToggleGroupContext(TOGGLE_GROUP_NAME);
  var ToggleGroupImpl = import_react123.default.forwardRef(
    (props, forwardedRef) => {
      const {
        __scopeToggleGroup,
        disabled = false,
        rovingFocus = true,
        orientation,
        dir,
        loop: loop2 = true,
        ...toggleGroupProps
      } = props;
      const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeToggleGroup);
      const direction = useDirection(dir);
      const commonProps = { role: "group", dir: direction, ...toggleGroupProps };
      return /* @__PURE__ */ (0, import_jsx_runtime105.jsx)(ToggleGroupContext, { scope: __scopeToggleGroup, rovingFocus, disabled, children: rovingFocus ? /* @__PURE__ */ (0, import_jsx_runtime105.jsx)(
        Root5,
        {
          asChild: true,
          ...rovingFocusGroupScope,
          orientation,
          dir: direction,
          loop: loop2,
          children: /* @__PURE__ */ (0, import_jsx_runtime105.jsx)(Primitive2.div, { ...commonProps, ref: forwardedRef })
        }
      ) : /* @__PURE__ */ (0, import_jsx_runtime105.jsx)(Primitive2.div, { ...commonProps, ref: forwardedRef }) });
    }
  );
  var ITEM_NAME2 = "ToggleGroupItem";
  var ToggleGroupItem = import_react123.default.forwardRef(
    (props, forwardedRef) => {
      const valueContext = useToggleGroupValueContext(ITEM_NAME2, props.__scopeToggleGroup);
      const context = useToggleGroupContext(ITEM_NAME2, props.__scopeToggleGroup);
      const rovingFocusGroupScope = useRovingFocusGroupScope(props.__scopeToggleGroup);
      const pressed = valueContext.value.includes(props.value);
      const disabled = context.disabled || props.disabled;
      const commonProps = { ...props, pressed, disabled };
      const ref = import_react123.default.useRef(null);
      return context.rovingFocus ? /* @__PURE__ */ (0, import_jsx_runtime105.jsx)(
        Item,
        {
          asChild: true,
          ...rovingFocusGroupScope,
          focusable: !disabled,
          active: pressed,
          ref,
          children: /* @__PURE__ */ (0, import_jsx_runtime105.jsx)(ToggleGroupItemImpl, { ...commonProps, ref: forwardedRef })
        }
      ) : /* @__PURE__ */ (0, import_jsx_runtime105.jsx)(ToggleGroupItemImpl, { ...commonProps, ref: forwardedRef });
    }
  );
  ToggleGroupItem.displayName = ITEM_NAME2;
  var ToggleGroupItemImpl = import_react123.default.forwardRef(
    (props, forwardedRef) => {
      const { __scopeToggleGroup, value, ...itemProps } = props;
      const valueContext = useToggleGroupValueContext(ITEM_NAME2, __scopeToggleGroup);
      const singleProps = { role: "radio", "aria-checked": props.pressed, "aria-pressed": void 0 };
      const typeProps = valueContext.type === "single" ? singleProps : void 0;
      return /* @__PURE__ */ (0, import_jsx_runtime105.jsx)(
        Toggle2,
        {
          ...typeProps,
          ...itemProps,
          ref: forwardedRef,
          onPressedChange: (pressed) => {
            if (pressed) {
              valueContext.onItemActivate(value);
            } else {
              valueContext.onItemDeactivate(value);
            }
          }
        }
      );
    }
  );
  var Root22 = ToggleGroup;
  var Item2 = ToggleGroupItem;

  // src/components/ToggleGroup.tsx
  var import_jsx_runtime106 = __toESM(require_jsx_runtime());
  var ToggleGroup2 = React108.forwardRef(({ className, variant, size: size4, children, ...props }, ref) => /* @__PURE__ */ (0, import_jsx_runtime106.jsx)(
    Root22,
    {
      ref,
      className: cn("flex items-center justify-center gap-1", className),
      ...props,
      children: /* @__PURE__ */ (0, import_jsx_runtime106.jsx)(ToggleGroupContext2.Provider, { value: { variant, size: size4 }, children })
    }
  ));
  ToggleGroup2.displayName = Root22.displayName;
  var ToggleGroupContext2 = React108.createContext({
    size: "default",
    variant: "default"
  });
  var ToggleGroupItem2 = React108.forwardRef(({ className, children, variant, size: size4, ...props }, ref) => {
    const context = React108.useContext(ToggleGroupContext2);
    return /* @__PURE__ */ (0, import_jsx_runtime106.jsx)(
      Item2,
      {
        ref,
        className: cn(
          toggleVariants({
            variant: context.variant || variant,
            size: context.size || size4
          }),
          className
        ),
        ...props,
        children
      }
    );
  });
  ToggleGroupItem2.displayName = Item2.displayName;

  // src/components/Tooltip.tsx
  var React114 = __toESM(require_react());

  // ../../node_modules/@radix-ui/react-tooltip/dist/index.mjs
  var React113 = __toESM(require_react2(), 1);

  // ../../node_modules/@radix-ui/react-popper/dist/index.mjs
  var React111 = __toESM(require_react2(), 1);

  // ../../node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
  var sides = ["top", "right", "bottom", "left"];
  var min2 = Math.min;
  var max2 = Math.max;
  var round = Math.round;
  var floor = Math.floor;
  var createCoords = (v2) => ({
    x: v2,
    y: v2
  });
  var oppositeSideMap = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
  };
  var oppositeAlignmentMap = {
    start: "end",
    end: "start"
  };
  function clamp4(start2, value, end) {
    return max2(start2, min2(value, end));
  }
  function evaluate(value, param) {
    return typeof value === "function" ? value(param) : value;
  }
  function getSide(placement) {
    return placement.split("-")[0];
  }
  function getAlignment(placement) {
    return placement.split("-")[1];
  }
  function getOppositeAxis(axis) {
    return axis === "x" ? "y" : "x";
  }
  function getAxisLength(axis) {
    return axis === "y" ? "height" : "width";
  }
  var yAxisSides = /* @__PURE__ */ new Set(["top", "bottom"]);
  function getSideAxis(placement) {
    return yAxisSides.has(getSide(placement)) ? "y" : "x";
  }
  function getAlignmentAxis(placement) {
    return getOppositeAxis(getSideAxis(placement));
  }
  function getAlignmentSides(placement, rects, rtl) {
    if (rtl === void 0) {
      rtl = false;
    }
    const alignment = getAlignment(placement);
    const alignmentAxis = getAlignmentAxis(placement);
    const length = getAxisLength(alignmentAxis);
    let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
    if (rects.reference[length] > rects.floating[length]) {
      mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
    }
    return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
  }
  function getExpandedPlacements(placement) {
    const oppositePlacement = getOppositePlacement(placement);
    return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
  }
  function getOppositeAlignmentPlacement(placement) {
    return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
  }
  var lrPlacement = ["left", "right"];
  var rlPlacement = ["right", "left"];
  var tbPlacement = ["top", "bottom"];
  var btPlacement = ["bottom", "top"];
  function getSideList(side, isStart, rtl) {
    switch (side) {
      case "top":
      case "bottom":
        if (rtl) return isStart ? rlPlacement : lrPlacement;
        return isStart ? lrPlacement : rlPlacement;
      case "left":
      case "right":
        return isStart ? tbPlacement : btPlacement;
      default:
        return [];
    }
  }
  function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
    const alignment = getAlignment(placement);
    let list = getSideList(getSide(placement), direction === "start", rtl);
    if (alignment) {
      list = list.map((side) => side + "-" + alignment);
      if (flipAlignment) {
        list = list.concat(list.map(getOppositeAlignmentPlacement));
      }
    }
    return list;
  }
  function getOppositePlacement(placement) {
    return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
  }
  function expandPaddingObject(padding) {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      ...padding
    };
  }
  function getPaddingObject(padding) {
    return typeof padding !== "number" ? expandPaddingObject(padding) : {
      top: padding,
      right: padding,
      bottom: padding,
      left: padding
    };
  }
  function rectToClientRect(rect) {
    const {
      x: x2,
      y: y2,
      width,
      height
    } = rect;
    return {
      width,
      height,
      top: y2,
      left: x2,
      right: x2 + width,
      bottom: y2 + height,
      x: x2,
      y: y2
    };
  }

  // ../../node_modules/@floating-ui/core/dist/floating-ui.core.mjs
  function computeCoordsFromPlacement(_ref, placement, rtl) {
    let {
      reference,
      floating
    } = _ref;
    const sideAxis = getSideAxis(placement);
    const alignmentAxis = getAlignmentAxis(placement);
    const alignLength = getAxisLength(alignmentAxis);
    const side = getSide(placement);
    const isVertical = sideAxis === "y";
    const commonX = reference.x + reference.width / 2 - floating.width / 2;
    const commonY = reference.y + reference.height / 2 - floating.height / 2;
    const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
    let coords;
    switch (side) {
      case "top":
        coords = {
          x: commonX,
          y: reference.y - floating.height
        };
        break;
      case "bottom":
        coords = {
          x: commonX,
          y: reference.y + reference.height
        };
        break;
      case "right":
        coords = {
          x: reference.x + reference.width,
          y: commonY
        };
        break;
      case "left":
        coords = {
          x: reference.x - floating.width,
          y: commonY
        };
        break;
      default:
        coords = {
          x: reference.x,
          y: reference.y
        };
    }
    switch (getAlignment(placement)) {
      case "start":
        coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
        break;
      case "end":
        coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
        break;
    }
    return coords;
  }
  var computePosition = async (reference, floating, config2) => {
    const {
      placement = "bottom",
      strategy = "absolute",
      middleware = [],
      platform: platform2
    } = config2;
    const validMiddleware = middleware.filter(Boolean);
    const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
    let rects = await platform2.getElementRects({
      reference,
      floating,
      strategy
    });
    let {
      x: x2,
      y: y2
    } = computeCoordsFromPlacement(rects, placement, rtl);
    let statefulPlacement = placement;
    let middlewareData = {};
    let resetCount = 0;
    for (let i3 = 0; i3 < validMiddleware.length; i3++) {
      const {
        name,
        fn
      } = validMiddleware[i3];
      const {
        x: nextX,
        y: nextY,
        data,
        reset
      } = await fn({
        x: x2,
        y: y2,
        initialPlacement: placement,
        placement: statefulPlacement,
        strategy,
        middlewareData,
        rects,
        platform: platform2,
        elements: {
          reference,
          floating
        }
      });
      x2 = nextX != null ? nextX : x2;
      y2 = nextY != null ? nextY : y2;
      middlewareData = {
        ...middlewareData,
        [name]: {
          ...middlewareData[name],
          ...data
        }
      };
      if (reset && resetCount <= 50) {
        resetCount++;
        if (typeof reset === "object") {
          if (reset.placement) {
            statefulPlacement = reset.placement;
          }
          if (reset.rects) {
            rects = reset.rects === true ? await platform2.getElementRects({
              reference,
              floating,
              strategy
            }) : reset.rects;
          }
          ({
            x: x2,
            y: y2
          } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
        }
        i3 = -1;
      }
    }
    return {
      x: x2,
      y: y2,
      placement: statefulPlacement,
      strategy,
      middlewareData
    };
  };
  async function detectOverflow(state, options) {
    var _await$platform$isEle;
    if (options === void 0) {
      options = {};
    }
    const {
      x: x2,
      y: y2,
      platform: platform2,
      rects,
      elements,
      strategy
    } = state;
    const {
      boundary = "clippingAncestors",
      rootBoundary = "viewport",
      elementContext = "floating",
      altBoundary = false,
      padding = 0
    } = evaluate(options, state);
    const paddingObject = getPaddingObject(padding);
    const altContext = elementContext === "floating" ? "reference" : "floating";
    const element = elements[altBoundary ? altContext : elementContext];
    const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
      element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
      boundary,
      rootBoundary,
      strategy
    }));
    const rect = elementContext === "floating" ? {
      x: x2,
      y: y2,
      width: rects.floating.width,
      height: rects.floating.height
    } : rects.reference;
    const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
    const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
      x: 1,
      y: 1
    } : {
      x: 1,
      y: 1
    };
    const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
      elements,
      rect,
      offsetParent,
      strategy
    }) : rect);
    return {
      top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
      bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
      left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
      right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
    };
  }
  var arrow = (options) => ({
    name: "arrow",
    options,
    async fn(state) {
      const {
        x: x2,
        y: y2,
        placement,
        rects,
        platform: platform2,
        elements,
        middlewareData
      } = state;
      const {
        element,
        padding = 0
      } = evaluate(options, state) || {};
      if (element == null) {
        return {};
      }
      const paddingObject = getPaddingObject(padding);
      const coords = {
        x: x2,
        y: y2
      };
      const axis = getAlignmentAxis(placement);
      const length = getAxisLength(axis);
      const arrowDimensions = await platform2.getDimensions(element);
      const isYAxis = axis === "y";
      const minProp = isYAxis ? "top" : "left";
      const maxProp = isYAxis ? "bottom" : "right";
      const clientProp = isYAxis ? "clientHeight" : "clientWidth";
      const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
      const startDiff = coords[axis] - rects.reference[axis];
      const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
      let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
      if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
        clientSize = elements.floating[clientProp] || rects.floating[length];
      }
      const centerToReference = endDiff / 2 - startDiff / 2;
      const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
      const minPadding = min2(paddingObject[minProp], largestPossiblePadding);
      const maxPadding = min2(paddingObject[maxProp], largestPossiblePadding);
      const min$1 = minPadding;
      const max3 = clientSize - arrowDimensions[length] - maxPadding;
      const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
      const offset4 = clamp4(min$1, center, max3);
      const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset4 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
      const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max3 : 0;
      return {
        [axis]: coords[axis] + alignmentOffset,
        data: {
          [axis]: offset4,
          centerOffset: center - offset4 - alignmentOffset,
          ...shouldAddOffset && {
            alignmentOffset
          }
        },
        reset: shouldAddOffset
      };
    }
  });
  var flip = function(options) {
    if (options === void 0) {
      options = {};
    }
    return {
      name: "flip",
      options,
      async fn(state) {
        var _middlewareData$arrow, _middlewareData$flip;
        const {
          placement,
          middlewareData,
          rects,
          initialPlacement,
          platform: platform2,
          elements
        } = state;
        const {
          mainAxis: checkMainAxis = true,
          crossAxis: checkCrossAxis = true,
          fallbackPlacements: specifiedFallbackPlacements,
          fallbackStrategy = "bestFit",
          fallbackAxisSideDirection = "none",
          flipAlignment = true,
          ...detectOverflowOptions
        } = evaluate(options, state);
        if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
          return {};
        }
        const side = getSide(placement);
        const initialSideAxis = getSideAxis(initialPlacement);
        const isBasePlacement = getSide(initialPlacement) === initialPlacement;
        const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
        const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
        const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
        if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
          fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
        }
        const placements2 = [initialPlacement, ...fallbackPlacements];
        const overflow = await detectOverflow(state, detectOverflowOptions);
        const overflows = [];
        let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
        if (checkMainAxis) {
          overflows.push(overflow[side]);
        }
        if (checkCrossAxis) {
          const sides2 = getAlignmentSides(placement, rects, rtl);
          overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
        }
        overflowsData = [...overflowsData, {
          placement,
          overflows
        }];
        if (!overflows.every((side2) => side2 <= 0)) {
          var _middlewareData$flip2, _overflowsData$filter;
          const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
          const nextPlacement = placements2[nextIndex];
          if (nextPlacement) {
            const ignoreCrossAxisOverflow = checkCrossAxis === "alignment" ? initialSideAxis !== getSideAxis(nextPlacement) : false;
            if (!ignoreCrossAxisOverflow || // We leave the current main axis only if every placement on that axis
            // overflows the main axis.
            overflowsData.every((d) => getSideAxis(d.placement) === initialSideAxis ? d.overflows[0] > 0 : true)) {
              return {
                data: {
                  index: nextIndex,
                  overflows: overflowsData
                },
                reset: {
                  placement: nextPlacement
                }
              };
            }
          }
          let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b2) => a.overflows[1] - b2.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
          if (!resetPlacement) {
            switch (fallbackStrategy) {
              case "bestFit": {
                var _overflowsData$filter2;
                const placement2 = (_overflowsData$filter2 = overflowsData.filter((d) => {
                  if (hasFallbackAxisSideDirection) {
                    const currentSideAxis = getSideAxis(d.placement);
                    return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                    // reading directions favoring greater width.
                    currentSideAxis === "y";
                  }
                  return true;
                }).map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b2) => a[1] - b2[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
                if (placement2) {
                  resetPlacement = placement2;
                }
                break;
              }
              case "initialPlacement":
                resetPlacement = initialPlacement;
                break;
            }
          }
          if (placement !== resetPlacement) {
            return {
              reset: {
                placement: resetPlacement
              }
            };
          }
        }
        return {};
      }
    };
  };
  function getSideOffsets(overflow, rect) {
    return {
      top: overflow.top - rect.height,
      right: overflow.right - rect.width,
      bottom: overflow.bottom - rect.height,
      left: overflow.left - rect.width
    };
  }
  function isAnySideFullyClipped(overflow) {
    return sides.some((side) => overflow[side] >= 0);
  }
  var hide = function(options) {
    if (options === void 0) {
      options = {};
    }
    return {
      name: "hide",
      options,
      async fn(state) {
        const {
          rects
        } = state;
        const {
          strategy = "referenceHidden",
          ...detectOverflowOptions
        } = evaluate(options, state);
        switch (strategy) {
          case "referenceHidden": {
            const overflow = await detectOverflow(state, {
              ...detectOverflowOptions,
              elementContext: "reference"
            });
            const offsets = getSideOffsets(overflow, rects.reference);
            return {
              data: {
                referenceHiddenOffsets: offsets,
                referenceHidden: isAnySideFullyClipped(offsets)
              }
            };
          }
          case "escaped": {
            const overflow = await detectOverflow(state, {
              ...detectOverflowOptions,
              altBoundary: true
            });
            const offsets = getSideOffsets(overflow, rects.floating);
            return {
              data: {
                escapedOffsets: offsets,
                escaped: isAnySideFullyClipped(offsets)
              }
            };
          }
          default: {
            return {};
          }
        }
      }
    };
  };
  var originSides = /* @__PURE__ */ new Set(["left", "top"]);
  async function convertValueToCoords(state, options) {
    const {
      placement,
      platform: platform2,
      elements
    } = state;
    const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
    const side = getSide(placement);
    const alignment = getAlignment(placement);
    const isVertical = getSideAxis(placement) === "y";
    const mainAxisMulti = originSides.has(side) ? -1 : 1;
    const crossAxisMulti = rtl && isVertical ? -1 : 1;
    const rawValue = evaluate(options, state);
    let {
      mainAxis,
      crossAxis,
      alignmentAxis
    } = typeof rawValue === "number" ? {
      mainAxis: rawValue,
      crossAxis: 0,
      alignmentAxis: null
    } : {
      mainAxis: rawValue.mainAxis || 0,
      crossAxis: rawValue.crossAxis || 0,
      alignmentAxis: rawValue.alignmentAxis
    };
    if (alignment && typeof alignmentAxis === "number") {
      crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
    }
    return isVertical ? {
      x: crossAxis * crossAxisMulti,
      y: mainAxis * mainAxisMulti
    } : {
      x: mainAxis * mainAxisMulti,
      y: crossAxis * crossAxisMulti
    };
  }
  var offset = function(options) {
    if (options === void 0) {
      options = 0;
    }
    return {
      name: "offset",
      options,
      async fn(state) {
        var _middlewareData$offse, _middlewareData$arrow;
        const {
          x: x2,
          y: y2,
          placement,
          middlewareData
        } = state;
        const diffCoords = await convertValueToCoords(state, options);
        if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
          return {};
        }
        return {
          x: x2 + diffCoords.x,
          y: y2 + diffCoords.y,
          data: {
            ...diffCoords,
            placement
          }
        };
      }
    };
  };
  var shift = function(options) {
    if (options === void 0) {
      options = {};
    }
    return {
      name: "shift",
      options,
      async fn(state) {
        const {
          x: x2,
          y: y2,
          placement
        } = state;
        const {
          mainAxis: checkMainAxis = true,
          crossAxis: checkCrossAxis = false,
          limiter = {
            fn: (_ref) => {
              let {
                x: x3,
                y: y3
              } = _ref;
              return {
                x: x3,
                y: y3
              };
            }
          },
          ...detectOverflowOptions
        } = evaluate(options, state);
        const coords = {
          x: x2,
          y: y2
        };
        const overflow = await detectOverflow(state, detectOverflowOptions);
        const crossAxis = getSideAxis(getSide(placement));
        const mainAxis = getOppositeAxis(crossAxis);
        let mainAxisCoord = coords[mainAxis];
        let crossAxisCoord = coords[crossAxis];
        if (checkMainAxis) {
          const minSide = mainAxis === "y" ? "top" : "left";
          const maxSide = mainAxis === "y" ? "bottom" : "right";
          const min3 = mainAxisCoord + overflow[minSide];
          const max3 = mainAxisCoord - overflow[maxSide];
          mainAxisCoord = clamp4(min3, mainAxisCoord, max3);
        }
        if (checkCrossAxis) {
          const minSide = crossAxis === "y" ? "top" : "left";
          const maxSide = crossAxis === "y" ? "bottom" : "right";
          const min3 = crossAxisCoord + overflow[minSide];
          const max3 = crossAxisCoord - overflow[maxSide];
          crossAxisCoord = clamp4(min3, crossAxisCoord, max3);
        }
        const limitedCoords = limiter.fn({
          ...state,
          [mainAxis]: mainAxisCoord,
          [crossAxis]: crossAxisCoord
        });
        return {
          ...limitedCoords,
          data: {
            x: limitedCoords.x - x2,
            y: limitedCoords.y - y2,
            enabled: {
              [mainAxis]: checkMainAxis,
              [crossAxis]: checkCrossAxis
            }
          }
        };
      }
    };
  };
  var limitShift = function(options) {
    if (options === void 0) {
      options = {};
    }
    return {
      options,
      fn(state) {
        const {
          x: x2,
          y: y2,
          placement,
          rects,
          middlewareData
        } = state;
        const {
          offset: offset4 = 0,
          mainAxis: checkMainAxis = true,
          crossAxis: checkCrossAxis = true
        } = evaluate(options, state);
        const coords = {
          x: x2,
          y: y2
        };
        const crossAxis = getSideAxis(placement);
        const mainAxis = getOppositeAxis(crossAxis);
        let mainAxisCoord = coords[mainAxis];
        let crossAxisCoord = coords[crossAxis];
        const rawOffset = evaluate(offset4, state);
        const computedOffset = typeof rawOffset === "number" ? {
          mainAxis: rawOffset,
          crossAxis: 0
        } : {
          mainAxis: 0,
          crossAxis: 0,
          ...rawOffset
        };
        if (checkMainAxis) {
          const len = mainAxis === "y" ? "height" : "width";
          const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
          const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
          if (mainAxisCoord < limitMin) {
            mainAxisCoord = limitMin;
          } else if (mainAxisCoord > limitMax) {
            mainAxisCoord = limitMax;
          }
        }
        if (checkCrossAxis) {
          var _middlewareData$offse, _middlewareData$offse2;
          const len = mainAxis === "y" ? "width" : "height";
          const isOriginSide = originSides.has(getSide(placement));
          const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
          const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
          if (crossAxisCoord < limitMin) {
            crossAxisCoord = limitMin;
          } else if (crossAxisCoord > limitMax) {
            crossAxisCoord = limitMax;
          }
        }
        return {
          [mainAxis]: mainAxisCoord,
          [crossAxis]: crossAxisCoord
        };
      }
    };
  };
  var size = function(options) {
    if (options === void 0) {
      options = {};
    }
    return {
      name: "size",
      options,
      async fn(state) {
        var _state$middlewareData, _state$middlewareData2;
        const {
          placement,
          rects,
          platform: platform2,
          elements
        } = state;
        const {
          apply = () => {
          },
          ...detectOverflowOptions
        } = evaluate(options, state);
        const overflow = await detectOverflow(state, detectOverflowOptions);
        const side = getSide(placement);
        const alignment = getAlignment(placement);
        const isYAxis = getSideAxis(placement) === "y";
        const {
          width,
          height
        } = rects.floating;
        let heightSide;
        let widthSide;
        if (side === "top" || side === "bottom") {
          heightSide = side;
          widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
        } else {
          widthSide = side;
          heightSide = alignment === "end" ? "top" : "bottom";
        }
        const maximumClippingHeight = height - overflow.top - overflow.bottom;
        const maximumClippingWidth = width - overflow.left - overflow.right;
        const overflowAvailableHeight = min2(height - overflow[heightSide], maximumClippingHeight);
        const overflowAvailableWidth = min2(width - overflow[widthSide], maximumClippingWidth);
        const noShift = !state.middlewareData.shift;
        let availableHeight = overflowAvailableHeight;
        let availableWidth = overflowAvailableWidth;
        if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
          availableWidth = maximumClippingWidth;
        }
        if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
          availableHeight = maximumClippingHeight;
        }
        if (noShift && !alignment) {
          const xMin = max2(overflow.left, 0);
          const xMax = max2(overflow.right, 0);
          const yMin = max2(overflow.top, 0);
          const yMax = max2(overflow.bottom, 0);
          if (isYAxis) {
            availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max2(overflow.left, overflow.right));
          } else {
            availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max2(overflow.top, overflow.bottom));
          }
        }
        await apply({
          ...state,
          availableWidth,
          availableHeight
        });
        const nextDimensions = await platform2.getDimensions(elements.floating);
        if (width !== nextDimensions.width || height !== nextDimensions.height) {
          return {
            reset: {
              rects: true
            }
          };
        }
        return {};
      }
    };
  };

  // ../../node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
  function hasWindow() {
    return typeof window !== "undefined";
  }
  function getNodeName(node) {
    if (isNode(node)) {
      return (node.nodeName || "").toLowerCase();
    }
    return "#document";
  }
  function getWindow(node) {
    var _node$ownerDocument;
    return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
  }
  function getDocumentElement(node) {
    var _ref;
    return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
  }
  function isNode(value) {
    if (!hasWindow()) {
      return false;
    }
    return value instanceof Node || value instanceof getWindow(value).Node;
  }
  function isElement(value) {
    if (!hasWindow()) {
      return false;
    }
    return value instanceof Element || value instanceof getWindow(value).Element;
  }
  function isHTMLElement2(value) {
    if (!hasWindow()) {
      return false;
    }
    return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
  }
  function isShadowRoot(value) {
    if (!hasWindow() || typeof ShadowRoot === "undefined") {
      return false;
    }
    return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
  }
  var invalidOverflowDisplayValues = /* @__PURE__ */ new Set(["inline", "contents"]);
  function isOverflowElement(element) {
    const {
      overflow,
      overflowX,
      overflowY,
      display
    } = getComputedStyle3(element);
    return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display);
  }
  var tableElements = /* @__PURE__ */ new Set(["table", "td", "th"]);
  function isTableElement(element) {
    return tableElements.has(getNodeName(element));
  }
  var topLayerSelectors = [":popover-open", ":modal"];
  function isTopLayer(element) {
    return topLayerSelectors.some((selector) => {
      try {
        return element.matches(selector);
      } catch (_e4) {
        return false;
      }
    });
  }
  var transformProperties = ["transform", "translate", "scale", "rotate", "perspective"];
  var willChangeValues = ["transform", "translate", "scale", "rotate", "perspective", "filter"];
  var containValues = ["paint", "layout", "strict", "content"];
  function isContainingBlock(elementOrCss) {
    const webkit = isWebKit();
    const css = isElement(elementOrCss) ? getComputedStyle3(elementOrCss) : elementOrCss;
    return transformProperties.some((value) => css[value] ? css[value] !== "none" : false) || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || willChangeValues.some((value) => (css.willChange || "").includes(value)) || containValues.some((value) => (css.contain || "").includes(value));
  }
  function getContainingBlock(element) {
    let currentNode = getParentNode(element);
    while (isHTMLElement2(currentNode) && !isLastTraversableNode(currentNode)) {
      if (isContainingBlock(currentNode)) {
        return currentNode;
      } else if (isTopLayer(currentNode)) {
        return null;
      }
      currentNode = getParentNode(currentNode);
    }
    return null;
  }
  function isWebKit() {
    if (typeof CSS === "undefined" || !CSS.supports) return false;
    return CSS.supports("-webkit-backdrop-filter", "none");
  }
  var lastTraversableNodeNames = /* @__PURE__ */ new Set(["html", "body", "#document"]);
  function isLastTraversableNode(node) {
    return lastTraversableNodeNames.has(getNodeName(node));
  }
  function getComputedStyle3(element) {
    return getWindow(element).getComputedStyle(element);
  }
  function getNodeScroll(element) {
    if (isElement(element)) {
      return {
        scrollLeft: element.scrollLeft,
        scrollTop: element.scrollTop
      };
    }
    return {
      scrollLeft: element.scrollX,
      scrollTop: element.scrollY
    };
  }
  function getParentNode(node) {
    if (getNodeName(node) === "html") {
      return node;
    }
    const result = (
      // Step into the shadow DOM of the parent of a slotted node.
      node.assignedSlot || // DOM Element detected.
      node.parentNode || // ShadowRoot detected.
      isShadowRoot(node) && node.host || // Fallback.
      getDocumentElement(node)
    );
    return isShadowRoot(result) ? result.host : result;
  }
  function getNearestOverflowAncestor(node) {
    const parentNode = getParentNode(node);
    if (isLastTraversableNode(parentNode)) {
      return node.ownerDocument ? node.ownerDocument.body : node.body;
    }
    if (isHTMLElement2(parentNode) && isOverflowElement(parentNode)) {
      return parentNode;
    }
    return getNearestOverflowAncestor(parentNode);
  }
  function getOverflowAncestors(node, list, traverseIframes) {
    var _node$ownerDocument2;
    if (list === void 0) {
      list = [];
    }
    if (traverseIframes === void 0) {
      traverseIframes = true;
    }
    const scrollableAncestor = getNearestOverflowAncestor(node);
    const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
    const win = getWindow(scrollableAncestor);
    if (isBody) {
      const frameElement = getFrameElement(win);
      return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
    }
    return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
  }
  function getFrameElement(win) {
    return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
  }

  // ../../node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
  function getCssDimensions(element) {
    const css = getComputedStyle3(element);
    let width = parseFloat(css.width) || 0;
    let height = parseFloat(css.height) || 0;
    const hasOffset = isHTMLElement2(element);
    const offsetWidth = hasOffset ? element.offsetWidth : width;
    const offsetHeight = hasOffset ? element.offsetHeight : height;
    const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
    if (shouldFallback) {
      width = offsetWidth;
      height = offsetHeight;
    }
    return {
      width,
      height,
      $: shouldFallback
    };
  }
  function unwrapElement(element) {
    return !isElement(element) ? element.contextElement : element;
  }
  function getScale(element) {
    const domElement = unwrapElement(element);
    if (!isHTMLElement2(domElement)) {
      return createCoords(1);
    }
    const rect = domElement.getBoundingClientRect();
    const {
      width,
      height,
      $: $5
    } = getCssDimensions(domElement);
    let x2 = ($5 ? round(rect.width) : rect.width) / width;
    let y2 = ($5 ? round(rect.height) : rect.height) / height;
    if (!x2 || !Number.isFinite(x2)) {
      x2 = 1;
    }
    if (!y2 || !Number.isFinite(y2)) {
      y2 = 1;
    }
    return {
      x: x2,
      y: y2
    };
  }
  var noOffsets = /* @__PURE__ */ createCoords(0);
  function getVisualOffsets(element) {
    const win = getWindow(element);
    if (!isWebKit() || !win.visualViewport) {
      return noOffsets;
    }
    return {
      x: win.visualViewport.offsetLeft,
      y: win.visualViewport.offsetTop
    };
  }
  function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
    if (isFixed === void 0) {
      isFixed = false;
    }
    if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
      return false;
    }
    return isFixed;
  }
  function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
    if (includeScale === void 0) {
      includeScale = false;
    }
    if (isFixedStrategy === void 0) {
      isFixedStrategy = false;
    }
    const clientRect = element.getBoundingClientRect();
    const domElement = unwrapElement(element);
    let scale2 = createCoords(1);
    if (includeScale) {
      if (offsetParent) {
        if (isElement(offsetParent)) {
          scale2 = getScale(offsetParent);
        }
      } else {
        scale2 = getScale(element);
      }
    }
    const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
    let x2 = (clientRect.left + visualOffsets.x) / scale2.x;
    let y2 = (clientRect.top + visualOffsets.y) / scale2.y;
    let width = clientRect.width / scale2.x;
    let height = clientRect.height / scale2.y;
    if (domElement) {
      const win = getWindow(domElement);
      const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
      let currentWin = win;
      let currentIFrame = getFrameElement(currentWin);
      while (currentIFrame && offsetParent && offsetWin !== currentWin) {
        const iframeScale = getScale(currentIFrame);
        const iframeRect = currentIFrame.getBoundingClientRect();
        const css = getComputedStyle3(currentIFrame);
        const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
        const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
        x2 *= iframeScale.x;
        y2 *= iframeScale.y;
        width *= iframeScale.x;
        height *= iframeScale.y;
        x2 += left;
        y2 += top;
        currentWin = getWindow(currentIFrame);
        currentIFrame = getFrameElement(currentWin);
      }
    }
    return rectToClientRect({
      width,
      height,
      x: x2,
      y: y2
    });
  }
  function getWindowScrollBarX(element, rect) {
    const leftScroll = getNodeScroll(element).scrollLeft;
    if (!rect) {
      return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
    }
    return rect.left + leftScroll;
  }
  function getHTMLOffset(documentElement, scroll2) {
    const htmlRect = documentElement.getBoundingClientRect();
    const x2 = htmlRect.left + scroll2.scrollLeft - getWindowScrollBarX(documentElement, htmlRect);
    const y2 = htmlRect.top + scroll2.scrollTop;
    return {
      x: x2,
      y: y2
    };
  }
  function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
    let {
      elements,
      rect,
      offsetParent,
      strategy
    } = _ref;
    const isFixed = strategy === "fixed";
    const documentElement = getDocumentElement(offsetParent);
    const topLayer = elements ? isTopLayer(elements.floating) : false;
    if (offsetParent === documentElement || topLayer && isFixed) {
      return rect;
    }
    let scroll2 = {
      scrollLeft: 0,
      scrollTop: 0
    };
    let scale2 = createCoords(1);
    const offsets = createCoords(0);
    const isOffsetParentAnElement = isHTMLElement2(offsetParent);
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
      if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
        scroll2 = getNodeScroll(offsetParent);
      }
      if (isHTMLElement2(offsetParent)) {
        const offsetRect = getBoundingClientRect(offsetParent);
        scale2 = getScale(offsetParent);
        offsets.x = offsetRect.x + offsetParent.clientLeft;
        offsets.y = offsetRect.y + offsetParent.clientTop;
      }
    }
    const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll2) : createCoords(0);
    return {
      width: rect.width * scale2.x,
      height: rect.height * scale2.y,
      x: rect.x * scale2.x - scroll2.scrollLeft * scale2.x + offsets.x + htmlOffset.x,
      y: rect.y * scale2.y - scroll2.scrollTop * scale2.y + offsets.y + htmlOffset.y
    };
  }
  function getClientRects(element) {
    return Array.from(element.getClientRects());
  }
  function getDocumentRect(element) {
    const html = getDocumentElement(element);
    const scroll2 = getNodeScroll(element);
    const body = element.ownerDocument.body;
    const width = max2(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
    const height = max2(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
    let x2 = -scroll2.scrollLeft + getWindowScrollBarX(element);
    const y2 = -scroll2.scrollTop;
    if (getComputedStyle3(body).direction === "rtl") {
      x2 += max2(html.clientWidth, body.clientWidth) - width;
    }
    return {
      width,
      height,
      x: x2,
      y: y2
    };
  }
  var SCROLLBAR_MAX = 25;
  function getViewportRect(element, strategy) {
    const win = getWindow(element);
    const html = getDocumentElement(element);
    const visualViewport = win.visualViewport;
    let width = html.clientWidth;
    let height = html.clientHeight;
    let x2 = 0;
    let y2 = 0;
    if (visualViewport) {
      width = visualViewport.width;
      height = visualViewport.height;
      const visualViewportBased = isWebKit();
      if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
        x2 = visualViewport.offsetLeft;
        y2 = visualViewport.offsetTop;
      }
    }
    const windowScrollbarX = getWindowScrollBarX(html);
    if (windowScrollbarX <= 0) {
      const doc = html.ownerDocument;
      const body = doc.body;
      const bodyStyles = getComputedStyle(body);
      const bodyMarginInline = doc.compatMode === "CSS1Compat" ? parseFloat(bodyStyles.marginLeft) + parseFloat(bodyStyles.marginRight) || 0 : 0;
      const clippingStableScrollbarWidth = Math.abs(html.clientWidth - body.clientWidth - bodyMarginInline);
      if (clippingStableScrollbarWidth <= SCROLLBAR_MAX) {
        width -= clippingStableScrollbarWidth;
      }
    } else if (windowScrollbarX <= SCROLLBAR_MAX) {
      width += windowScrollbarX;
    }
    return {
      width,
      height,
      x: x2,
      y: y2
    };
  }
  var absoluteOrFixed = /* @__PURE__ */ new Set(["absolute", "fixed"]);
  function getInnerBoundingClientRect(element, strategy) {
    const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
    const top = clientRect.top + element.clientTop;
    const left = clientRect.left + element.clientLeft;
    const scale2 = isHTMLElement2(element) ? getScale(element) : createCoords(1);
    const width = element.clientWidth * scale2.x;
    const height = element.clientHeight * scale2.y;
    const x2 = left * scale2.x;
    const y2 = top * scale2.y;
    return {
      width,
      height,
      x: x2,
      y: y2
    };
  }
  function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
    let rect;
    if (clippingAncestor === "viewport") {
      rect = getViewportRect(element, strategy);
    } else if (clippingAncestor === "document") {
      rect = getDocumentRect(getDocumentElement(element));
    } else if (isElement(clippingAncestor)) {
      rect = getInnerBoundingClientRect(clippingAncestor, strategy);
    } else {
      const visualOffsets = getVisualOffsets(element);
      rect = {
        x: clippingAncestor.x - visualOffsets.x,
        y: clippingAncestor.y - visualOffsets.y,
        width: clippingAncestor.width,
        height: clippingAncestor.height
      };
    }
    return rectToClientRect(rect);
  }
  function hasFixedPositionAncestor(element, stopNode) {
    const parentNode = getParentNode(element);
    if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
      return false;
    }
    return getComputedStyle3(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
  }
  function getClippingElementAncestors(element, cache) {
    const cachedResult = cache.get(element);
    if (cachedResult) {
      return cachedResult;
    }
    let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
    let currentContainingBlockComputedStyle = null;
    const elementIsFixed = getComputedStyle3(element).position === "fixed";
    let currentNode = elementIsFixed ? getParentNode(element) : element;
    while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
      const computedStyle = getComputedStyle3(currentNode);
      const currentNodeIsContaining = isContainingBlock(currentNode);
      if (!currentNodeIsContaining && computedStyle.position === "fixed") {
        currentContainingBlockComputedStyle = null;
      }
      const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && absoluteOrFixed.has(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
      if (shouldDropCurrentNode) {
        result = result.filter((ancestor) => ancestor !== currentNode);
      } else {
        currentContainingBlockComputedStyle = computedStyle;
      }
      currentNode = getParentNode(currentNode);
    }
    cache.set(element, result);
    return result;
  }
  function getClippingRect(_ref) {
    let {
      element,
      boundary,
      rootBoundary,
      strategy
    } = _ref;
    const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
    const clippingAncestors = [...elementClippingAncestors, rootBoundary];
    const firstClippingAncestor = clippingAncestors[0];
    const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
      const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
      accRect.top = max2(rect.top, accRect.top);
      accRect.right = min2(rect.right, accRect.right);
      accRect.bottom = min2(rect.bottom, accRect.bottom);
      accRect.left = max2(rect.left, accRect.left);
      return accRect;
    }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
    return {
      width: clippingRect.right - clippingRect.left,
      height: clippingRect.bottom - clippingRect.top,
      x: clippingRect.left,
      y: clippingRect.top
    };
  }
  function getDimensions(element) {
    const {
      width,
      height
    } = getCssDimensions(element);
    return {
      width,
      height
    };
  }
  function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
    const isOffsetParentAnElement = isHTMLElement2(offsetParent);
    const documentElement = getDocumentElement(offsetParent);
    const isFixed = strategy === "fixed";
    const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
    let scroll2 = {
      scrollLeft: 0,
      scrollTop: 0
    };
    const offsets = createCoords(0);
    function setLeftRTLScrollbarOffset() {
      offsets.x = getWindowScrollBarX(documentElement);
    }
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
      if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
        scroll2 = getNodeScroll(offsetParent);
      }
      if (isOffsetParentAnElement) {
        const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
        offsets.x = offsetRect.x + offsetParent.clientLeft;
        offsets.y = offsetRect.y + offsetParent.clientTop;
      } else if (documentElement) {
        setLeftRTLScrollbarOffset();
      }
    }
    if (isFixed && !isOffsetParentAnElement && documentElement) {
      setLeftRTLScrollbarOffset();
    }
    const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll2) : createCoords(0);
    const x2 = rect.left + scroll2.scrollLeft - offsets.x - htmlOffset.x;
    const y2 = rect.top + scroll2.scrollTop - offsets.y - htmlOffset.y;
    return {
      x: x2,
      y: y2,
      width: rect.width,
      height: rect.height
    };
  }
  function isStaticPositioned(element) {
    return getComputedStyle3(element).position === "static";
  }
  function getTrueOffsetParent(element, polyfill) {
    if (!isHTMLElement2(element) || getComputedStyle3(element).position === "fixed") {
      return null;
    }
    if (polyfill) {
      return polyfill(element);
    }
    let rawOffsetParent = element.offsetParent;
    if (getDocumentElement(element) === rawOffsetParent) {
      rawOffsetParent = rawOffsetParent.ownerDocument.body;
    }
    return rawOffsetParent;
  }
  function getOffsetParent(element, polyfill) {
    const win = getWindow(element);
    if (isTopLayer(element)) {
      return win;
    }
    if (!isHTMLElement2(element)) {
      let svgOffsetParent = getParentNode(element);
      while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
        if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
          return svgOffsetParent;
        }
        svgOffsetParent = getParentNode(svgOffsetParent);
      }
      return win;
    }
    let offsetParent = getTrueOffsetParent(element, polyfill);
    while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
      offsetParent = getTrueOffsetParent(offsetParent, polyfill);
    }
    if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
      return win;
    }
    return offsetParent || getContainingBlock(element) || win;
  }
  var getElementRects = async function(data) {
    const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
    const getDimensionsFn = this.getDimensions;
    const floatingDimensions = await getDimensionsFn(data.floating);
    return {
      reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
      floating: {
        x: 0,
        y: 0,
        width: floatingDimensions.width,
        height: floatingDimensions.height
      }
    };
  };
  function isRTL(element) {
    return getComputedStyle3(element).direction === "rtl";
  }
  var platform = {
    convertOffsetParentRelativeRectToViewportRelativeRect,
    getDocumentElement,
    getClippingRect,
    getOffsetParent,
    getElementRects,
    getClientRects,
    getDimensions,
    getScale,
    isElement,
    isRTL
  };
  function rectsAreEqual(a, b2) {
    return a.x === b2.x && a.y === b2.y && a.width === b2.width && a.height === b2.height;
  }
  function observeMove(element, onMove) {
    let io = null;
    let timeoutId;
    const root = getDocumentElement(element);
    function cleanup() {
      var _io;
      clearTimeout(timeoutId);
      (_io = io) == null || _io.disconnect();
      io = null;
    }
    function refresh(skip, threshold) {
      if (skip === void 0) {
        skip = false;
      }
      if (threshold === void 0) {
        threshold = 1;
      }
      cleanup();
      const elementRectForRootMargin = element.getBoundingClientRect();
      const {
        left,
        top,
        width,
        height
      } = elementRectForRootMargin;
      if (!skip) {
        onMove();
      }
      if (!width || !height) {
        return;
      }
      const insetTop = floor(top);
      const insetRight = floor(root.clientWidth - (left + width));
      const insetBottom = floor(root.clientHeight - (top + height));
      const insetLeft = floor(left);
      const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
      const options = {
        rootMargin,
        threshold: max2(0, min2(1, threshold)) || 1
      };
      let isFirstUpdate = true;
      function handleObserve(entries) {
        const ratio = entries[0].intersectionRatio;
        if (ratio !== threshold) {
          if (!isFirstUpdate) {
            return refresh();
          }
          if (!ratio) {
            timeoutId = setTimeout(() => {
              refresh(false, 1e-7);
            }, 1e3);
          } else {
            refresh(false, ratio);
          }
        }
        if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
          refresh();
        }
        isFirstUpdate = false;
      }
      try {
        io = new IntersectionObserver(handleObserve, {
          ...options,
          // Handle <iframe>s
          root: root.ownerDocument
        });
      } catch (_e4) {
        io = new IntersectionObserver(handleObserve, options);
      }
      io.observe(element);
    }
    refresh(true);
    return cleanup;
  }
  function autoUpdate(reference, floating, update3, options) {
    if (options === void 0) {
      options = {};
    }
    const {
      ancestorScroll = true,
      ancestorResize = true,
      elementResize = typeof ResizeObserver === "function",
      layoutShift = typeof IntersectionObserver === "function",
      animationFrame = false
    } = options;
    const referenceEl = unwrapElement(reference);
    const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.addEventListener("scroll", update3, {
        passive: true
      });
      ancestorResize && ancestor.addEventListener("resize", update3);
    });
    const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update3) : null;
    let reobserveFrame = -1;
    let resizeObserver = null;
    if (elementResize) {
      resizeObserver = new ResizeObserver((_ref) => {
        let [firstEntry] = _ref;
        if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
          resizeObserver.unobserve(floating);
          cancelAnimationFrame(reobserveFrame);
          reobserveFrame = requestAnimationFrame(() => {
            var _resizeObserver;
            (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
          });
        }
        update3();
      });
      if (referenceEl && !animationFrame) {
        resizeObserver.observe(referenceEl);
      }
      resizeObserver.observe(floating);
    }
    let frameId;
    let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
    if (animationFrame) {
      frameLoop2();
    }
    function frameLoop2() {
      const nextRefRect = getBoundingClientRect(reference);
      if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
        update3();
      }
      prevRefRect = nextRefRect;
      frameId = requestAnimationFrame(frameLoop2);
    }
    update3();
    return () => {
      var _resizeObserver2;
      ancestors.forEach((ancestor) => {
        ancestorScroll && ancestor.removeEventListener("scroll", update3);
        ancestorResize && ancestor.removeEventListener("resize", update3);
      });
      cleanupIo == null || cleanupIo();
      (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
      resizeObserver = null;
      if (animationFrame) {
        cancelAnimationFrame(frameId);
      }
    };
  }
  var offset2 = offset;
  var shift2 = shift;
  var flip2 = flip;
  var size2 = size;
  var hide2 = hide;
  var arrow2 = arrow;
  var limitShift2 = limitShift;
  var computePosition2 = (reference, floating, options) => {
    const cache = /* @__PURE__ */ new Map();
    const mergedOptions = {
      platform,
      ...options
    };
    const platformWithCache = {
      ...mergedOptions.platform,
      _c: cache
    };
    return computePosition(reference, floating, {
      ...mergedOptions,
      platform: platformWithCache
    });
  };

  // ../../node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs
  var React109 = __toESM(require_react2(), 1);
  var import_react124 = __toESM(require_react2(), 1);
  var ReactDOM4 = __toESM(require_react_dom(), 1);
  var isClient = typeof document !== "undefined";
  var noop3 = function noop4() {
  };
  var index = isClient ? import_react124.useLayoutEffect : noop3;
  function deepEqual(a, b2) {
    if (a === b2) {
      return true;
    }
    if (typeof a !== typeof b2) {
      return false;
    }
    if (typeof a === "function" && a.toString() === b2.toString()) {
      return true;
    }
    let length;
    let i3;
    let keys2;
    if (a && b2 && typeof a === "object") {
      if (Array.isArray(a)) {
        length = a.length;
        if (length !== b2.length) return false;
        for (i3 = length; i3-- !== 0; ) {
          if (!deepEqual(a[i3], b2[i3])) {
            return false;
          }
        }
        return true;
      }
      keys2 = Object.keys(a);
      length = keys2.length;
      if (length !== Object.keys(b2).length) {
        return false;
      }
      for (i3 = length; i3-- !== 0; ) {
        if (!{}.hasOwnProperty.call(b2, keys2[i3])) {
          return false;
        }
      }
      for (i3 = length; i3-- !== 0; ) {
        const key = keys2[i3];
        if (key === "_owner" && a.$$typeof) {
          continue;
        }
        if (!deepEqual(a[key], b2[key])) {
          return false;
        }
      }
      return true;
    }
    return a !== a && b2 !== b2;
  }
  function getDPR(element) {
    if (typeof window === "undefined") {
      return 1;
    }
    const win = element.ownerDocument.defaultView || window;
    return win.devicePixelRatio || 1;
  }
  function roundByDPR(element, value) {
    const dpr = getDPR(element);
    return Math.round(value * dpr) / dpr;
  }
  function useLatestRef(value) {
    const ref = React109.useRef(value);
    index(() => {
      ref.current = value;
    });
    return ref;
  }
  function useFloating(options) {
    if (options === void 0) {
      options = {};
    }
    const {
      placement = "bottom",
      strategy = "absolute",
      middleware = [],
      platform: platform2,
      elements: {
        reference: externalReference,
        floating: externalFloating
      } = {},
      transform: transform2 = true,
      whileElementsMounted,
      open
    } = options;
    const [data, setData] = React109.useState({
      x: 0,
      y: 0,
      strategy,
      placement,
      middlewareData: {},
      isPositioned: false
    });
    const [latestMiddleware, setLatestMiddleware] = React109.useState(middleware);
    if (!deepEqual(latestMiddleware, middleware)) {
      setLatestMiddleware(middleware);
    }
    const [_reference, _setReference] = React109.useState(null);
    const [_floating, _setFloating] = React109.useState(null);
    const setReference = React109.useCallback((node) => {
      if (node !== referenceRef.current) {
        referenceRef.current = node;
        _setReference(node);
      }
    }, []);
    const setFloating = React109.useCallback((node) => {
      if (node !== floatingRef.current) {
        floatingRef.current = node;
        _setFloating(node);
      }
    }, []);
    const referenceEl = externalReference || _reference;
    const floatingEl = externalFloating || _floating;
    const referenceRef = React109.useRef(null);
    const floatingRef = React109.useRef(null);
    const dataRef = React109.useRef(data);
    const hasWhileElementsMounted = whileElementsMounted != null;
    const whileElementsMountedRef = useLatestRef(whileElementsMounted);
    const platformRef = useLatestRef(platform2);
    const openRef = useLatestRef(open);
    const update3 = React109.useCallback(() => {
      if (!referenceRef.current || !floatingRef.current) {
        return;
      }
      const config2 = {
        placement,
        strategy,
        middleware: latestMiddleware
      };
      if (platformRef.current) {
        config2.platform = platformRef.current;
      }
      computePosition2(referenceRef.current, floatingRef.current, config2).then((data2) => {
        const fullData = {
          ...data2,
          // The floating element's position may be recomputed while it's closed
          // but still mounted (such as when transitioning out). To ensure
          // `isPositioned` will be `false` initially on the next open, avoid
          // setting it to `true` when `open === false` (must be specified).
          isPositioned: openRef.current !== false
        };
        if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
          dataRef.current = fullData;
          ReactDOM4.flushSync(() => {
            setData(fullData);
          });
        }
      });
    }, [latestMiddleware, placement, strategy, platformRef, openRef]);
    index(() => {
      if (open === false && dataRef.current.isPositioned) {
        dataRef.current.isPositioned = false;
        setData((data2) => ({
          ...data2,
          isPositioned: false
        }));
      }
    }, [open]);
    const isMountedRef = React109.useRef(false);
    index(() => {
      isMountedRef.current = true;
      return () => {
        isMountedRef.current = false;
      };
    }, []);
    index(() => {
      if (referenceEl) referenceRef.current = referenceEl;
      if (floatingEl) floatingRef.current = floatingEl;
      if (referenceEl && floatingEl) {
        if (whileElementsMountedRef.current) {
          return whileElementsMountedRef.current(referenceEl, floatingEl, update3);
        }
        update3();
      }
    }, [referenceEl, floatingEl, update3, whileElementsMountedRef, hasWhileElementsMounted]);
    const refs = React109.useMemo(() => ({
      reference: referenceRef,
      floating: floatingRef,
      setReference,
      setFloating
    }), [setReference, setFloating]);
    const elements = React109.useMemo(() => ({
      reference: referenceEl,
      floating: floatingEl
    }), [referenceEl, floatingEl]);
    const floatingStyles = React109.useMemo(() => {
      const initialStyles = {
        position: strategy,
        left: 0,
        top: 0
      };
      if (!elements.floating) {
        return initialStyles;
      }
      const x2 = roundByDPR(elements.floating, data.x);
      const y2 = roundByDPR(elements.floating, data.y);
      if (transform2) {
        return {
          ...initialStyles,
          transform: "translate(" + x2 + "px, " + y2 + "px)",
          ...getDPR(elements.floating) >= 1.5 && {
            willChange: "transform"
          }
        };
      }
      return {
        position: strategy,
        left: x2,
        top: y2
      };
    }, [strategy, transform2, elements.floating, data.x, data.y]);
    return React109.useMemo(() => ({
      ...data,
      update: update3,
      refs,
      elements,
      floatingStyles
    }), [data, update3, refs, elements, floatingStyles]);
  }
  var arrow$1 = (options) => {
    function isRef(value) {
      return {}.hasOwnProperty.call(value, "current");
    }
    return {
      name: "arrow",
      options,
      fn(state) {
        const {
          element,
          padding
        } = typeof options === "function" ? options(state) : options;
        if (element && isRef(element)) {
          if (element.current != null) {
            return arrow2({
              element: element.current,
              padding
            }).fn(state);
          }
          return {};
        }
        if (element) {
          return arrow2({
            element,
            padding
          }).fn(state);
        }
        return {};
      }
    };
  };
  var offset3 = (options, deps) => ({
    ...offset2(options),
    options: [options, deps]
  });
  var shift3 = (options, deps) => ({
    ...shift2(options),
    options: [options, deps]
  });
  var limitShift3 = (options, deps) => ({
    ...limitShift2(options),
    options: [options, deps]
  });
  var flip3 = (options, deps) => ({
    ...flip2(options),
    options: [options, deps]
  });
  var size3 = (options, deps) => ({
    ...size2(options),
    options: [options, deps]
  });
  var hide3 = (options, deps) => ({
    ...hide2(options),
    options: [options, deps]
  });
  var arrow3 = (options, deps) => ({
    ...arrow$1(options),
    options: [options, deps]
  });

  // ../../node_modules/@radix-ui/react-arrow/dist/index.mjs
  var React110 = __toESM(require_react2(), 1);
  var import_jsx_runtime107 = __toESM(require_jsx_runtime2(), 1);
  var NAME2 = "Arrow";
  var Arrow = React110.forwardRef((props, forwardedRef) => {
    const { children, width = 10, height = 5, ...arrowProps } = props;
    return /* @__PURE__ */ (0, import_jsx_runtime107.jsx)(
      Primitive2.svg,
      {
        ...arrowProps,
        ref: forwardedRef,
        width,
        height,
        viewBox: "0 0 30 10",
        preserveAspectRatio: "none",
        children: props.asChild ? children : /* @__PURE__ */ (0, import_jsx_runtime107.jsx)("polygon", { points: "0,0 30,0 15,10" })
      }
    );
  });
  Arrow.displayName = NAME2;
  var Root6 = Arrow;

  // ../../node_modules/@radix-ui/react-popper/dist/index.mjs
  var import_jsx_runtime108 = __toESM(require_jsx_runtime2(), 1);
  var POPPER_NAME = "Popper";
  var [createPopperContext, createPopperScope] = createContextScope2(POPPER_NAME);
  var [PopperProvider, usePopperContext] = createPopperContext(POPPER_NAME);
  var Popper = (props) => {
    const { __scopePopper, children } = props;
    const [anchor, setAnchor] = React111.useState(null);
    return /* @__PURE__ */ (0, import_jsx_runtime108.jsx)(PopperProvider, { scope: __scopePopper, anchor, onAnchorChange: setAnchor, children });
  };
  Popper.displayName = POPPER_NAME;
  var ANCHOR_NAME = "PopperAnchor";
  var PopperAnchor = React111.forwardRef(
    (props, forwardedRef) => {
      const { __scopePopper, virtualRef, ...anchorProps } = props;
      const context = usePopperContext(ANCHOR_NAME, __scopePopper);
      const ref = React111.useRef(null);
      const composedRefs = useComposedRefs2(forwardedRef, ref);
      const anchorRef = React111.useRef(null);
      React111.useEffect(() => {
        const previousAnchor = anchorRef.current;
        anchorRef.current = virtualRef?.current || ref.current;
        if (previousAnchor !== anchorRef.current) {
          context.onAnchorChange(anchorRef.current);
        }
      });
      return virtualRef ? null : /* @__PURE__ */ (0, import_jsx_runtime108.jsx)(Primitive2.div, { ...anchorProps, ref: composedRefs });
    }
  );
  PopperAnchor.displayName = ANCHOR_NAME;
  var CONTENT_NAME2 = "PopperContent";
  var [PopperContentProvider, useContentContext] = createPopperContext(CONTENT_NAME2);
  var PopperContent = React111.forwardRef(
    (props, forwardedRef) => {
      const {
        __scopePopper,
        side = "bottom",
        sideOffset = 0,
        align = "center",
        alignOffset = 0,
        arrowPadding = 0,
        avoidCollisions = true,
        collisionBoundary = [],
        collisionPadding: collisionPaddingProp = 0,
        sticky = "partial",
        hideWhenDetached = false,
        updatePositionStrategy = "optimized",
        onPlaced,
        ...contentProps
      } = props;
      const context = usePopperContext(CONTENT_NAME2, __scopePopper);
      const [content, setContent] = React111.useState(null);
      const composedRefs = useComposedRefs2(forwardedRef, (node) => setContent(node));
      const [arrow4, setArrow] = React111.useState(null);
      const arrowSize = useSize(arrow4);
      const arrowWidth = arrowSize?.width ?? 0;
      const arrowHeight = arrowSize?.height ?? 0;
      const desiredPlacement = side + (align !== "center" ? "-" + align : "");
      const collisionPadding = typeof collisionPaddingProp === "number" ? collisionPaddingProp : { top: 0, right: 0, bottom: 0, left: 0, ...collisionPaddingProp };
      const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [collisionBoundary];
      const hasExplicitBoundaries = boundary.length > 0;
      const detectOverflowOptions = {
        padding: collisionPadding,
        boundary: boundary.filter(isNotNull3),
        // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
        altBoundary: hasExplicitBoundaries
      };
      const { refs, floatingStyles, placement, isPositioned, middlewareData } = useFloating({
        // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
        strategy: "fixed",
        placement: desiredPlacement,
        whileElementsMounted: (...args) => {
          const cleanup = autoUpdate(...args, {
            animationFrame: updatePositionStrategy === "always"
          });
          return cleanup;
        },
        elements: {
          reference: context.anchor
        },
        middleware: [
          offset3({ mainAxis: sideOffset + arrowHeight, alignmentAxis: alignOffset }),
          avoidCollisions && shift3({
            mainAxis: true,
            crossAxis: false,
            limiter: sticky === "partial" ? limitShift3() : void 0,
            ...detectOverflowOptions
          }),
          avoidCollisions && flip3({ ...detectOverflowOptions }),
          size3({
            ...detectOverflowOptions,
            apply: ({ elements, rects, availableWidth, availableHeight }) => {
              const { width: anchorWidth, height: anchorHeight } = rects.reference;
              const contentStyle = elements.floating.style;
              contentStyle.setProperty("--radix-popper-available-width", `${availableWidth}px`);
              contentStyle.setProperty("--radix-popper-available-height", `${availableHeight}px`);
              contentStyle.setProperty("--radix-popper-anchor-width", `${anchorWidth}px`);
              contentStyle.setProperty("--radix-popper-anchor-height", `${anchorHeight}px`);
            }
          }),
          arrow4 && arrow3({ element: arrow4, padding: arrowPadding }),
          transformOrigin({ arrowWidth, arrowHeight }),
          hideWhenDetached && hide3({ strategy: "referenceHidden", ...detectOverflowOptions })
        ]
      });
      const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
      const handlePlaced = useCallbackRef(onPlaced);
      useLayoutEffect22(() => {
        if (isPositioned) {
          handlePlaced?.();
        }
      }, [isPositioned, handlePlaced]);
      const arrowX = middlewareData.arrow?.x;
      const arrowY = middlewareData.arrow?.y;
      const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;
      const [contentZIndex, setContentZIndex] = React111.useState();
      useLayoutEffect22(() => {
        if (content) setContentZIndex(window.getComputedStyle(content).zIndex);
      }, [content]);
      return /* @__PURE__ */ (0, import_jsx_runtime108.jsx)(
        "div",
        {
          ref: refs.setFloating,
          "data-radix-popper-content-wrapper": "",
          style: {
            ...floatingStyles,
            transform: isPositioned ? floatingStyles.transform : "translate(0, -200%)",
            // keep off the page when measuring
            minWidth: "max-content",
            zIndex: contentZIndex,
            ["--radix-popper-transform-origin"]: [
              middlewareData.transformOrigin?.x,
              middlewareData.transformOrigin?.y
            ].join(" "),
            // hide the content if using the hide middleware and should be hidden
            // set visibility to hidden and disable pointer events so the UI behaves
            // as if the PopperContent isn't there at all
            ...middlewareData.hide?.referenceHidden && {
              visibility: "hidden",
              pointerEvents: "none"
            }
          },
          dir: props.dir,
          children: /* @__PURE__ */ (0, import_jsx_runtime108.jsx)(
            PopperContentProvider,
            {
              scope: __scopePopper,
              placedSide,
              onArrowChange: setArrow,
              arrowX,
              arrowY,
              shouldHideArrow: cannotCenterArrow,
              children: /* @__PURE__ */ (0, import_jsx_runtime108.jsx)(
                Primitive2.div,
                {
                  "data-side": placedSide,
                  "data-align": placedAlign,
                  ...contentProps,
                  ref: composedRefs,
                  style: {
                    ...contentProps.style,
                    // if the PopperContent hasn't been placed yet (not all measurements done)
                    // we prevent animations so that users's animation don't kick in too early referring wrong sides
                    animation: !isPositioned ? "none" : void 0
                  }
                }
              )
            }
          )
        }
      );
    }
  );
  PopperContent.displayName = CONTENT_NAME2;
  var ARROW_NAME = "PopperArrow";
  var OPPOSITE_SIDE = {
    top: "bottom",
    right: "left",
    bottom: "top",
    left: "right"
  };
  var PopperArrow = React111.forwardRef(function PopperArrow2(props, forwardedRef) {
    const { __scopePopper, ...arrowProps } = props;
    const contentContext = useContentContext(ARROW_NAME, __scopePopper);
    const baseSide = OPPOSITE_SIDE[contentContext.placedSide];
    return (
      // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
      // doesn't report size as we'd expect on SVG elements.
      // it reports their bounding box which is effectively the largest path inside the SVG.
      /* @__PURE__ */ (0, import_jsx_runtime108.jsx)(
        "span",
        {
          ref: contentContext.onArrowChange,
          style: {
            position: "absolute",
            left: contentContext.arrowX,
            top: contentContext.arrowY,
            [baseSide]: 0,
            transformOrigin: {
              top: "",
              right: "0 0",
              bottom: "center 0",
              left: "100% 0"
            }[contentContext.placedSide],
            transform: {
              top: "translateY(100%)",
              right: "translateY(50%) rotate(90deg) translateX(-50%)",
              bottom: `rotate(180deg)`,
              left: "translateY(50%) rotate(-90deg) translateX(50%)"
            }[contentContext.placedSide],
            visibility: contentContext.shouldHideArrow ? "hidden" : void 0
          },
          children: /* @__PURE__ */ (0, import_jsx_runtime108.jsx)(
            Root6,
            {
              ...arrowProps,
              ref: forwardedRef,
              style: {
                ...arrowProps.style,
                // ensures the element can be measured correctly (mostly for if SVG)
                display: "block"
              }
            }
          )
        }
      )
    );
  });
  PopperArrow.displayName = ARROW_NAME;
  function isNotNull3(value) {
    return value !== null;
  }
  var transformOrigin = (options) => ({
    name: "transformOrigin",
    options,
    fn(data) {
      const { placement, rects, middlewareData } = data;
      const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;
      const isArrowHidden = cannotCenterArrow;
      const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;
      const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;
      const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
      const noArrowAlign = { start: "0%", center: "50%", end: "100%" }[placedAlign];
      const arrowXCenter = (middlewareData.arrow?.x ?? 0) + arrowWidth / 2;
      const arrowYCenter = (middlewareData.arrow?.y ?? 0) + arrowHeight / 2;
      let x2 = "";
      let y2 = "";
      if (placedSide === "bottom") {
        x2 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
        y2 = `${-arrowHeight}px`;
      } else if (placedSide === "top") {
        x2 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
        y2 = `${rects.floating.height + arrowHeight}px`;
      } else if (placedSide === "right") {
        x2 = `${-arrowHeight}px`;
        y2 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
      } else if (placedSide === "left") {
        x2 = `${rects.floating.width + arrowHeight}px`;
        y2 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
      }
      return { data: { x: x2, y: y2 } };
    }
  });
  function getSideAndAlignFromPlacement(placement) {
    const [side, align = "center"] = placement.split("-");
    return [side, align];
  }
  var Root23 = Popper;
  var Anchor = PopperAnchor;
  var Content2 = PopperContent;
  var Arrow2 = PopperArrow;

  // ../../node_modules/@radix-ui/react-visually-hidden/dist/index.mjs
  var React112 = __toESM(require_react2(), 1);
  var import_jsx_runtime109 = __toESM(require_jsx_runtime2(), 1);
  var VISUALLY_HIDDEN_STYLES = Object.freeze({
    // See: https://github.com/twbs/bootstrap/blob/main/scss/mixins/_visually-hidden.scss
    position: "absolute",
    border: 0,
    width: 1,
    height: 1,
    padding: 0,
    margin: -1,
    overflow: "hidden",
    clip: "rect(0, 0, 0, 0)",
    whiteSpace: "nowrap",
    wordWrap: "normal"
  });
  var NAME3 = "VisuallyHidden";
  var VisuallyHidden = React112.forwardRef(
    (props, forwardedRef) => {
      return /* @__PURE__ */ (0, import_jsx_runtime109.jsx)(
        Primitive2.span,
        {
          ...props,
          ref: forwardedRef,
          style: { ...VISUALLY_HIDDEN_STYLES, ...props.style }
        }
      );
    }
  );
  VisuallyHidden.displayName = NAME3;
  var Root7 = VisuallyHidden;

  // ../../node_modules/@radix-ui/react-tooltip/dist/index.mjs
  var import_jsx_runtime110 = __toESM(require_jsx_runtime2(), 1);
  var [createTooltipContext, createTooltipScope] = createContextScope2("Tooltip", [
    createPopperScope
  ]);
  var usePopperScope = createPopperScope();
  var PROVIDER_NAME = "TooltipProvider";
  var DEFAULT_DELAY_DURATION = 700;
  var TOOLTIP_OPEN = "tooltip.open";
  var [TooltipProviderContextProvider, useTooltipProviderContext] = createTooltipContext(PROVIDER_NAME);
  var TooltipProvider = (props) => {
    const {
      __scopeTooltip,
      delayDuration = DEFAULT_DELAY_DURATION,
      skipDelayDuration = 300,
      disableHoverableContent = false,
      children
    } = props;
    const isOpenDelayedRef = React113.useRef(true);
    const isPointerInTransitRef = React113.useRef(false);
    const skipDelayTimerRef = React113.useRef(0);
    React113.useEffect(() => {
      const skipDelayTimer = skipDelayTimerRef.current;
      return () => window.clearTimeout(skipDelayTimer);
    }, []);
    return /* @__PURE__ */ (0, import_jsx_runtime110.jsx)(
      TooltipProviderContextProvider,
      {
        scope: __scopeTooltip,
        isOpenDelayedRef,
        delayDuration,
        onOpen: React113.useCallback(() => {
          window.clearTimeout(skipDelayTimerRef.current);
          isOpenDelayedRef.current = false;
        }, []),
        onClose: React113.useCallback(() => {
          window.clearTimeout(skipDelayTimerRef.current);
          skipDelayTimerRef.current = window.setTimeout(
            () => isOpenDelayedRef.current = true,
            skipDelayDuration
          );
        }, [skipDelayDuration]),
        isPointerInTransitRef,
        onPointerInTransitChange: React113.useCallback((inTransit) => {
          isPointerInTransitRef.current = inTransit;
        }, []),
        disableHoverableContent,
        children
      }
    );
  };
  TooltipProvider.displayName = PROVIDER_NAME;
  var TOOLTIP_NAME = "Tooltip";
  var [TooltipContextProvider, useTooltipContext] = createTooltipContext(TOOLTIP_NAME);
  var Tooltip = (props) => {
    const {
      __scopeTooltip,
      children,
      open: openProp,
      defaultOpen,
      onOpenChange,
      disableHoverableContent: disableHoverableContentProp,
      delayDuration: delayDurationProp
    } = props;
    const providerContext = useTooltipProviderContext(TOOLTIP_NAME, props.__scopeTooltip);
    const popperScope = usePopperScope(__scopeTooltip);
    const [trigger, setTrigger] = React113.useState(null);
    const contentId = useId5();
    const openTimerRef = React113.useRef(0);
    const disableHoverableContent = disableHoverableContentProp ?? providerContext.disableHoverableContent;
    const delayDuration = delayDurationProp ?? providerContext.delayDuration;
    const wasOpenDelayedRef = React113.useRef(false);
    const [open, setOpen] = useControllableState({
      prop: openProp,
      defaultProp: defaultOpen ?? false,
      onChange: (open2) => {
        if (open2) {
          providerContext.onOpen();
          document.dispatchEvent(new CustomEvent(TOOLTIP_OPEN));
        } else {
          providerContext.onClose();
        }
        onOpenChange?.(open2);
      },
      caller: TOOLTIP_NAME
    });
    const stateAttribute = React113.useMemo(() => {
      return open ? wasOpenDelayedRef.current ? "delayed-open" : "instant-open" : "closed";
    }, [open]);
    const handleOpen = React113.useCallback(() => {
      window.clearTimeout(openTimerRef.current);
      openTimerRef.current = 0;
      wasOpenDelayedRef.current = false;
      setOpen(true);
    }, [setOpen]);
    const handleClose = React113.useCallback(() => {
      window.clearTimeout(openTimerRef.current);
      openTimerRef.current = 0;
      setOpen(false);
    }, [setOpen]);
    const handleDelayedOpen = React113.useCallback(() => {
      window.clearTimeout(openTimerRef.current);
      openTimerRef.current = window.setTimeout(() => {
        wasOpenDelayedRef.current = true;
        setOpen(true);
        openTimerRef.current = 0;
      }, delayDuration);
    }, [delayDuration, setOpen]);
    React113.useEffect(() => {
      return () => {
        if (openTimerRef.current) {
          window.clearTimeout(openTimerRef.current);
          openTimerRef.current = 0;
        }
      };
    }, []);
    return /* @__PURE__ */ (0, import_jsx_runtime110.jsx)(Root23, { ...popperScope, children: /* @__PURE__ */ (0, import_jsx_runtime110.jsx)(
      TooltipContextProvider,
      {
        scope: __scopeTooltip,
        contentId,
        open,
        stateAttribute,
        trigger,
        onTriggerChange: setTrigger,
        onTriggerEnter: React113.useCallback(() => {
          if (providerContext.isOpenDelayedRef.current) handleDelayedOpen();
          else handleOpen();
        }, [providerContext.isOpenDelayedRef, handleDelayedOpen, handleOpen]),
        onTriggerLeave: React113.useCallback(() => {
          if (disableHoverableContent) {
            handleClose();
          } else {
            window.clearTimeout(openTimerRef.current);
            openTimerRef.current = 0;
          }
        }, [handleClose, disableHoverableContent]),
        onOpen: handleOpen,
        onClose: handleClose,
        disableHoverableContent,
        children
      }
    ) });
  };
  Tooltip.displayName = TOOLTIP_NAME;
  var TRIGGER_NAME2 = "TooltipTrigger";
  var TooltipTrigger = React113.forwardRef(
    (props, forwardedRef) => {
      const { __scopeTooltip, ...triggerProps } = props;
      const context = useTooltipContext(TRIGGER_NAME2, __scopeTooltip);
      const providerContext = useTooltipProviderContext(TRIGGER_NAME2, __scopeTooltip);
      const popperScope = usePopperScope(__scopeTooltip);
      const ref = React113.useRef(null);
      const composedRefs = useComposedRefs2(forwardedRef, ref, context.onTriggerChange);
      const isPointerDownRef = React113.useRef(false);
      const hasPointerMoveOpenedRef = React113.useRef(false);
      const handlePointerUp = React113.useCallback(() => isPointerDownRef.current = false, []);
      React113.useEffect(() => {
        return () => document.removeEventListener("pointerup", handlePointerUp);
      }, [handlePointerUp]);
      return /* @__PURE__ */ (0, import_jsx_runtime110.jsx)(Anchor, { asChild: true, ...popperScope, children: /* @__PURE__ */ (0, import_jsx_runtime110.jsx)(
        Primitive2.button,
        {
          "aria-describedby": context.open ? context.contentId : void 0,
          "data-state": context.stateAttribute,
          ...triggerProps,
          ref: composedRefs,
          onPointerMove: composeEventHandlers(props.onPointerMove, (event) => {
            if (event.pointerType === "touch") return;
            if (!hasPointerMoveOpenedRef.current && !providerContext.isPointerInTransitRef.current) {
              context.onTriggerEnter();
              hasPointerMoveOpenedRef.current = true;
            }
          }),
          onPointerLeave: composeEventHandlers(props.onPointerLeave, () => {
            context.onTriggerLeave();
            hasPointerMoveOpenedRef.current = false;
          }),
          onPointerDown: composeEventHandlers(props.onPointerDown, () => {
            if (context.open) {
              context.onClose();
            }
            isPointerDownRef.current = true;
            document.addEventListener("pointerup", handlePointerUp, { once: true });
          }),
          onFocus: composeEventHandlers(props.onFocus, () => {
            if (!isPointerDownRef.current) context.onOpen();
          }),
          onBlur: composeEventHandlers(props.onBlur, context.onClose),
          onClick: composeEventHandlers(props.onClick, context.onClose)
        }
      ) });
    }
  );
  TooltipTrigger.displayName = TRIGGER_NAME2;
  var PORTAL_NAME3 = "TooltipPortal";
  var [PortalProvider2, usePortalContext2] = createTooltipContext(PORTAL_NAME3, {
    forceMount: void 0
  });
  var TooltipPortal = (props) => {
    const { __scopeTooltip, forceMount, children, container } = props;
    const context = useTooltipContext(PORTAL_NAME3, __scopeTooltip);
    return /* @__PURE__ */ (0, import_jsx_runtime110.jsx)(PortalProvider2, { scope: __scopeTooltip, forceMount, children: /* @__PURE__ */ (0, import_jsx_runtime110.jsx)(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ (0, import_jsx_runtime110.jsx)(Portal, { asChild: true, container, children }) }) });
  };
  TooltipPortal.displayName = PORTAL_NAME3;
  var CONTENT_NAME3 = "TooltipContent";
  var TooltipContent = React113.forwardRef(
    (props, forwardedRef) => {
      const portalContext = usePortalContext2(CONTENT_NAME3, props.__scopeTooltip);
      const { forceMount = portalContext.forceMount, side = "top", ...contentProps } = props;
      const context = useTooltipContext(CONTENT_NAME3, props.__scopeTooltip);
      return /* @__PURE__ */ (0, import_jsx_runtime110.jsx)(Presence, { present: forceMount || context.open, children: context.disableHoverableContent ? /* @__PURE__ */ (0, import_jsx_runtime110.jsx)(TooltipContentImpl, { side, ...contentProps, ref: forwardedRef }) : /* @__PURE__ */ (0, import_jsx_runtime110.jsx)(TooltipContentHoverable, { side, ...contentProps, ref: forwardedRef }) });
    }
  );
  var TooltipContentHoverable = React113.forwardRef((props, forwardedRef) => {
    const context = useTooltipContext(CONTENT_NAME3, props.__scopeTooltip);
    const providerContext = useTooltipProviderContext(CONTENT_NAME3, props.__scopeTooltip);
    const ref = React113.useRef(null);
    const composedRefs = useComposedRefs2(forwardedRef, ref);
    const [pointerGraceArea, setPointerGraceArea] = React113.useState(null);
    const { trigger, onClose } = context;
    const content = ref.current;
    const { onPointerInTransitChange } = providerContext;
    const handleRemoveGraceArea = React113.useCallback(() => {
      setPointerGraceArea(null);
      onPointerInTransitChange(false);
    }, [onPointerInTransitChange]);
    const handleCreateGraceArea = React113.useCallback(
      (event, hoverTarget) => {
        const currentTarget = event.currentTarget;
        const exitPoint = { x: event.clientX, y: event.clientY };
        const exitSide = getExitSideFromRect(exitPoint, currentTarget.getBoundingClientRect());
        const paddedExitPoints = getPaddedExitPoints(exitPoint, exitSide);
        const hoverTargetPoints = getPointsFromRect(hoverTarget.getBoundingClientRect());
        const graceArea = getHull([...paddedExitPoints, ...hoverTargetPoints]);
        setPointerGraceArea(graceArea);
        onPointerInTransitChange(true);
      },
      [onPointerInTransitChange]
    );
    React113.useEffect(() => {
      return () => handleRemoveGraceArea();
    }, [handleRemoveGraceArea]);
    React113.useEffect(() => {
      if (trigger && content) {
        const handleTriggerLeave = (event) => handleCreateGraceArea(event, content);
        const handleContentLeave = (event) => handleCreateGraceArea(event, trigger);
        trigger.addEventListener("pointerleave", handleTriggerLeave);
        content.addEventListener("pointerleave", handleContentLeave);
        return () => {
          trigger.removeEventListener("pointerleave", handleTriggerLeave);
          content.removeEventListener("pointerleave", handleContentLeave);
        };
      }
    }, [trigger, content, handleCreateGraceArea, handleRemoveGraceArea]);
    React113.useEffect(() => {
      if (pointerGraceArea) {
        const handleTrackPointerGrace = (event) => {
          const target = event.target;
          const pointerPosition = { x: event.clientX, y: event.clientY };
          const hasEnteredTarget = trigger?.contains(target) || content?.contains(target);
          const isPointerOutsideGraceArea = !isPointInPolygon(pointerPosition, pointerGraceArea);
          if (hasEnteredTarget) {
            handleRemoveGraceArea();
          } else if (isPointerOutsideGraceArea) {
            handleRemoveGraceArea();
            onClose();
          }
        };
        document.addEventListener("pointermove", handleTrackPointerGrace);
        return () => document.removeEventListener("pointermove", handleTrackPointerGrace);
      }
    }, [trigger, content, pointerGraceArea, onClose, handleRemoveGraceArea]);
    return /* @__PURE__ */ (0, import_jsx_runtime110.jsx)(TooltipContentImpl, { ...props, ref: composedRefs });
  });
  var [VisuallyHiddenContentContextProvider, useVisuallyHiddenContentContext] = createTooltipContext(TOOLTIP_NAME, { isInside: false });
  var Slottable = createSlottable("TooltipContent");
  var TooltipContentImpl = React113.forwardRef(
    (props, forwardedRef) => {
      const {
        __scopeTooltip,
        children,
        "aria-label": ariaLabel,
        onEscapeKeyDown,
        onPointerDownOutside,
        ...contentProps
      } = props;
      const context = useTooltipContext(CONTENT_NAME3, __scopeTooltip);
      const popperScope = usePopperScope(__scopeTooltip);
      const { onClose } = context;
      React113.useEffect(() => {
        document.addEventListener(TOOLTIP_OPEN, onClose);
        return () => document.removeEventListener(TOOLTIP_OPEN, onClose);
      }, [onClose]);
      React113.useEffect(() => {
        if (context.trigger) {
          const handleScroll2 = (event) => {
            const target = event.target;
            if (target?.contains(context.trigger)) onClose();
          };
          window.addEventListener("scroll", handleScroll2, { capture: true });
          return () => window.removeEventListener("scroll", handleScroll2, { capture: true });
        }
      }, [context.trigger, onClose]);
      return /* @__PURE__ */ (0, import_jsx_runtime110.jsx)(
        DismissableLayer,
        {
          asChild: true,
          disableOutsidePointerEvents: false,
          onEscapeKeyDown,
          onPointerDownOutside,
          onFocusOutside: (event) => event.preventDefault(),
          onDismiss: onClose,
          children: /* @__PURE__ */ (0, import_jsx_runtime110.jsxs)(
            Content2,
            {
              "data-state": context.stateAttribute,
              ...popperScope,
              ...contentProps,
              ref: forwardedRef,
              style: {
                ...contentProps.style,
                // re-namespace exposed content custom properties
                ...{
                  "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
                  "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
                  "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
                  "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
                  "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
                }
              },
              children: [
                /* @__PURE__ */ (0, import_jsx_runtime110.jsx)(Slottable, { children }),
                /* @__PURE__ */ (0, import_jsx_runtime110.jsx)(VisuallyHiddenContentContextProvider, { scope: __scopeTooltip, isInside: true, children: /* @__PURE__ */ (0, import_jsx_runtime110.jsx)(Root7, { id: context.contentId, role: "tooltip", children: ariaLabel || children }) })
              ]
            }
          )
        }
      );
    }
  );
  TooltipContent.displayName = CONTENT_NAME3;
  var ARROW_NAME2 = "TooltipArrow";
  var TooltipArrow = React113.forwardRef(
    (props, forwardedRef) => {
      const { __scopeTooltip, ...arrowProps } = props;
      const popperScope = usePopperScope(__scopeTooltip);
      const visuallyHiddenContentContext = useVisuallyHiddenContentContext(
        ARROW_NAME2,
        __scopeTooltip
      );
      return visuallyHiddenContentContext.isInside ? null : /* @__PURE__ */ (0, import_jsx_runtime110.jsx)(Arrow2, { ...popperScope, ...arrowProps, ref: forwardedRef });
    }
  );
  TooltipArrow.displayName = ARROW_NAME2;
  function getExitSideFromRect(point2, rect) {
    const top = Math.abs(rect.top - point2.y);
    const bottom = Math.abs(rect.bottom - point2.y);
    const right = Math.abs(rect.right - point2.x);
    const left = Math.abs(rect.left - point2.x);
    switch (Math.min(top, bottom, right, left)) {
      case left:
        return "left";
      case right:
        return "right";
      case top:
        return "top";
      case bottom:
        return "bottom";
      default:
        throw new Error("unreachable");
    }
  }
  function getPaddedExitPoints(exitPoint, exitSide, padding = 5) {
    const paddedExitPoints = [];
    switch (exitSide) {
      case "top":
        paddedExitPoints.push(
          { x: exitPoint.x - padding, y: exitPoint.y + padding },
          { x: exitPoint.x + padding, y: exitPoint.y + padding }
        );
        break;
      case "bottom":
        paddedExitPoints.push(
          { x: exitPoint.x - padding, y: exitPoint.y - padding },
          { x: exitPoint.x + padding, y: exitPoint.y - padding }
        );
        break;
      case "left":
        paddedExitPoints.push(
          { x: exitPoint.x + padding, y: exitPoint.y - padding },
          { x: exitPoint.x + padding, y: exitPoint.y + padding }
        );
        break;
      case "right":
        paddedExitPoints.push(
          { x: exitPoint.x - padding, y: exitPoint.y - padding },
          { x: exitPoint.x - padding, y: exitPoint.y + padding }
        );
        break;
    }
    return paddedExitPoints;
  }
  function getPointsFromRect(rect) {
    const { top, right, bottom, left } = rect;
    return [
      { x: left, y: top },
      { x: right, y: top },
      { x: right, y: bottom },
      { x: left, y: bottom }
    ];
  }
  function isPointInPolygon(point2, polygon) {
    const { x: x2, y: y2 } = point2;
    let inside = false;
    for (let i3 = 0, j2 = polygon.length - 1; i3 < polygon.length; j2 = i3++) {
      const ii = polygon[i3];
      const jj = polygon[j2];
      const xi = ii.x;
      const yi = ii.y;
      const xj = jj.x;
      const yj = jj.y;
      const intersect = yi > y2 !== yj > y2 && x2 < (xj - xi) * (y2 - yi) / (yj - yi) + xi;
      if (intersect) inside = !inside;
    }
    return inside;
  }
  function getHull(points) {
    const newPoints = points.slice();
    newPoints.sort((a, b2) => {
      if (a.x < b2.x) return -1;
      else if (a.x > b2.x) return 1;
      else if (a.y < b2.y) return -1;
      else if (a.y > b2.y) return 1;
      else return 0;
    });
    return getHullPresorted(newPoints);
  }
  function getHullPresorted(points) {
    if (points.length <= 1) return points.slice();
    const upperHull = [];
    for (let i3 = 0; i3 < points.length; i3++) {
      const p3 = points[i3];
      while (upperHull.length >= 2) {
        const q3 = upperHull[upperHull.length - 1];
        const r4 = upperHull[upperHull.length - 2];
        if ((q3.x - r4.x) * (p3.y - r4.y) >= (q3.y - r4.y) * (p3.x - r4.x)) upperHull.pop();
        else break;
      }
      upperHull.push(p3);
    }
    upperHull.pop();
    const lowerHull = [];
    for (let i3 = points.length - 1; i3 >= 0; i3--) {
      const p3 = points[i3];
      while (lowerHull.length >= 2) {
        const q3 = lowerHull[lowerHull.length - 1];
        const r4 = lowerHull[lowerHull.length - 2];
        if ((q3.x - r4.x) * (p3.y - r4.y) >= (q3.y - r4.y) * (p3.x - r4.x)) lowerHull.pop();
        else break;
      }
      lowerHull.push(p3);
    }
    lowerHull.pop();
    if (upperHull.length === 1 && lowerHull.length === 1 && upperHull[0].x === lowerHull[0].x && upperHull[0].y === lowerHull[0].y) {
      return upperHull;
    } else {
      return upperHull.concat(lowerHull);
    }
  }
  var Provider = TooltipProvider;
  var Root32 = Tooltip;
  var Trigger2 = TooltipTrigger;
  var Content22 = TooltipContent;
  var Arrow22 = TooltipArrow;

  // src/components/Tooltip.tsx
  var import_jsx_runtime111 = __toESM(require_jsx_runtime());
  var TooltipProvider2 = Provider;
  var Tooltip2 = Root32;
  var TooltipTrigger2 = Trigger2;
  var TooltipContext = React114.createContext({ variant: "simple" });
  var TooltipContent2 = React114.forwardRef(({ className, sideOffset = 4, variant = "simple", ...props }, ref) => /* @__PURE__ */ (0, import_jsx_runtime111.jsxs)(
    Content22,
    {
      ref,
      sideOffset,
      className: cn(
        "z-50 overflow-hidden rounded-md border px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        // Simple (Default)
        variant === "simple" && "bg-popover border-border",
        // Rich (Glassy, slightly larger padding)
        variant === "rich" && "bg-black/80 text-white backdrop-blur-md border-white/10 px-4 py-2 rounded-xl",
        // Arrow (High contrast, needs Arrow element)
        variant === "arrow" && "bg-primary text-primary-foreground border-transparent px-3 py-2",
        className
      ),
      ...props,
      children: [
        props.children,
        variant === "arrow" && /* @__PURE__ */ (0, import_jsx_runtime111.jsx)(Arrow22, { className: "fill-primary" })
      ]
    }
  ));
  TooltipContent2.displayName = Content22.displayName;

  // src/components/TrueFocus.tsx
  var import_react125 = __toESM(require_react());
  var import_jsx_runtime112 = __toESM(require_jsx_runtime());
  function TrueFocus({
    className,
    label = "Focus me",
    focusColor = "#8b5cf6",
    // Violet-500
    ...props
  }) {
    const [isFocused, setIsFocused] = (0, import_react125.useState)(false);
    return /* @__PURE__ */ (0, import_jsx_runtime112.jsxs)("div", { className: "relative group", children: [
      /* @__PURE__ */ (0, import_jsx_runtime112.jsx)(
        "div",
        {
          className: cn(
            "absolute -inset-0.5 rounded-lg opacity-0 transition-opacity duration-300 blur-md group-hover:opacity-50",
            isFocused ? "opacity-100" : ""
          ),
          style: {
            background: isFocused ? `linear-gradient(45deg, ${focusColor}, transparent)` : "transparent"
          }
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime112.jsxs)("div", { className: "relative", children: [
        /* @__PURE__ */ (0, import_jsx_runtime112.jsx)(
          "input",
          {
            className: cn(
              "flex h-10 w-full rounded-md border border-input bg-background/50 px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-0 disabled:cursor-not-allowed disabled:opacity-50 backdrop-blur-sm transition-all duration-300",
              className
            ),
            onFocus: () => setIsFocused(true),
            onBlur: () => setIsFocused(false),
            placeholder: label,
            ...props
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime112.jsx)(
          "div",
          {
            className: cn(
              "absolute bottom-0 left-0 h-[2px] w-0 bg-gradient-to-r from-transparent via-violet-500 to-transparent transition-all duration-500 ease-out",
              isFocused ? "w-full" : "w-0"
            )
          }
        )
      ] })
    ] });
  }

  // src/components/TypingAnimation.tsx
  var import_react126 = __toESM(require_react());
  var import_jsx_runtime113 = __toESM(require_jsx_runtime());
  var TypingAnimation = ({
    text,
    duration = 100,
    delay: delay2 = 0,
    cursor = true,
    className,
    onComplete
  }) => {
    const [displayText, setDisplayText] = import_react126.default.useState("");
    const [isComplete, setIsComplete] = import_react126.default.useState(false);
    import_react126.default.useEffect(() => {
      let timeout;
      let charIndex = 0;
      const startTyping = () => {
        const type = () => {
          if (charIndex < text.length) {
            setDisplayText(text.slice(0, charIndex + 1));
            charIndex++;
            timeout = setTimeout(type, duration);
          } else {
            setIsComplete(true);
            onComplete?.();
          }
        };
        type();
      };
      timeout = setTimeout(startTyping, delay2);
      return () => clearTimeout(timeout);
    }, [text, duration, delay2, onComplete]);
    return /* @__PURE__ */ (0, import_jsx_runtime113.jsxs)("span", { className: cn("inline-block", className), children: [
      displayText,
      cursor && /* @__PURE__ */ (0, import_jsx_runtime113.jsx)(
        "span",
        {
          className: cn(
            "inline-block w-[2px] h-[1em] ml-0.5 bg-current align-middle",
            isComplete ? "animate-blink" : ""
          )
        }
      )
    ] });
  };
  var typingStyles = `
@keyframes blink {
  0%, 50% { opacity: 1; }
  51%, 100% { opacity: 0; }
}
.animate-blink {
  animation: blink 1s step-end infinite;
}
`;
  if (typeof document !== "undefined") {
    const styleId = "auralix-typing-styles";
    if (!document.getElementById(styleId)) {
      const style = document.createElement("style");
      style.id = styleId;
      style.textContent = typingStyles;
      document.head.appendChild(style);
    }
  }

  // src/components/tracing-beam.tsx
  var import_react127 = __toESM(require_react());
  var import_jsx_runtime114 = __toESM(require_jsx_runtime());
  var TracingBeam = ({
    children,
    className
  }) => {
    const ref = (0, import_react127.useRef)(null);
    const { scrollYProgress } = useScroll({
      target: ref,
      offset: ["start start", "end start"]
    });
    const contentRef = (0, import_react127.useRef)(null);
    const [svgHeight, setSvgHeight] = (0, import_react127.useState)(0);
    (0, import_react127.useEffect)(() => {
      if (contentRef.current) {
        setSvgHeight(contentRef.current.offsetHeight);
      }
    }, []);
    const y1 = useSpring(
      useTransform(scrollYProgress, [0, 0.8], [50, svgHeight]),
      {
        stiffness: 500,
        damping: 90
      }
    );
    const y2 = useSpring(
      useTransform(scrollYProgress, [0, 1], [50, svgHeight - 200]),
      {
        stiffness: 500,
        damping: 90
      }
    );
    return /* @__PURE__ */ (0, import_jsx_runtime114.jsxs)(
      motion.div,
      {
        ref,
        className: cn("relative w-full max-w-4xl mx-auto h-full", className),
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime114.jsxs)("div", { className: "absolute -left-4 md:-left-20 top-3", children: [
            /* @__PURE__ */ (0, import_jsx_runtime114.jsx)(
              motion.div,
              {
                transition: {
                  duration: 0.2,
                  delay: 0.5
                },
                animate: {
                  boxShadow: scrollYProgress.get() > 0 ? "none" : "rgba(0, 0, 0, 0.24) 0px 3px 8px"
                },
                className: "ml-[27px] h-4 w-4 rounded-full border border-neutral-200 shadow-sm flex items-center justify-center",
                children: /* @__PURE__ */ (0, import_jsx_runtime114.jsx)(
                  motion.div,
                  {
                    transition: {
                      duration: 0.2,
                      delay: 0.5
                    },
                    animate: {
                      backgroundColor: scrollYProgress.get() > 0 ? "white" : "var(--emerald-500)",
                      borderColor: scrollYProgress.get() > 0 ? "white" : "var(--emerald-600)"
                    },
                    className: "h-2 w-2 rounded-full border border-neutral-300 bg-white"
                  }
                )
              }
            ),
            /* @__PURE__ */ (0, import_jsx_runtime114.jsxs)(
              "svg",
              {
                viewBox: `0 0 20 ${svgHeight}`,
                width: "20",
                height: svgHeight,
                className: " ml-4 block",
                "aria-hidden": "true",
                children: [
                  /* @__PURE__ */ (0, import_jsx_runtime114.jsx)(
                    motion.path,
                    {
                      d: `M 1 0V -36 l 18 24 V ${svgHeight * 0.8} l -18 24V ${svgHeight}`,
                      fill: "none",
                      stroke: "#9091A0",
                      strokeOpacity: "0.16",
                      transition: {
                        duration: 10
                      }
                    }
                  ),
                  /* @__PURE__ */ (0, import_jsx_runtime114.jsx)(
                    motion.path,
                    {
                      d: `M 1 0V -36 l 18 24 V ${svgHeight * 0.8} l -18 24V ${svgHeight}`,
                      fill: "none",
                      stroke: "url(#gradient)",
                      strokeWidth: "1.25",
                      className: "motion-reduce:hidden",
                      transition: {
                        duration: 10
                      }
                    }
                  ),
                  /* @__PURE__ */ (0, import_jsx_runtime114.jsx)("defs", { children: /* @__PURE__ */ (0, import_jsx_runtime114.jsxs)(
                    motion.linearGradient,
                    {
                      id: "gradient",
                      gradientUnits: "userSpaceOnUse",
                      x1: "0",
                      x2: "0",
                      y1,
                      y2,
                      children: [
                        /* @__PURE__ */ (0, import_jsx_runtime114.jsx)("stop", { stopColor: "#18CCFC", stopOpacity: "0" }),
                        /* @__PURE__ */ (0, import_jsx_runtime114.jsx)("stop", { stopColor: "#18CCFC" }),
                        /* @__PURE__ */ (0, import_jsx_runtime114.jsx)("stop", { offset: "0.325", stopColor: "#6344F5" }),
                        /* @__PURE__ */ (0, import_jsx_runtime114.jsx)("stop", { offset: "1", stopColor: "#AE48FF", stopOpacity: "0" })
                      ]
                    }
                  ) })
                ]
              }
            )
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime114.jsx)("div", { ref: contentRef, children })
        ]
      }
    );
  };
  return __toCommonJS(index_exports);
})();
/*! Bundled license information:

react/cjs/react.production.js:
react/cjs/react.production.js:
  (**
   * @license React
   * react.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react/cjs/react.development.js:
react/cjs/react.development.js:
  (**
   * @license React
   * react.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react/cjs/react-jsx-runtime.production.js:
react/cjs/react-jsx-runtime.production.js:
  (**
   * @license React
   * react-jsx-runtime.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react/cjs/react-jsx-runtime.development.js:
react/cjs/react-jsx-runtime.development.js:
  (**
   * @license React
   * react-jsx-runtime.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom.production.js:
  (**
   * @license React
   * react-dom.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom.development.js:
  (**
   * @license React
   * react-dom.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

use-sync-external-store/cjs/use-sync-external-store-shim.production.js:
  (**
   * @license React
   * use-sync-external-store-shim.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

use-sync-external-store/cjs/use-sync-external-store-shim.development.js:
  (**
   * @license React
   * use-sync-external-store-shim.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

lucide-react/dist/esm/shared/src/utils.js:
lucide-react/dist/esm/defaultAttributes.js:
lucide-react/dist/esm/Icon.js:
lucide-react/dist/esm/createLucideIcon.js:
lucide-react/dist/esm/icons/calendar.js:
lucide-react/dist/esm/icons/check.js:
lucide-react/dist/esm/icons/chevron-down.js:
lucide-react/dist/esm/icons/chevron-left.js:
lucide-react/dist/esm/icons/chevron-right.js:
lucide-react/dist/esm/icons/chevrons-up-down.js:
lucide-react/dist/esm/icons/circle-alert.js:
lucide-react/dist/esm/icons/copy.js:
lucide-react/dist/esm/icons/dot.js:
lucide-react/dist/esm/icons/grip-vertical.js:
lucide-react/dist/esm/icons/info.js:
lucide-react/dist/esm/icons/x.js:
lucide-react/dist/esm/lucide-react.js:
  (**
   * @license lucide-react v0.562.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=index.global.js.map